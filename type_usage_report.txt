Type Usage Report (Max Depth: 10)
================================================================

### Analyzing expressions using type: '!' ###

--- AST Node Type: Block ---
  Expressions using '!' with 3 other type(s):
    Depth 7: (Count: 1)
      - '{ | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"!", "LazyStorage", "Rng", "Cell"})
    Depth 9: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"!", "Rng", "Cell", "LazyStorage"})
  Expressions using '!' with 4 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline] fn __init () -> Cell < Rng > { Cell :: new (Rng (random_seed () . unwrap_or (DEFAULT_RNG_SEED))) } unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) } }' (Used Types: {"LazyStorage", "()", "Rng", "!", "Cell"})

--- AST Node Type: Call ---
  Expressions using '!' with 4 other type(s):
    Depth 4: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } })' (Used Types: {"Cell", "()", "!", "LazyStorage", "Rng"})

--- AST Node Type: Closure ---
  Expressions using '!' with 3 other type(s):
    Depth 8: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Cell", "!", "LazyStorage", "Rng"})

--- AST Node Type: If ---
  Expressions using '!' with 4 other type(s):
    Depth 6: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"()", "LazyStorage", "Rng", "!", "Cell"})

--- AST Node Type: Unknown ---
  Expressions using '!' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }' (Used Types: {"Cell", "Rng", "()", "LazyStorage", "!"})

--- AST Node Type: Unsafe ---
  Expressions using '!' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) }' (Used Types: {"!", "LazyStorage", "Rng", "()", "Cell"})

### Analyzing expressions using type: '& 'a T' ###

--- AST Node Type: Call ---
  Expressions using '& 'a T' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'Ok :: < & 'a T , Void > (f ())' (Used Types: {"Void", "& 'a T", "T"})

--- AST Node Type: Closure ---
  Expressions using '& 'a T' with 2 other type(s):
    Depth 4: (Count: 1)
      - '| | Ok :: < & 'a T , Void > (f ())' (Used Types: {"& 'a T", "T", "Void"})

--- AST Node Type: Match ---
  Expressions using '& 'a T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'match self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"& 'a T", "T", "Void"})

--- AST Node Type: MethodCall ---
  Expressions using '& 'a T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ()))' (Used Types: {"Void", "& 'a T", "T"})

--- AST Node Type: Path ---
  Expressions using '& 'a T' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'Ok :: < & 'a T , Void >' (Used Types: {"& 'a T", "T", "Void"})

### Analyzing expressions using type: '& 'de ()' ###

--- AST Node Type: Block ---
  Expressions using '& 'de ()' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& 'de ()' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '& 'static ErrorVTable' ###

--- AST Node Type: Cast ---
  Expressions using '& 'static ErrorVTable' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'p . as_ptr () as * const & 'static ErrorVTable' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Paren ---
  Expressions using '& 'static ErrorVTable' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

--- AST Node Type: Unary ---
  Expressions using '& 'static ErrorVTable' with 2 other type(s):
    Depth 3: (Count: 1)
      - '* (p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Unsafe ---
  Expressions using '& 'static ErrorVTable' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { * (p . as_ptr () as * const & 'static ErrorVTable) }' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

### Analyzing expressions using type: '& 'static [& 'static str]' ###

--- AST Node Type: Block ---
  Expressions using '& 'static [& 'static str]' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& 'static [& 'static str]' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '& 'static str' ###

--- AST Node Type: Block ---
  Expressions using '& 'static str' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& 'static str' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: If ---
  Expressions using '& 'static str' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'if let Some ((flags , delim)) = env_flags { const ALLOW_FEATURES : & 'static str = "allow-features=" ; let rustflags = flags . to_string_lossy () ; let allow_features = rustflags . split (delim) . map (| flag | flag . trim_left_matches ("-Z") . trim ()) . filter (| flag | flag . starts_with (ALLOW_FEATURES)) . map (| flag | & flag [ALLOW_FEATURES . len () ..]) ; if let Some (allow_features) = allow_features . last () { return Some (allow_features . split (',') . any (| f | f . trim () == feature)) ; } }' (Used Types: {"& 'static str"})

### Analyzing expressions using type: '& Guid' ###

--- AST Node Type: Call ---
  Expressions using '& Guid' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self)' (Used Types: {"Guid", "[u8 ; 16]", "& Guid", "& [u8 ; 16]"})

--- AST Node Type: Path ---
  Expressions using '& Guid' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] >' (Used Types: {"Guid", "[u8 ; 16]", "& [u8 ; 16]", "& Guid"})

--- AST Node Type: Unsafe ---
  Expressions using '& Guid' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self) }' (Used Types: {"Guid", "& Guid", "[u8 ; 16]", "& [u8 ; 16]"})

### Analyzing expressions using type: '& Self' ###

--- AST Node Type: Block ---
  Expressions using '& Self' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
  Expressions using '& Self' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using '& Self' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& Self' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: If ---
  Expressions using '& Self' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

### Analyzing expressions using type: '& [_]' ###

--- AST Node Type: Call ---
  Expressions using '& [_]' with 2 other type(s):
    Depth 2: (Count: 3)
      - 'Source :: count (self as & [_])' (Used Types: {"_", "& [_]", "[_]"})
      - 'Source :: get (self as & [_] , key)' (Used Types: {"& [_]", "_", "[_]"})
      - 'Source :: visit (self as & [_] , visitor)' (Used Types: {"[_]", "_", "& [_]"})

--- AST Node Type: Cast ---
  Expressions using '& [_]' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'self as & [_]' (Used Types: {"[_]", "_", "& [_]"})

### Analyzing expressions using type: '& [u8 ; 16]' ###

--- AST Node Type: Call ---
  Expressions using '& [u8 ; 16]' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self)' (Used Types: {"Guid", "[u8 ; 16]", "& Guid", "& [u8 ; 16]"})

--- AST Node Type: Path ---
  Expressions using '& [u8 ; 16]' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] >' (Used Types: {"Guid", "[u8 ; 16]", "& [u8 ; 16]", "& Guid"})

--- AST Node Type: Unsafe ---
  Expressions using '& [u8 ; 16]' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self) }' (Used Types: {"Guid", "& Guid", "[u8 ; 16]", "& [u8 ; 16]"})

### Analyzing expressions using type: '& [u8]' ###

--- AST Node Type: Block ---
  Expressions using '& [u8]' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& [u8]' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: If ---
  Expressions using '& [u8]' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let slice : & [u8] = unsafe { core :: mem :: transmute (self . as_slice ()) } ; encoder . writer () . write (slice) ? ; } else { for item in self . iter () { item . encode (encoder) ? ; } }' (Used Types: {"& [u8]", "Item", "[u8]"})

### Analyzing expressions using type: '& dyn core :: error :: Error' ###

--- AST Node Type: Call ---
  Expressions using '& dyn core :: error :: Error' with 1 other type(s):
    Depth 3: (Count: 4)
      - 'crate :: nightly :: request_ref_backtrace (& * boxed_error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& * error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& self as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

--- AST Node Type: Cast ---
  Expressions using '& dyn core :: error :: Error' with 1 other type(s):
    Depth 4: (Count: 4)
      - '& * boxed_error as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - '& * error as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - '& error as & dyn core :: error :: Error' (Used Types: {"& dyn core :: error :: Error", "dyn core :: error :: Error"})
      - '& self as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

--- AST Node Type: Match ---
  Expressions using '& dyn core :: error :: Error' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'match crate :: nightly :: request_ref_backtrace (& * boxed_error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"& dyn core :: error :: Error", "dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& * error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& self as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

### Analyzing expressions using type: '& mut [A :: Item]' ###

--- AST Node Type: Call ---
  Expressions using '& mut [A :: Item]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice)' (Used Types: {"& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]", "Item"})

--- AST Node Type: If ---
  Expressions using '& mut [A :: Item]' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"[A :: Item]", "& mut [u8]", "[u8]", "Item", "& mut [A :: Item]"})
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item", "& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]"})

--- AST Node Type: Path ---
  Expressions using '& mut [A :: Item]' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] >' (Used Types: {"& mut [u8]", "& mut [A :: Item]", "[u8]", "[A :: Item]", "Item"})

--- AST Node Type: Unsafe ---
  Expressions using '& mut [A :: Item]' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) }' (Used Types: {"[u8]", "Item", "[A :: Item]", "& mut [A :: Item]", "& mut [u8]"})

### Analyzing expressions using type: '& mut [u8]' ###

--- AST Node Type: Call ---
  Expressions using '& mut [u8]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice)' (Used Types: {"& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]", "Item"})

--- AST Node Type: If ---
  Expressions using '& mut [u8]' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"[A :: Item]", "& mut [u8]", "[u8]", "Item", "& mut [A :: Item]"})
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item", "& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]"})

--- AST Node Type: Path ---
  Expressions using '& mut [u8]' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] >' (Used Types: {"& mut [u8]", "& mut [A :: Item]", "[u8]", "[A :: Item]", "Item"})

--- AST Node Type: Unsafe ---
  Expressions using '& mut [u8]' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) }' (Used Types: {"[u8]", "Item", "[A :: Item]", "& mut [A :: Item]", "& mut [u8]"})

### Analyzing expressions using type: '& mut _serde :: __private :: Formatter' ###

--- AST Node Type: Block ---
  Expressions using '& mut _serde :: __private :: Formatter' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})

### Analyzing expressions using type: '& mut _serde :: __private228 :: Formatter' ###

--- AST Node Type: Block ---
  Expressions using '& mut _serde :: __private228 :: Formatter' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '& mut arbitrary :: Unstructured < 'arbitrary >' ###

--- AST Node Type: Block ---
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 6 other type(s):
    Depth 2: (Count: 8)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using '& mut arbitrary :: Unstructured < 'arbitrary >' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

### Analyzing expressions using type: '& mut fmt :: Formatter < '_ >' ###

--- AST Node Type: If ---
  Expressions using '& mut fmt :: Formatter < '_ >' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

### Analyzing expressions using type: '& str' ###

--- AST Node Type: Block ---
  Expressions using '& str' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '& str' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using '& str' with 0 other type(s):
    Depth 2: (Count: 3)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as i64) . write (buf) }) ()' (Used Types: {"& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as u64) . write (buf) }) ()' (Used Types: {"& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; if f . is_nonfinite () { f . format_nonfinite () } else { self . format_finite (f) } }) ()' (Used Types: {"& str"})
  Expressions using '& str' with 1 other type(s):
    Depth 2: (Count: 2)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"* mut u8", "& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"& str", "* mut u8"})
  Expressions using '& str' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }) ()' (Used Types: {"* const u8", "& str", "* mut u8"})
  Expressions using '& str' with 4 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut u8", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit"})
  Expressions using '& str' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using '& str' with 0 other type(s):
    Depth 3: (Count: 1)
      - '| s : & str | s . splitn (2 , ":") . nth (1) . map (| s | s . trim () . to_string ())' (Used Types: {"& str"})
    Depth 4: (Count: 3)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as i64) . write (buf) }' (Used Types: {"& str"})
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as u64) . write (buf) }' (Used Types: {"& str"})
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; if f . is_nonfinite () { f . format_nonfinite () } else { self . format_finite (f) } }' (Used Types: {"& str"})
  Expressions using '& str' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"* mut u8", "& str"})
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"& str", "* mut u8"})
  Expressions using '& str' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }' (Used Types: {"* mut u8", "* const u8", "& str"})
  Expressions using '& str' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "* mut u8"})
  Expressions using '& str' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: ForLoop ---
  Expressions using '& str' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'for line in s . lines () { let split = | s : & str | s . splitn (2 , ":") . nth (1) . map (| s | s . trim () . to_string ()) ; match line . trim () . split (" ") . nth (0) { Some ("rustc") => { let (v , d) = version_and_date_from_rustc_version (line) ; version = version . or (v) ; date = date . or (d) ; } Some ("release:") => version = split (line) , Some ("commit-date:") if line . ends_with ("unknown") => date = None , Some ("commit-date:") => date = split (line) , _ => continue , } }' (Used Types: {"& str"})

--- AST Node Type: If ---
  Expressions using '& str' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: Paren ---
  Expressions using '& str' with 0 other type(s):
    Depth 3: (Count: 3)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as i64) . write (buf) })' (Used Types: {"& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; (self as u64) . write (buf) })' (Used Types: {"& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; if f . is_nonfinite () { f . format_nonfinite () } else { self . format_finite (f) } })' (Used Types: {"& str"})
  Expressions using '& str' with 1 other type(s):
    Depth 3: (Count: 2)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut u8", "& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"& str", "* mut u8"})
  Expressions using '& str' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } })' (Used Types: {"& str", "* mut u8", "* const u8"})
  Expressions using '& str' with 4 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "& str"})
  Expressions using '& str' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '()' ###

--- AST Node Type: Binary ---
  Expressions using '()' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize' (Used Types: {"AtomicPtr", "()"})
    Depth 7: (Count: 1)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
  Expressions using '()' with 2 other type(s):
    Depth 4: (Count: 3)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"()", "AtomicPtr", "* mut ()"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
    Depth 7: (Count: 3)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > ()' (Used Types: {"* mut ()", "()", "AtomicPtr"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})

--- AST Node Type: Block ---
  Expressions using '()' with 1 other type(s):
    Depth 2: (Count: 1)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize] ; }' (Used Types: {"()", "AtomicPtr"})
  Expressions using '()' with 2 other type(s):
    Depth 2: (Count: 3)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "* mut ()", "()"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "AtomicUsize", "()"})
    Depth 6: (Count: 1)
      - '{ core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) }' (Used Types: {"()", "FnTy", "* mut ()"})
  Expressions using '()' with 3 other type(s):
    Depth 8: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Rng", "()", "LazyStorage", "Cell"})
  Expressions using '()' with 4 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline] fn __init () -> Cell < Rng > { Cell :: new (Rng (random_seed () . unwrap_or (DEFAULT_RNG_SEED))) } unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) } }' (Used Types: {"LazyStorage", "()", "Rng", "!", "Cell"})
  Expressions using '()' with 5 other type(s):
    Depth 2: (Count: 3)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 10)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})
  Expressions using '()' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '()' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using '()' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'Some (Ref :: new (& unerased . _object . context) . cast :: < () > ())' (Used Types: {"()"})
    Depth 4: (Count: 1)
      - 'Some (Ref :: new (& unerased . _object . error) . cast :: < () > ())' (Used Types: {"()"})
  Expressions using '()' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,)' (Used Types: {"AtomicPtr", "()"})
    Depth 7: (Count: 1)
      - 'core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,)' (Used Types: {"* mut ()", "()"})
    Depth 8: (Count: 3)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < * mut () > ()' (Used Types: {"()", "* mut ()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
  Expressions using '()' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve (& mut self . map , additional)' (Used Types: {"T", "(T , ())", "()"})
    Depth 4: (Count: 1)
      - 'Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})
    Depth 6: (Count: 3)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,)' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,)' (Used Types: {"AtomicPtr", "* mut ()", "()"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,)' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})
    Depth 7: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed))' (Used Types: {"FnTy", "()", "* mut ()"})
  Expressions using '()' with 4 other type(s):
    Depth 4: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } })' (Used Types: {"Cell", "()", "!", "LazyStorage", "Rng"})

--- AST Node Type: Cast ---
  Expressions using '()' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize' (Used Types: {"AtomicPtr", "()"})
    Depth 8: (Count: 2)
      - 'detect as * mut ()' (Used Types: {"* mut ()", "()"})
      - 'func as * mut ()' (Used Types: {"* mut ()", "()"})
  Expressions using '()' with 2 other type(s):
    Depth 5: (Count: 3)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"* mut ()", "()", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})

--- AST Node Type: Closure ---
  Expressions using '()' with 3 other type(s):
    Depth 7: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"LazyStorage", "()", "Rng", "Cell"})

--- AST Node Type: If ---
  Expressions using '()' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < C > () == target { Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else { let source = & unerased . _object . error ; unsafe { (vtable (source . inner . ptr) . object_downcast) (source . inner . by_ref () , target) } }' (Used Types: {"C", "()"})
  Expressions using '()' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < E > > () ; return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,) ; } else { None }' (Used Types: {"E", "ErrorImpl", "* mut E", "()"})
  Expressions using '()' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < C > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"E", "ErrorImpl", "()", "C", "ContextError"})
    Depth 3: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"ContextError", "ErrorImpl", "E", "C", "()"})
    Depth 6: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"()", "LazyStorage", "Rng", "!", "Cell"})

--- AST Node Type: Match ---
  Expressions using '()' with 5 other type(s):
    Depth 4: (Count: 3)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: MethodCall ---
  Expressions using '()' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'Ref :: new (& unerased . _object . context) . cast :: < () > ()' (Used Types: {"()"})
    Depth 5: (Count: 1)
      - 'Ref :: new (& unerased . _object . error) . cast :: < () > ()' (Used Types: {"()"})
  Expressions using '()' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,)' (Used Types: {"* mut ()", "()"})
  Expressions using '()' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > ()' (Used Types: {"* mut E", "E", "()"})

--- AST Node Type: Path ---
  Expressions using '()' with 1 other type(s):
    Depth 9: (Count: 3)
      - 'core :: mem :: align_of :: < AtomicPtr < () > >' (Used Types: {"AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < * mut () >' (Used Types: {"()", "* mut ()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > >' (Used Types: {"AtomicPtr", "()"})
  Expressions using '()' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve' (Used Types: {"(T , ())", "T", "()"})
    Depth 8: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , >' (Used Types: {"* mut ()", "FnTy", "()"})

--- AST Node Type: Repeat ---
  Expressions using '()' with 1 other type(s):
    Depth 3: (Count: 1)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize]' (Used Types: {"()", "AtomicPtr"})
  Expressions using '()' with 2 other type(s):
    Depth 3: (Count: 3)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize]' (Used Types: {"()", "* mut ()", "AtomicPtr"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})

--- AST Node Type: Return ---
  Expressions using '()' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})

--- AST Node Type: Unknown ---
  Expressions using '()' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }' (Used Types: {"Cell", "Rng", "()", "LazyStorage", "!"})

--- AST Node Type: Unsafe ---
  Expressions using '()' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) }' (Used Types: {"!", "LazyStorage", "Rng", "()", "Cell"})
  Expressions using '()' with 5 other type(s):
    Depth 3: (Count: 3)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: '(K , V)' ###

--- AST Node Type: Call ---
  Expressions using '(K , V)' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve (self , additional)' (Used Types: {"(K , V)", "K", "V"})

--- AST Node Type: Path ---
  Expressions using '(K , V)' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve' (Used Types: {"(K , V)", "V", "K"})

### Analyzing expressions using type: '(T , ())' ###

--- AST Node Type: Call ---
  Expressions using '(T , ())' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve (& mut self . map , additional)' (Used Types: {"T", "(T , ())", "()"})

--- AST Node Type: Path ---
  Expressions using '(T , ())' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve' (Used Types: {"(T , ())", "T", "()"})

### Analyzing expressions using type: '(dyn Any + Send)' ###

--- AST Node Type: If ---
  Expressions using '(dyn Any + Send)' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "(dyn Any + Send)", "T", "* mut (dyn Any + Send)", "dyn Any + Send"})

--- AST Node Type: Unsafe ---
  Expressions using '(dyn Any + Send)' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"* mut T", "T", "* mut (dyn Any + Send)", "(dyn Any + Send)", "dyn Any + Send"})

### Analyzing expressions using type: '(kv :: Key , kv :: Value)' ###

--- AST Node Type: Call ---
  Expressions using '(kv :: Key , kv :: Value)' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'KeyValues (& None :: < (kv :: Key , kv :: Value) >)' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: Path ---
  Expressions using '(kv :: Key , kv :: Value)' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'None :: < (kv :: Key , kv :: Value) >' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: Reference ---
  Expressions using '(kv :: Key , kv :: Value)' with 2 other type(s):
    Depth 5: (Count: 1)
      - '& None :: < (kv :: Key , kv :: Value) >' (Used Types: {"Value", "(kv :: Key , kv :: Value)", "Key"})

--- AST Node Type: Struct ---
  Expressions using '(kv :: Key , kv :: Value)' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'RecordBuilder { record : Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , } , }' (Used Types: {"(kv :: Key , kv :: Value)", "Value", "Key"})
    Depth 3: (Count: 1)
      - 'Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , }' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

### Analyzing expressions using type: '(u128 , u64)' ###

--- AST Node Type: Call ---
  Expressions using '(u128 , u64)' with 0 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> (u128 , u64) { let n = __arg0 ; let d = 10_000_000_000_000_000_000_u64 ; let quot = if n < 1 << 83 { ((n >> 19) as u64 / (d >> 19)) as u128 } else { u128_mulhi (n , 156927543384667019095894735580191660403) >> 62 } ; let rem = (n - quot * d as u128) as u64 ; if true { match (& quot , & (n / d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } if true { match (& (rem as u128) , & (n % d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } (quot , rem) }) ()' (Used Types: {"(u128 , u64)"})

--- AST Node Type: Closure ---
  Expressions using '(u128 , u64)' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> (u128 , u64) { let n = __arg0 ; let d = 10_000_000_000_000_000_000_u64 ; let quot = if n < 1 << 83 { ((n >> 19) as u64 / (d >> 19)) as u128 } else { u128_mulhi (n , 156927543384667019095894735580191660403) >> 62 } ; let rem = (n - quot * d as u128) as u64 ; if true { match (& quot , & (n / d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } if true { match (& (rem as u128) , & (n % d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } (quot , rem) }' (Used Types: {"(u128 , u64)"})

--- AST Node Type: Paren ---
  Expressions using '(u128 , u64)' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> (u128 , u64) { let n = __arg0 ; let d = 10_000_000_000_000_000_000_u64 ; let quot = if n < 1 << 83 { ((n >> 19) as u64 / (d >> 19)) as u128 } else { u128_mulhi (n , 156927543384667019095894735580191660403) >> 62 } ; let rem = (n - quot * d as u128) as u64 ; if true { match (& quot , & (n / d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } if true { match (& (rem as u128) , & (n % d as u128)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } (quot , rem) })' (Used Types: {"(u128 , u64)"})

### Analyzing expressions using type: '(usize , :: core :: option :: Option < usize >)' ###

--- AST Node Type: Block ---
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 6 other type(s):
    Depth 2: (Count: 8)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using '(usize , :: core :: option :: Option < usize >)' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

### Analyzing expressions using type: '* const & 'static ErrorVTable' ###

--- AST Node Type: Cast ---
  Expressions using '* const & 'static ErrorVTable' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'p . as_ptr () as * const & 'static ErrorVTable' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Paren ---
  Expressions using '* const & 'static ErrorVTable' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

--- AST Node Type: Unary ---
  Expressions using '* const & 'static ErrorVTable' with 2 other type(s):
    Depth 3: (Count: 1)
      - '* (p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Unsafe ---
  Expressions using '* const & 'static ErrorVTable' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { * (p . as_ptr () as * const & 'static ErrorVTable) }' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

### Analyzing expressions using type: '* const A :: Item' ###

--- AST Node Type: Call ---
  Expressions using '* const A :: Item' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'ConstNonNull :: new (self . inline . as_ptr () as * const A :: Item)' (Used Types: {"* const A :: Item", "Item"})

--- AST Node Type: Cast ---
  Expressions using '* const A :: Item' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'self . inline . as_ptr () as * const A :: Item' (Used Types: {"Item", "* const A :: Item"})

--- AST Node Type: MethodCall ---
  Expressions using '* const A :: Item' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'ConstNonNull :: new (self . inline . as_ptr () as * const A :: Item) . unwrap ()' (Used Types: {"* const A :: Item", "Item"})

### Analyzing expressions using type: '* const AtomicU8' ###

--- AST Node Type: Block ---
  Expressions using '* const AtomicU8' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } }' (Used Types: {"AtomicU8", "* const AtomicU8"})

--- AST Node Type: Cast ---
  Expressions using '* const AtomicU8' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'self . state as * const AtomicU8 as usize' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 4: (Count: 1)
      - 'self . state as * const AtomicU8' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 6: (Count: 1)
      - 'state as * const AtomicU8 as usize' (Used Types: {"AtomicU8", "* const AtomicU8"})
    Depth 7: (Count: 1)
      - 'state as * const AtomicU8' (Used Types: {"* const AtomicU8", "AtomicU8"})

--- AST Node Type: Loop ---
  Expressions using '* const AtomicU8' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'loop { let exchange = state . compare_exchange_weak (INCOMPLETE , RUNNING , Ordering :: Acquire , Ordering :: Acquire ,) ; match exchange { Ok (_) => { let mut guard = Guard { state , new_state : INCOMPLETE , } ; if init () { guard . new_state = COMPLETE ; } return ; } Err (COMPLETE) => return , Err (RUNNING) => { unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } } Err (INCOMPLETE) => { } Err (_) => { if true { if ! false { :: core :: panicking :: panic ("assertion failed: false") } } } } }' (Used Types: {"* const AtomicU8", "AtomicU8"})

--- AST Node Type: Match ---
  Expressions using '* const AtomicU8' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'match exchange { Ok (_) => { let mut guard = Guard { state , new_state : INCOMPLETE , } ; if init () { guard . new_state = COMPLETE ; } return ; } Err (COMPLETE) => return , Err (RUNNING) => { unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } } Err (INCOMPLETE) => { } Err (_) => { if true { if ! false { :: core :: panicking :: panic ("assertion failed: false") } } } }' (Used Types: {"* const AtomicU8", "AtomicU8"})

--- AST Node Type: Unsafe ---
  Expressions using '* const AtomicU8' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let key = self . state as * const AtomicU8 as usize ; parking_lot_core :: unpark_all (key , parking_lot_core :: DEFAULT_UNPARK_TOKEN ,) ; }' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 5: (Count: 1)
      - 'unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; }' (Used Types: {"* const AtomicU8", "AtomicU8"})

### Analyzing expressions using type: '* const AtomicUsize' ###

--- AST Node Type: Cast ---
  Expressions using '* const AtomicUsize' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const AtomicUsize' (Used Types: {"Self", "* const AtomicUsize", "* const Self", "AtomicUsize"})

--- AST Node Type: Paren ---
  Expressions using '* const AtomicUsize' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const AtomicUsize)' (Used Types: {"AtomicUsize", "* const Self", "Self", "* const AtomicUsize"})

--- AST Node Type: Reference ---
  Expressions using '* const AtomicUsize' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const AtomicUsize)' (Used Types: {"* const AtomicUsize", "* const Self", "Self", "AtomicUsize"})

--- AST Node Type: Unary ---
  Expressions using '* const AtomicUsize' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const AtomicUsize)' (Used Types: {"Self", "* const Self", "* const AtomicUsize", "AtomicUsize"})

--- AST Node Type: Unsafe ---
  Expressions using '* const AtomicUsize' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const AtomicUsize) }' (Used Types: {"* const Self", "Self", "* const AtomicUsize", "AtomicUsize"})

### Analyzing expressions using type: '* const CStr' ###

--- AST Node Type: Cast ---
  Expressions using '* const CStr' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'bytes as * const [u8] as * const CStr' (Used Types: {"* const CStr", "[u8]", "CStr", "* const [u8]"})

--- AST Node Type: Paren ---
  Expressions using '* const CStr' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "CStr", "* const [u8]", "[u8]"})

--- AST Node Type: Reference ---
  Expressions using '* const CStr' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (bytes as * const [u8] as * const CStr)' (Used Types: {"[u8]", "* const [u8]", "* const CStr", "CStr"})

--- AST Node Type: Unary ---
  Expressions using '* const CStr' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "[u8]", "* const [u8]", "CStr"})

--- AST Node Type: Unsafe ---
  Expressions using '* const CStr' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (bytes as * const [u8] as * const CStr) }' (Used Types: {"CStr", "* const [u8]", "[u8]", "* const CStr"})

### Analyzing expressions using type: '* const ChunkFooter' ###

--- AST Node Type: Binary ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'ptr <= self as * const ChunkFooter as * const u8' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using '* const ChunkFooter' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const ChunkFooter' (Used Types: {"* const ChunkFooter", "ChunkFooter"})
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 6: (Count: 1)
      - 'self as * const ChunkFooter as * const u8' (Used Types: {"* const u8", "ChunkFooter", "* const ChunkFooter"})

--- AST Node Type: If ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if true { if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) } }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 3: (Count: 1)
      - 'if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) }' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: MethodCall ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})

--- AST Node Type: Paren ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 5: (Count: 2)
      - '(ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})
      - '(self as * const ChunkFooter as * const u8)' (Used Types: {"* const u8", "* const ChunkFooter", "ChunkFooter"})

--- AST Node Type: Unary ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - '! (ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})

--- AST Node Type: Unsafe ---
  Expressions using '* const ChunkFooter' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})

### Analyzing expressions using type: '* const EmptyChunkFooter' ###

--- AST Node Type: Call ---
  Expressions using '* const EmptyChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) })' (Used Types: {"EmptyChunkFooter", "* mut u8", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8)' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using '* const EmptyChunkFooter' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) })' (Used Types: {"ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,)' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "ChunkFooter"})
  Expressions using '* const EmptyChunkFooter' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'EmptyChunkFooter (ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , })' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "* mut u8", "* const EmptyChunkFooter", "EmptyChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using '* const EmptyChunkFooter' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter"})
  Expressions using '* const EmptyChunkFooter' with 2 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using '* const EmptyChunkFooter' with 3 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})

--- AST Node Type: Struct ---
  Expressions using '* const EmptyChunkFooter' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , }' (Used Types: {"ChunkFooter", "* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "* mut u8"})

--- AST Node Type: Unsafe ---
  Expressions using '* const EmptyChunkFooter' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }' (Used Types: {"EmptyChunkFooter", "* const EmptyChunkFooter", "* mut u8"})
  Expressions using '* const EmptyChunkFooter' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }' (Used Types: {"* const EmptyChunkFooter", "ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter"})

### Analyzing expressions using type: '* const Fd' ###

--- AST Node Type: Call ---
  Expressions using '* const Fd' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd))' (Used Types: {"* const Fd", "Fd"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd)' (Used Types: {"Fd", "* const Fd"})

--- AST Node Type: Cast ---
  Expressions using '* const Fd' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Fd' (Used Types: {"Fd", "* const Fd"})

--- AST Node Type: Match ---
  Expressions using '* const Fd' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Fd", "Fd"})

### Analyzing expressions using type: '* const Fdstat' ###

--- AST Node Type: Call ---
  Expressions using '* const Fdstat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat))' (Used Types: {"* const Fdstat", "Fdstat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat)' (Used Types: {"* const Fdstat", "Fdstat"})

--- AST Node Type: Cast ---
  Expressions using '* const Fdstat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Fdstat' (Used Types: {"* const Fdstat", "Fdstat"})

--- AST Node Type: Match ---
  Expressions using '* const Fdstat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Fdstat", "Fdstat"})

### Analyzing expressions using type: '* const Filesize' ###

--- AST Node Type: Call ---
  Expressions using '* const Filesize' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize))' (Used Types: {"* const Filesize", "Filesize"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize)' (Used Types: {"* const Filesize", "Filesize"})

--- AST Node Type: Cast ---
  Expressions using '* const Filesize' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Filesize' (Used Types: {"Filesize", "* const Filesize"})

--- AST Node Type: Match ---
  Expressions using '* const Filesize' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Filesize", "Filesize"})

### Analyzing expressions using type: '* const Filestat' ###

--- AST Node Type: Call ---
  Expressions using '* const Filestat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat))' (Used Types: {"Filestat", "* const Filestat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat)' (Used Types: {"* const Filestat", "Filestat"})

--- AST Node Type: Cast ---
  Expressions using '* const Filestat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Filestat' (Used Types: {"* const Filestat", "Filestat"})

--- AST Node Type: Match ---
  Expressions using '* const Filestat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Filestat", "Filestat"})

### Analyzing expressions using type: '* const Prestat' ###

--- AST Node Type: Call ---
  Expressions using '* const Prestat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat))' (Used Types: {"Prestat", "* const Prestat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat)' (Used Types: {"Prestat", "* const Prestat"})

--- AST Node Type: Cast ---
  Expressions using '* const Prestat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Prestat' (Used Types: {"* const Prestat", "Prestat"})

--- AST Node Type: Match ---
  Expressions using '* const Prestat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Prestat", "Prestat"})

### Analyzing expressions using type: '* const Roflags' ###

--- AST Node Type: Block ---
  Expressions using '* const Roflags' with 3 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) }' (Used Types: {"Roflags", "Size", "* const Size", "* const Roflags"})

--- AST Node Type: Call ---
  Expressions using '* const Roflags' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags)' (Used Types: {"* const Roflags", "Roflags"})
  Expressions using '* const Roflags' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,))' (Used Types: {"Size", "* const Roflags", "Roflags", "* const Size"})

--- AST Node Type: Cast ---
  Expressions using '* const Roflags' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'rp1 . as_mut_ptr () as i32 as * const Roflags' (Used Types: {"Roflags", "* const Roflags"})

--- AST Node Type: Match ---
  Expressions using '* const Roflags' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Roflags", "* const Roflags", "* const Size", "Size"})

--- AST Node Type: Tuple ---
  Expressions using '* const Roflags' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)' (Used Types: {"* const Roflags", "* const Size", "Roflags", "Size"})

### Analyzing expressions using type: '* const Self' ###

--- AST Node Type: Cast ---
  Expressions using '* const Self' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self' (Used Types: {"Self", "* const Self"})
  Expressions using '* const Self' with 3 other type(s):
    Depth 6: (Count: 4)
      - 'self as * const Self as * const AtomicUsize' (Used Types: {"Self", "* const AtomicUsize", "* const Self", "AtomicUsize"})
      - 'self as * const Self as * const crate :: AtomicU32' (Used Types: {"Self", "AtomicU32", "* const Self", "* const crate :: AtomicU32"})
      - 'self as * const Self as * const crate :: AtomicU64' (Used Types: {"Self", "* const Self", "AtomicU64", "* const crate :: AtomicU64"})
      - 'self as * const Self as * const imp :: AtomicU8' (Used Types: {"AtomicU8", "* const Self", "* const imp :: AtomicU8", "Self"})
    Depth 7: (Count: 10)
      - 'self as * const Self as * const UnsafeCell < i16 >' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i32 >' (Used Types: {"* const UnsafeCell < i32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i64 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i64 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < i8 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i8 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < isize >' (Used Types: {"* const UnsafeCell < isize >", "UnsafeCell", "* const Self", "Self"})
      - 'self as * const Self as * const UnsafeCell < u16 >' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < u16 >"})
      - 'self as * const Self as * const UnsafeCell < u32 >' (Used Types: {"* const UnsafeCell < u32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u64 >' (Used Types: {"* const UnsafeCell < u64 >", "Self", "* const Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u8 >' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u8 >"})
      - 'self as * const Self as * const UnsafeCell < usize >' (Used Types: {"* const UnsafeCell < usize >", "UnsafeCell", "* const Self", "Self"})
  Expressions using '* const Self' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: MethodCall ---
  Expressions using '* const Self' with 3 other type(s):
    Depth 3: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >)) . get ()' (Used Types: {"* const UnsafeCell < i16 >", "UnsafeCell", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >)) . get ()' (Used Types: {"* const Self", "* const UnsafeCell < i32 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >)) . get ()' (Used Types: {"* const UnsafeCell < i8 >", "Self", "* const Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >)) . get ()' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >)) . get ()' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >)) . get ()' (Used Types: {"UnsafeCell", "* const UnsafeCell < u64 >", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >)) . get ()' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u8 >"})
      - '(* (self as * const Self as * const UnsafeCell < usize >)) . get ()' (Used Types: {"Self", "* const UnsafeCell < usize >", "UnsafeCell", "* const Self"})
  Expressions using '* const Self' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using '* const Self' with 3 other type(s):
    Depth 4: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >))' (Used Types: {"* const Self", "* const UnsafeCell < i16 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >))' (Used Types: {"UnsafeCell", "Self", "* const UnsafeCell < i32 >", "* const Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >))' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i64 >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >))' (Used Types: {"* const UnsafeCell < i8 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >))' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < isize >"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >))' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >))' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >))' (Used Types: {"* const UnsafeCell < u64 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >))' (Used Types: {"* const Self", "* const UnsafeCell < u8 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < usize >))' (Used Types: {"* const Self", "* const UnsafeCell < usize >", "UnsafeCell", "Self"})
    Depth 5: (Count: 4)
      - '(self as * const Self as * const AtomicUsize)' (Used Types: {"AtomicUsize", "* const Self", "Self", "* const AtomicUsize"})
      - '(self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "Self", "AtomicU32", "* const crate :: AtomicU32"})
      - '(self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "* const crate :: AtomicU64", "Self", "AtomicU64"})
      - '(self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})
    Depth 6: (Count: 10)
      - '(self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < i16 >"})
      - '(self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i32 >", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i8 >"})
      - '(self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"* const Self", "* const UnsafeCell < isize >", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"* const UnsafeCell < u32 >", "UnsafeCell", "* const Self", "Self"})
      - '(self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '(self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const Self", "UnsafeCell", "* const UnsafeCell < u8 >", "Self"})
      - '(self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"* const UnsafeCell < usize >", "Self", "* const Self", "UnsafeCell"})
  Expressions using '* const Self' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Reference ---
  Expressions using '* const Self' with 3 other type(s):
    Depth 3: (Count: 4)
      - '& * (self as * const Self as * const AtomicUsize)' (Used Types: {"* const AtomicUsize", "* const Self", "Self", "AtomicUsize"})
      - '& * (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "* const crate :: AtomicU32", "Self", "AtomicU32"})
      - '& * (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"Self", "AtomicU64", "* const crate :: AtomicU64", "* const Self"})
      - '& * (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"Self", "* const imp :: AtomicU8", "* const Self", "AtomicU8"})

--- AST Node Type: Unary ---
  Expressions using '* const Self' with 3 other type(s):
    Depth 4: (Count: 4)
      - '* (self as * const Self as * const AtomicUsize)' (Used Types: {"Self", "* const Self", "* const AtomicUsize", "AtomicUsize"})
      - '* (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"AtomicU32", "Self", "* const Self", "* const crate :: AtomicU32"})
      - '* (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "AtomicU64", "* const crate :: AtomicU64", "Self"})
      - '* (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})
    Depth 5: (Count: 10)
      - '* (self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"Self", "* const UnsafeCell < i16 >", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"* const UnsafeCell < i64 >", "Self", "* const Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i8 >", "* const Self", "Self"})
      - '* (self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"UnsafeCell", "* const Self", "* const UnsafeCell < isize >", "Self"})
      - '* (self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '* (self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '* (self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const UnsafeCell < u8 >", "Self", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < usize >"})
  Expressions using '* const Self' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using '* const Self' with 3 other type(s):
    Depth 2: (Count: 14)
      - 'unsafe { & * (self as * const Self as * const AtomicUsize) }' (Used Types: {"* const Self", "Self", "* const AtomicUsize", "AtomicUsize"})
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU32) }' (Used Types: {"* const Self", "AtomicU32", "* const crate :: AtomicU32", "Self"})
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU64) }' (Used Types: {"* const Self", "AtomicU64", "Self", "* const crate :: AtomicU64"})
      - 'unsafe { & * (self as * const Self as * const imp :: AtomicU8) }' (Used Types: {"AtomicU8", "Self", "* const Self", "* const imp :: AtomicU8"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i16 >)) . get () }' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i32 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i64 >)) . get () }' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < i64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i8 >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i8 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < isize >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u16 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < u16 >", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u32 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u64 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u8 >)) . get () }' (Used Types: {"* const UnsafeCell < u8 >", "UnsafeCell", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < usize >)) . get () }' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < usize >", "* const Self"})
  Expressions using '* const Self' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

### Analyzing expressions using type: '* const Self :: Item' ###

--- AST Node Type: If ---
  Expressions using '* const Self :: Item' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})

--- AST Node Type: Unsafe ---
  Expressions using '* const Self :: Item' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"* const Self :: Item", "Item", "* mut Self :: Item"})

--- AST Node Type: While ---
  Expressions using '* const Self :: Item' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"Item", "* const Self :: Item", "* mut Self :: Item"})

### Analyzing expressions using type: '* const Size' ###

--- AST Node Type: Block ---
  Expressions using '* const Size' with 1 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)) }' (Used Types: {"Size", "* const Size"})
  Expressions using '* const Size' with 3 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) }' (Used Types: {"Roflags", "Size", "* const Size", "* const Roflags"})

--- AST Node Type: Call ---
  Expressions using '* const Size' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size))' (Used Types: {"* const Size", "Size"})
    Depth 4: (Count: 2)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,))' (Used Types: {"* const Size", "Size"})
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size)' (Used Types: {"Size", "* const Size"})
    Depth 6: (Count: 1)
      - 'core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size)' (Used Types: {"Size", "* const Size"})
  Expressions using '* const Size' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,))' (Used Types: {"Size", "* const Roflags", "Roflags", "* const Size"})

--- AST Node Type: Cast ---
  Expressions using '* const Size' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Size' (Used Types: {"* const Size", "Size"})
    Depth 7: (Count: 1)
      - 'rp1 . as_mut_ptr () as i32 as * const Size' (Used Types: {"Size", "* const Size"})

--- AST Node Type: Match ---
  Expressions using '* const Size' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"Size", "* const Size"})
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Size", "* const Size"})
  Expressions using '* const Size' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Roflags", "* const Roflags", "* const Size", "Size"})

--- AST Node Type: Tuple ---
  Expressions using '* const Size' with 1 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)' (Used Types: {"Size", "* const Size"})
  Expressions using '* const Size' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)' (Used Types: {"* const Roflags", "* const Size", "Roflags", "Size"})

### Analyzing expressions using type: '* const T' ###

--- AST Node Type: Block ---
  Expressions using '* const T' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ begin . add (self . len ()) as * const T }' (Used Types: {"* const T", "T"})

--- AST Node Type: Call ---
  Expressions using '* const T' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'ptr :: copy_nonoverlapping (other as * const T , self . as_mut_ptr () . add (len) , count ,)' (Used Types: {"T", "* const T"})
    Depth 5: (Count: 1)
      - '< * const T > :: cast_mut (value)' (Used Types: {"T", "* const T"})

--- AST Node Type: Cast ---
  Expressions using '* const T' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'self . ptr . as_ptr () as * const T' (Used Types: {"* const T", "T"})
    Depth 3: (Count: 3)
      - '(* self) as * const T' (Used Types: {"* const T", "T"})
      - 'other as * const T' (Used Types: {"T", "* const T"})
      - 'ptr as * const T' (Used Types: {"T", "* const T"})
    Depth 5: (Count: 1)
      - 'begin . add (self . len ()) as * const T' (Used Types: {"* const T", "T"})
  Expressions using '* const T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'ptr as * const T as * mut T' (Used Types: {"* const T", "T", "* mut T"})
    Depth 4: (Count: 1)
      - 'arith_offset (begin as * const i8 , self . len () as isize) as * const T' (Used Types: {"* const T", "* const i8", "T"})
  Expressions using '* const T' with 3 other type(s):
    Depth 2: (Count: 2)
      - '(* self) as * const T as * const c_void' (Used Types: {"* const T", "c_void", "T", "* const c_void"})
      - 'self as * const _ as * const T' (Used Types: {"* const _", "* const T", "_", "T"})

--- AST Node Type: If ---
  Expressions using '* const T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T }' (Used Types: {"* const i8", "* const T", "T"})
    Depth 4: (Count: 1)
      - 'if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* const T", "* mut T", "T"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut T", "T", "* const T"})

--- AST Node Type: MethodCall ---
  Expressions using '* const T' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,)' (Used Types: {"* const T", "T"})
  Expressions using '* const T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ()) . map_err (< * mut T > :: cast_const)' (Used Types: {"T", "* mut T", "* const T"})
    Depth 3: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ())' (Used Types: {"* const T", "* mut T", "T"})

--- AST Node Type: Path ---
  Expressions using '* const T' with 1 other type(s):
    Depth 6: (Count: 1)
      - '< * const T > :: cast_mut' (Used Types: {"T", "* const T"})

--- AST Node Type: Unsafe ---
  Expressions using '* const T' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { let begin = self . as_mut_ptr () ; let end = if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T } ; mem :: forget (self) ; IntoIter { phantom : PhantomData , ptr : begin , end , } }' (Used Types: {"* const T", "T", "* const i8"})
      - 'unsafe { while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"T", "* const T", "* mut T"})

--- AST Node Type: While ---
  Expressions using '* const T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"T", "* mut T", "* const T"})

### Analyzing expressions using type: '* const Timestamp' ###

--- AST Node Type: Call ---
  Expressions using '* const Timestamp' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp))' (Used Types: {"* const Timestamp", "Timestamp"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp)' (Used Types: {"* const Timestamp", "Timestamp"})

--- AST Node Type: Cast ---
  Expressions using '* const Timestamp' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Timestamp' (Used Types: {"Timestamp", "* const Timestamp"})

--- AST Node Type: Match ---
  Expressions using '* const Timestamp' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"Timestamp", "* const Timestamp"})

### Analyzing expressions using type: '* const UnsafeCell < * mut T >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < * mut T >' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < * mut T >' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < * mut T >' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < * mut T >' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < * mut T >' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

### Analyzing expressions using type: '* const UnsafeCell < i16 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < i16 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < i16 >' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < i16 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i16 >)) . get ()' (Used Types: {"* const UnsafeCell < i16 >", "UnsafeCell", "* const Self", "Self"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < i16 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i16 >))' (Used Types: {"* const Self", "* const UnsafeCell < i16 >", "UnsafeCell", "Self"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < i16 >"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < i16 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"Self", "* const UnsafeCell < i16 >", "UnsafeCell", "* const Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < i16 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i16 >)) . get () }' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})

### Analyzing expressions using type: '* const UnsafeCell < i32 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < i32 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < i32 >' (Used Types: {"* const UnsafeCell < i32 >", "* const Self", "Self", "UnsafeCell"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < i32 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i32 >)) . get ()' (Used Types: {"* const Self", "* const UnsafeCell < i32 >", "UnsafeCell", "Self"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < i32 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i32 >))' (Used Types: {"UnsafeCell", "Self", "* const UnsafeCell < i32 >", "* const Self"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i32 >", "UnsafeCell"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < i32 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < i32 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i32 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})

### Analyzing expressions using type: '* const UnsafeCell < i64 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < i64 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < i64 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i64 >", "* const Self"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < i64 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i64 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < i64 >"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < i64 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i64 >))' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i64 >", "UnsafeCell"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i64 >"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < i64 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"* const UnsafeCell < i64 >", "Self", "* const Self", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < i64 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i64 >)) . get () }' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < i64 >"})

### Analyzing expressions using type: '* const UnsafeCell < i8 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < i8 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < i8 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i8 >", "* const Self"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < i8 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i8 >)) . get ()' (Used Types: {"* const UnsafeCell < i8 >", "Self", "* const Self", "UnsafeCell"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < i8 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < i8 >))' (Used Types: {"* const UnsafeCell < i8 >", "* const Self", "Self", "UnsafeCell"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i8 >"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < i8 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i8 >", "* const Self", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < i8 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i8 >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i8 >", "UnsafeCell"})

### Analyzing expressions using type: '* const UnsafeCell < isize >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < isize >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < isize >' (Used Types: {"* const UnsafeCell < isize >", "UnsafeCell", "* const Self", "Self"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < isize >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < isize >)) . get ()' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < isize >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < isize >))' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < isize >"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"* const Self", "* const UnsafeCell < isize >", "Self", "UnsafeCell"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < isize >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"UnsafeCell", "* const Self", "* const UnsafeCell < isize >", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < isize >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < isize >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})

### Analyzing expressions using type: '* const UnsafeCell < u16 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < u16 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < u16 >' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < u16 >"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < u16 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u16 >)) . get ()' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u16 >"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < u16 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u16 >))' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < u16 >"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < u16 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < u16 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u16 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < u16 >", "* const Self", "Self"})

### Analyzing expressions using type: '* const UnsafeCell < u32 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < u32 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < u32 >' (Used Types: {"* const UnsafeCell < u32 >", "* const Self", "Self", "UnsafeCell"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < u32 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u32 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < u32 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u32 >))' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u32 >"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"* const UnsafeCell < u32 >", "UnsafeCell", "* const Self", "Self"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < u32 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u32 >"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < u32 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u32 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})

### Analyzing expressions using type: '* const UnsafeCell < u64 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < u64 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < u64 >' (Used Types: {"* const UnsafeCell < u64 >", "Self", "* const Self", "UnsafeCell"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < u64 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u64 >)) . get ()' (Used Types: {"UnsafeCell", "* const UnsafeCell < u64 >", "* const Self", "Self"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < u64 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u64 >))' (Used Types: {"* const UnsafeCell < u64 >", "* const Self", "Self", "UnsafeCell"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < u64 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u64 >"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < u64 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u64 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})

### Analyzing expressions using type: '* const UnsafeCell < u8 >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < u8 >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < u8 >' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u8 >"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < u8 >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u8 >)) . get ()' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u8 >"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < u8 >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < u8 >))' (Used Types: {"* const Self", "* const UnsafeCell < u8 >", "UnsafeCell", "Self"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const Self", "UnsafeCell", "* const UnsafeCell < u8 >", "Self"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < u8 >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const UnsafeCell < u8 >", "Self", "UnsafeCell", "* const Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < u8 >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u8 >)) . get () }' (Used Types: {"* const UnsafeCell < u8 >", "UnsafeCell", "* const Self", "Self"})

### Analyzing expressions using type: '* const UnsafeCell < usize >' ###

--- AST Node Type: Cast ---
  Expressions using '* const UnsafeCell < usize >' with 3 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < usize >' (Used Types: {"* const UnsafeCell < usize >", "UnsafeCell", "* const Self", "Self"})

--- AST Node Type: MethodCall ---
  Expressions using '* const UnsafeCell < usize >' with 3 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < usize >)) . get ()' (Used Types: {"Self", "* const UnsafeCell < usize >", "UnsafeCell", "* const Self"})

--- AST Node Type: Paren ---
  Expressions using '* const UnsafeCell < usize >' with 3 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < usize >))' (Used Types: {"* const Self", "* const UnsafeCell < usize >", "UnsafeCell", "Self"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"* const UnsafeCell < usize >", "Self", "* const Self", "UnsafeCell"})

--- AST Node Type: Unary ---
  Expressions using '* const UnsafeCell < usize >' with 3 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < usize >"})

--- AST Node Type: Unsafe ---
  Expressions using '* const UnsafeCell < usize >' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < usize >)) . get () }' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < usize >", "* const Self"})

### Analyzing expressions using type: '* const [u8]' ###

--- AST Node Type: Block ---
  Expressions using '* const [u8]' with 1 other type(s):
    Depth 3: (Count: 1)
      - '{ match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , } }' (Used Types: {"[u8]", "* const [u8]"})
    Depth 5: (Count: 1)
      - '{ let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) }' (Used Types: {"[u8]", "* const [u8]"})

--- AST Node Type: Cast ---
  Expressions using '* const [u8]' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'bytes as * const [u8]' (Used Types: {"[u8]", "* const [u8]"})
  Expressions using '* const [u8]' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'bytes as * const [u8] as * const CStr' (Used Types: {"* const CStr", "[u8]", "CStr", "* const [u8]"})

--- AST Node Type: Match ---
  Expressions using '* const [u8]' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match input { Cow :: Borrowed (bytes) => String :: from_utf8_lossy (bytes) , Cow :: Owned (bytes) => { match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , } } }' (Used Types: {"* const [u8]", "[u8]"})
    Depth 4: (Count: 1)
      - 'match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , }' (Used Types: {"[u8]", "* const [u8]"})

--- AST Node Type: Paren ---
  Expressions using '* const [u8]' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "CStr", "* const [u8]", "[u8]"})

--- AST Node Type: Reference ---
  Expressions using '* const [u8]' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (bytes as * const [u8] as * const CStr)' (Used Types: {"[u8]", "* const [u8]", "* const CStr", "CStr"})

--- AST Node Type: Unary ---
  Expressions using '* const [u8]' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "[u8]", "* const [u8]", "CStr"})

--- AST Node Type: Unsafe ---
  Expressions using '* const [u8]' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (bytes as * const [u8] as * const CStr) }' (Used Types: {"CStr", "* const [u8]", "[u8]", "* const CStr"})

### Analyzing expressions using type: '* const _' ###

--- AST Node Type: Binary ---
  Expressions using '* const _' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'self . ptr as * const _ == self . end' (Used Types: {"_", "* const _"})

--- AST Node Type: Block ---
  Expressions using '* const _' with 1 other type(s):
    Depth 3: (Count: 2)
      - '{ unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) } }' (Used Types: {"* const _", "_"})
      - '{ unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) } }' (Used Types: {"* const _", "_"})

--- AST Node Type: Call ---
  Expressions using '* const _' with 1 other type(s):
    Depth 5: (Count: 3)
      - 'Err (AllocOrInitError :: Init (ptr :: read (e as * const _)))' (Used Types: {"* const _", "_"})
      - 'Err (ptr :: read (e as * const _))' (Used Types: {"* const _", "_"})
      - 'ptr :: read (elt as * const _)' (Used Types: {"_", "* const _"})
    Depth 6: (Count: 1)
      - 'AllocOrInitError :: Init (ptr :: read (e as * const _))' (Used Types: {"* const _", "_"})
    Depth 7: (Count: 1)
      - 'ptr :: read (e as * const _)' (Used Types: {"* const _", "_"})

--- AST Node Type: Cast ---
  Expressions using '* const _' with 1 other type(s):
    Depth 2: (Count: 1)
      - '& self . state as * const _ as usize' (Used Types: {"_", "* const _"})
    Depth 3: (Count: 2)
      - '& self . state as * const _' (Used Types: {"_", "* const _"})
      - 'self as * const _' (Used Types: {"* const _", "_"})
    Depth 5: (Count: 1)
      - 'self . ptr as * const _' (Used Types: {"_", "* const _"})
    Depth 6: (Count: 1)
      - 'elt as * const _' (Used Types: {"* const _", "_"})
    Depth 8: (Count: 1)
      - 'e as * const _' (Used Types: {"_", "* const _"})
  Expressions using '* const _' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'self as * const _ as * const T' (Used Types: {"* const _", "* const T", "_", "T"})

--- AST Node Type: Closure ---
  Expressions using '* const _' with 1 other type(s):
    Depth 3: (Count: 1)
      - '| elt | unsafe { ptr :: read (elt as * const _) }' (Used Types: {"* const _", "_"})

--- AST Node Type: If ---
  Expressions using '* const _' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "_", "* const i8", "* const _", "* mut T"})

--- AST Node Type: Match ---
  Expressions using '* const _' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) } } }' (Used Types: {"* const _", "* mut _", "_"})
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) } } }' (Used Types: {"* mut _", "_", "* const _"})

--- AST Node Type: MethodCall ---
  Expressions using '* const _' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'self . iter . next () . map (| elt | unsafe { ptr :: read (elt as * const _) })' (Used Types: {"* const _", "_"})
      - 'self . iter . next_back () . map (| elt | unsafe { ptr :: read (elt as * const _) })' (Used Types: {"_", "* const _"})

--- AST Node Type: Unsafe ---
  Expressions using '* const _' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let (ptr , len_ptr , _) = self . triple_mut () ; let ptr : * const _ = ptr . as_ptr () ; if * len_ptr == 0 { return None ; } let last_index = * len_ptr - 1 ; * len_ptr = last_index ; Some (ptr :: read (ptr . add (last_index))) }' (Used Types: {"* const _", "_"})
    Depth 4: (Count: 3)
      - 'unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) }' (Used Types: {"_", "* const _"})
      - 'unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) }' (Used Types: {"* const _", "_"})
      - 'unsafe { ptr :: read (elt as * const _) }' (Used Types: {"* const _", "_"})
  Expressions using '* const _' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) } }' (Used Types: {"* const _", "_", "* mut T", "T", "* const i8"})

### Analyzing expressions using type: '* const c_void' ###

--- AST Node Type: Cast ---
  Expressions using '* const c_void' with 1 other type(s):
    Depth 2: (Count: 1)
      - '(* self) as * const c_void' (Used Types: {"c_void", "* const c_void"})
  Expressions using '* const c_void' with 3 other type(s):
    Depth 2: (Count: 1)
      - '(* self) as * const T as * const c_void' (Used Types: {"* const T", "c_void", "T", "* const c_void"})

### Analyzing expressions using type: '* const crate :: AtomicU32' ###

--- AST Node Type: Cast ---
  Expressions using '* const crate :: AtomicU32' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const crate :: AtomicU32' (Used Types: {"Self", "AtomicU32", "* const Self", "* const crate :: AtomicU32"})

--- AST Node Type: Paren ---
  Expressions using '* const crate :: AtomicU32' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "Self", "AtomicU32", "* const crate :: AtomicU32"})

--- AST Node Type: Reference ---
  Expressions using '* const crate :: AtomicU32' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "* const crate :: AtomicU32", "Self", "AtomicU32"})

--- AST Node Type: Unary ---
  Expressions using '* const crate :: AtomicU32' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"AtomicU32", "Self", "* const Self", "* const crate :: AtomicU32"})

--- AST Node Type: Unsafe ---
  Expressions using '* const crate :: AtomicU32' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU32) }' (Used Types: {"* const Self", "AtomicU32", "* const crate :: AtomicU32", "Self"})

### Analyzing expressions using type: '* const crate :: AtomicU64' ###

--- AST Node Type: Cast ---
  Expressions using '* const crate :: AtomicU64' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const crate :: AtomicU64' (Used Types: {"Self", "* const Self", "AtomicU64", "* const crate :: AtomicU64"})

--- AST Node Type: Paren ---
  Expressions using '* const crate :: AtomicU64' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "* const crate :: AtomicU64", "Self", "AtomicU64"})

--- AST Node Type: Reference ---
  Expressions using '* const crate :: AtomicU64' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"Self", "AtomicU64", "* const crate :: AtomicU64", "* const Self"})

--- AST Node Type: Unary ---
  Expressions using '* const crate :: AtomicU64' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "AtomicU64", "* const crate :: AtomicU64", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const crate :: AtomicU64' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU64) }' (Used Types: {"* const Self", "AtomicU64", "Self", "* const crate :: AtomicU64"})

### Analyzing expressions using type: '* const i8' ###

--- AST Node Type: Assign ---
  Expressions using '* const i8' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'self . end = arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"T", "* const i8", "* mut T"})

--- AST Node Type: Call ---
  Expressions using '* const i8' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'arith_offset (begin as * const i8 , self . len () as isize)' (Used Types: {"* const i8"})
    Depth 7: (Count: 2)
      - 'arith_offset (self . end as * const i8 , - 1)' (Used Types: {"* const i8"})
      - 'arith_offset (self . ptr as * const i8 , 1)' (Used Types: {"* const i8"})

--- AST Node Type: Cast ---
  Expressions using '* const i8' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'begin as * const i8' (Used Types: {"* const i8"})
    Depth 8: (Count: 2)
      - 'self . end as * const i8' (Used Types: {"* const i8"})
      - 'self . ptr as * const i8' (Used Types: {"* const i8"})
  Expressions using '* const i8' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'arith_offset (begin as * const i8 , self . len () as isize) as * const T' (Used Types: {"* const T", "* const i8", "T"})
    Depth 6: (Count: 2)
      - 'arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})

--- AST Node Type: If ---
  Expressions using '* const i8' with 2 other type(s):
    Depth 3: (Count: 2)
      - 'if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T }' (Used Types: {"* const i8", "* const T", "T"})
      - 'if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"* const i8", "* mut T", "T"})
    Depth 4: (Count: 2)
      - 'if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "* const i8", "* mut T"})
  Expressions using '* const i8' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "_", "* const i8", "* const _", "* mut T"})

--- AST Node Type: Unsafe ---
  Expressions using '* const i8' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) } }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'unsafe { let begin = self . as_mut_ptr () ; let end = if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T } ; mem :: forget (self) ; IntoIter { phantom : PhantomData , ptr : begin , end , } }' (Used Types: {"* const T", "T", "* const i8"})
  Expressions using '* const i8' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) } }' (Used Types: {"* const _", "_", "* mut T", "T", "* const i8"})

### Analyzing expressions using type: '* const imp :: AtomicU8' ###

--- AST Node Type: Cast ---
  Expressions using '* const imp :: AtomicU8' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const imp :: AtomicU8' (Used Types: {"AtomicU8", "* const Self", "* const imp :: AtomicU8", "Self"})

--- AST Node Type: Paren ---
  Expressions using '* const imp :: AtomicU8' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})

--- AST Node Type: Reference ---
  Expressions using '* const imp :: AtomicU8' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"Self", "* const imp :: AtomicU8", "* const Self", "AtomicU8"})

--- AST Node Type: Unary ---
  Expressions using '* const imp :: AtomicU8' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* const imp :: AtomicU8' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const imp :: AtomicU8) }' (Used Types: {"AtomicU8", "Self", "* const Self", "* const imp :: AtomicU8"})

### Analyzing expressions using type: '* const mem :: MaybeUninit < u8 >' ###

--- AST Node Type: Call ---
  Expressions using '* const mem :: MaybeUninit < u8 >' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'slice :: from_raw_parts (ptr as * const mem :: MaybeUninit < u8 > , len)' (Used Types: {"MaybeUninit", "* const mem :: MaybeUninit < u8 >"})

--- AST Node Type: Cast ---
  Expressions using '* const mem :: MaybeUninit < u8 >' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'ptr as * const mem :: MaybeUninit < u8 >' (Used Types: {"* const mem :: MaybeUninit < u8 >", "MaybeUninit"})

--- AST Node Type: Unsafe ---
  Expressions using '* const mem :: MaybeUninit < u8 >' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let (ptr , len) = self . raw . next () ? ; let slice = slice :: from_raw_parts (ptr as * const mem :: MaybeUninit < u8 > , len) ; Some (slice) }' (Used Types: {"* const mem :: MaybeUninit < u8 >", "MaybeUninit"})

### Analyzing expressions using type: '* const siginfo_t' ###

--- AST Node Type: Cast ---
  Expressions using '* const siginfo_t' with 1 other type(s):
    Depth 8: (Count: 1)
      - 'self as * const siginfo_t' (Used Types: {"* const siginfo_t", "siginfo_t"})

--- AST Node Type: Field ---
  Expressions using '* const siginfo_t' with 2 other type(s):
    Depth 2: (Count: 2)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()) . si_addr' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ()) . si_sigval' (Used Types: {"siginfo_timer", "siginfo_t", "* const siginfo_t"})
    Depth 3: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: MethodCall ---
  Expressions using '* const siginfo_t' with 2 other type(s):
    Depth 5: (Count: 2)
      - '(self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_sigfault"})
      - '(self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_timer"})
    Depth 6: (Count: 1)
      - '(self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: Paren ---
  Expressions using '* const siginfo_t' with 1 other type(s):
    Depth 7: (Count: 1)
      - '(self as * const siginfo_t)' (Used Types: {"siginfo_t", "* const siginfo_t"})
  Expressions using '* const siginfo_t' with 2 other type(s):
    Depth 3: (Count: 2)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ())' (Used Types: {"siginfo_sigfault", "* const siginfo_t", "siginfo_t"})
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ())' (Used Types: {"siginfo_timer", "* const siginfo_t", "siginfo_t"})
    Depth 4: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ())' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

--- AST Node Type: Reference ---
  Expressions using '* const siginfo_t' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& (* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"siginfo_t", "siginfo_f", "* const siginfo_t"})

--- AST Node Type: Unary ---
  Expressions using '* const siginfo_t' with 2 other type(s):
    Depth 4: (Count: 2)
      - '* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})
      - '* (self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"siginfo_t", "siginfo_timer", "* const siginfo_t"})
    Depth 5: (Count: 1)
      - '* (self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

### Analyzing expressions using type: '* const u8' ###

--- AST Node Type: Binary ---
  Expressions using '* const u8' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'ptr <= self as * const ChunkFooter as * const u8' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: Block ---
  Expressions using '* const u8' with 1 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }' (Used Types: {"* const u8", "* mut u8"})

--- AST Node Type: Call ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 7: (Count: 1)
      - 'slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,)' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }) ()' (Used Types: {"* const u8", "& str", "* mut u8"})

--- AST Node Type: Cast ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 2: (Count: 3)
      - 'self . data . as_ptr () as * const u8' (Used Types: {"* const u8"})
      - 'self . ptr . get () . as_ptr () as * const u8' (Used Types: {"* const u8"})
      - 'set as * const u8' (Used Types: {"* const u8"})
    Depth 6: (Count: 1)
      - '& raw const (* this) . storage as * const u8' (Used Types: {"* const u8"})
    Depth 8: (Count: 1)
      - 'self . bytes . as_ptr () as * const u8' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 6: (Count: 1)
      - 'self as * const ChunkFooter as * const u8' (Used Types: {"* const u8", "ChunkFooter", "* const ChunkFooter"})

--- AST Node Type: Closure ---
  Expressions using '* const u8' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }' (Used Types: {"* mut u8", "* const u8", "& str"})

--- AST Node Type: If ---
  Expressions using '* const u8' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if true { if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) } }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 3: (Count: 1)
      - 'if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) }' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: MethodCall ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(& raw const (* this) . storage as * const u8) . offset (byte_index as isize)' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})

--- AST Node Type: Paren ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 5: (Count: 1)
      - '(& raw const (* this) . storage as * const u8)' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } })' (Used Types: {"& str", "* mut u8", "* const u8"})
    Depth 5: (Count: 2)
      - '(ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})
      - '(self as * const ChunkFooter as * const u8)' (Used Types: {"* const u8", "* const ChunkFooter", "ChunkFooter"})

--- AST Node Type: Unary ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 3: (Count: 1)
      - '* (& raw const (* this) . storage as * const u8) . offset (byte_index as isize)' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 4: (Count: 1)
      - '! (ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})

--- AST Node Type: Unsafe ---
  Expressions using '* const u8' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { * (& raw const (* this) . storage as * const u8) . offset (byte_index as isize) }' (Used Types: {"* const u8"})
  Expressions using '* const u8' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) }' (Used Types: {"* const u8", "* mut u8"})
  Expressions using '* const u8' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})

### Analyzing expressions using type: '* mut ()' ###

--- AST Node Type: Binary ---
  Expressions using '* mut ()' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"()", "AtomicPtr", "* mut ()"})
    Depth 7: (Count: 1)
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > ()' (Used Types: {"* mut ()", "()", "AtomicPtr"})

--- AST Node Type: Block ---
  Expressions using '* mut ()' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "* mut ()", "()"})
    Depth 6: (Count: 1)
      - '{ core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) }' (Used Types: {"()", "FnTy", "* mut ()"})
  Expressions using '* mut ()' with 5 other type(s):
    Depth 2: (Count: 3)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 10)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})

--- AST Node Type: Call ---
  Expressions using '* mut ()' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,)' (Used Types: {"* mut ()", "()"})
    Depth 8: (Count: 1)
      - 'core :: mem :: size_of :: < * mut () > ()' (Used Types: {"()", "* mut ()"})
  Expressions using '* mut ()' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,)' (Used Types: {"AtomicPtr", "* mut ()", "()"})
    Depth 7: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed))' (Used Types: {"FnTy", "()", "* mut ()"})

--- AST Node Type: Cast ---
  Expressions using '* mut ()' with 1 other type(s):
    Depth 8: (Count: 2)
      - 'detect as * mut ()' (Used Types: {"* mut ()", "()"})
      - 'func as * mut ()' (Used Types: {"* mut ()", "()"})
  Expressions using '* mut ()' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"* mut ()", "()", "AtomicPtr"})

--- AST Node Type: Match ---
  Expressions using '* mut ()' with 5 other type(s):
    Depth 4: (Count: 3)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut ()' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,)' (Used Types: {"* mut ()", "()"})

--- AST Node Type: Path ---
  Expressions using '* mut ()' with 1 other type(s):
    Depth 9: (Count: 1)
      - 'core :: mem :: size_of :: < * mut () >' (Used Types: {"()", "* mut ()"})
  Expressions using '* mut ()' with 2 other type(s):
    Depth 8: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , >' (Used Types: {"* mut ()", "FnTy", "()"})

--- AST Node Type: Repeat ---
  Expressions using '* mut ()' with 2 other type(s):
    Depth 3: (Count: 1)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize]' (Used Types: {"()", "* mut ()", "AtomicPtr"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut ()' with 5 other type(s):
    Depth 3: (Count: 3)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: '* mut (dyn Any + Send)' ###

--- AST Node Type: If ---
  Expressions using '* mut (dyn Any + Send)' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "(dyn Any + Send)", "T", "* mut (dyn Any + Send)", "dyn Any + Send"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut (dyn Any + Send)' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"* mut T", "T", "* mut (dyn Any + Send)", "(dyn Any + Send)", "dyn Any + Send"})

### Analyzing expressions using type: '* mut < I as private :: Sealed > :: Buffer' ###

--- AST Node Type: Block ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Reference ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Unary ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut < I as private :: Sealed > :: Buffer' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '* mut A :: Item' ###

--- AST Node Type: Call ---
  Expressions using '* mut A :: Item' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'NonNull :: new (self . inline . as_mut_ptr () as * mut A :: Item)' (Used Types: {"* mut A :: Item", "Item"})
    Depth 6: (Count: 1)
      - 'ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,)' (Used Types: {"* mut A :: Item", "Item"})
  Expressions using '* mut A :: Item' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data })' (Used Types: {"Item", "A", "* mut A :: Item", "MaybeUninit"})

--- AST Node Type: Cast ---
  Expressions using '* mut A :: Item' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'self . inline . as_mut_ptr () as * mut A :: Item' (Used Types: {"* mut A :: Item", "Item"})
    Depth 7: (Count: 1)
      - 'data . as_mut_ptr () as * mut A :: Item' (Used Types: {"Item", "* mut A :: Item"})

--- AST Node Type: If ---
  Expressions using '* mut A :: Item' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if len <= Self :: inline_capacity () { SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , } } else { let mut b = slice . to_vec () ; let cap = b . capacity () ; let ptr = NonNull :: new (b . as_mut_ptr ()) . expect ("Vec always contain non null pointers.") ; mem :: forget (b) ; SmallVec { capacity : cap , data : SmallVecData :: from_heap (ptr , len) , } }' (Used Types: {"MaybeUninit", "Item", "A", "* mut A :: Item"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut A :: Item' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'NonNull :: new (self . inline . as_mut_ptr () as * mut A :: Item) . unwrap ()' (Used Types: {"Item", "* mut A :: Item"})

--- AST Node Type: Struct ---
  Expressions using '* mut A :: Item' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , }' (Used Types: {"MaybeUninit", "A", "* mut A :: Item", "Item"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut A :: Item' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }' (Used Types: {"A", "Item", "* mut A :: Item", "MaybeUninit"})

### Analyzing expressions using type: '* mut ChunkFooter' ###

--- AST Node Type: Call ---
  Expressions using '* mut ChunkFooter' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) })' (Used Types: {"ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,)' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "ChunkFooter"})
  Expressions using '* mut ChunkFooter' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'EmptyChunkFooter (ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , })' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "* mut u8", "* const EmptyChunkFooter", "EmptyChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using '* mut ChunkFooter' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'footer_ptr as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter"})
  Expressions using '* mut ChunkFooter' with 3 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})

--- AST Node Type: Struct ---
  Expressions using '* mut ChunkFooter' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , }' (Used Types: {"ChunkFooter", "* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "* mut u8"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut ChunkFooter' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }' (Used Types: {"* const EmptyChunkFooter", "ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter"})

### Analyzing expressions using type: '* mut CompletionStatus' ###

--- AST Node Type: If ---
  Expressions using '* mut CompletionStatus' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'if ! prev . is_null () { let ptr : * mut CompletionStatus = self . pin_project () . 1 . get_unchecked_mut () ; match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut CompletionStatus' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { let task = cabi :: wasip3_task_set (ptr :: null_mut ()) ; if ! ! task . is_null () { :: core :: panicking :: panic ("assertion failed: !task.is_null()") } if ! ((* task) . version >= cabi :: WASIP3_TASK_V1) { :: core :: panicking :: panic ("assertion failed: (*task).version >= cabi::WASIP3_TASK_V1" ,) } let prev = ((* task) . waitable_unregister) ((* task) . ptr , waitable) ; if ! prev . is_null () { let ptr : * mut CompletionStatus = self . pin_project () . 1 . get_unchecked_mut () ; match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } cabi :: wasip3_task_set (task) ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})
      - 'unsafe { let task = cabi :: wasip3_task_set (ptr :: null_mut ()) ; if ! ! task . is_null () { :: core :: panicking :: panic ("assertion failed: !task.is_null()") } if ! ((* task) . version >= cabi :: WASIP3_TASK_V1) { :: core :: panicking :: panic ("assertion failed: (*task).version >= cabi::WASIP3_TASK_V1" ,) } let ptr : * mut CompletionStatus = completion_status . get_unchecked_mut () ; let prev = ((* task) . waitable_register) ((* task) . ptr , waitable , cabi_wake , ptr . cast () ,) ; if ! prev . is_null () { match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } cabi :: wasip3_task_set (task) ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})

### Analyzing expressions using type: '* mut E' ###

--- AST Node Type: Call ---
  Expressions using '* mut E' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) })' (Used Types: {"E", "* mut E"})
    Depth 5: (Count: 1)
      - 'NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E)' (Used Types: {"E", "* mut E"})
    Depth 6: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) })' (Used Types: {"E", "* mut E"})
    Depth 8: (Count: 1)
      - 'NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,)' (Used Types: {"E", "* mut E"})
  Expressions using '* mut E' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})

--- AST Node Type: Cast ---
  Expressions using '* mut E' with 1 other type(s):
    Depth 9: (Count: 1)
      - '& raw const (* unerased_ref . as_ptr ()) . _object as * mut E' (Used Types: {"* mut E", "E"})

--- AST Node Type: If ---
  Expressions using '* mut E' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < E > > () ; return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,) ; } else { None }' (Used Types: {"E", "ErrorImpl", "* mut E", "()"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut E' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > ()' (Used Types: {"* mut E", "E", "()"})

--- AST Node Type: Return ---
  Expressions using '* mut E' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'return Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) })' (Used Types: {"* mut E", "E"})
  Expressions using '* mut E' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut E' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) }' (Used Types: {"* mut E", "E"})
    Depth 7: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }' (Used Types: {"* mut E", "E"})

### Analyzing expressions using type: '* mut FutureState' ###

--- AST Node Type: Cast ---
  Expressions using '* mut FutureState' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'self as * mut FutureState' (Used Types: {"* mut FutureState", "FutureState"})

### Analyzing expressions using type: '* mut Self' ###

--- AST Node Type: Cast ---
  Expressions using '* mut Self' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'ptr as * mut Self' (Used Types: {"* mut Self", "Self"})

--- AST Node Type: Paren ---
  Expressions using '* mut Self' with 1 other type(s):
    Depth 5: (Count: 1)
      - '(ptr as * mut Self)' (Used Types: {"Self", "* mut Self"})

--- AST Node Type: Reference ---
  Expressions using '* mut Self' with 1 other type(s):
    Depth 3: (Count: 1)
      - '& * (ptr as * mut Self)' (Used Types: {"* mut Self", "Self"})

--- AST Node Type: Unary ---
  Expressions using '* mut Self' with 1 other type(s):
    Depth 4: (Count: 1)
      - '* (ptr as * mut Self)' (Used Types: {"Self", "* mut Self"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut Self' with 1 other type(s):
    Depth 2: (Count: 1)
      - '# [allow (clippy :: cast_ptr_alignment)] unsafe { & * (ptr as * mut Self) }' (Used Types: {"Self", "* mut Self"})

### Analyzing expressions using type: '* mut Self :: Item' ###

--- AST Node Type: If ---
  Expressions using '* mut Self :: Item' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut Self :: Item' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"* const Self :: Item", "Item", "* mut Self :: Item"})

--- AST Node Type: While ---
  Expressions using '* mut Self :: Item' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"Item", "* const Self :: Item", "* mut Self :: Item"})

### Analyzing expressions using type: '* mut T' ###

--- AST Node Type: Assign ---
  Expressions using '* mut T' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'self . end = arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"T", "* const i8", "* mut T"})

--- AST Node Type: Call ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'NonNull :: new (ptr as * mut T)' (Used Types: {"T", "* mut T"})
      - 'slice :: from_raw_parts_mut (self . ptr as * mut T , self . len ())' (Used Types: {"* mut T", "T"})
    Depth 4: (Count: 1)
      - 'Ok (Box :: from_raw (raw as * mut T))' (Used Types: {"* mut T", "T"})
    Depth 5: (Count: 2)
      - 'Box :: from_raw (raw as * mut T)' (Used Types: {"* mut T", "T"})
      - 'Some (| ptr | ptr :: drop_in_place (ptr as * mut T))' (Used Types: {"* mut T", "T"})
    Depth 7: (Count: 1)
      - 'ptr :: drop_in_place (ptr as * mut T)' (Used Types: {"T", "* mut T"})

--- AST Node Type: Cast ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'b . deref_mut () . 0 as * mut T' (Used Types: {"* mut T", "T"})
      - 'p . as_ptr () as * mut T' (Used Types: {"T", "* mut T"})
    Depth 4: (Count: 2)
      - 'ptr as * mut T' (Used Types: {"* mut T", "T"})
      - 'self . ptr as * mut T' (Used Types: {"* mut T", "T"})
    Depth 6: (Count: 1)
      - 'raw as * mut T' (Used Types: {"* mut T", "T"})
  Expressions using '* mut T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'ptr as * const T as * mut T' (Used Types: {"* const T", "T", "* mut T"})
    Depth 6: (Count: 2)
      - 'arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
  Expressions using '* mut T' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'self as * mut _ as * mut T' (Used Types: {"* mut _", "* mut T", "T", "_"})
  Expressions using '* mut T' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: Closure ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 4: (Count: 1)
      - '| _ : * mut T | ()' (Used Types: {"T", "* mut T"})
    Depth 6: (Count: 1)
      - '| ptr | ptr :: drop_in_place (ptr as * mut T)' (Used Types: {"* mut T", "T"})

--- AST Node Type: If ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None }' (Used Types: {"* mut T", "T"})
  Expressions using '* mut T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"* const i8", "* mut T", "T"})
    Depth 4: (Count: 3)
      - 'if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* const T", "* mut T", "T"})
      - 'if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "* const i8", "* mut T"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut T", "T", "* const T"})
  Expressions using '* mut T' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "dyn Any", "* mut dyn Any", "T"})
  Expressions using '* mut T' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "(dyn Any + Send)", "T", "* mut (dyn Any + Send)", "dyn Any + Send"})
    Depth 3: (Count: 1)
      - 'if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "_", "* const i8", "* const _", "* mut T"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'NonNull :: new (ptr as * mut T) . map (Self)' (Used Types: {"* mut T", "T"})
    Depth 3: (Count: 1)
      - 'self . table . reserve_rehash_inner (& self . alloc , additional , & | table , index | hasher (table . bucket :: < T > (index) . as_ref ()) , fallibility , Self :: TABLE_LAYOUT , if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None } ,)' (Used Types: {"* mut T", "T"})
  Expressions using '* mut T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ()) . map_err (< * mut T > :: cast_const)' (Used Types: {"T", "* mut T", "* const T"})
    Depth 3: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ())' (Used Types: {"* const T", "* mut T", "T"})
  Expressions using '* mut T' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using '* mut T' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Path ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 3: (Count: 1)
      - '< * mut T > :: cast_const' (Used Types: {"* mut T", "T"})

--- AST Node Type: Unary ---
  Expressions using '* mut T' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut T' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'unsafe { let hole : * mut T = & mut self [index] ; let last = ptr :: read (self . get_unchecked (self . len - 1)) ; self . len -= 1 ; ptr :: replace (hole , last) }' (Used Types: {"* mut T", "T"})
      - 'unsafe { let p = self . alloc_layout (layout) ; let p = p . as_ptr () as * mut T ; inner_writer (p , f) ; & mut * p }' (Used Types: {"* mut T", "T"})
      - 'unsafe { self . table . reserve_rehash_inner (& self . alloc , additional , & | table , index | hasher (table . bucket :: < T > (index) . as_ref ()) , fallibility , Self :: TABLE_LAYOUT , if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None } ,) }' (Used Types: {"T", "* mut T"})
      - 'unsafe { slice :: from_raw_parts_mut (self . ptr as * mut T , self . len ()) }' (Used Types: {"* mut T", "T"})
  Expressions using '* mut T' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) } }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'unsafe { while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"T", "* const T", "* mut T"})
  Expressions using '* mut T' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"dyn Any", "* mut dyn Any", "T", "* mut T"})
  Expressions using '* mut T' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) } }' (Used Types: {"* const _", "_", "* mut T", "T", "* const i8"})
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"* mut T", "T", "* mut (dyn Any + Send)", "(dyn Any + Send)", "dyn Any + Send"})
  Expressions using '* mut T' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

--- AST Node Type: While ---
  Expressions using '* mut T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"T", "* mut T", "* const T"})

### Analyzing expressions using type: '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' ###

--- AST Node Type: Block ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Reference ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Unary ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' ###

--- AST Node Type: Block ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 3 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8"})

--- AST Node Type: Call ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut u8", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Cast ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 8: (Count: 1)
      - 'buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

--- AST Node Type: Closure ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "* mut u8"})

--- AST Node Type: If ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

--- AST Node Type: Paren ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "& str"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] }' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '* mut [T ; N]' ###

--- AST Node Type: Cast ---
  Expressions using '* mut [T ; N]' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'slice . as_mut_ptr () as * mut [T ; N]' (Used Types: {"* mut [T ; N]", "T", "[T ; N]"})

--- AST Node Type: If ---
  Expressions using '* mut [T ; N]' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if slice . len () == N { let mut slice = ManuallyDrop :: new (slice) ; let ptr = slice . as_mut_ptr () as * mut [T ; N] ; Ok (unsafe { Box :: from_raw (ptr) }) } else { Err (slice) }' (Used Types: {"T", "* mut [T ; N]", "[T ; N]"})

### Analyzing expressions using type: '* mut _' ###

--- AST Node Type: Call ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (unsafe { & mut * (t as * mut _) })' (Used Types: {"_", "* mut _"})
    Depth 4: (Count: 1)
      - 'NonNull :: new_unchecked (self as * mut _)' (Used Types: {"* mut _", "_"})

--- AST Node Type: Cast ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'self as * mut _' (Used Types: {"_", "* mut _"})
    Depth 8: (Count: 1)
      - 't as * mut _' (Used Types: {"* mut _", "_"})
  Expressions using '* mut _' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'self as * mut _ as * mut T' (Used Types: {"* mut _", "* mut T", "T", "_"})

--- AST Node Type: Match ---
  Expressions using '* mut _' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) } } }' (Used Types: {"* const _", "* mut _", "_"})
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) } } }' (Used Types: {"* mut _", "_", "* const _"})

--- AST Node Type: Paren ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 7: (Count: 1)
      - '(t as * mut _)' (Used Types: {"_", "* mut _"})

--- AST Node Type: Reference ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 5: (Count: 1)
      - '& mut * (t as * mut _)' (Used Types: {"_", "* mut _"})

--- AST Node Type: Struct ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Drain { tail_start : end , tail_len : len - end , iter : range_slice . iter () , vec : NonNull :: new_unchecked (self as * mut _) , }' (Used Types: {"_", "* mut _"})

--- AST Node Type: Unary ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 6: (Count: 1)
      - '* (t as * mut _)' (Used Types: {"* mut _", "_"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut _' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { self . set_len (start) ; let range_slice = slice :: from_raw_parts (self . as_ptr () . add (start) , end - start ,) ; Drain { tail_start : end , tail_len : len - end , iter : range_slice . iter () , vec : NonNull :: new_unchecked (self as * mut _) , } }' (Used Types: {"* mut _", "_"})
    Depth 4: (Count: 1)
      - 'unsafe { & mut * (t as * mut _) }' (Used Types: {"_", "* mut _"})

### Analyzing expressions using type: '* mut bool' ###

--- AST Node Type: Cast ---
  Expressions using '* mut bool' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'self . v . get () as * mut bool' (Used Types: {"* mut bool"})

### Analyzing expressions using type: '* mut c_uchar' ###

--- AST Node Type: Cast ---
  Expressions using '* mut c_uchar' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'cmsg . offset (1) as * mut c_uchar' (Used Types: {"c_uchar", "* mut c_uchar"})
    Depth 4: (Count: 1)
      - 'cmsg as * mut c_uchar' (Used Types: {"c_uchar", "* mut c_uchar"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut c_uchar' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut c_uchar) . add (size_of :: < cmsghdr > ())' (Used Types: {"cmsghdr", "* mut c_uchar", "c_uchar"})

--- AST Node Type: Paren ---
  Expressions using '* mut c_uchar' with 1 other type(s):
    Depth 3: (Count: 1)
      - '(cmsg as * mut c_uchar)' (Used Types: {"c_uchar", "* mut c_uchar"})

### Analyzing expressions using type: '* mut c_void' ###

--- AST Node Type: Cast ---
  Expressions using '* mut c_void' with 1 other type(s):
    Depth 2: (Count: 2)
      - '! 0 as * mut c_void' (Used Types: {"* mut c_void", "c_void"})
      - '- 1i64 as * mut c_void' (Used Types: {"c_void", "* mut c_void"})

### Analyzing expressions using type: '* mut cmsghdr' ###

--- AST Node Type: Cast ---
  Expressions using '* mut cmsghdr' with 1 other type(s):
    Depth 2: (Count: 2)
      - '(* mhdr) . msg_control as * mut cmsghdr' (Used Types: {"* mut cmsghdr", "cmsghdr"})
      - '(cmsg as usize + super :: CMSG_ALIGN ((* cmsg) . cmsg_len as usize)) as * mut cmsghdr' (Used Types: {"* mut cmsghdr", "cmsghdr"})
  Expressions using '* mut cmsghdr' with 3 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize) as * mut cmsghdr' (Used Types: {"_", "* mut cmsghdr", "cmsghdr", "* mut u8"})

### Analyzing expressions using type: '* mut crate :: sockaddr' ###

--- AST Node Type: Cast ---
  Expressions using '* mut crate :: sockaddr' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'ee . offset (1) as * mut crate :: sockaddr' (Used Types: {"* mut crate :: sockaddr", "sockaddr"})

### Analyzing expressions using type: '* mut dyn Any' ###

--- AST Node Type: If ---
  Expressions using '* mut dyn Any' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "dyn Any", "* mut dyn Any", "T"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut dyn Any' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"dyn Any", "* mut dyn Any", "T", "* mut T"})

### Analyzing expressions using type: '* mut str' ###

--- AST Node Type: Call ---
  Expressions using '* mut str' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Box :: from_raw (Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str)' (Used Types: {"* mut str", "[u8]"})

--- AST Node Type: Cast ---
  Expressions using '* mut str' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str' (Used Types: {"[u8]", "* mut str"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut str' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { Box :: from_raw (Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str) }' (Used Types: {"* mut str", "[u8]"})

### Analyzing expressions using type: '* mut u128' ###

--- AST Node Type: Block ---
  Expressions using '* mut u128' with 5 other type(s):
    Depth 2: (Count: 3)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 10)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})

--- AST Node Type: Match ---
  Expressions using '* mut u128' with 5 other type(s):
    Depth 4: (Count: 3)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut u128' with 5 other type(s):
    Depth 3: (Count: 3)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: '* mut u8' ###

--- AST Node Type: Block ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 5: (Count: 2)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"* mut u8"})
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }' (Used Types: {"* const u8", "* mut u8"})
    Depth 6: (Count: 1)
      - '{ let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; }' (Used Types: {"* mut u8", "Item"})
  Expressions using '* mut u8' with 3 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8"})

--- AST Node Type: Call ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'alloc :: alloc :: dealloc (ptr . as_ptr () as * mut u8 , layout)' (Used Types: {"* mut u8"})
    Depth 3: (Count: 1)
      - 'Some ((ptr as * mut u8 , len))' (Used Types: {"* mut u8"})
    Depth 7: (Count: 1)
      - 'alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,)' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 2: (Count: 2)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"* mut u8", "& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"& str", "* mut u8"})
  Expressions using '* mut u8' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }) ()' (Used Types: {"* const u8", "& str", "* mut u8"})
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) })' (Used Types: {"EmptyChunkFooter", "* mut u8", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8)' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using '* mut u8' with 4 other type(s):
    Depth 2: (Count: 2)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut u8", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit"})
      - 'EmptyChunkFooter (ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , })' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "* mut u8", "* const EmptyChunkFooter", "EmptyChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'set as * mut u8' (Used Types: {"* mut u8"})
    Depth 5: (Count: 4)
      - '& raw mut (* this) . storage as * mut u8' (Used Types: {"* mut u8"})
      - 'align as * mut u8' (Used Types: {"* mut u8"})
      - 'cmsg as * mut u8' (Used Types: {"* mut u8"})
      - 'ptr as * mut u8' (Used Types: {"* mut u8"})
    Depth 6: (Count: 1)
      - 'buf . as_mut_ptr () as * mut u8' (Used Types: {"* mut u8"})
    Depth 8: (Count: 2)
      - 'ptr . as_ptr () as * mut u8' (Used Types: {"* mut u8"})
      - 'self . bytes . as_mut_ptr () as * mut u8' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 2 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using '* mut u8' with 3 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize) as * mut cmsghdr' (Used Types: {"_", "* mut cmsghdr", "cmsghdr", "* mut u8"})

--- AST Node Type: Closure ---
  Expressions using '* mut u8' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"* mut u8", "& str"})
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"& str", "* mut u8"})
  Expressions using '* mut u8' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } }' (Used Types: {"* mut u8", "* const u8", "& str"})
  Expressions using '* mut u8' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "* mut u8"})

--- AST Node Type: If ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'if old_len == 0 { if new_len == 0 { return align as * mut u8 ; } layout = Layout :: from_size_align_unchecked (new_len , align) ; allocate (layout) } else { if true { match (& (new_len) , & (0)) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("non-zero old_len requires non-zero new_len!") ,) ,) ; } } } ; } layout = Layout :: from_size_align_unchecked (old_len , align) ; realloc (old_ptr , layout , new_len) }' (Used Types: {"* mut u8"})
    Depth 3: (Count: 1)
      - 'if new_len == 0 { return align as * mut u8 ; }' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'if new_cap <= Self :: inline_capacity () { if unspilled { return Ok (()) ; } self . data = SmallVecData :: from_inline (MaybeUninit :: uninit ()) ; ptr :: copy_nonoverlapping (ptr . as_ptr () , self . data . inline_mut () . as_ptr () , len ,) ; self . capacity = len ; deallocate (ptr , cap) ; } else if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; }' (Used Types: {"Item", "* mut u8"})
    Depth 4: (Count: 1)
      - 'if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; }' (Used Types: {"* mut u8", "Item"})
    Depth 5: (Count: 1)
      - 'if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; }' (Used Types: {"* mut u8", "Item"})

--- AST Node Type: MethodCall ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(& raw mut (* this) . storage as * mut u8) . offset (byte_index as isize)' (Used Types: {"* mut u8"})
    Depth 7: (Count: 1)
      - 'f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8)' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 3: (Count: 1)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize)' (Used Types: {"* mut u8", "_"})

--- AST Node Type: Paren ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 4: (Count: 2)
      - '(& raw mut (* this) . storage as * mut u8)' (Used Types: {"* mut u8"})
      - '(cmsg as * mut u8)' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 3: (Count: 2)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u32 } else { (! (self as u32)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut u8", "& str"})
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let mut n = if is_nonnegative { self as u64 } else { (! (self as u64)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let lut_ptr = DEC_DIGITS_LUT . as_ptr () ; while n >= 10000 { let rem = n % 10000 ; n /= 10000 ; let d1 = ((rem / 100) << 1) as usize ; let d2 = ((rem % 100) << 1) as usize ; curr -= 4 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; ptr :: copy_nonoverlapping (lut_ptr . add (d2) , buf_ptr . add (curr + 2) , 2) ; } } if n >= 100 { let d1 = ((n % 100) << 1) as usize ; n /= 100 ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if n < 10 { curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } else { let d1 = (n << 1) as usize ; curr -= 2 ; unsafe { ptr :: copy_nonoverlapping (lut_ptr . add (d1) , buf_ptr . add (curr) , 2) ; } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"& str", "* mut u8"})
  Expressions using '* mut u8' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let f = __arg1 ; unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) } })' (Used Types: {"& str", "* mut u8", "* const u8"})
  Expressions using '* mut u8' with 4 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "& str"})

--- AST Node Type: Return ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'return align as * mut u8' (Used Types: {"* mut u8"})

--- AST Node Type: Struct ---
  Expressions using '* mut u8' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , }' (Used Types: {"ChunkFooter", "* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "* mut u8"})

--- AST Node Type: Tuple ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(ptr as * mut u8 , len)' (Used Types: {"* mut u8"})

--- AST Node Type: Unsafe ---
  Expressions using '* mut u8' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { (& raw mut (* this) . storage as * mut u8) . offset (byte_index as isize) }' (Used Types: {"* mut u8"})
      - 'unsafe { let foot = self . footer . as_ref () ; if foot . is_empty () { return None ; } let (ptr , len) = foot . as_raw_parts () ; self . footer = foot . prev . get () ; Some ((ptr as * mut u8 , len)) }' (Used Types: {"* mut u8"})
  Expressions using '* mut u8' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let unspilled = ! self . spilled () ; let (ptr , & mut len , cap) = self . triple_mut () ; if ! (new_cap >= len) { :: core :: panicking :: panic ("assertion failed: new_cap >= len") } if new_cap <= Self :: inline_capacity () { if unspilled { return Ok (()) ; } self . data = SmallVecData :: from_inline (MaybeUninit :: uninit ()) ; ptr :: copy_nonoverlapping (ptr . as_ptr () , self . data . inline_mut () . as_ptr () , len ,) ; self . capacity = len ; deallocate (ptr , cap) ; } else if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; } Ok (()) }' (Used Types: {"* mut u8", "Item"})
    Depth 6: (Count: 1)
      - 'unsafe { let n = f . write_to_ryu_buffer (self . bytes . as_mut_ptr () as * mut u8) ; if true { if ! (n <= self . bytes . len ()) { :: core :: panicking :: panic ("assertion failed: n <= self.bytes.len()" ,) } } let slice = slice :: from_raw_parts (self . bytes . as_ptr () as * const u8 , n ,) ; str :: from_utf8_unchecked (slice) }' (Used Types: {"* const u8", "* mut u8"})
  Expressions using '* mut u8' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }' (Used Types: {"EmptyChunkFooter", "* const EmptyChunkFooter", "* mut u8"})

### Analyzing expressions using type: 'A' ###

--- AST Node Type: Array ---
  Expressions using 'A' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]' (Used Types: {"V", "A"})

--- AST Node Type: Binary ---
  Expressions using 'A' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()' (Used Types: {"A", "Item"})
    Depth 6: (Count: 2)
      - 'mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()' (Used Types: {"Item", "A"})
      - 'mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > ()' (Used Types: {"A", "Item"})

--- AST Node Type: Block ---
  Expressions using 'A' with 0 other type(s):
    Depth 3: (Count: 1)
      - '{ let mut v = SmallVec :: < A > :: new () ; unsafe { let (ptr , len_ptr , _) = v . triple_mut () ; let ptr = ptr . as_ptr () ; let mut local_len = SetLenOnDrop :: new (len_ptr) ; for i in 0 .. n { :: core :: ptr :: write (ptr . add (i) , elem . clone ()) ; local_len . increment_len (1) ; } } v }' (Used Types: {"A"})
  Expressions using 'A' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

--- AST Node Type: Call ---
  Expressions using 'A' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'SmallVec :: < A > :: new ()' (Used Types: {"A"})
      - 'SmallVecData :: < A > :: from_inline (MaybeUninit :: uninit ())' (Used Types: {"A"})
    Depth 7: (Count: 2)
      - 'mem :: align_of :: < A > ()' (Used Types: {"A"})
      - 'mem :: size_of :: < A > ()' (Used Types: {"A"})
    Depth 10: (Count: 1)
      - ':: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,)' (Used Types: {"A"})
  Expressions using 'A' with 1 other type(s):
    Depth 8: (Count: 1)
      - ':: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,])' (Used Types: {"A", "V"})
  Expressions using 'A' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data })' (Used Types: {"Item", "A", "* mut A :: Item", "MaybeUninit"})
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,)' (Used Types: {"[_]", "_", "A", "V"})

--- AST Node Type: Closure ---
  Expressions using 'A' with 0 other type(s):
    Depth 6: (Count: 1)
      - '| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])' (Used Types: {"A"})

--- AST Node Type: If ---
  Expressions using 'A' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'if n > Self :: inline_capacity () { :: alloc :: vec :: from_elem (elem , n) . into () } else { let mut v = SmallVec :: < A > :: new () ; unsafe { let (ptr , len_ptr , _) = v . triple_mut () ; let ptr = ptr . as_ptr () ; let mut local_len = SetLenOnDrop :: new (len_ptr) ; for i in 0 .. n { :: core :: ptr :: write (ptr . add (i) , elem . clone ()) ; local_len . increment_len (1) ; } } v }' (Used Types: {"A"})
      - 'if vec . capacity () <= Self :: inline_capacity () { unsafe { let mut data = SmallVecData :: < A > :: from_inline (MaybeUninit :: uninit ()) ; let len = vec . len () ; vec . set_len (0) ; ptr :: copy_nonoverlapping (vec . as_ptr () , data . inline_mut () . as_ptr () , len) ; SmallVec { capacity : len , data } } } else { let (ptr , cap , len) = (vec . as_mut_ptr () , vec . capacity () , vec . len ()) ; mem :: forget (vec) ; let ptr = NonNull :: new (ptr) . expect ("Cannot be null by `Vec` invariant") ; SmallVec { capacity : cap , data : SmallVecData :: from_heap (ptr , len) , } }' (Used Types: {"A"})
  Expressions using 'A' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'if ! (mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()) { :: core :: panicking :: panic ("assertion failed: mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>() &&\n    mem::align_of::<A>() >= mem::align_of::<A::Item>()" ,) }' (Used Types: {"A", "Item"})
  Expressions using 'A' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if len <= Self :: inline_capacity () { SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , } } else { let mut b = slice . to_vec () ; let cap = b . capacity () ; let ptr = NonNull :: new (b . as_mut_ptr ()) . expect ("Vec always contain non null pointers.") ; mem :: forget (b) ; SmallVec { capacity : cap , data : SmallVecData :: from_heap (ptr , len) , } }' (Used Types: {"MaybeUninit", "Item", "A", "* mut A :: Item"})

--- AST Node Type: MethodCall ---
  Expressions using 'A' with 0 other type(s):
    Depth 7: (Count: 1)
      - 'f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])' (Used Types: {"A"})
    Depth 8: (Count: 1)
      - 'f . ty :: < A > () . name ("rest") . type_name ("A")' (Used Types: {"A"})
    Depth 9: (Count: 1)
      - 'f . ty :: < A > () . name ("rest")' (Used Types: {"A"})
    Depth 10: (Count: 1)
      - 'f . ty :: < A > ()' (Used Types: {"A"})
  Expressions using 'A' with 1 other type(s):
    Depth 5: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& []))' (Used Types: {"V", "A"})
  Expressions using 'A' with 3 other type(s):
    Depth 4: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,)' (Used Types: {"[_]", "V", "A", "_"})
    Depth 5: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,)' (Used Types: {"A", "[_]", "V", "_"})
    Depth 6: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,)' (Used Types: {"V", "A", "_", "[_]"})

--- AST Node Type: Paren ---
  Expressions using 'A' with 1 other type(s):
    Depth 4: (Count: 1)
      - '(mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ())' (Used Types: {"A", "Item"})

--- AST Node Type: Path ---
  Expressions using 'A' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'SmallVec :: < A > :: new' (Used Types: {"A"})
      - 'SmallVecData :: < A > :: from_inline' (Used Types: {"A"})
    Depth 8: (Count: 2)
      - 'mem :: align_of :: < A >' (Used Types: {"A"})
      - 'mem :: size_of :: < A >' (Used Types: {"A"})

--- AST Node Type: Struct ---
  Expressions using 'A' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , }' (Used Types: {"MaybeUninit", "A", "* mut A :: Item", "Item"})

--- AST Node Type: Unary ---
  Expressions using 'A' with 1 other type(s):
    Depth 3: (Count: 1)
      - '! (mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ())' (Used Types: {"A", "Item"})

--- AST Node Type: Unsafe ---
  Expressions using 'A' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let mut data = SmallVecData :: < A > :: from_inline (MaybeUninit :: uninit ()) ; let len = vec . len () ; vec . set_len (0) ; ptr :: copy_nonoverlapping (vec . as_ptr () , data . inline_mut () . as_ptr () , len) ; SmallVec { capacity : len , data } }' (Used Types: {"A"})
  Expressions using 'A' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }' (Used Types: {"A", "Item", "* mut A :: Item", "MaybeUninit"})

### Analyzing expressions using type: 'ATerm' ###

--- AST Node Type: Block ---
  Expressions using 'ATerm' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for ATerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("ATerm" , "typenum::array")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for type arrays."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "ATerm"})
  Expressions using 'ATerm' with 4 other type(s):
    Depth 2: (Count: 2)
      - '{ # [doc = " A type which contributes nothing when adding (i.e. a zero)"] pub struct Null ; impl < T > Add < T > for Null { type Output = T ; fn add (self , rhs : T) -> Self :: Output { rhs } } impl FoldAdd for ATerm { type Output = Null ; } }' (Used Types: {"ATerm", "T", "Self", "Output", "Null"})
      - '{ # [doc = " A type which contributes nothing when multiplying (i.e. a one)"] pub struct Null ; impl < T > Mul < T > for Null { type Output = T ; fn mul (self , rhs : T) -> Self :: Output { rhs } } impl FoldMul for ATerm { type Output = Null ; } }' (Used Types: {"Self", "Null", "T", "Output", "ATerm"})

### Analyzing expressions using type: 'Alternation' ###

--- AST Node Type: Block ---
  Expressions using 'Alternation' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Alternation' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
  Expressions using 'Alternation' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Alternation' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Alternation' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'Alternation' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'Assertion' ###

--- AST Node Type: Block ---
  Expressions using 'Assertion' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Assertion' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
  Expressions using 'Assertion' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Assertion' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Assertion' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'Assertion' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'AssertionKind' ###

--- AST Node Type: Array ---
  Expressions using 'AssertionKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "AssertionKind"})

--- AST Node Type: Block ---
  Expressions using 'AssertionKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
  Expressions using 'AssertionKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})

--- AST Node Type: Call ---
  Expressions using 'AssertionKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "AssertionKind"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"AssertionKind", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"AssertionKind", "Span"})

--- AST Node Type: Closure ---
  Expressions using 'AssertionKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "AssertionKind"})

--- AST Node Type: Reference ---
  Expressions using 'AssertionKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"AssertionKind", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'AssertionKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"AssertionKind"})

### Analyzing expressions using type: 'Ast' ###

--- AST Node Type: Array ---
  Expressions using 'Ast' with 2 other type(s):
    Depth 9: (Count: 2)
      - '[< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Vec", "Comment"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "Ast"})
  Expressions using 'Ast' with 3 other type(s):
    Depth 9: (Count: 2)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"GroupKind", "Box", "Ast", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Box", "Ast", "Span"})

--- AST Node Type: Block ---
  Expressions using 'Ast' with 13 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Ast' with 14 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Ast' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Ast' with 2 other type(s):
    Depth 4: (Count: 2)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Ast", "Vec", "Comment"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
    Depth 6: (Count: 2)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Comment", "Ast", "Vec"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
    Depth 7: (Count: 2)
      - 'arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Ast", "Vec", "Comment"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "Vec", "Ast"})
  Expressions using 'Ast' with 3 other type(s):
    Depth 4: (Count: 2)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})
    Depth 6: (Count: 2)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Box", "RepetitionOp", "Ast"})
    Depth 7: (Count: 2)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Box", "Span", "GroupKind", "Ast"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"RepetitionOp", "Box", "Span", "Ast"})

--- AST Node Type: Closure ---
  Expressions using 'Ast' with 2 other type(s):
    Depth 5: (Count: 2)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Ast", "Comment"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Span", "Ast"})
  Expressions using 'Ast' with 3 other type(s):
    Depth 5: (Count: 2)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "GroupKind", "Box", "Ast"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "RepetitionOp", "Ast", "Span"})

--- AST Node Type: Reference ---
  Expressions using 'Ast' with 2 other type(s):
    Depth 8: (Count: 2)
      - '& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Comment", "Vec", "Ast"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Span", "Vec"})
  Expressions using 'Ast' with 3 other type(s):
    Depth 8: (Count: 2)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "GroupKind", "Span", "Box"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'Ast' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Ast"})
  Expressions using 'Ast' with 1 other type(s):
    Depth 10: (Count: 2)
      - '< Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Box", "Ast"})
      - '< Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Vec", "Ast"})

### Analyzing expressions using type: 'AtomicBool' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < AtomicBool , u8 > (self) != 0' (Used Types: {"AtomicBool"})
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > () ,) as usize' (Used Types: {"AtomicBool"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > () ,) as usize' (Used Types: {"AtomicBool"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > ()' (Used Types: {"AtomicBool"})
      - 'core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > ()' (Used Types: {"AtomicBool"})

--- AST Node Type: Block ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > () ,) as usize] ; }' (Used Types: {"AtomicBool"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > () ,) as usize] ; }' (Used Types: {"AtomicBool"})

--- AST Node Type: Call ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < AtomicBool , u8 > (self)' (Used Types: {"AtomicBool"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > () ,)' (Used Types: {"AtomicBool"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > () ,)' (Used Types: {"AtomicBool"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicBool > ()' (Used Types: {"AtomicBool"})
      - 'core :: mem :: size_of :: < AtomicBool > ()' (Used Types: {"AtomicBool"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > () ,) as usize' (Used Types: {"AtomicBool"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > () ,) as usize' (Used Types: {"AtomicBool"})

--- AST Node Type: Path ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < AtomicBool , u8 >' (Used Types: {"AtomicBool"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicBool >' (Used Types: {"AtomicBool"})
      - 'core :: mem :: size_of :: < AtomicBool >' (Used Types: {"AtomicBool"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicBool > () == core :: mem :: size_of :: < AtomicBool > () ,) as usize]' (Used Types: {"AtomicBool"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicBool > () == core :: mem :: size_of :: < bool > () ,) as usize]' (Used Types: {"AtomicBool"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicBool' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < AtomicBool , u8 > (self) != 0 }' (Used Types: {"AtomicBool"})

### Analyzing expressions using type: 'AtomicF32' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > () ,) as usize' (Used Types: {"AtomicF32"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > () ,) as usize' (Used Types: {"AtomicF32"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > ()' (Used Types: {"AtomicF32"})
      - 'core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > ()' (Used Types: {"AtomicF32"})

--- AST Node Type: Block ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > () ,) as usize] ; }' (Used Types: {"AtomicF32"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > () ,) as usize] ; }' (Used Types: {"AtomicF32"})

--- AST Node Type: Call ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: float :: AtomicF32 > :: is_lock_free ()' (Used Types: {"AtomicF32"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > () ,)' (Used Types: {"AtomicF32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > () ,)' (Used Types: {"AtomicF32"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF32 > ()' (Used Types: {"AtomicF32"})
      - 'core :: mem :: size_of :: < AtomicF32 > ()' (Used Types: {"AtomicF32"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > () ,) as usize' (Used Types: {"AtomicF32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > () ,) as usize' (Used Types: {"AtomicF32"})

--- AST Node Type: Path ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: float :: AtomicF32 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicF32"})
    Depth 3: (Count: 1)
      - '< imp :: float :: AtomicF32 > :: is_lock_free' (Used Types: {"AtomicF32"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF32 >' (Used Types: {"AtomicF32"})
      - 'core :: mem :: size_of :: < AtomicF32 >' (Used Types: {"AtomicF32"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicF32' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF32 > () == core :: mem :: size_of :: < AtomicF32 > () ,) as usize]' (Used Types: {"AtomicF32"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF32 > () == core :: mem :: size_of :: < f32 > () ,) as usize]' (Used Types: {"AtomicF32"})

### Analyzing expressions using type: 'AtomicF64' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > () ,) as usize' (Used Types: {"AtomicF64"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > () ,) as usize' (Used Types: {"AtomicF64"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > ()' (Used Types: {"AtomicF64"})
      - 'core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > ()' (Used Types: {"AtomicF64"})

--- AST Node Type: Block ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > () ,) as usize] ; }' (Used Types: {"AtomicF64"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > () ,) as usize] ; }' (Used Types: {"AtomicF64"})

--- AST Node Type: Call ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: float :: AtomicF64 > :: is_lock_free ()' (Used Types: {"AtomicF64"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > () ,)' (Used Types: {"AtomicF64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > () ,)' (Used Types: {"AtomicF64"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF64 > ()' (Used Types: {"AtomicF64"})
      - 'core :: mem :: size_of :: < AtomicF64 > ()' (Used Types: {"AtomicF64"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > () ,) as usize' (Used Types: {"AtomicF64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > () ,) as usize' (Used Types: {"AtomicF64"})

--- AST Node Type: Path ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: float :: AtomicF64 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicF64"})
    Depth 3: (Count: 1)
      - '< imp :: float :: AtomicF64 > :: is_lock_free' (Used Types: {"AtomicF64"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicF64 >' (Used Types: {"AtomicF64"})
      - 'core :: mem :: size_of :: < AtomicF64 >' (Used Types: {"AtomicF64"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicF64' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicF64 > () == core :: mem :: size_of :: < AtomicF64 > () ,) as usize]' (Used Types: {"AtomicF64"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicF64 > () == core :: mem :: size_of :: < f64 > () ,) as usize]' (Used Types: {"AtomicF64"})

### Analyzing expressions using type: 'AtomicI128' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > () ,) as usize' (Used Types: {"AtomicI128"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > () ,) as usize' (Used Types: {"AtomicI128"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > ()' (Used Types: {"AtomicI128"})
      - 'core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > ()' (Used Types: {"AtomicI128"})

--- AST Node Type: Block ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > () ,) as usize] ; }' (Used Types: {"AtomicI128"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > () ,) as usize] ; }' (Used Types: {"AtomicI128"})

--- AST Node Type: Call ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI128 > :: is_lock_free ()' (Used Types: {"AtomicI128"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > () ,)' (Used Types: {"AtomicI128"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > () ,)' (Used Types: {"AtomicI128"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI128 > ()' (Used Types: {"AtomicI128"})
      - 'core :: mem :: size_of :: < AtomicI128 > ()' (Used Types: {"AtomicI128"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > () ,) as usize' (Used Types: {"AtomicI128"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > () ,) as usize' (Used Types: {"AtomicI128"})

--- AST Node Type: Path ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI128 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicI128"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicI128 > :: is_lock_free' (Used Types: {"AtomicI128"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI128 >' (Used Types: {"AtomicI128"})
      - 'core :: mem :: size_of :: < AtomicI128 >' (Used Types: {"AtomicI128"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicI128' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI128 > () == core :: mem :: size_of :: < AtomicI128 > () ,) as usize]' (Used Types: {"AtomicI128"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI128 > () == core :: mem :: size_of :: < i128 > () ,) as usize]' (Used Types: {"AtomicI128"})

### Analyzing expressions using type: 'AtomicI16' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > () ,) as usize' (Used Types: {"AtomicI16"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > () ,) as usize' (Used Types: {"AtomicI16"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > ()' (Used Types: {"AtomicI16"})
      - 'core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > ()' (Used Types: {"AtomicI16"})

--- AST Node Type: Block ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > () ,) as usize] ; }' (Used Types: {"AtomicI16"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > () ,) as usize] ; }' (Used Types: {"AtomicI16"})

--- AST Node Type: Call ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI16 > :: is_lock_free ()' (Used Types: {"AtomicI16"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > () ,)' (Used Types: {"AtomicI16"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > () ,)' (Used Types: {"AtomicI16"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI16 > ()' (Used Types: {"AtomicI16"})
      - 'core :: mem :: size_of :: < AtomicI16 > ()' (Used Types: {"AtomicI16"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > () ,) as usize' (Used Types: {"AtomicI16"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > () ,) as usize' (Used Types: {"AtomicI16"})

--- AST Node Type: Path ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI16 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicI16"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicI16 > :: is_lock_free' (Used Types: {"AtomicI16"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI16 >' (Used Types: {"AtomicI16"})
      - 'core :: mem :: size_of :: < AtomicI16 >' (Used Types: {"AtomicI16"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicI16' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI16 > () == core :: mem :: size_of :: < AtomicI16 > () ,) as usize]' (Used Types: {"AtomicI16"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI16 > () == core :: mem :: size_of :: < i16 > () ,) as usize]' (Used Types: {"AtomicI16"})

### Analyzing expressions using type: 'AtomicI32' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > () ,) as usize' (Used Types: {"AtomicI32"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > () ,) as usize' (Used Types: {"AtomicI32"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > ()' (Used Types: {"AtomicI32"})
      - 'core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > ()' (Used Types: {"AtomicI32"})

--- AST Node Type: Block ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > () ,) as usize] ; }' (Used Types: {"AtomicI32"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > () ,) as usize] ; }' (Used Types: {"AtomicI32"})

--- AST Node Type: Call ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI32 > :: is_lock_free ()' (Used Types: {"AtomicI32"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > () ,)' (Used Types: {"AtomicI32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > () ,)' (Used Types: {"AtomicI32"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI32 > ()' (Used Types: {"AtomicI32"})
      - 'core :: mem :: size_of :: < AtomicI32 > ()' (Used Types: {"AtomicI32"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > () ,) as usize' (Used Types: {"AtomicI32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > () ,) as usize' (Used Types: {"AtomicI32"})

--- AST Node Type: Path ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI32 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicI32"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicI32 > :: is_lock_free' (Used Types: {"AtomicI32"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI32 >' (Used Types: {"AtomicI32"})
      - 'core :: mem :: size_of :: < AtomicI32 >' (Used Types: {"AtomicI32"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicI32' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI32 > () == core :: mem :: size_of :: < AtomicI32 > () ,) as usize]' (Used Types: {"AtomicI32"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI32 > () == core :: mem :: size_of :: < i32 > () ,) as usize]' (Used Types: {"AtomicI32"})

### Analyzing expressions using type: 'AtomicI64' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > () ,) as usize' (Used Types: {"AtomicI64"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > () ,) as usize' (Used Types: {"AtomicI64"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > ()' (Used Types: {"AtomicI64"})
      - 'core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > ()' (Used Types: {"AtomicI64"})

--- AST Node Type: Block ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > () ,) as usize] ; }' (Used Types: {"AtomicI64"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > () ,) as usize] ; }' (Used Types: {"AtomicI64"})

--- AST Node Type: Call ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI64 > :: is_lock_free ()' (Used Types: {"AtomicI64"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > () ,)' (Used Types: {"AtomicI64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > () ,)' (Used Types: {"AtomicI64"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI64 > ()' (Used Types: {"AtomicI64"})
      - 'core :: mem :: size_of :: < AtomicI64 > ()' (Used Types: {"AtomicI64"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > () ,) as usize' (Used Types: {"AtomicI64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > () ,) as usize' (Used Types: {"AtomicI64"})

--- AST Node Type: Path ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI64 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicI64"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicI64 > :: is_lock_free' (Used Types: {"AtomicI64"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI64 >' (Used Types: {"AtomicI64"})
      - 'core :: mem :: size_of :: < AtomicI64 >' (Used Types: {"AtomicI64"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicI64' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI64 > () == core :: mem :: size_of :: < AtomicI64 > () ,) as usize]' (Used Types: {"AtomicI64"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI64 > () == core :: mem :: size_of :: < i64 > () ,) as usize]' (Used Types: {"AtomicI64"})

### Analyzing expressions using type: 'AtomicI8' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > () ,) as usize' (Used Types: {"AtomicI8"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > () ,) as usize' (Used Types: {"AtomicI8"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > ()' (Used Types: {"AtomicI8"})
      - 'core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > ()' (Used Types: {"AtomicI8"})

--- AST Node Type: Block ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > () ,) as usize] ; }' (Used Types: {"AtomicI8"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > () ,) as usize] ; }' (Used Types: {"AtomicI8"})

--- AST Node Type: Call ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI8 > :: is_lock_free ()' (Used Types: {"AtomicI8"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > () ,)' (Used Types: {"AtomicI8"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > () ,)' (Used Types: {"AtomicI8"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI8 > ()' (Used Types: {"AtomicI8"})
      - 'core :: mem :: size_of :: < AtomicI8 > ()' (Used Types: {"AtomicI8"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > () ,) as usize' (Used Types: {"AtomicI8"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > () ,) as usize' (Used Types: {"AtomicI8"})

--- AST Node Type: Path ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicI8 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicI8"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicI8 > :: is_lock_free' (Used Types: {"AtomicI8"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicI8 >' (Used Types: {"AtomicI8"})
      - 'core :: mem :: size_of :: < AtomicI8 >' (Used Types: {"AtomicI8"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicI8' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicI8 > () == core :: mem :: size_of :: < AtomicI8 > () ,) as usize]' (Used Types: {"AtomicI8"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicI8 > () == core :: mem :: size_of :: < i8 > () ,) as usize]' (Used Types: {"AtomicI8"})

### Analyzing expressions using type: 'AtomicIsize' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > () ,) as usize' (Used Types: {"AtomicIsize"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > () ,) as usize' (Used Types: {"AtomicIsize"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > ()' (Used Types: {"AtomicIsize"})
      - 'core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > ()' (Used Types: {"AtomicIsize"})

--- AST Node Type: Block ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > () ,) as usize] ; }' (Used Types: {"AtomicIsize"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > () ,) as usize] ; }' (Used Types: {"AtomicIsize"})

--- AST Node Type: Call ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicIsize > :: is_lock_free ()' (Used Types: {"AtomicIsize"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > () ,)' (Used Types: {"AtomicIsize"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > () ,)' (Used Types: {"AtomicIsize"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicIsize > ()' (Used Types: {"AtomicIsize"})
      - 'core :: mem :: size_of :: < AtomicIsize > ()' (Used Types: {"AtomicIsize"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > () ,) as usize' (Used Types: {"AtomicIsize"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > () ,) as usize' (Used Types: {"AtomicIsize"})

--- AST Node Type: Path ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicIsize > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicIsize"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicIsize > :: is_lock_free' (Used Types: {"AtomicIsize"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicIsize >' (Used Types: {"AtomicIsize"})
      - 'core :: mem :: size_of :: < AtomicIsize >' (Used Types: {"AtomicIsize"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicIsize' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicIsize > () == core :: mem :: size_of :: < AtomicIsize > () ,) as usize]' (Used Types: {"AtomicIsize"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicIsize > () == core :: mem :: size_of :: < isize > () ,) as usize]' (Used Types: {"AtomicIsize"})

### Analyzing expressions using type: 'AtomicPtr' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize' (Used Types: {"AtomicPtr", "()"})
    Depth 7: (Count: 1)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
  Expressions using 'AtomicPtr' with 2 other type(s):
    Depth 4: (Count: 3)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"()", "AtomicPtr", "* mut ()"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
    Depth 7: (Count: 3)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > ()' (Used Types: {"* mut ()", "()", "AtomicPtr"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})

--- AST Node Type: Block ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize] ; }' (Used Types: {"()", "AtomicPtr"})
  Expressions using 'AtomicPtr' with 2 other type(s):
    Depth 2: (Count: 3)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "* mut ()", "()"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "AtomicUsize", "()"})
  Expressions using 'AtomicPtr' with 5 other type(s):
    Depth 2: (Count: 3)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 10)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})

--- AST Node Type: Call ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicPtr < T > > :: is_lock_free ()' (Used Types: {"T", "AtomicPtr"})
    Depth 6: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,)' (Used Types: {"AtomicPtr", "()"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > ()' (Used Types: {"AtomicPtr", "()"})
  Expressions using 'AtomicPtr' with 2 other type(s):
    Depth 6: (Count: 3)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,)' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,)' (Used Types: {"AtomicPtr", "* mut ()", "()"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,)' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize' (Used Types: {"AtomicPtr", "()"})
  Expressions using 'AtomicPtr' with 2 other type(s):
    Depth 5: (Count: 3)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize' (Used Types: {"* mut ()", "()", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})

--- AST Node Type: Match ---
  Expressions using 'AtomicPtr' with 5 other type(s):
    Depth 4: (Count: 3)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: Path ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicPtr < T > > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicPtr", "T"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicPtr < T > > :: is_lock_free' (Used Types: {"AtomicPtr", "T"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicPtr < () > >' (Used Types: {"AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > >' (Used Types: {"AtomicPtr", "()"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicPtr' with 1 other type(s):
    Depth 3: (Count: 1)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicPtr < () > > () ,) as usize]' (Used Types: {"()", "AtomicPtr"})
  Expressions using 'AtomicPtr' with 2 other type(s):
    Depth 3: (Count: 3)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < * mut () > () ,) as usize]' (Used Types: {"()", "* mut ()", "AtomicPtr"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicPtr' with 5 other type(s):
    Depth 3: (Count: 3)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: 'AtomicU128' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > () ,) as usize' (Used Types: {"AtomicU128"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > () ,) as usize' (Used Types: {"AtomicU128"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > ()' (Used Types: {"AtomicU128"})
      - 'core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > ()' (Used Types: {"AtomicU128"})

--- AST Node Type: Block ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > () ,) as usize] ; }' (Used Types: {"AtomicU128"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > () ,) as usize] ; }' (Used Types: {"AtomicU128"})

--- AST Node Type: Call ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU128 > :: is_lock_free ()' (Used Types: {"AtomicU128"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > () ,)' (Used Types: {"AtomicU128"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > () ,)' (Used Types: {"AtomicU128"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU128 > ()' (Used Types: {"AtomicU128"})
      - 'core :: mem :: size_of :: < AtomicU128 > ()' (Used Types: {"AtomicU128"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > () ,) as usize' (Used Types: {"AtomicU128"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > () ,) as usize' (Used Types: {"AtomicU128"})

--- AST Node Type: Path ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU128 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicU128"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicU128 > :: is_lock_free' (Used Types: {"AtomicU128"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU128 >' (Used Types: {"AtomicU128"})
      - 'core :: mem :: size_of :: < AtomicU128 >' (Used Types: {"AtomicU128"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicU128' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU128 > () == core :: mem :: size_of :: < AtomicU128 > () ,) as usize]' (Used Types: {"AtomicU128"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU128 > () == core :: mem :: size_of :: < u128 > () ,) as usize]' (Used Types: {"AtomicU128"})

### Analyzing expressions using type: 'AtomicU16' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > () ,) as usize' (Used Types: {"AtomicU16"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > () ,) as usize' (Used Types: {"AtomicU16"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > ()' (Used Types: {"AtomicU16"})
      - 'core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > ()' (Used Types: {"AtomicU16"})

--- AST Node Type: Block ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > () ,) as usize] ; }' (Used Types: {"AtomicU16"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > () ,) as usize] ; }' (Used Types: {"AtomicU16"})

--- AST Node Type: Call ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU16 > :: is_lock_free ()' (Used Types: {"AtomicU16"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > () ,)' (Used Types: {"AtomicU16"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > () ,)' (Used Types: {"AtomicU16"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU16 > ()' (Used Types: {"AtomicU16"})
      - 'core :: mem :: size_of :: < AtomicU16 > ()' (Used Types: {"AtomicU16"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > () ,) as usize' (Used Types: {"AtomicU16"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > () ,) as usize' (Used Types: {"AtomicU16"})

--- AST Node Type: Path ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU16 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicU16"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicU16 > :: is_lock_free' (Used Types: {"AtomicU16"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU16 >' (Used Types: {"AtomicU16"})
      - 'core :: mem :: size_of :: < AtomicU16 >' (Used Types: {"AtomicU16"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicU16' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU16 > () == core :: mem :: size_of :: < AtomicU16 > () ,) as usize]' (Used Types: {"AtomicU16"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU16 > () == core :: mem :: size_of :: < u16 > () ,) as usize]' (Used Types: {"AtomicU16"})

### Analyzing expressions using type: 'AtomicU32' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > () ,) as usize' (Used Types: {"AtomicU32"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > () ,) as usize' (Used Types: {"AtomicU32"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > ()' (Used Types: {"AtomicU32"})
      - 'core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > ()' (Used Types: {"AtomicU32"})

--- AST Node Type: Block ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > () ,) as usize] ; }' (Used Types: {"AtomicU32"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > () ,) as usize] ; }' (Used Types: {"AtomicU32"})

--- AST Node Type: Call ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU32 > :: is_lock_free ()' (Used Types: {"AtomicU32"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > () ,)' (Used Types: {"AtomicU32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > () ,)' (Used Types: {"AtomicU32"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU32 > ()' (Used Types: {"AtomicU32"})
      - 'core :: mem :: size_of :: < AtomicU32 > ()' (Used Types: {"AtomicU32"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > () ,) as usize' (Used Types: {"AtomicU32"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > () ,) as usize' (Used Types: {"AtomicU32"})
  Expressions using 'AtomicU32' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const crate :: AtomicU32' (Used Types: {"Self", "AtomicU32", "* const Self", "* const crate :: AtomicU32"})

--- AST Node Type: Paren ---
  Expressions using 'AtomicU32' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "Self", "AtomicU32", "* const crate :: AtomicU32"})

--- AST Node Type: Path ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU32 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicU32"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicU32 > :: is_lock_free' (Used Types: {"AtomicU32"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU32 >' (Used Types: {"AtomicU32"})
      - 'core :: mem :: size_of :: < AtomicU32 >' (Used Types: {"AtomicU32"})

--- AST Node Type: Reference ---
  Expressions using 'AtomicU32' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "* const crate :: AtomicU32", "Self", "AtomicU32"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicU32' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU32 > () == core :: mem :: size_of :: < AtomicU32 > () ,) as usize]' (Used Types: {"AtomicU32"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU32 > () == core :: mem :: size_of :: < u32 > () ,) as usize]' (Used Types: {"AtomicU32"})

--- AST Node Type: Unary ---
  Expressions using 'AtomicU32' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"AtomicU32", "Self", "* const Self", "* const crate :: AtomicU32"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicU32' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU32) }' (Used Types: {"* const Self", "AtomicU32", "* const crate :: AtomicU32", "Self"})

### Analyzing expressions using type: 'AtomicU64' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > () ,) as usize' (Used Types: {"AtomicU64"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > () ,) as usize' (Used Types: {"AtomicU64"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > ()' (Used Types: {"AtomicU64"})
      - 'core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > ()' (Used Types: {"AtomicU64"})

--- AST Node Type: Block ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > () ,) as usize] ; }' (Used Types: {"AtomicU64"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > () ,) as usize] ; }' (Used Types: {"AtomicU64"})

--- AST Node Type: Call ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU64 > :: is_lock_free ()' (Used Types: {"AtomicU64"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > () ,)' (Used Types: {"AtomicU64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > () ,)' (Used Types: {"AtomicU64"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU64 > ()' (Used Types: {"AtomicU64"})
      - 'core :: mem :: size_of :: < AtomicU64 > ()' (Used Types: {"AtomicU64"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > () ,) as usize' (Used Types: {"AtomicU64"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > () ,) as usize' (Used Types: {"AtomicU64"})
  Expressions using 'AtomicU64' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const crate :: AtomicU64' (Used Types: {"Self", "* const Self", "AtomicU64", "* const crate :: AtomicU64"})

--- AST Node Type: Paren ---
  Expressions using 'AtomicU64' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "* const crate :: AtomicU64", "Self", "AtomicU64"})

--- AST Node Type: Path ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU64 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicU64"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicU64 > :: is_lock_free' (Used Types: {"AtomicU64"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU64 >' (Used Types: {"AtomicU64"})
      - 'core :: mem :: size_of :: < AtomicU64 >' (Used Types: {"AtomicU64"})

--- AST Node Type: Reference ---
  Expressions using 'AtomicU64' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"Self", "AtomicU64", "* const crate :: AtomicU64", "* const Self"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicU64' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU64 > () == core :: mem :: size_of :: < AtomicU64 > () ,) as usize]' (Used Types: {"AtomicU64"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU64 > () == core :: mem :: size_of :: < u64 > () ,) as usize]' (Used Types: {"AtomicU64"})

--- AST Node Type: Unary ---
  Expressions using 'AtomicU64' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "AtomicU64", "* const crate :: AtomicU64", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicU64' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU64) }' (Used Types: {"* const Self", "AtomicU64", "Self", "* const crate :: AtomicU64"})

### Analyzing expressions using type: 'AtomicU8' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > () ,) as usize' (Used Types: {"AtomicU8"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > () ,) as usize' (Used Types: {"AtomicU8"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > ()' (Used Types: {"AtomicU8"})
      - 'core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > ()' (Used Types: {"AtomicU8"})

--- AST Node Type: Block ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > () ,) as usize] ; }' (Used Types: {"AtomicU8"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > () ,) as usize] ; }' (Used Types: {"AtomicU8"})
  Expressions using 'AtomicU8' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } }' (Used Types: {"AtomicU8", "* const AtomicU8"})

--- AST Node Type: Call ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU8 > :: is_lock_free ()' (Used Types: {"AtomicU8"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > () ,)' (Used Types: {"AtomicU8"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > () ,)' (Used Types: {"AtomicU8"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU8 > ()' (Used Types: {"AtomicU8"})
      - 'core :: mem :: size_of :: < AtomicU8 > ()' (Used Types: {"AtomicU8"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > () ,) as usize' (Used Types: {"AtomicU8"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > () ,) as usize' (Used Types: {"AtomicU8"})
  Expressions using 'AtomicU8' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'self . state as * const AtomicU8 as usize' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 4: (Count: 1)
      - 'self . state as * const AtomicU8' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 6: (Count: 1)
      - 'state as * const AtomicU8 as usize' (Used Types: {"AtomicU8", "* const AtomicU8"})
    Depth 7: (Count: 1)
      - 'state as * const AtomicU8' (Used Types: {"* const AtomicU8", "AtomicU8"})
  Expressions using 'AtomicU8' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const imp :: AtomicU8' (Used Types: {"AtomicU8", "* const Self", "* const imp :: AtomicU8", "Self"})

--- AST Node Type: Loop ---
  Expressions using 'AtomicU8' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'loop { let exchange = state . compare_exchange_weak (INCOMPLETE , RUNNING , Ordering :: Acquire , Ordering :: Acquire ,) ; match exchange { Ok (_) => { let mut guard = Guard { state , new_state : INCOMPLETE , } ; if init () { guard . new_state = COMPLETE ; } return ; } Err (COMPLETE) => return , Err (RUNNING) => { unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } } Err (INCOMPLETE) => { } Err (_) => { if true { if ! false { :: core :: panicking :: panic ("assertion failed: false") } } } } }' (Used Types: {"* const AtomicU8", "AtomicU8"})

--- AST Node Type: Match ---
  Expressions using 'AtomicU8' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'match exchange { Ok (_) => { let mut guard = Guard { state , new_state : INCOMPLETE , } ; if init () { guard . new_state = COMPLETE ; } return ; } Err (COMPLETE) => return , Err (RUNNING) => { unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; } } Err (INCOMPLETE) => { } Err (_) => { if true { if ! false { :: core :: panicking :: panic ("assertion failed: false") } } } }' (Used Types: {"* const AtomicU8", "AtomicU8"})

--- AST Node Type: Paren ---
  Expressions using 'AtomicU8' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})

--- AST Node Type: Path ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicU8 > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicU8"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicU8 > :: is_lock_free' (Used Types: {"AtomicU8"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicU8 >' (Used Types: {"AtomicU8"})
      - 'core :: mem :: size_of :: < AtomicU8 >' (Used Types: {"AtomicU8"})

--- AST Node Type: Reference ---
  Expressions using 'AtomicU8' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"Self", "* const imp :: AtomicU8", "* const Self", "AtomicU8"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicU8' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicU8 > () == core :: mem :: size_of :: < AtomicU8 > () ,) as usize]' (Used Types: {"AtomicU8"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicU8 > () == core :: mem :: size_of :: < u8 > () ,) as usize]' (Used Types: {"AtomicU8"})

--- AST Node Type: Unary ---
  Expressions using 'AtomicU8' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicU8' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let key = self . state as * const AtomicU8 as usize ; parking_lot_core :: unpark_all (key , parking_lot_core :: DEFAULT_UNPARK_TOKEN ,) ; }' (Used Types: {"* const AtomicU8", "AtomicU8"})
    Depth 5: (Count: 1)
      - 'unsafe { let key = state as * const AtomicU8 as usize ; parking_lot_core :: park (key , | | state . load (Ordering :: Relaxed) == RUNNING , | | () , | _ , _ | () , parking_lot_core :: DEFAULT_PARK_TOKEN , None ,) ; }' (Used Types: {"* const AtomicU8", "AtomicU8"})
  Expressions using 'AtomicU8' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const imp :: AtomicU8) }' (Used Types: {"AtomicU8", "Self", "* const Self", "* const imp :: AtomicU8"})

### Analyzing expressions using type: 'AtomicUsize' ###

--- AST Node Type: Binary ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicUsize"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > () ,) as usize' (Used Types: {"AtomicUsize"})
    Depth 7: (Count: 3)
      - 'align_of :: < AtomicUsize > () % align_of :: < usize > () == 0' (Used Types: {"AtomicUsize"})
      - 'core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize"})
      - 'core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > ()' (Used Types: {"AtomicUsize"})
    Depth 8: (Count: 1)
      - 'align_of :: < AtomicUsize > () % align_of :: < usize > ()' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 2 other type(s):
    Depth 4: (Count: 2)
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - 'true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
    Depth 7: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})
      - 'core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})

--- AST Node Type: Block ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicUsize"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > () ,) as usize] ; }' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 2 other type(s):
    Depth 2: (Count: 2)
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - '{ let [] = [() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize] ; }' (Used Types: {"AtomicPtr", "AtomicUsize", "()"})

--- AST Node Type: Call ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicUsize > :: is_lock_free ()' (Used Types: {"AtomicUsize"})
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > () ,)' (Used Types: {"AtomicUsize"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > () ,)' (Used Types: {"AtomicUsize"})
    Depth 8: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize"})
      - 'core :: mem :: size_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize"})
    Depth 9: (Count: 1)
      - 'align_of :: < AtomicUsize > ()' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 2 other type(s):
    Depth 6: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,)' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,)' (Used Types: {"AtomicUsize", "AtomicPtr", "()"})

--- AST Node Type: Cast ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicUsize"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > () ,) as usize' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize' (Used Types: {"AtomicUsize", "()", "AtomicPtr"})
      - 'crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize' (Used Types: {"()", "AtomicUsize", "AtomicPtr"})
  Expressions using 'AtomicUsize' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'self as * const Self as * const AtomicUsize' (Used Types: {"Self", "* const AtomicUsize", "* const Self", "AtomicUsize"})

--- AST Node Type: If ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'if ! (align_of :: < AtomicUsize > () % align_of :: < usize > () == 0) { :: core :: panicking :: panic ("assertion failed: align_of::<AtomicUsize>() % align_of::<usize>() == 0" ,) }' (Used Types: {"AtomicUsize"})

--- AST Node Type: Paren ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 6: (Count: 1)
      - '(align_of :: < AtomicUsize > () % align_of :: < usize > () == 0)' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const Self as * const AtomicUsize)' (Used Types: {"AtomicUsize", "* const Self", "Self", "* const AtomicUsize"})

--- AST Node Type: Path ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicUsize > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicUsize"})
    Depth 3: (Count: 1)
      - '< imp :: AtomicUsize > :: is_lock_free' (Used Types: {"AtomicUsize"})
    Depth 9: (Count: 2)
      - 'core :: mem :: align_of :: < AtomicUsize >' (Used Types: {"AtomicUsize"})
      - 'core :: mem :: size_of :: < AtomicUsize >' (Used Types: {"AtomicUsize"})
    Depth 10: (Count: 1)
      - 'align_of :: < AtomicUsize >' (Used Types: {"AtomicUsize"})

--- AST Node Type: Reference ---
  Expressions using 'AtomicUsize' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (self as * const Self as * const AtomicUsize)' (Used Types: {"* const AtomicUsize", "* const Self", "Self", "AtomicUsize"})

--- AST Node Type: Repeat ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicUsize > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicUsize"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicUsize > () == core :: mem :: size_of :: < usize > () ,) as usize]' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 2 other type(s):
    Depth 3: (Count: 2)
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: align_of :: < AtomicPtr < () > > () == core :: mem :: align_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})
      - '[() ; true as usize - crate :: utils :: _assert_is_bool (core :: mem :: size_of :: < AtomicPtr < () > > () == core :: mem :: size_of :: < AtomicUsize > () ,) as usize]' (Used Types: {"AtomicPtr", "()", "AtomicUsize"})

--- AST Node Type: Unary ---
  Expressions using 'AtomicUsize' with 0 other type(s):
    Depth 5: (Count: 1)
      - '! (align_of :: < AtomicUsize > () % align_of :: < usize > () == 0)' (Used Types: {"AtomicUsize"})
  Expressions using 'AtomicUsize' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const Self as * const AtomicUsize)' (Used Types: {"Self", "* const Self", "* const AtomicUsize", "AtomicUsize"})

--- AST Node Type: Unsafe ---
  Expressions using 'AtomicUsize' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (self as * const Self as * const AtomicUsize) }' (Used Types: {"* const Self", "Self", "* const AtomicUsize", "AtomicUsize"})

### Analyzing expressions using type: 'B' ###

--- AST Node Type: Array ---
  Expressions using 'B' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]' (Used Types: {"U", "B"})

--- AST Node Type: Block ---
  Expressions using 'B' with 0 other type(s):
    Depth 7: (Count: 1)
      - '{ f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }' (Used Types: {"B"})
  Expressions using 'B' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})

--- AST Node Type: Call ---
  Expressions using 'B' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (B :: from_bits_truncate (from_str :: < B > (input) ? . bits ()))' (Used Types: {"B"})
    Depth 3: (Count: 1)
      - 'B :: from_bits_truncate (from_str :: < B > (input) ? . bits ())' (Used Types: {"B"})
    Depth 6: (Count: 1)
      - 'from_str :: < B > (input)' (Used Types: {"B"})
    Depth 10: (Count: 1)
      - ':: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,)' (Used Types: {"B"})
  Expressions using 'B' with 1 other type(s):
    Depth 8: (Count: 1)
      - ':: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,])' (Used Types: {"B", "U"})
  Expressions using 'B' with 2 other type(s):
    Depth 3: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32 ()' (Used Types: {"UInt", "U", "B"})
  Expressions using 'B' with 3 other type(s):
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_", "B"})

--- AST Node Type: Closure ---
  Expressions using 'B' with 0 other type(s):
    Depth 6: (Count: 1)
      - '| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }' (Used Types: {"B"})

--- AST Node Type: If ---
  Expressions using 'B' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: MethodCall ---
  Expressions using 'B' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'from_str :: < B > (input) ? . bits ()' (Used Types: {"B"})
    Depth 8: (Count: 1)
      - 'f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."])' (Used Types: {"B"})
    Depth 9: (Count: 1)
      - 'f . ty :: < B > () . name ("lsb") . type_name ("B")' (Used Types: {"B"})
    Depth 10: (Count: 1)
      - 'f . ty :: < B > () . name ("lsb")' (Used Types: {"B"})
  Expressions using 'B' with 1 other type(s):
    Depth 5: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) })' (Used Types: {"U", "B"})
  Expressions using 'B' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . pow (< UInt < U , B > as Unsigned > :: to_u32 ())' (Used Types: {"U", "UInt", "B"})
  Expressions using 'B' with 3 other type(s):
    Depth 4: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,)' (Used Types: {"B", "U", "[_]", "_"})
    Depth 5: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,)' (Used Types: {"U", "B", "_", "[_]"})
    Depth 6: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,)' (Used Types: {"[_]", "_", "B", "U"})

--- AST Node Type: Path ---
  Expressions using 'B' with 0 other type(s):
    Depth 7: (Count: 1)
      - 'from_str :: < B >' (Used Types: {"B"})
  Expressions using 'B' with 2 other type(s):
    Depth 4: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32' (Used Types: {"B", "UInt", "U"})

--- AST Node Type: Unknown ---
  Expressions using 'B' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'from_str :: < B > (input) ?' (Used Types: {"B"})

### Analyzing expressions using type: 'B0' ###

--- AST Node Type: Block ---
  Expressions using 'B0' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for B0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B0" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"B0", "Type", "Self"})

### Analyzing expressions using type: 'B1' ###

--- AST Node Type: Block ---
  Expressions using 'B1' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for B1 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B1" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 1."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "B1"})

### Analyzing expressions using type: 'BTreeMap' ###

--- AST Node Type: If ---
  Expressions using 'BTreeMap' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . required_libs . is_empty () { let ports = match load_ports (& vcpkg_target) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } } ; if ports . get (& port_name . to_owned ()) . is_none () { return Err (Error :: LibNotFound (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("package {0} is not installed for vcpkg triplet {1}" , port_name . to_owned () , vcpkg_target . target_triplet . triplet ,) ,) }) ,) ,) ; } let mut required_ports : BTreeMap < String , Port > = BTreeMap :: new () ; let mut ports_to_scan = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,) ; while ! ports_to_scan . is_empty () { let port_name = ports_to_scan . pop () . unwrap () ; if required_ports . contains_key (& port_name) { continue ; } if let Some (port) = ports . get (& port_name) { for dep in & port . deps { ports_to_scan . push (dep . clone ()) ; } required_ports . insert (port_name . clone () , (* port) . clone ()) ; remove_item (& mut required_port_order , & port_name) ; required_port_order . push (port_name) ; } else { } } if self . required_libs . is_empty () { for port_name in & required_port_order { let port = required_ports . get (port_name) . unwrap () ; self . required_libs . extend (port . libs . iter () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; self . required_dlls . extend (port . dlls . iter () . cloned () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; } } }' (Used Types: {"[_]", "Port", "_", "BTreeMap"})

### Analyzing expressions using type: 'Backtrace' ###

--- AST Node Type: Call ---
  Expressions using 'Backtrace' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'assert :: < Backtrace > ()' (Used Types: {"Backtrace"})
      - 'request_ref :: < Backtrace > (err)' (Used Types: {"Backtrace"})

--- AST Node Type: Path ---
  Expressions using 'Backtrace' with 0 other type(s):
    Depth 3: (Count: 2)
      - 'assert :: < Backtrace >' (Used Types: {"Backtrace"})
      - 'request_ref :: < Backtrace >' (Used Types: {"Backtrace"})

### Analyzing expressions using type: 'Bits' ###

--- AST Node Type: Call ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 6: (Count: 1)
      - '< B :: Bits > :: parse_hex (flag)' (Used Types: {"Bits"})

--- AST Node Type: ForLoop ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'for flag in input . split ('|') { let flag = flag . trim () ; if flag . is_empty () { return Err (ParseError :: empty_flag ()) ; } let parsed_flag = if let Some (flag) = flag . strip_prefix ("0x") { let bits = < B :: Bits > :: parse_hex (flag) . map_err (| _ | ParseError :: invalid_hex_flag (flag)) ? ; B :: from_bits_retain (bits) } else { B :: from_name (flag) . ok_or_else (| | ParseError :: invalid_named_flag (flag)) ? } ; parsed_flags . insert (parsed_flag) ; }' (Used Types: {"Bits"})

--- AST Node Type: If ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'if let Some (flag) = flag . strip_prefix ("0x") { let bits = < B :: Bits > :: parse_hex (flag) . map_err (| _ | ParseError :: invalid_hex_flag (flag)) ? ; B :: from_bits_retain (bits) } else { B :: from_name (flag) . ok_or_else (| | ParseError :: invalid_named_flag (flag)) ? }' (Used Types: {"Bits"})
  Expressions using 'Bits' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: MethodCall ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 5: (Count: 1)
      - '< B :: Bits > :: parse_hex (flag) . map_err (| _ | ParseError :: invalid_hex_flag (flag))' (Used Types: {"Bits"})

--- AST Node Type: Path ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 7: (Count: 1)
      - '< B :: Bits > :: parse_hex' (Used Types: {"Bits"})

--- AST Node Type: Unknown ---
  Expressions using 'Bits' with 0 other type(s):
    Depth 4: (Count: 1)
      - '< B :: Bits > :: parse_hex (flag) . map_err (| _ | ParseError :: invalid_hex_flag (flag)) ?' (Used Types: {"Bits"})

### Analyzing expressions using type: 'Block' ###

--- AST Node Type: Assign ---
  Expressions using 'Block' with 1 other type(s):
    Depth 8: (Count: 1)
      - '__field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,)' (Used Types: {"Block", "Vec"})

--- AST Node Type: Binary ---
  Expressions using 'Block' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'self . bitset & (0 as Block) . wrapping_sub (self . bitset)' (Used Types: {"Block"})

--- AST Node Type: Block ---
  Expressions using 'Block' with 2 other type(s):
    Depth 7: (Count: 1)
      - '{ if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; }' (Used Types: {"Error", "Vec", "Block"})
  Expressions using 'Block' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Block' with 1 other type(s):
    Depth 7: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq)' (Used Types: {"Block", "Vec"})
    Depth 9: (Count: 1)
      - '_serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,)' (Used Types: {"Vec", "Block"})

--- AST Node Type: Cast ---
  Expressions using 'Block' with 0 other type(s):
    Depth 5: (Count: 1)
      - '0 as Block' (Used Types: {"Block"})

--- AST Node Type: Match ---
  Expressions using 'Block' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } }' (Used Types: {"Vec", "Block"})
  Expressions using 'Block' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } }' (Used Types: {"IgnoredAny", "Error", "Vec", "Block"})

--- AST Node Type: MethodCall ---
  Expressions using 'Block' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(0 as Block) . wrapping_sub (self . bitset)' (Used Types: {"Block"})

--- AST Node Type: Paren ---
  Expressions using 'Block' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(0 as Block)' (Used Types: {"Block"})

--- AST Node Type: Path ---
  Expressions using 'Block' with 1 other type(s):
    Depth 8: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , >' (Used Types: {"Vec", "Block"})

--- AST Node Type: Unknown ---
  Expressions using 'Block' with 1 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ?' (Used Types: {"Vec", "Block"})
    Depth 10: (Count: 1)
      - '_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ?' (Used Types: {"Vec", "Block"})

--- AST Node Type: While ---
  Expressions using 'Block' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"__Field", "IgnoredAny", "Error", "Block", "Vec"})

### Analyzing expressions using type: 'Box' ###

--- AST Node Type: Array ---
  Expressions using 'Box' with 3 other type(s):
    Depth 9: (Count: 3)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span", "Box", "ClassSetBinaryOpKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"GroupKind", "Box", "Ast", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Box", "Ast", "Span"})

--- AST Node Type: Block ---
  Expressions using 'Box' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'Box' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Box' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Box' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Box' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Box' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "T", "Void"})
  Expressions using 'Box' with 3 other type(s):
    Depth 4: (Count: 3)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Box", "ClassSetBinaryOpKind", "ClassSet"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})
    Depth 6: (Count: 3)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "Span", "ClassSet", "ClassSetBinaryOpKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Box", "RepetitionOp", "Ast"})
    Depth 7: (Count: 3)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassSetBinaryOpKind", "Box", "ClassSet"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Box", "Span", "GroupKind", "Ast"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"RepetitionOp", "Box", "Span", "Ast"})
  Expressions using 'Box' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'Box' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Box' with 2 other type(s):
    Depth 4: (Count: 1)
      - '| | Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "Void", "T"})
  Expressions using 'Box' with 3 other type(s):
    Depth 5: (Count: 3)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "GroupKind", "Box", "Ast"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "RepetitionOp", "Ast", "Span"})
  Expressions using 'Box' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'Box' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Match ---
  Expressions using 'Box' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'match self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"Void", "T", "Box"})

--- AST Node Type: MethodCall ---
  Expressions using 'Box' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ()))' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Path ---
  Expressions using 'Box' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'object_downcast :: < Box < dyn StdError + Send + Sync > >' (Used Types: {"dyn StdError + Send + Sync", "Box"})
      - 'object_drop_front :: < Box < dyn StdError + Send + Sync > >' (Used Types: {"Box", "dyn StdError + Send + Sync"})
  Expressions using 'Box' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'Ok :: < Box < T > , Void >' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Reference ---
  Expressions using 'Box' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"BoxedError", "Box", "dyn StdError + Send + Sync"})
  Expressions using 'Box' with 3 other type(s):
    Depth 8: (Count: 3)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "GroupKind", "Span", "Box"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})

--- AST Node Type: Struct ---
  Expressions using 'Box' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"Box", "BoxedError", "dyn StdError + Send + Sync"})

--- AST Node Type: Unknown ---
  Expressions using 'Box' with 1 other type(s):
    Depth 10: (Count: 2)
      - '< Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Box", "Ast"})
      - '< Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Box", "ClassSet"})
  Expressions using 'Box' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'Box' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

--- AST Node Type: Unsafe ---
  Expressions using 'Box' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let slice = slice :: from_raw_parts_mut (self . as_mut_ptr () , self . len) ; let output : Box < 'bump , [T] > = Box :: from_raw (slice) ; mem :: forget (self) ; output }' (Used Types: {"T", "Box", "[T]"})

### Analyzing expressions using type: 'BoxFuture' ###

--- AST Node Type: Call ---
  Expressions using 'BoxFuture' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'FutureState :: new (Box :: pin (future . map (move | v | drop (tx . send (v)))) as BoxFuture ,)' (Used Types: {"BoxFuture"})

--- AST Node Type: Cast ---
  Expressions using 'BoxFuture' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'Box :: pin (future . map (move | v | drop (tx . send (v)))) as BoxFuture' (Used Types: {"BoxFuture"})

--- AST Node Type: Reference ---
  Expressions using 'BoxFuture' with 0 other type(s):
    Depth 2: (Count: 1)
      - '& mut FutureState :: new (Box :: pin (future . map (move | v | drop (tx . send (v)))) as BoxFuture ,)' (Used Types: {"BoxFuture"})

### Analyzing expressions using type: 'BoxedError' ###

--- AST Node Type: Path ---
  Expressions using 'BoxedError' with 0 other type(s):
    Depth 4: (Count: 4)
      - 'object_boxed :: < BoxedError >' (Used Types: {"BoxedError"})
      - 'object_drop :: < BoxedError >' (Used Types: {"BoxedError"})
      - 'object_reallocate_boxed :: < BoxedError >' (Used Types: {"BoxedError"})
      - 'object_ref :: < BoxedError >' (Used Types: {"BoxedError"})

--- AST Node Type: Reference ---
  Expressions using 'BoxedError' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"BoxedError", "Box", "dyn StdError + Send + Sync"})

--- AST Node Type: Struct ---
  Expressions using 'BoxedError' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"Box", "BoxedError", "dyn StdError + Send + Sync"})

### Analyzing expressions using type: 'Buffer' ###

--- AST Node Type: Block ---
  Expressions using 'Buffer' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using 'Buffer' with 0 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> Buffer { let bytes = [MaybeUninit :: < u8 > :: uninit () ; i128 :: MAX_STR_LEN] ; Buffer { bytes } }) ()' (Used Types: {"Buffer"})
  Expressions using 'Buffer' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using 'Buffer' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> Buffer { let bytes = [MaybeUninit :: < u8 > :: uninit () ; i128 :: MAX_STR_LEN] ; Buffer { bytes } }' (Used Types: {"Buffer"})
  Expressions using 'Buffer' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: MethodCall ---
  Expressions using 'Buffer' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using 'Buffer' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> Buffer { let bytes = [MaybeUninit :: < u8 > :: uninit () ; i128 :: MAX_STR_LEN] ; Buffer { bytes } })' (Used Types: {"Buffer"})
  Expressions using 'Buffer' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using 'Buffer' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Reference ---
  Expressions using 'Buffer' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Unary ---
  Expressions using 'Buffer' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using 'Buffer' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: 'C' ###

--- AST Node Type: Binary ---
  Expressions using 'C' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'TypeId :: of :: < C > () == target' (Used Types: {"C"})

--- AST Node Type: Block ---
  Expressions using 'C' with 4 other type(s):
    Depth 3: (Count: 2)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"C", "ErrorImpl", "ContextError", "ManuallyDrop", "E"})
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"C", "ContextError", "ErrorImpl", "ManuallyDrop", "Error"})

--- AST Node Type: Call ---
  Expressions using 'C' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'TypeId :: of :: < C > ()' (Used Types: {"C"})

--- AST Node Type: If ---
  Expressions using 'C' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < C > () == target { Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else { let source = & unerased . _object . error ; unsafe { (vtable (source . inner . ptr) . object_downcast) (source . inner . by_ref () , target) } }' (Used Types: {"C", "()"})
  Expressions using 'C' with 4 other type(s):
    Depth 2: (Count: 3)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"ErrorImpl", "ContextError", "E", "C", "ManuallyDrop"})
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"ErrorImpl", "C", "ManuallyDrop", "Error", "ContextError"})
      - 'if TypeId :: of :: < C > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"E", "ErrorImpl", "()", "C", "ContextError"})
    Depth 3: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"ContextError", "ErrorImpl", "E", "C", "()"})

--- AST Node Type: MethodCall ---
  Expressions using 'C' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , Error > > > ()' (Used Types: {"C", "ErrorImpl", "ContextError", "Error"})
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , E > > > ()' (Used Types: {"C", "ErrorImpl", "E", "ContextError"})
  Expressions using 'C' with 4 other type(s):
    Depth 3: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "C", "ContextError", "E"})
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > ()' (Used Types: {"ContextError", "ManuallyDrop", "C", "Error", "ErrorImpl"})
    Depth 4: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > ()' (Used Types: {"ContextError", "ErrorImpl", "ManuallyDrop", "E", "C"})
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "Error", "C", "ContextError"})

--- AST Node Type: Path ---
  Expressions using 'C' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'context_chain_downcast :: < C >' (Used Types: {"C"})
      - 'context_chain_drop_rest :: < C >' (Used Types: {"C"})
    Depth 5: (Count: 1)
      - 'TypeId :: of :: < C >' (Used Types: {"C"})
  Expressions using 'C' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'context_downcast :: < C , E >' (Used Types: {"C", "E"})
      - 'context_drop_rest :: < C , E >' (Used Types: {"E", "C"})
  Expressions using 'C' with 2 other type(s):
    Depth 4: (Count: 8)
      - 'object_boxed :: < ContextError < C , E > >' (Used Types: {"ContextError", "C", "E"})
      - 'object_boxed :: < ContextError < C , Error > >' (Used Types: {"ContextError", "C", "Error"})
      - 'object_drop :: < ContextError < C , E > >' (Used Types: {"C", "E", "ContextError"})
      - 'object_drop :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_reallocate_boxed :: < ContextError < C , E > >' (Used Types: {"C", "ContextError", "E"})
      - 'object_reallocate_boxed :: < ContextError < C , Error > , >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_ref :: < ContextError < C , E > >' (Used Types: {"ContextError", "E", "C"})
      - 'object_ref :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Reference ---
  Expressions using 'C' with 2 other type(s):
    Depth 2: (Count: 2)
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "C", "E"})
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Struct ---
  Expressions using 'C' with 2 other type(s):
    Depth 3: (Count: 2)
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "E", "C"})
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "C", "ContextError"})

### Analyzing expressions using type: 'CStr' ###

--- AST Node Type: Block ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: CStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: CStr > , T2 : AsRef < :: std :: ffi :: CStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: CStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: CStr > , T2 : AsMut < :: std :: ffi :: CStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"CStr", "T2", "T1", "Either"})

--- AST Node Type: Cast ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'bytes as * const [u8] as * const CStr' (Used Types: {"* const CStr", "[u8]", "CStr", "* const [u8]"})

--- AST Node Type: Paren ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "CStr", "* const [u8]", "[u8]"})

--- AST Node Type: Reference ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (bytes as * const [u8] as * const CStr)' (Used Types: {"[u8]", "* const [u8]", "* const CStr", "CStr"})

--- AST Node Type: Unary ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "[u8]", "* const [u8]", "CStr"})

--- AST Node Type: Unsafe ---
  Expressions using 'CStr' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (bytes as * const [u8] as * const CStr) }' (Used Types: {"CStr", "* const [u8]", "[u8]", "* const CStr"})

### Analyzing expressions using type: 'CaptureName' ###

--- AST Node Type: Block ---
  Expressions using 'CaptureName' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flags", "CaptureName"})
  Expressions using 'CaptureName' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})

--- AST Node Type: Call ---
  Expressions using 'CaptureName' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"CaptureName", "Flags"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"CaptureName", "Flags"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"CaptureName", "Flags"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,)' (Used Types: {"CaptureName", "Flags"})

--- AST Node Type: Closure ---
  Expressions using 'CaptureName' with 1 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flags", "CaptureName"})

--- AST Node Type: Unknown ---
  Expressions using 'CaptureName' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"Flags", "CaptureName"})

### Analyzing expressions using type: 'Cell' ###

--- AST Node Type: Block ---
  Expressions using 'Cell' with 0 other type(s):
    Depth 9: (Count: 1)
      - '{ | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } }' (Used Types: {"Cell"})
  Expressions using 'Cell' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } }' (Used Types: {"EagerStorage", "Cell"})
    Depth 10: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () }' (Used Types: {"EagerStorage", "Cell"})
  Expressions using 'Cell' with 3 other type(s):
    Depth 7: (Count: 1)
      - '{ | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"!", "LazyStorage", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Rng", "()", "LazyStorage", "Cell"})
    Depth 9: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"!", "Rng", "Cell", "LazyStorage"})
  Expressions using 'Cell' with 4 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline] fn __init () -> Cell < Rng > { Cell :: new (Rng (random_seed () . unwrap_or (DEFAULT_RNG_SEED))) } unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) } }' (Used Types: {"LazyStorage", "()", "Rng", "!", "Cell"})
  Expressions using 'Cell' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'Cell' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'Cell' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Cell' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Cell' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Cell' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Cell' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Cell' with 0 other type(s):
    Depth 9: (Count: 1)
      - ':: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > ()' (Used Types: {"Cell"})
  Expressions using 'Cell' with 1 other type(s):
    Depth 6: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } })' (Used Types: {"Cell", "EagerStorage"})
    Depth 7: (Count: 1)
      - ':: std :: mem :: needs_drop :: < Cell < Rng > > ()' (Used Types: {"Rng", "Cell"})
  Expressions using 'Cell' with 4 other type(s):
    Depth 4: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } })' (Used Types: {"Cell", "()", "!", "LazyStorage", "Rng"})

--- AST Node Type: Closure ---
  Expressions using 'Cell' with 0 other type(s):
    Depth 10: (Count: 1)
      - '| _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL }' (Used Types: {"Cell"})
  Expressions using 'Cell' with 1 other type(s):
    Depth 9: (Count: 1)
      - '| _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () }' (Used Types: {"EagerStorage", "Cell"})
  Expressions using 'Cell' with 3 other type(s):
    Depth 7: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"LazyStorage", "()", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Cell", "!", "LazyStorage", "Rng"})

--- AST Node Type: If ---
  Expressions using 'Cell' with 1 other type(s):
    Depth 8: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } }' (Used Types: {"Cell", "EagerStorage"})
  Expressions using 'Cell' with 4 other type(s):
    Depth 6: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"()", "LazyStorage", "Rng", "!", "Cell"})

--- AST Node Type: Path ---
  Expressions using 'Cell' with 0 other type(s):
    Depth 10: (Count: 1)
      - ':: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > >' (Used Types: {"Cell"})
  Expressions using 'Cell' with 1 other type(s):
    Depth 8: (Count: 1)
      - ':: std :: mem :: needs_drop :: < Cell < Rng > >' (Used Types: {"Rng", "Cell"})

--- AST Node Type: Unknown ---
  Expressions using 'Cell' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }' (Used Types: {"Cell", "EagerStorage"})
  Expressions using 'Cell' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }' (Used Types: {"Cell", "Rng", "()", "LazyStorage", "!"})

--- AST Node Type: Unsafe ---
  Expressions using 'Cell' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) }' (Used Types: {"Cell", "EagerStorage"})
  Expressions using 'Cell' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) }' (Used Types: {"!", "LazyStorage", "Rng", "()", "Cell"})

### Analyzing expressions using type: 'Chunk' ###

--- AST Node Type: Binary ---
  Expressions using 'Chunk' with 0 other type(s):
    Depth 2: (Count: 1)
      - '8 * mem :: size_of :: < Chunk > ()' (Used Types: {"Chunk"})

--- AST Node Type: Call ---
  Expressions using 'Chunk' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'mem :: size_of :: < Chunk > ()' (Used Types: {"Chunk"})

--- AST Node Type: Path ---
  Expressions using 'Chunk' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'mem :: size_of :: < Chunk >' (Used Types: {"Chunk"})

### Analyzing expressions using type: 'ChunkFooter' ###

--- AST Node Type: Binary ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'self . iter_allocated_chunks_raw () . count () * mem :: size_of :: < ChunkFooter > ()' (Used Types: {"ChunkFooter"})
    Depth 6: (Count: 1)
      - 'mem :: align_of :: < ChunkFooter > () <= CHUNK_ALIGN' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'ptr <= self as * const ChunkFooter as * const u8' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: Block ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 2: (Count: 1)
      - '{ if ! (mem :: align_of :: < ChunkFooter > () <= CHUNK_ALIGN) { :: core :: panicking :: panic ("assertion failed: mem::align_of::<ChunkFooter>() <= CHUNK_ALIGN" ,) } }' (Used Types: {"ChunkFooter"})

--- AST Node Type: Call ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'Layout :: new :: < ChunkFooter > ()' (Used Types: {"ChunkFooter"})
      - 'mem :: size_of :: < ChunkFooter > ()' (Used Types: {"ChunkFooter"})
    Depth 7: (Count: 1)
      - 'mem :: align_of :: < ChunkFooter > ()' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) })' (Used Types: {"ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,)' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "ChunkFooter"})
  Expressions using 'ChunkFooter' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'EmptyChunkFooter (ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , })' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "* mut u8", "* const EmptyChunkFooter", "EmptyChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using 'ChunkFooter' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'footer_ptr as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter"})
    Depth 7: (Count: 1)
      - 'self as * const ChunkFooter' (Used Types: {"* const ChunkFooter", "ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 6: (Count: 1)
      - 'self as * const ChunkFooter as * const u8' (Used Types: {"* const u8", "ChunkFooter", "* const ChunkFooter"})
  Expressions using 'ChunkFooter' with 3 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})

--- AST Node Type: If ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'if ! (mem :: align_of :: < ChunkFooter > () <= CHUNK_ALIGN) { :: core :: panicking :: panic ("assertion failed: mem::align_of::<ChunkFooter>() <= CHUNK_ALIGN" ,) }' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if true { if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) } }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
    Depth 3: (Count: 1)
      - 'if ! (ptr <= self as * const ChunkFooter as * const u8) { :: core :: panicking :: panic ("assertion failed: ptr <= self as *const ChunkFooter as *const u8" ,) }' (Used Types: {"* const ChunkFooter", "* const u8", "ChunkFooter"})

--- AST Node Type: MethodCall ---
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(self as * const ChunkFooter as * const u8) . offset_from (ptr)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})

--- AST Node Type: Paren ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 5: (Count: 1)
      - '(mem :: align_of :: < ChunkFooter > () <= CHUNK_ALIGN)' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 5: (Count: 2)
      - '(ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const ChunkFooter", "* const u8"})
      - '(self as * const ChunkFooter as * const u8)' (Used Types: {"* const u8", "* const ChunkFooter", "ChunkFooter"})

--- AST Node Type: Path ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 5: (Count: 2)
      - 'Layout :: new :: < ChunkFooter >' (Used Types: {"ChunkFooter"})
      - 'mem :: size_of :: < ChunkFooter >' (Used Types: {"ChunkFooter"})
    Depth 8: (Count: 1)
      - 'mem :: align_of :: < ChunkFooter >' (Used Types: {"ChunkFooter"})

--- AST Node Type: Struct ---
  Expressions using 'ChunkFooter' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , }' (Used Types: {"ChunkFooter", "* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "* mut u8"})

--- AST Node Type: Unary ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 4: (Count: 1)
      - '! (mem :: align_of :: < ChunkFooter > () <= CHUNK_ALIGN)' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - '! (ptr <= self as * const ChunkFooter as * const u8)' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})

--- AST Node Type: Unsafe ---
  Expressions using 'ChunkFooter' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { self . iter_allocated_chunks_raw () . count () * mem :: size_of :: < ChunkFooter > () }' (Used Types: {"ChunkFooter"})
  Expressions using 'ChunkFooter' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (self as * const ChunkFooter as * const u8) . offset_from (ptr) as usize }' (Used Types: {"ChunkFooter", "* const u8", "* const ChunkFooter"})
  Expressions using 'ChunkFooter' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }' (Used Types: {"* const EmptyChunkFooter", "ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter"})

### Analyzing expressions using type: 'ClassAscii' ###

--- AST Node Type: Block ---
  Expressions using 'ClassAscii' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassAscii' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
  Expressions using 'ClassAscii' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})

--- AST Node Type: Call ---
  Expressions using 'ClassAscii' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})

--- AST Node Type: Closure ---
  Expressions using 'ClassAscii' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassAscii' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})

### Analyzing expressions using type: 'ClassAsciiKind' ###

--- AST Node Type: Array ---
  Expressions using 'ClassAsciiKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassAsciiKind", "Span"})

--- AST Node Type: Block ---
  Expressions using 'ClassAsciiKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
  Expressions using 'ClassAsciiKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})

--- AST Node Type: Call ---
  Expressions using 'ClassAsciiKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ClassAsciiKind", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassAsciiKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassAsciiKind"})

--- AST Node Type: Closure ---
  Expressions using 'ClassAsciiKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassAsciiKind"})

--- AST Node Type: Reference ---
  Expressions using 'ClassAsciiKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassAsciiKind"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassAsciiKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"ClassAsciiKind"})

### Analyzing expressions using type: 'ClassBracketed' ###

--- AST Node Type: Block ---
  Expressions using 'ClassBracketed' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassBracketed' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'ClassBracketed' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
  Expressions using 'ClassBracketed' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'ClassBracketed' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'ClassBracketed' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'ClassBracketed' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'ClassBracketed' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'ClassBracketed' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassBracketed' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'ClassBracketed' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'ClassPerl' ###

--- AST Node Type: Block ---
  Expressions using 'ClassPerl' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassPerl' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'ClassPerl' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
  Expressions using 'ClassPerl' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'ClassPerl' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'ClassPerl' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'ClassPerl' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'ClassPerl' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'ClassPerl' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassPerl' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'ClassPerl' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'ClassPerlKind' ###

--- AST Node Type: Array ---
  Expressions using 'ClassPerlKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassPerlKind"})

--- AST Node Type: Block ---
  Expressions using 'ClassPerlKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
  Expressions using 'ClassPerlKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})

--- AST Node Type: Call ---
  Expressions using 'ClassPerlKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "ClassPerlKind"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassPerlKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassPerlKind"})

--- AST Node Type: Closure ---
  Expressions using 'ClassPerlKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassPerlKind"})

--- AST Node Type: Reference ---
  Expressions using 'ClassPerlKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassPerlKind", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassPerlKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"ClassPerlKind"})

### Analyzing expressions using type: 'ClassSet' ###

--- AST Node Type: Array ---
  Expressions using 'ClassSet' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span"})
  Expressions using 'ClassSet' with 3 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span", "Box", "ClassSetBinaryOpKind"})

--- AST Node Type: Block ---
  Expressions using 'ClassSet' with 12 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
  Expressions using 'ClassSet' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})

--- AST Node Type: Call ---
  Expressions using 'ClassSet' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ClassSet", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSet", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"ClassSet", "Span"})
  Expressions using 'ClassSet' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Box", "ClassSetBinaryOpKind", "ClassSet"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "Span", "ClassSet", "ClassSetBinaryOpKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassSetBinaryOpKind", "Box", "ClassSet"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSet' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSet", "Span"})
  Expressions using 'ClassSet' with 3 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})

--- AST Node Type: Reference ---
  Expressions using 'ClassSet' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassSet"})
  Expressions using 'ClassSet' with 3 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSet' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"ClassSet"})
  Expressions using 'ClassSet' with 1 other type(s):
    Depth 10: (Count: 1)
      - '< Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Box", "ClassSet"})

### Analyzing expressions using type: 'ClassSetBinaryOp' ###

--- AST Node Type: Block ---
  Expressions using 'ClassSetBinaryOp' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
  Expressions using 'ClassSetBinaryOp' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
  Expressions using 'ClassSetBinaryOp' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})

--- AST Node Type: Call ---
  Expressions using 'ClassSetBinaryOp' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSetBinaryOp' with 1 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSetBinaryOp' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})

### Analyzing expressions using type: 'ClassSetBinaryOpKind' ###

--- AST Node Type: Array ---
  Expressions using 'ClassSetBinaryOpKind' with 3 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span", "Box", "ClassSetBinaryOpKind"})

--- AST Node Type: Block ---
  Expressions using 'ClassSetBinaryOpKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
  Expressions using 'ClassSetBinaryOpKind' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})

--- AST Node Type: Call ---
  Expressions using 'ClassSetBinaryOpKind' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Box", "ClassSetBinaryOpKind", "ClassSet"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "Span", "ClassSet", "ClassSetBinaryOpKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassSetBinaryOpKind", "Box", "ClassSet"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSetBinaryOpKind' with 3 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})

--- AST Node Type: Reference ---
  Expressions using 'ClassSetBinaryOpKind' with 3 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSetBinaryOpKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"ClassSetBinaryOpKind"})

### Analyzing expressions using type: 'ClassSetItem' ###

--- AST Node Type: Array ---
  Expressions using 'ClassSetItem' with 2 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "ClassSetItem"})

--- AST Node Type: Block ---
  Expressions using 'ClassSetItem' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
  Expressions using 'ClassSetItem' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
  Expressions using 'ClassSetItem' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
  Expressions using 'ClassSetItem' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})

--- AST Node Type: Call ---
  Expressions using 'ClassSetItem' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassSetBinaryOp", "ClassSetItem"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})
  Expressions using 'ClassSetItem' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "Span", "ClassSetItem"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSetItem", "Span", "Vec"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"ClassSetItem", "Vec", "Span"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSetItem' with 1 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})
  Expressions using 'ClassSetItem' with 2 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "ClassSetItem", "Span"})

--- AST Node Type: Reference ---
  Expressions using 'ClassSetItem' with 2 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSetItem", "Span", "Vec"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSetItem' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetItem", "ClassSetBinaryOp"})
    Depth 10: (Count: 1)
      - '< Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Vec", "ClassSetItem"})

### Analyzing expressions using type: 'ClassSetRange' ###

--- AST Node Type: Block ---
  Expressions using 'ClassSetRange' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassSetRange' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
  Expressions using 'ClassSetRange' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})

--- AST Node Type: Call ---
  Expressions using 'ClassSetRange' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSetRange' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSetRange' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})

### Analyzing expressions using type: 'ClassSetUnion' ###

--- AST Node Type: Block ---
  Expressions using 'ClassSetUnion' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassSetUnion' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
  Expressions using 'ClassSetUnion' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})

--- AST Node Type: Call ---
  Expressions using 'ClassSetUnion' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})

--- AST Node Type: Closure ---
  Expressions using 'ClassSetUnion' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassSetUnion' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})

### Analyzing expressions using type: 'ClassUnicode' ###

--- AST Node Type: Block ---
  Expressions using 'ClassUnicode' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'ClassUnicode' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'ClassUnicode' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
  Expressions using 'ClassUnicode' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'ClassUnicode' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'ClassUnicode' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'ClassUnicode' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'ClassUnicode' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'ClassUnicode' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassUnicode' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'ClassUnicode' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'ClassUnicodeKind' ###

--- AST Node Type: Array ---
  Expressions using 'ClassUnicodeKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"ClassUnicodeKind", "Span"})

--- AST Node Type: Block ---
  Expressions using 'ClassUnicodeKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})

--- AST Node Type: Call ---
  Expressions using 'ClassUnicodeKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "ClassUnicodeKind"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"ClassUnicodeKind", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"Span", "ClassUnicodeKind"})

--- AST Node Type: Closure ---
  Expressions using 'ClassUnicodeKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "ClassUnicodeKind"})

--- AST Node Type: Reference ---
  Expressions using 'ClassUnicodeKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "ClassUnicodeKind"})

--- AST Node Type: Unknown ---
  Expressions using 'ClassUnicodeKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"ClassUnicodeKind"})

### Analyzing expressions using type: 'ClassUnicodeOpKind' ###

--- AST Node Type: Block ---
  Expressions using 'ClassUnicodeOpKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})

### Analyzing expressions using type: 'Comment' ###

--- AST Node Type: Array ---
  Expressions using 'Comment' with 2 other type(s):
    Depth 9: (Count: 1)
      - '[< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Vec", "Comment"})

--- AST Node Type: Block ---
  Expressions using 'Comment' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
  Expressions using 'Comment' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})

--- AST Node Type: Call ---
  Expressions using 'Comment' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Ast", "Vec", "Comment"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Comment", "Ast", "Vec"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Ast", "Vec", "Comment"})

--- AST Node Type: Closure ---
  Expressions using 'Comment' with 2 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Ast", "Comment"})

--- AST Node Type: Reference ---
  Expressions using 'Comment' with 2 other type(s):
    Depth 8: (Count: 1)
      - '& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Comment", "Vec", "Ast"})

--- AST Node Type: Unknown ---
  Expressions using 'Comment' with 1 other type(s):
    Depth 10: (Count: 1)
      - '< Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Comment", "Vec"})

### Analyzing expressions using type: 'CompletionStatus' ###

--- AST Node Type: If ---
  Expressions using 'CompletionStatus' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'if ! prev . is_null () { let ptr : * mut CompletionStatus = self . pin_project () . 1 . get_unchecked_mut () ; match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})

--- AST Node Type: MethodCall ---
  Expressions using 'CompletionStatus' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'ptr . cast :: < CompletionStatus > ()' (Used Types: {"CompletionStatus"})

--- AST Node Type: Reference ---
  Expressions using 'CompletionStatus' with 0 other type(s):
    Depth 3: (Count: 1)
      - '& mut * ptr . cast :: < CompletionStatus > ()' (Used Types: {"CompletionStatus"})

--- AST Node Type: Unary ---
  Expressions using 'CompletionStatus' with 0 other type(s):
    Depth 4: (Count: 1)
      - '* ptr . cast :: < CompletionStatus > ()' (Used Types: {"CompletionStatus"})

--- AST Node Type: Unsafe ---
  Expressions using 'CompletionStatus' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { let task = cabi :: wasip3_task_set (ptr :: null_mut ()) ; if ! ! task . is_null () { :: core :: panicking :: panic ("assertion failed: !task.is_null()") } if ! ((* task) . version >= cabi :: WASIP3_TASK_V1) { :: core :: panicking :: panic ("assertion failed: (*task).version >= cabi::WASIP3_TASK_V1" ,) } let prev = ((* task) . waitable_unregister) ((* task) . ptr , waitable) ; if ! prev . is_null () { let ptr : * mut CompletionStatus = self . pin_project () . 1 . get_unchecked_mut () ; match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } cabi :: wasip3_task_set (task) ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})
      - 'unsafe { let task = cabi :: wasip3_task_set (ptr :: null_mut ()) ; if ! ! task . is_null () { :: core :: panicking :: panic ("assertion failed: !task.is_null()") } if ! ((* task) . version >= cabi :: WASIP3_TASK_V1) { :: core :: panicking :: panic ("assertion failed: (*task).version >= cabi::WASIP3_TASK_V1" ,) } let ptr : * mut CompletionStatus = completion_status . get_unchecked_mut () ; let prev = ((* task) . waitable_register) ((* task) . ptr , waitable , cabi_wake , ptr . cast () ,) ; if ! prev . is_null () { match (& ptr , & prev . cast ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; } cabi :: wasip3_task_set (task) ; }' (Used Types: {"CompletionStatus", "* mut CompletionStatus"})

### Analyzing expressions using type: 'Concat' ###

--- AST Node Type: Block ---
  Expressions using 'Concat' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Concat' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
  Expressions using 'Concat' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Concat' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Concat' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'Concat' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'Content' ###

--- AST Node Type: Block ---
  Expressions using 'Content' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})

--- AST Node Type: Call ---
  Expressions using 'Content' with 0 other type(s):
    Depth 5: (Count: 1)
      - '< _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,)' (Used Types: {"Content"})

--- AST Node Type: Path ---
  Expressions using 'Content' with 0 other type(s):
    Depth 6: (Count: 1)
      - '< _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize' (Used Types: {"Content"})

--- AST Node Type: Unknown ---
  Expressions using 'Content' with 0 other type(s):
    Depth 4: (Count: 1)
      - '< _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ?' (Used Types: {"Content"})

### Analyzing expressions using type: 'ContextError' ###

--- AST Node Type: Block ---
  Expressions using 'ContextError' with 4 other type(s):
    Depth 3: (Count: 2)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"C", "ErrorImpl", "ContextError", "ManuallyDrop", "E"})
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"C", "ContextError", "ErrorImpl", "ManuallyDrop", "Error"})

--- AST Node Type: If ---
  Expressions using 'ContextError' with 4 other type(s):
    Depth 2: (Count: 3)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"ErrorImpl", "ContextError", "E", "C", "ManuallyDrop"})
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"ErrorImpl", "C", "ManuallyDrop", "Error", "ContextError"})
      - 'if TypeId :: of :: < C > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"E", "ErrorImpl", "()", "C", "ContextError"})
    Depth 3: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"ContextError", "ErrorImpl", "E", "C", "()"})

--- AST Node Type: MethodCall ---
  Expressions using 'ContextError' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , Error > > > ()' (Used Types: {"C", "ErrorImpl", "ContextError", "Error"})
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , E > > > ()' (Used Types: {"C", "ErrorImpl", "E", "ContextError"})
  Expressions using 'ContextError' with 4 other type(s):
    Depth 3: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "C", "ContextError", "E"})
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > ()' (Used Types: {"ContextError", "ManuallyDrop", "C", "Error", "ErrorImpl"})
    Depth 4: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > ()' (Used Types: {"ContextError", "ErrorImpl", "ManuallyDrop", "E", "C"})
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "Error", "C", "ContextError"})

--- AST Node Type: Path ---
  Expressions using 'ContextError' with 2 other type(s):
    Depth 4: (Count: 8)
      - 'object_boxed :: < ContextError < C , E > >' (Used Types: {"ContextError", "C", "E"})
      - 'object_boxed :: < ContextError < C , Error > >' (Used Types: {"ContextError", "C", "Error"})
      - 'object_drop :: < ContextError < C , E > >' (Used Types: {"C", "E", "ContextError"})
      - 'object_drop :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_reallocate_boxed :: < ContextError < C , E > >' (Used Types: {"C", "ContextError", "E"})
      - 'object_reallocate_boxed :: < ContextError < C , Error > , >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_ref :: < ContextError < C , E > >' (Used Types: {"ContextError", "E", "C"})
      - 'object_ref :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Reference ---
  Expressions using 'ContextError' with 2 other type(s):
    Depth 2: (Count: 2)
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "C", "E"})
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Struct ---
  Expressions using 'ContextError' with 2 other type(s):
    Depth 3: (Count: 2)
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "E", "C"})
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "C", "ContextError"})

### Analyzing expressions using type: 'Cow' ###

--- AST Node Type: Call ---
  Expressions using 'Cow' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ') ,)' (Used Types: {"Result", "[u8]", "Cow", "Vec", "QuoteError"})

--- AST Node Type: MethodCall ---
  Expressions using 'Cow' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ')' (Used Types: {"QuoteError", "Cow", "Vec", "Result", "[u8]"})
    Depth 5: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > ()' (Used Types: {"QuoteError", "[u8]", "Cow", "Result", "Vec"})

--- AST Node Type: Unknown ---
  Expressions using 'Cow' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ?' (Used Types: {"Vec", "Result", "QuoteError", "Cow", "[u8]"})

### Analyzing expressions using type: 'DisplayError' ###

--- AST Node Type: Path ---
  Expressions using 'DisplayError' with 1 other type(s):
    Depth 4: (Count: 4)
      - 'object_boxed :: < DisplayError < M > >' (Used Types: {"M", "DisplayError"})
      - 'object_drop :: < DisplayError < M > >' (Used Types: {"DisplayError", "M"})
      - 'object_reallocate_boxed :: < DisplayError < M > >' (Used Types: {"DisplayError", "M"})
      - 'object_ref :: < DisplayError < M > >' (Used Types: {"M", "DisplayError"})

--- AST Node Type: Reference ---
  Expressions using 'DisplayError' with 1 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < DisplayError < M > > , object_ref : object_ref :: < DisplayError < M > > , object_boxed : object_boxed :: < DisplayError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < DisplayError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"M", "DisplayError"})

--- AST Node Type: Struct ---
  Expressions using 'DisplayError' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < DisplayError < M > > , object_ref : object_ref :: < DisplayError < M > > , object_boxed : object_boxed :: < DisplayError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < DisplayError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"DisplayError", "M"})

### Analyzing expressions using type: 'E' ###

--- AST Node Type: Binary ---
  Expressions using 'E' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'TypeId :: of :: < E > () == target' (Used Types: {"E"})

--- AST Node Type: Block ---
  Expressions using 'E' with 4 other type(s):
    Depth 3: (Count: 1)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"C", "ErrorImpl", "ContextError", "ManuallyDrop", "E"})

--- AST Node Type: Call ---
  Expressions using 'E' with 0 other type(s):
    Depth 3: (Count: 2)
      - 'Some (addr . cast :: < E > () . deref ())' (Used Types: {"E"})
      - 'Some (addr . cast :: < E > () . deref_mut ())' (Used Types: {"E"})
    Depth 5: (Count: 1)
      - 'TypeId :: of :: < E > ()' (Used Types: {"E"})
  Expressions using 'E' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) })' (Used Types: {"E", "* mut E"})
    Depth 5: (Count: 1)
      - 'NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E)' (Used Types: {"E", "* mut E"})
    Depth 6: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) })' (Used Types: {"E", "* mut E"})
    Depth 8: (Count: 1)
      - 'NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,)' (Used Types: {"E", "* mut E"})
  Expressions using 'E' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})

--- AST Node Type: Cast ---
  Expressions using 'E' with 1 other type(s):
    Depth 9: (Count: 1)
      - '& raw const (* unerased_ref . as_ptr ()) . _object as * mut E' (Used Types: {"* mut E", "E"})

--- AST Node Type: If ---
  Expressions using 'E' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < E > > () ; return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,) ; } else { None }' (Used Types: {"E", "ErrorImpl", "* mut E", "()"})
  Expressions using 'E' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"ErrorImpl", "ContextError", "E", "C", "ManuallyDrop"})
      - 'if TypeId :: of :: < C > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"E", "ErrorImpl", "()", "C", "ContextError"})
    Depth 3: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"ContextError", "ErrorImpl", "E", "C", "()"})
  Expressions using 'E' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: MethodCall ---
  Expressions using 'E' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'self . downcast_ref :: < E > () . is_some ()' (Used Types: {"E"})
    Depth 3: (Count: 2)
      - 'addr . cast :: < E > () . read ()' (Used Types: {"E"})
      - 'self . downcast_ref :: < E > ()' (Used Types: {"E"})
    Depth 4: (Count: 2)
      - 'addr . cast :: < E > () . deref ()' (Used Types: {"E"})
      - 'addr . cast :: < E > () . deref_mut ()' (Used Types: {"E"})
    Depth 5: (Count: 1)
      - 'addr . cast :: < E > ()' (Used Types: {"E"})
  Expressions using 'E' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'e . cast :: < ErrorImpl < E > > ()' (Used Types: {"E", "ErrorImpl"})
  Expressions using 'E' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ManuallyDrop < E > > > ()' (Used Types: {"ErrorImpl", "E", "ManuallyDrop"})
    Depth 5: (Count: 1)
      - 'Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > ()' (Used Types: {"* mut E", "E", "()"})
  Expressions using 'E' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , E > > > ()' (Used Types: {"C", "ErrorImpl", "E", "ContextError"})
  Expressions using 'E' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "C", "ContextError", "E"})
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > ()' (Used Types: {"ContextError", "ErrorImpl", "ManuallyDrop", "E", "C"})

--- AST Node Type: Path ---
  Expressions using 'E' with 0 other type(s):
    Depth 4: (Count: 6)
      - 'object_boxed :: < E >' (Used Types: {"E"})
      - 'object_downcast :: < E >' (Used Types: {"E"})
      - 'object_drop :: < E >' (Used Types: {"E"})
      - 'object_drop_front :: < E >' (Used Types: {"E"})
      - 'object_reallocate_boxed :: < E >' (Used Types: {"E"})
      - 'object_ref :: < E >' (Used Types: {"E"})
    Depth 6: (Count: 1)
      - 'TypeId :: of :: < E >' (Used Types: {"E"})
  Expressions using 'E' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'context_downcast :: < C , E >' (Used Types: {"C", "E"})
      - 'context_drop_rest :: < C , E >' (Used Types: {"E", "C"})
  Expressions using 'E' with 2 other type(s):
    Depth 4: (Count: 4)
      - 'object_boxed :: < ContextError < C , E > >' (Used Types: {"ContextError", "C", "E"})
      - 'object_drop :: < ContextError < C , E > >' (Used Types: {"C", "E", "ContextError"})
      - 'object_reallocate_boxed :: < ContextError < C , E > >' (Used Types: {"C", "ContextError", "E"})
      - 'object_ref :: < ContextError < C , E > >' (Used Types: {"ContextError", "E", "C"})

--- AST Node Type: Reference ---
  Expressions using 'E' with 0 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < E > , object_ref : object_ref :: < E > , object_boxed : object_boxed :: < E > , object_reallocate_boxed : object_reallocate_boxed :: < E > , object_downcast : object_downcast :: < E > , object_drop_rest : object_drop_front :: < E > , }' (Used Types: {"E"})
  Expressions using 'E' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "C", "E"})

--- AST Node Type: Return ---
  Expressions using 'E' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'return Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) })' (Used Types: {"* mut E", "E"})
  Expressions using 'E' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,)' (Used Types: {"E", "* mut E", "()"})

--- AST Node Type: Struct ---
  Expressions using 'E' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < E > , object_ref : object_ref :: < E > , object_boxed : object_boxed :: < E > , object_reallocate_boxed : object_reallocate_boxed :: < E > , object_downcast : object_downcast :: < E > , object_drop_rest : object_drop_front :: < E > , }' (Used Types: {"E"})
  Expressions using 'E' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , E > > , object_ref : object_ref :: < ContextError < C , E > > , object_boxed : object_boxed :: < ContextError < C , E > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , E > > , object_downcast : context_downcast :: < C , E > , object_drop_rest : context_drop_rest :: < C , E > , }' (Used Types: {"ContextError", "E", "C"})

--- AST Node Type: Unsafe ---
  Expressions using 'E' with 0 other type(s):
    Depth 2: (Count: 3)
      - 'unsafe { let addr = (vtable (self . inner . ptr) . object_downcast) (self . inner . by_ref () , target) ? . by_mut () ; Some (addr . cast :: < E > () . deref_mut ()) }' (Used Types: {"E"})
      - 'unsafe { let addr = (vtable (self . inner . ptr) . object_downcast) (self . inner . by_ref () , target) ? ; Some (addr . cast :: < E > () . deref ()) }' (Used Types: {"E"})
      - 'unsafe { let addr = match (vtable (inner . ptr) . object_downcast) (inner . by_ref () , target) { Some (addr) => addr . by_mut () . extend () , None => return Err (self) , } ; let outer = ManuallyDrop :: new (self) ; let error = addr . cast :: < E > () . read () ; (vtable (outer . inner . ptr) . object_drop_rest) (outer . inner , target) ; Ok (error) }' (Used Types: {"E"})
  Expressions using 'E' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E) }' (Used Types: {"* mut E", "E"})
    Depth 7: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }' (Used Types: {"* mut E", "E"})

### Analyzing expressions using type: 'EagerStorage' ###

--- AST Node Type: Block ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } }' (Used Types: {"EagerStorage", "Cell"})
    Depth 10: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () }' (Used Types: {"EagerStorage", "Cell"})
  Expressions using 'EagerStorage' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'EagerStorage' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'EagerStorage' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'EagerStorage' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'EagerStorage' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'EagerStorage' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'EagerStorage' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 6: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } })' (Used Types: {"Cell", "EagerStorage"})

--- AST Node Type: Closure ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 9: (Count: 1)
      - '| _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () }' (Used Types: {"EagerStorage", "Cell"})

--- AST Node Type: If ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 8: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } }' (Used Types: {"Cell", "EagerStorage"})

--- AST Node Type: Unknown ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }' (Used Types: {"Cell", "EagerStorage"})

--- AST Node Type: Unsafe ---
  Expressions using 'EagerStorage' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) }' (Used Types: {"Cell", "EagerStorage"})

### Analyzing expressions using type: 'Either' ###

--- AST Node Type: Block ---
  Expressions using 'Either' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < str > > () { } fn propagate_ref < T1 : AsRef < str > , T2 : AsRef < str > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < str > > () { } fn propagate_mut < T1 : AsMut < str > , T2 : AsMut < str > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Either", "T1", "T2"})
  Expressions using 'Either' with 3 other type(s):
    Depth 2: (Count: 3)
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: CStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: CStr > , T2 : AsRef < :: std :: ffi :: CStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: CStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: CStr > , T2 : AsMut < :: std :: ffi :: CStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"CStr", "T2", "T1", "Either"})
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: OsStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: OsStr > , T2 : AsRef < :: std :: ffi :: OsStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: OsStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: OsStr > , T2 : AsMut < :: std :: ffi :: OsStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"T2", "T1", "Either", "OsStr"})
      - '{ fn check_ref < T : AsRef < :: std :: path :: Path > > () { } fn propagate_ref < T1 : AsRef < :: std :: path :: Path > , T2 : AsRef < :: std :: path :: Path > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: path :: Path > > () { } fn propagate_mut < T1 : AsMut < :: std :: path :: Path > , T2 : AsMut < :: std :: path :: Path > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Path", "T2", "Either", "T1"})
  Expressions using 'Either' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'Either' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'Either' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})

--- AST Node Type: Call ---
  Expressions using 'Either' with 2 other type(s):
    Depth 4: (Count: 3)
      - '_serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,)' (Used Types: {"Either", "L", "R"})
      - 'check_mut :: < Either < T1 , T2 > > ()' (Used Types: {"T1", "T2", "Either"})
      - 'check_ref :: < Either < T1 , T2 > > ()' (Used Types: {"T2", "Either", "T1"})
  Expressions using 'Either' with 3 other type(s):
    Depth 3: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T2", "T1", "Either"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T1", "Either", "T2"})

--- AST Node Type: Path ---
  Expressions using 'Either' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'check_mut :: < Either < T1 , T2 > >' (Used Types: {"Either", "T1", "T2"})
      - 'check_ref :: < Either < T1 , T2 > >' (Used Types: {"T1", "T2", "Either"})
    Depth 6: (Count: 1)
      - '_serde :: __private :: PhantomData :: < Either < L , R > >' (Used Types: {"L", "Either", "R"})
  Expressions using 'Either' with 3 other type(s):
    Depth 4: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ >' (Used Types: {"T2", "T1", "Either", "_"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ >' (Used Types: {"_", "T2", "Either", "T1"})

--- AST Node Type: Struct ---
  Expressions using 'Either' with 2 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , }' (Used Types: {"Either", "R", "L"})

### Analyzing expressions using type: 'EmptyChunkFooter' ###

--- AST Node Type: Call ---
  Expressions using 'EmptyChunkFooter' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) })' (Used Types: {"EmptyChunkFooter", "* mut u8", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8)' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using 'EmptyChunkFooter' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) })' (Used Types: {"ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})
    Depth 6: (Count: 1)
      - 'NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,)' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "ChunkFooter"})
  Expressions using 'EmptyChunkFooter' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'EmptyChunkFooter (ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , })' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "* mut u8", "* const EmptyChunkFooter", "EmptyChunkFooter"})

--- AST Node Type: Cast ---
  Expressions using 'EmptyChunkFooter' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter' (Used Types: {"* const EmptyChunkFooter", "EmptyChunkFooter"})
  Expressions using 'EmptyChunkFooter' with 2 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8' (Used Types: {"* const EmptyChunkFooter", "* mut u8", "EmptyChunkFooter"})
  Expressions using 'EmptyChunkFooter' with 3 other type(s):
    Depth 7: (Count: 1)
      - '& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter' (Used Types: {"* mut ChunkFooter", "ChunkFooter", "EmptyChunkFooter", "* const EmptyChunkFooter"})

--- AST Node Type: Struct ---
  Expressions using 'EmptyChunkFooter' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'ChunkFooter { layout : Layout :: new :: < ChunkFooter > () , data : unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) } , ptr : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }) , prev : Cell :: new (unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }) , allocated_bytes : 0 , }' (Used Types: {"ChunkFooter", "* const EmptyChunkFooter", "EmptyChunkFooter", "* mut ChunkFooter", "* mut u8"})

--- AST Node Type: Unsafe ---
  Expressions using 'EmptyChunkFooter' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut u8) }' (Used Types: {"EmptyChunkFooter", "* const EmptyChunkFooter", "* mut u8"})
  Expressions using 'EmptyChunkFooter' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { NonNull :: new_unchecked (& EMPTY_CHUNK as * const EmptyChunkFooter as * mut ChunkFooter ,) }' (Used Types: {"* const EmptyChunkFooter", "ChunkFooter", "* mut ChunkFooter", "EmptyChunkFooter"})

### Analyzing expressions using type: 'Equal' ###

--- AST Node Type: Block ---
  Expressions using 'Equal' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for Equal { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Equal" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Equal`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Equal", "Type", "Self"})

### Analyzing expressions using type: 'Error' ###

--- AST Node Type: Block ---
  Expressions using 'Error' with 0 other type(s):
    Depth 7: (Count: 1)
      - '{ if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; }' (Used Types: {"Error"})
  Expressions using 'Error' with 2 other type(s):
    Depth 7: (Count: 1)
      - '{ if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; }' (Used Types: {"Error", "Vec", "Block"})
  Expressions using 'Error' with 4 other type(s):
    Depth 3: (Count: 1)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"C", "ContextError", "ErrorImpl", "ManuallyDrop", "Error"})
  Expressions using 'Error' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
  Expressions using 'Error' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'Error' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'Error' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
  Expressions using 'Error' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'Error' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Error' with 0 other type(s):
    Depth 2: (Count: 1)
      - '< Error as fmt :: Display > :: fmt (self , f)' (Used Types: {"Error"})
    Depth 4: (Count: 1)
      - '_serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content)' (Used Types: {"Error"})
    Depth 10: (Count: 2)
      - '_serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,)' (Used Types: {"Error"})
      - '_serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,)' (Used Types: {"Error"})

--- AST Node Type: If ---
  Expressions using 'Error' with 0 other type(s):
    Depth 8: (Count: 2)
      - 'if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; }' (Used Types: {"Error"})
      - 'if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; }' (Used Types: {"Error"})
  Expressions using 'Error' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"ErrorImpl", "C", "ManuallyDrop", "Error", "ContextError"})

--- AST Node Type: Match ---
  Expressions using 'Error' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } }' (Used Types: {"IgnoredAny", "Error", "Vec", "Block"})

--- AST Node Type: MethodCall ---
  Expressions using 'Error' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , Error > > > ()' (Used Types: {"C", "ErrorImpl", "ContextError", "Error"})
  Expressions using 'Error' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > ()' (Used Types: {"ContextError", "ManuallyDrop", "C", "Error", "ErrorImpl"})
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "Error", "C", "ContextError"})

--- AST Node Type: Path ---
  Expressions using 'Error' with 0 other type(s):
    Depth 3: (Count: 1)
      - '< Error as fmt :: Display > :: fmt' (Used Types: {"Error"})
    Depth 5: (Count: 1)
      - '_serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new' (Used Types: {"Error"})
  Expressions using 'Error' with 2 other type(s):
    Depth 4: (Count: 4)
      - 'object_boxed :: < ContextError < C , Error > >' (Used Types: {"ContextError", "C", "Error"})
      - 'object_drop :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_reallocate_boxed :: < ContextError < C , Error > , >' (Used Types: {"Error", "ContextError", "C"})
      - 'object_ref :: < ContextError < C , Error > >' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Reference ---
  Expressions using 'Error' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "ContextError", "C"})

--- AST Node Type: Return ---
  Expressions using 'Error' with 0 other type(s):
    Depth 9: (Count: 2)
      - 'return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,)' (Used Types: {"Error"})
      - 'return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,)' (Used Types: {"Error"})

--- AST Node Type: Struct ---
  Expressions using 'Error' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < ContextError < C , Error > > , object_ref : object_ref :: < ContextError < C , Error > > , object_boxed : object_boxed :: < ContextError < C , Error > > , object_reallocate_boxed : object_reallocate_boxed :: < ContextError < C , Error > , > , object_downcast : context_chain_downcast :: < C > , object_drop_rest : context_chain_drop_rest :: < C > , }' (Used Types: {"Error", "C", "ContextError"})

--- AST Node Type: While ---
  Expressions using 'Error' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"__Field", "IgnoredAny", "Error", "Block", "Vec"})

### Analyzing expressions using type: 'ErrorImpl' ###

--- AST Node Type: Block ---
  Expressions using 'ErrorImpl' with 4 other type(s):
    Depth 3: (Count: 2)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"C", "ErrorImpl", "ContextError", "ManuallyDrop", "E"})
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"C", "ContextError", "ErrorImpl", "ManuallyDrop", "Error"})

--- AST Node Type: If ---
  Expressions using 'ErrorImpl' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < E > > () ; return Some (Ref :: from_raw (unsafe { NonNull :: new_unchecked (& raw const (* unerased_ref . as_ptr ()) . _object as * mut E ,) }) . cast :: < () > () ,) ; } else { None }' (Used Types: {"E", "ErrorImpl", "* mut E", "()"})
  Expressions using 'ErrorImpl' with 4 other type(s):
    Depth 2: (Count: 3)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"ErrorImpl", "ContextError", "E", "C", "ManuallyDrop"})
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"ErrorImpl", "C", "ManuallyDrop", "Error", "ContextError"})
      - 'if TypeId :: of :: < C > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . context) . cast :: < () > ()) } else if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"E", "ErrorImpl", "()", "C", "ContextError"})
    Depth 3: (Count: 1)
      - 'if TypeId :: of :: < E > () == target { let unerased_ref = e . cast :: < ErrorImpl < ContextError < C , E > > > () ; let unerased = unsafe { unerased_ref . deref () } ; Some (Ref :: new (& unerased . _object . error) . cast :: < () > ()) } else { None }' (Used Types: {"ContextError", "ErrorImpl", "E", "C", "()"})

--- AST Node Type: MethodCall ---
  Expressions using 'ErrorImpl' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'Own :: new (inner) . cast :: < ErrorImpl > ()' (Used Types: {"ErrorImpl"})
      - 'Ref :: new (self) . cast :: < ErrorImpl > ()' (Used Types: {"ErrorImpl"})
  Expressions using 'ErrorImpl' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'e . cast :: < ErrorImpl < E > > ()' (Used Types: {"E", "ErrorImpl"})
  Expressions using 'ErrorImpl' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ManuallyDrop < E > > > ()' (Used Types: {"ErrorImpl", "E", "ManuallyDrop"})
  Expressions using 'ErrorImpl' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , Error > > > ()' (Used Types: {"C", "ErrorImpl", "ContextError", "Error"})
    Depth 4: (Count: 1)
      - 'e . cast :: < ErrorImpl < ContextError < C , E > > > ()' (Used Types: {"C", "ErrorImpl", "E", "ContextError"})
  Expressions using 'ErrorImpl' with 4 other type(s):
    Depth 3: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "C", "ContextError", "E"})
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > ()' (Used Types: {"ContextError", "ManuallyDrop", "C", "Error", "ErrorImpl"})
    Depth 4: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > ()' (Used Types: {"ContextError", "ErrorImpl", "ManuallyDrop", "E", "C"})
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "Error", "C", "ContextError"})

### Analyzing expressions using type: 'ErrorKind' ###

--- AST Node Type: Array ---
  Expressions using 'ErrorKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ErrorKind", "Span"})

--- AST Node Type: Block ---
  Expressions using 'ErrorKind' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
  Expressions using 'ErrorKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})

--- AST Node Type: Call ---
  Expressions using 'ErrorKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ErrorKind", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ErrorKind", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ErrorKind"})

--- AST Node Type: Closure ---
  Expressions using 'ErrorKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ErrorKind"})

--- AST Node Type: Reference ---
  Expressions using 'ErrorKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ErrorKind", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'ErrorKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"ErrorKind"})

### Analyzing expressions using type: 'ErrorVTable' ###

--- AST Node Type: Cast ---
  Expressions using 'ErrorVTable' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'p . as_ptr () as * const & 'static ErrorVTable' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Paren ---
  Expressions using 'ErrorVTable' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

--- AST Node Type: Unary ---
  Expressions using 'ErrorVTable' with 2 other type(s):
    Depth 3: (Count: 1)
      - '* (p . as_ptr () as * const & 'static ErrorVTable)' (Used Types: {"ErrorVTable", "* const & 'static ErrorVTable", "& 'static ErrorVTable"})

--- AST Node Type: Unsafe ---
  Expressions using 'ErrorVTable' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { * (p . as_ptr () as * const & 'static ErrorVTable) }' (Used Types: {"& 'static ErrorVTable", "* const & 'static ErrorVTable", "ErrorVTable"})

### Analyzing expressions using type: 'Fd' ###

--- AST Node Type: Call ---
  Expressions using 'Fd' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Fd > :: uninit ()' (Used Types: {"Fd"})
  Expressions using 'Fd' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd))' (Used Types: {"* const Fd", "Fd"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd)' (Used Types: {"Fd", "* const Fd"})

--- AST Node Type: Cast ---
  Expressions using 'Fd' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Fd' (Used Types: {"Fd", "* const Fd"})

--- AST Node Type: Match ---
  Expressions using 'Fd' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fd)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Fd", "Fd"})

--- AST Node Type: Path ---
  Expressions using 'Fd' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Fd > :: uninit' (Used Types: {"Fd"})

### Analyzing expressions using type: 'Fdstat' ###

--- AST Node Type: Call ---
  Expressions using 'Fdstat' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Fdstat > :: uninit ()' (Used Types: {"Fdstat"})
  Expressions using 'Fdstat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat))' (Used Types: {"* const Fdstat", "Fdstat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat)' (Used Types: {"* const Fdstat", "Fdstat"})

--- AST Node Type: Cast ---
  Expressions using 'Fdstat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Fdstat' (Used Types: {"* const Fdstat", "Fdstat"})

--- AST Node Type: Match ---
  Expressions using 'Fdstat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Fdstat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Fdstat", "Fdstat"})

--- AST Node Type: Path ---
  Expressions using 'Fdstat' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Fdstat > :: uninit' (Used Types: {"Fdstat"})

### Analyzing expressions using type: 'Filesize' ###

--- AST Node Type: Call ---
  Expressions using 'Filesize' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Filesize > :: uninit ()' (Used Types: {"Filesize"})
  Expressions using 'Filesize' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize))' (Used Types: {"* const Filesize", "Filesize"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize)' (Used Types: {"* const Filesize", "Filesize"})

--- AST Node Type: Cast ---
  Expressions using 'Filesize' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Filesize' (Used Types: {"Filesize", "* const Filesize"})

--- AST Node Type: Match ---
  Expressions using 'Filesize' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filesize)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Filesize", "Filesize"})

--- AST Node Type: Path ---
  Expressions using 'Filesize' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Filesize > :: uninit' (Used Types: {"Filesize"})

### Analyzing expressions using type: 'Filestat' ###

--- AST Node Type: Call ---
  Expressions using 'Filestat' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Filestat > :: uninit ()' (Used Types: {"Filestat"})
  Expressions using 'Filestat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat))' (Used Types: {"Filestat", "* const Filestat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat)' (Used Types: {"* const Filestat", "Filestat"})

--- AST Node Type: Cast ---
  Expressions using 'Filestat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Filestat' (Used Types: {"* const Filestat", "Filestat"})

--- AST Node Type: Match ---
  Expressions using 'Filestat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Filestat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Filestat", "Filestat"})

--- AST Node Type: Path ---
  Expressions using 'Filestat' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Filestat > :: uninit' (Used Types: {"Filestat"})

### Analyzing expressions using type: 'FixedBitSet' ###

--- AST Node Type: Block ---
  Expressions using 'FixedBitSet' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
  Expressions using 'FixedBitSet' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'FixedBitSet' with 0 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,)' (Used Types: {"FixedBitSet"})

--- AST Node Type: Path ---
  Expressions using 'FixedBitSet' with 0 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: __private228 :: PhantomData :: < FixedBitSet >' (Used Types: {"FixedBitSet"})

--- AST Node Type: Struct ---
  Expressions using 'FixedBitSet' with 0 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , }' (Used Types: {"FixedBitSet"})

### Analyzing expressions using type: 'Flag' ###

--- AST Node Type: Block ---
  Expressions using 'Flag' with 0 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flag"})
  Expressions using 'Flag' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
  Expressions using 'Flag' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})

--- AST Node Type: Call ---
  Expressions using 'Flag' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"Flag"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Flag"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Flag"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,)' (Used Types: {"Flag"})

--- AST Node Type: Closure ---
  Expressions using 'Flag' with 0 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flag"})

--- AST Node Type: Unknown ---
  Expressions using 'Flag' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"Flag"})

### Analyzing expressions using type: 'Flags' ###

--- AST Node Type: Array ---
  Expressions using 'Flags' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Flags", "Span"})

--- AST Node Type: Block ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 2: (Count: 1)
      - '{ { let flag = < Flags as crate :: Flags > :: FLAGS [i] . value () . bits () ; truncated = truncated | flag ; i += 1 ; } }' (Used Types: {"Flags"})
    Depth 3: (Count: 1)
      - '{ let flag = < Flags as crate :: Flags > :: FLAGS [i] . value () . bits () ; truncated = truncated | flag ; i += 1 ; }' (Used Types: {"Flags"})
  Expressions using 'Flags' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flags", "CaptureName"})
  Expressions using 'Flags' with 12 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Flags' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})

--- AST Node Type: Call ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'crate :: iter :: Iter :: __private_const_new (< Flags as crate :: Flags > :: FLAGS , Flags :: from_bits_retain (self . bits ()) , Flags :: from_bits_retain (self . bits ()) ,)' (Used Types: {"Flags"})
      - 'crate :: iter :: IterNames :: __private_const_new (< Flags as crate :: Flags > :: FLAGS , Flags :: from_bits_retain (self . bits ()) , Flags :: from_bits_retain (self . bits ()) ,)' (Used Types: {"Flags"})
    Depth 3: (Count: 1)
      - 'crate :: parser :: from_str :: < Flags > (s)' (Used Types: {"Flags"})
  Expressions using 'Flags' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"CaptureName", "Flags"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Flags"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"CaptureName", "Flags"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Flags", "Span"})
    Depth 7: (Count: 2)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Flags", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"CaptureName", "Flags"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,)' (Used Types: {"CaptureName", "Flags"})

--- AST Node Type: Closure ---
  Expressions using 'Flags' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Flags"})
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) }' (Used Types: {"Flags", "CaptureName"})

--- AST Node Type: Index ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 6: (Count: 1)
      - '< Flags as crate :: Flags > :: FLAGS [i]' (Used Types: {"Flags"})

--- AST Node Type: MethodCall ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'crate :: parser :: from_str :: < Flags > (s) . map (| flags | flags . 0)' (Used Types: {"Flags"})
    Depth 4: (Count: 1)
      - '< Flags as crate :: Flags > :: FLAGS [i] . value () . bits ()' (Used Types: {"Flags"})
    Depth 5: (Count: 1)
      - '< Flags as crate :: Flags > :: FLAGS [i] . value ()' (Used Types: {"Flags"})

--- AST Node Type: Path ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 3: (Count: 1)
      - '< Flags as crate :: Flags > :: FLAGS' (Used Types: {"Flags"})
    Depth 4: (Count: 1)
      - 'crate :: parser :: from_str :: < Flags >' (Used Types: {"Flags"})

--- AST Node Type: Reference ---
  Expressions using 'Flags' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Flags", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'Flags' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Flags"})
  Expressions using 'Flags' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"Flags", "CaptureName"})

### Analyzing expressions using type: 'FlagsItem' ###

--- AST Node Type: Array ---
  Expressions using 'FlagsItem' with 2 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "FlagsItem", "Span"})

--- AST Node Type: Block ---
  Expressions using 'FlagsItem' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
  Expressions using 'FlagsItem' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})

--- AST Node Type: Call ---
  Expressions using 'FlagsItem' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Vec", "Span", "FlagsItem"})

--- AST Node Type: Closure ---
  Expressions using 'FlagsItem' with 2 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"FlagsItem", "Span", "Vec"})

--- AST Node Type: Reference ---
  Expressions using 'FlagsItem' with 2 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "Span", "FlagsItem"})

--- AST Node Type: Unknown ---
  Expressions using 'FlagsItem' with 1 other type(s):
    Depth 10: (Count: 1)
      - '< Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"FlagsItem", "Vec"})

### Analyzing expressions using type: 'FlagsItemKind' ###

--- AST Node Type: Array ---
  Expressions using 'FlagsItemKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"FlagsItemKind", "Span"})

--- AST Node Type: Block ---
  Expressions using 'FlagsItemKind' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
  Expressions using 'FlagsItemKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})

--- AST Node Type: Call ---
  Expressions using 'FlagsItemKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"FlagsItemKind", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "FlagsItemKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"Span", "FlagsItemKind"})

--- AST Node Type: Closure ---
  Expressions using 'FlagsItemKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"FlagsItemKind", "Span"})

--- AST Node Type: Reference ---
  Expressions using 'FlagsItemKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "FlagsItemKind"})

--- AST Node Type: Unknown ---
  Expressions using 'FlagsItemKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"FlagsItemKind"})

### Analyzing expressions using type: 'FlagsVisitor' ###

--- AST Node Type: If ---
  Expressions using 'FlagsVisitor' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

### Analyzing expressions using type: 'FnTy' ###

--- AST Node Type: Block ---
  Expressions using 'FnTy' with 2 other type(s):
    Depth 6: (Count: 1)
      - '{ core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) }' (Used Types: {"()", "FnTy", "* mut ()"})
  Expressions using 'FnTy' with 5 other type(s):
    Depth 2: (Count: 3)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 10)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})

--- AST Node Type: Call ---
  Expressions using 'FnTy' with 2 other type(s):
    Depth 7: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed))' (Used Types: {"FnTy", "()", "* mut ()"})

--- AST Node Type: Match ---
  Expressions using 'FnTy' with 5 other type(s):
    Depth 4: (Count: 3)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: Path ---
  Expressions using 'FnTy' with 2 other type(s):
    Depth 8: (Count: 1)
      - 'core :: mem :: transmute :: < * mut () , FnTy , >' (Used Types: {"* mut ()", "FnTy", "()"})

--- AST Node Type: Unsafe ---
  Expressions using 'FnTy' with 5 other type(s):
    Depth 3: (Count: 3)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: 'Formatter' ###

--- AST Node Type: Block ---
  Expressions using 'Formatter' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'Formatter' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: If ---
  Expressions using 'Formatter' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

### Analyzing expressions using type: 'FutureState' ###

--- AST Node Type: Cast ---
  Expressions using 'FutureState' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'self as * mut FutureState' (Used Types: {"* mut FutureState", "FutureState"})

--- AST Node Type: MethodCall ---
  Expressions using 'FutureState' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'context_get () . cast :: < FutureState > ()' (Used Types: {"FutureState"})
      - 'ptr . cast :: < FutureState > ()' (Used Types: {"FutureState"})

### Analyzing expressions using type: 'Greater' ###

--- AST Node Type: Block ---
  Expressions using 'Greater' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for Greater { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Greater" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Greater`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "Greater"})

### Analyzing expressions using type: 'Group' ###

--- AST Node Type: Block ---
  Expressions using 'Group' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Group' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
  Expressions using 'Group' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Group' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Group' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'Group' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'GroupKind' ###

--- AST Node Type: Array ---
  Expressions using 'GroupKind' with 3 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"GroupKind", "Box", "Ast", "Span"})

--- AST Node Type: Block ---
  Expressions using 'GroupKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
  Expressions using 'GroupKind' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})

--- AST Node Type: Call ---
  Expressions using 'GroupKind' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Box", "Span", "GroupKind", "Ast"})

--- AST Node Type: Closure ---
  Expressions using 'GroupKind' with 3 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "GroupKind", "Box", "Ast"})

--- AST Node Type: Reference ---
  Expressions using 'GroupKind' with 3 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "GroupKind", "Span", "Box"})

--- AST Node Type: Unknown ---
  Expressions using 'GroupKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"GroupKind"})

### Analyzing expressions using type: 'Guid' ###

--- AST Node Type: Call ---
  Expressions using 'Guid' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < [u8 ; 16] , Guid > (* bytes)' (Used Types: {"Guid", "[u8 ; 16]"})
  Expressions using 'Guid' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self)' (Used Types: {"Guid", "[u8 ; 16]", "& Guid", "& [u8 ; 16]"})

--- AST Node Type: Path ---
  Expressions using 'Guid' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < [u8 ; 16] , Guid >' (Used Types: {"Guid", "[u8 ; 16]"})
  Expressions using 'Guid' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] >' (Used Types: {"Guid", "[u8 ; 16]", "& [u8 ; 16]", "& Guid"})

--- AST Node Type: Unsafe ---
  Expressions using 'Guid' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < [u8 ; 16] , Guid > (* bytes) }' (Used Types: {"[u8 ; 16]", "Guid"})
  Expressions using 'Guid' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self) }' (Used Types: {"Guid", "& Guid", "[u8 ; 16]", "& [u8 ; 16]"})

### Analyzing expressions using type: 'HexLiteralKind' ###

--- AST Node Type: Block ---
  Expressions using 'HexLiteralKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
  Expressions using 'HexLiteralKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
  Expressions using 'HexLiteralKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})

--- AST Node Type: Call ---
  Expressions using 'HexLiteralKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})

--- AST Node Type: Closure ---
  Expressions using 'HexLiteralKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})

--- AST Node Type: Unknown ---
  Expressions using 'HexLiteralKind' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})

### Analyzing expressions using type: 'I' ###

--- AST Node Type: Block ---
  Expressions using 'I' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using 'I' with 1 other type(s):
    Depth 2: (Count: 1)
      - '< U1 as Shl < I > > :: shl (U1 :: new () , i)' (Used Types: {"U1", "I"})
  Expressions using 'I' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using 'I' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: MethodCall ---
  Expressions using 'I' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using 'I' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using 'I' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Path ---
  Expressions using 'I' with 1 other type(s):
    Depth 3: (Count: 1)
      - '< U1 as Shl < I > > :: shl' (Used Types: {"I", "U1"})

--- AST Node Type: Reference ---
  Expressions using 'I' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Unary ---
  Expressions using 'I' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using 'I' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: 'IgnoredAny' ###

--- AST Node Type: Block ---
  Expressions using 'IgnoredAny' with 0 other type(s):
    Depth 7: (Count: 1)
      - '{ let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; }' (Used Types: {"IgnoredAny"})
  Expressions using 'IgnoredAny' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'IgnoredAny' with 0 other type(s):
    Depth 9: (Count: 1)
      - '_serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map)' (Used Types: {"IgnoredAny"})

--- AST Node Type: Match ---
  Expressions using 'IgnoredAny' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } }' (Used Types: {"IgnoredAny", "Error", "Vec", "Block"})

--- AST Node Type: Path ---
  Expressions using 'IgnoredAny' with 0 other type(s):
    Depth 10: (Count: 1)
      - '_serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , >' (Used Types: {"IgnoredAny"})

--- AST Node Type: Unknown ---
  Expressions using 'IgnoredAny' with 0 other type(s):
    Depth 8: (Count: 1)
      - '_serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ?' (Used Types: {"IgnoredAny"})

--- AST Node Type: While ---
  Expressions using 'IgnoredAny' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"__Field", "IgnoredAny", "Error", "Block", "Vec"})

### Analyzing expressions using type: 'Internal' ###

--- AST Node Type: MethodCall ---
  Expressions using 'Internal' with 0 other type(s):
    Depth 2: (Count: 13)
      - '() . private_div_quotient (n , d , q . set_bit :: < Internal > (i , B1) , U0 :: new () , i - B1 ,)' (Used Types: {"Internal"})
      - '() . private_div_quotient (n , d , q . set_bit :: < Internal > (i , B1) , r - d , i - B1)' (Used Types: {"Internal"})
      - '() . private_div_remainder (n , d , q . set_bit :: < Internal > (i , B1) , U0 :: new () , i - B1 ,)' (Used Types: {"Internal"})
      - '() . private_div_remainder (n , d , q . set_bit :: < Internal > (i , B1) , r - d , i - B1)' (Used Types: {"Internal"})
      - '(UInt { msb : UTerm , lsb : n . get_bit :: < Internal > (& i) , }) . trim ()' (Used Types: {"Internal"})
      - 'lhs . compare :: < Internal > (& rhs)' (Used Types: {"Internal"})
      - 'q . set_bit :: < Internal > (i , B1)' (Used Types: {"Internal"})
      - 'r . compare :: < Internal > (& d)' (Used Types: {"Internal"})
      - 'rhs . compare :: < Internal > (& lhs)' (Used Types: {"Internal"})
      - 'rhs . n . compare :: < Internal > (& self . n)' (Used Types: {"Internal"})
      - 'self . compare :: < Internal > (& rhs)' (Used Types: {"Internal"})
      - 'self . msb . get_bit :: < Internal > (& (* i - B1))' (Used Types: {"Internal"})
      - 'self . n . compare :: < Internal > (& rhs . n)' (Used Types: {"Internal"})
    Depth 3: (Count: 1)
      - 'n . get_bit :: < Internal > (& i)' (Used Types: {"Internal"})

--- AST Node Type: Paren ---
  Expressions using 'Internal' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(UInt { msb : UTerm , lsb : n . get_bit :: < Internal > (& i) , })' (Used Types: {"Internal"})

--- AST Node Type: Struct ---
  Expressions using 'Internal' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'UInt { msb : r , lsb : n . get_bit :: < Internal > (& i) , }' (Used Types: {"Internal"})
    Depth 4: (Count: 1)
      - 'UInt { msb : UTerm , lsb : n . get_bit :: < Internal > (& i) , }' (Used Types: {"Internal"})

### Analyzing expressions using type: 'Ioctl' ###

--- AST Node Type: Cast ---
  Expressions using 'Ioctl' with 0 other type(s):
    Depth 2: (Count: 1)
      - '((dir << _IOC_DIRSHIFT) | (ty << _IOC_TYPESHIFT) | (nr << _IOC_NRSHIFT) | ((size as u32) << _IOC_SIZESHIFT)) as Ioctl' (Used Types: {"Ioctl"})

### Analyzing expressions using type: 'Item' ###

--- AST Node Type: Binary ---
  Expressions using 'Item' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'mem :: size_of :: < A :: Item > () > 0' (Used Types: {"Item"})
    Depth 7: (Count: 1)
      - 'A :: size () * mem :: size_of :: < A :: Item > ()' (Used Types: {"Item"})
  Expressions using 'Item' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()' (Used Types: {"A", "Item"})
    Depth 6: (Count: 2)
      - 'mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()' (Used Types: {"Item", "A"})
      - 'mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > ()' (Used Types: {"A", "Item"})

--- AST Node Type: Block ---
  Expressions using 'Item' with 0 other type(s):
    Depth 3: (Count: 2)
      - '{ for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"Item"})
      - '{ for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item"})
  Expressions using 'Item' with 1 other type(s):
    Depth 6: (Count: 1)
      - '{ let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; }' (Used Types: {"* mut u8", "Item"})

--- AST Node Type: Call ---
  Expressions using 'Item' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'unty :: type_equal :: < A :: Item , u8 > ()' (Used Types: {"Item"})
    Depth 4: (Count: 1)
      - 'mem :: size_of :: < A :: Item > ()' (Used Types: {"Item"})
    Depth 6: (Count: 2)
      - 'core :: mem :: size_of :: < A :: Item > ()' (Used Types: {"Item"})
      - 'layout_array :: < A :: Item > (new_cap)' (Used Types: {"Item"})
    Depth 7: (Count: 1)
      - 'mem :: align_of :: < A :: Item > ()' (Used Types: {"Item"})
    Depth 8: (Count: 1)
      - 'layout_array :: < A :: Item > (cap)' (Used Types: {"Item"})
  Expressions using 'Item' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'ConstNonNull :: new (self . inline . as_ptr () as * const A :: Item)' (Used Types: {"* const A :: Item", "Item"})
      - 'NonNull :: new (self . inline . as_mut_ptr () as * mut A :: Item)' (Used Types: {"* mut A :: Item", "Item"})
    Depth 6: (Count: 1)
      - 'ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,)' (Used Types: {"* mut A :: Item", "Item"})
  Expressions using 'Item' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data })' (Used Types: {"Item", "A", "* mut A :: Item", "MaybeUninit"})
  Expressions using 'Item' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice)' (Used Types: {"& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]", "Item"})

--- AST Node Type: Cast ---
  Expressions using 'Item' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'self . inline . as_mut_ptr () as * mut A :: Item' (Used Types: {"* mut A :: Item", "Item"})
      - 'self . inline . as_ptr () as * const A :: Item' (Used Types: {"Item", "* const A :: Item"})
    Depth 7: (Count: 1)
      - 'data . as_mut_ptr () as * mut A :: Item' (Used Types: {"Item", "* mut A :: Item"})

--- AST Node Type: ForLoop ---
  Expressions using 'Item' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; }' (Used Types: {"Item"})
      - 'for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; }' (Used Types: {"Item"})

--- AST Node Type: If ---
  Expressions using 'Item' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'if mem :: size_of :: < A :: Item > () > 0 { A :: size () } else { core :: usize :: MAX }' (Used Types: {"Item"})
  Expressions using 'Item' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'if ! (mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ()) { :: core :: panicking :: panic ("assertion failed: mem::size_of::<A>() == A::size() * mem::size_of::<A::Item>() &&\n    mem::align_of::<A>() >= mem::align_of::<A::Item>()" ,) }' (Used Types: {"A", "Item"})
    Depth 3: (Count: 1)
      - 'if new_cap <= Self :: inline_capacity () { if unspilled { return Ok (()) ; } self . data = SmallVecData :: from_inline (MaybeUninit :: uninit ()) ; ptr :: copy_nonoverlapping (ptr . as_ptr () , self . data . inline_mut () . as_ptr () , len ,) ; self . capacity = len ; deallocate (ptr , cap) ; } else if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; }' (Used Types: {"Item", "* mut u8"})
    Depth 4: (Count: 1)
      - 'if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; }' (Used Types: {"* mut u8", "Item"})
    Depth 5: (Count: 1)
      - 'if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; }' (Used Types: {"* mut u8", "Item"})
  Expressions using 'Item' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let slice : & [u8] = unsafe { core :: mem :: transmute (self . as_slice ()) } ; encoder . writer () . write (slice) ? ; } else { for item in self . iter () { item . encode (encoder) ? ; } }' (Used Types: {"& [u8]", "Item", "[u8]"})
    Depth 4: (Count: 1)
      - 'if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut Self :: Item", "Item", "* const Self :: Item"})
  Expressions using 'Item' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if len <= Self :: inline_capacity () { SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , } } else { let mut b = slice . to_vec () ; let cap = b . capacity () ; let ptr = NonNull :: new (b . as_mut_ptr ()) . expect ("Vec always contain non null pointers.") ; mem :: forget (b) ; SmallVec { capacity : cap , data : SmallVecData :: from_heap (ptr , len) , } }' (Used Types: {"MaybeUninit", "Item", "A", "* mut A :: Item"})
  Expressions using 'Item' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"[A :: Item]", "& mut [u8]", "[u8]", "Item", "& mut [A :: Item]"})
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item", "& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]"})

--- AST Node Type: MethodCall ---
  Expressions using 'Item' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'decoder . claim_container_read :: < A :: Item > (len)' (Used Types: {"Item"})
    Depth 5: (Count: 1)
      - 'decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ())' (Used Types: {"Item"})
  Expressions using 'Item' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'ConstNonNull :: new (self . inline . as_ptr () as * const A :: Item) . unwrap ()' (Used Types: {"* const A :: Item", "Item"})
      - 'NonNull :: new (self . inline . as_mut_ptr () as * mut A :: Item) . unwrap ()' (Used Types: {"Item", "* mut A :: Item"})

--- AST Node Type: Paren ---
  Expressions using 'Item' with 1 other type(s):
    Depth 4: (Count: 1)
      - '(mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ())' (Used Types: {"A", "Item"})

--- AST Node Type: Path ---
  Expressions using 'Item' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'unty :: type_equal :: < A :: Item , u8 >' (Used Types: {"Item"})
    Depth 5: (Count: 1)
      - 'mem :: size_of :: < A :: Item >' (Used Types: {"Item"})
    Depth 7: (Count: 1)
      - 'core :: mem :: size_of :: < A :: Item >' (Used Types: {"Item"})
    Depth 8: (Count: 1)
      - 'mem :: align_of :: < A :: Item >' (Used Types: {"Item"})
    Depth 9: (Count: 1)
      - 'layout_array :: < A :: Item >' (Used Types: {"Item"})
  Expressions using 'Item' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] >' (Used Types: {"& mut [u8]", "& mut [A :: Item]", "[u8]", "[A :: Item]", "Item"})

--- AST Node Type: Struct ---
  Expressions using 'Item' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , }' (Used Types: {"MaybeUninit", "A", "* mut A :: Item", "Item"})

--- AST Node Type: Unary ---
  Expressions using 'Item' with 1 other type(s):
    Depth 3: (Count: 1)
      - '! (mem :: size_of :: < A > () == A :: size () * mem :: size_of :: < A :: Item > () && mem :: align_of :: < A > () >= mem :: align_of :: < A :: Item > ())' (Used Types: {"A", "Item"})

--- AST Node Type: Unknown ---
  Expressions using 'Item' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'decoder . claim_container_read :: < A :: Item > (len) ?' (Used Types: {"Item"})
    Depth 5: (Count: 1)
      - 'layout_array :: < A :: Item > (new_cap) ?' (Used Types: {"Item"})
    Depth 7: (Count: 1)
      - 'layout_array :: < A :: Item > (cap) ?' (Used Types: {"Item"})

--- AST Node Type: Unsafe ---
  Expressions using 'Item' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let unspilled = ! self . spilled () ; let (ptr , & mut len , cap) = self . triple_mut () ; if ! (new_cap >= len) { :: core :: panicking :: panic ("assertion failed: new_cap >= len") } if new_cap <= Self :: inline_capacity () { if unspilled { return Ok (()) ; } self . data = SmallVecData :: from_inline (MaybeUninit :: uninit ()) ; ptr :: copy_nonoverlapping (ptr . as_ptr () , self . data . inline_mut () . as_ptr () , len ,) ; self . capacity = len ; deallocate (ptr , cap) ; } else if new_cap != cap { let layout = layout_array :: < A :: Item > (new_cap) ? ; if true { if ! (layout . size () > 0) { :: core :: panicking :: panic ("assertion failed: layout.size() > 0") } } let new_alloc ; if unspilled { new_alloc = NonNull :: new (alloc :: alloc :: alloc (layout)) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; ptr :: copy_nonoverlapping (ptr . as_ptr () , new_alloc . as_ptr () , len) ; } else { let old_layout = layout_array :: < A :: Item > (cap) ? ; let new_ptr = alloc :: alloc :: realloc (ptr . as_ptr () as * mut u8 , old_layout , layout . size () ,) ; new_alloc = NonNull :: new (new_ptr) . ok_or (CollectionAllocErr :: AllocErr { layout , }) ? . cast () ; } self . data = SmallVecData :: from_heap (new_alloc , len) ; self . capacity = new_cap ; } Ok (()) }' (Used Types: {"* mut u8", "Item"})
  Expressions using 'Item' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"* const Self :: Item", "Item", "* mut Self :: Item"})
  Expressions using 'Item' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }' (Used Types: {"A", "Item", "* mut A :: Item", "MaybeUninit"})
  Expressions using 'Item' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) }' (Used Types: {"[u8]", "Item", "[A :: Item]", "& mut [A :: Item]", "& mut [u8]"})

--- AST Node Type: While ---
  Expressions using 'Item' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx < self . old_len { let i = self . idx ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len) ; self . panic_flag = true ; let drained = (self . pred) (& mut v [i]) ; self . panic_flag = false ; self . idx += 1 ; if drained { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const Self :: Item = & v [i] ; let dst : * mut Self :: Item = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"Item", "* const Self :: Item", "* mut Self :: Item"})

### Analyzing expressions using type: 'K' ###

--- AST Node Type: Call ---
  Expressions using 'K' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'make_hash :: < K , S > (& self . hash_builder , & k)' (Used Types: {"S", "K"})
      - 'make_hash :: < K , S > (& self . hash_builder , & key)' (Used Types: {"K", "S"})
      - 'make_hash :: < K , S > (self . hash_builder , & key)' (Used Types: {"K", "S"})
  Expressions using 'K' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve (self , additional)' (Used Types: {"(K , V)", "K", "V"})

--- AST Node Type: Path ---
  Expressions using 'K' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'make_hash :: < K , S >' (Used Types: {"K", "S"})
  Expressions using 'K' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve' (Used Types: {"(K , V)", "V", "K"})

### Analyzing expressions using type: 'Key' ###

--- AST Node Type: Call ---
  Expressions using 'Key' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'KeyValues (& None :: < (kv :: Key , kv :: Value) >)' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: Path ---
  Expressions using 'Key' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'None :: < (kv :: Key , kv :: Value) >' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: Reference ---
  Expressions using 'Key' with 2 other type(s):
    Depth 5: (Count: 1)
      - '& None :: < (kv :: Key , kv :: Value) >' (Used Types: {"Value", "(kv :: Key , kv :: Value)", "Key"})

--- AST Node Type: Struct ---
  Expressions using 'Key' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'RecordBuilder { record : Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , } , }' (Used Types: {"(kv :: Key , kv :: Value)", "Value", "Key"})
    Depth 3: (Count: 1)
      - 'Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , }' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

### Analyzing expressions using type: 'L' ###

--- AST Node Type: Block ---
  Expressions using 'L' with 0 other type(s):
    Depth 6: (Count: 1)
      - '{ _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) }' (Used Types: {"L"})
  Expressions using 'L' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'L' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'L' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})

--- AST Node Type: Call ---
  Expressions using 'L' with 0 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,)' (Used Types: {"L"})
    Depth 7: (Count: 2)
      - '< L as _serde :: Deserialize > :: deserialize (__deserializer)' (Used Types: {"L"})
      - '_serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,)' (Used Types: {"L"})
    Depth 8: (Count: 1)
      - '_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant)' (Used Types: {"L"})
  Expressions using 'L' with 2 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,)' (Used Types: {"Either", "L", "R"})

--- AST Node Type: If ---
  Expressions using 'L' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; }' (Used Types: {"L"})

--- AST Node Type: Let ---
  Expressions using 'L' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,)' (Used Types: {"L"})

--- AST Node Type: Match ---
  Expressions using 'L' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } }' (Used Types: {"R", "L"})

--- AST Node Type: Path ---
  Expressions using 'L' with 0 other type(s):
    Depth 8: (Count: 1)
      - '< L as _serde :: Deserialize > :: deserialize' (Used Types: {"L"})
    Depth 9: (Count: 1)
      - '_serde :: de :: VariantAccess :: newtype_variant :: < L >' (Used Types: {"L"})
  Expressions using 'L' with 2 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: __private :: PhantomData :: < Either < L , R > >' (Used Types: {"L", "Either", "R"})

--- AST Node Type: Struct ---
  Expressions using 'L' with 2 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , }' (Used Types: {"Either", "R", "L"})

### Analyzing expressions using type: 'LazyStorage' ###

--- AST Node Type: Block ---
  Expressions using 'LazyStorage' with 3 other type(s):
    Depth 7: (Count: 1)
      - '{ | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"!", "LazyStorage", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Rng", "()", "LazyStorage", "Cell"})
    Depth 9: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"!", "Rng", "Cell", "LazyStorage"})
  Expressions using 'LazyStorage' with 4 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline] fn __init () -> Cell < Rng > { Cell :: new (Rng (random_seed () . unwrap_or (DEFAULT_RNG_SEED))) } unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) } }' (Used Types: {"LazyStorage", "()", "Rng", "!", "Cell"})

--- AST Node Type: Call ---
  Expressions using 'LazyStorage' with 4 other type(s):
    Depth 4: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } })' (Used Types: {"Cell", "()", "!", "LazyStorage", "Rng"})

--- AST Node Type: Closure ---
  Expressions using 'LazyStorage' with 3 other type(s):
    Depth 7: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"LazyStorage", "()", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Cell", "!", "LazyStorage", "Rng"})

--- AST Node Type: If ---
  Expressions using 'LazyStorage' with 4 other type(s):
    Depth 6: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"()", "LazyStorage", "Rng", "!", "Cell"})

--- AST Node Type: Unknown ---
  Expressions using 'LazyStorage' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }' (Used Types: {"Cell", "Rng", "()", "LazyStorage", "!"})

--- AST Node Type: Unsafe ---
  Expressions using 'LazyStorage' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) }' (Used Types: {"!", "LazyStorage", "Rng", "()", "Cell"})

### Analyzing expressions using type: 'Less' ###

--- AST Node Type: Block ---
  Expressions using 'Less' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for Less { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Less" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Less`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Less"})

### Analyzing expressions using type: 'Literal' ###

--- AST Node Type: Array ---
  Expressions using 'Literal' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Literal", "Span"})

--- AST Node Type: Block ---
  Expressions using 'Literal' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'Literal' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Literal' with 12 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
  Expressions using 'Literal' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Literal' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Literal' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Literal", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Literal", "Span"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "Literal"})
  Expressions using 'Literal' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'Literal' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Literal' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Literal"})
  Expressions using 'Literal' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'Literal' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Reference ---
  Expressions using 'Literal' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Literal"})

--- AST Node Type: Unknown ---
  Expressions using 'Literal' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Literal"})
  Expressions using 'Literal' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'Literal' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'LiteralKind' ###

--- AST Node Type: Array ---
  Expressions using 'LiteralKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "LiteralKind"})

--- AST Node Type: Block ---
  Expressions using 'LiteralKind' with 12 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})

--- AST Node Type: Call ---
  Expressions using 'LiteralKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "LiteralKind"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "LiteralKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"LiteralKind", "Span"})

--- AST Node Type: Closure ---
  Expressions using 'LiteralKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "LiteralKind"})

--- AST Node Type: Reference ---
  Expressions using 'LiteralKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "LiteralKind"})

--- AST Node Type: Unknown ---
  Expressions using 'LiteralKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"LiteralKind"})

### Analyzing expressions using type: 'LocalKey' ###

--- AST Node Type: Block ---
  Expressions using 'LocalKey' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'LocalKey' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'LocalKey' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'LocalKey' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'LocalKey' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'LocalKey' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'LocalKey' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

### Analyzing expressions using type: 'M' ###

--- AST Node Type: Path ---
  Expressions using 'M' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'object_downcast :: < M >' (Used Types: {"M"})
      - 'object_drop_front :: < M >' (Used Types: {"M"})
  Expressions using 'M' with 1 other type(s):
    Depth 4: (Count: 8)
      - 'object_boxed :: < DisplayError < M > >' (Used Types: {"M", "DisplayError"})
      - 'object_boxed :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_drop :: < DisplayError < M > >' (Used Types: {"DisplayError", "M"})
      - 'object_drop :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_reallocate_boxed :: < DisplayError < M > >' (Used Types: {"DisplayError", "M"})
      - 'object_reallocate_boxed :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_ref :: < DisplayError < M > >' (Used Types: {"M", "DisplayError"})
      - 'object_ref :: < MessageError < M > >' (Used Types: {"M", "MessageError"})

--- AST Node Type: Reference ---
  Expressions using 'M' with 1 other type(s):
    Depth 2: (Count: 2)
      - '& ErrorVTable { object_drop : object_drop :: < DisplayError < M > > , object_ref : object_ref :: < DisplayError < M > > , object_boxed : object_boxed :: < DisplayError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < DisplayError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"M", "DisplayError"})
      - '& ErrorVTable { object_drop : object_drop :: < MessageError < M > > , object_ref : object_ref :: < MessageError < M > > , object_boxed : object_boxed :: < MessageError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < MessageError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"M", "MessageError"})

--- AST Node Type: Struct ---
  Expressions using 'M' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'ErrorVTable { object_drop : object_drop :: < DisplayError < M > > , object_ref : object_ref :: < DisplayError < M > > , object_boxed : object_boxed :: < DisplayError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < DisplayError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"DisplayError", "M"})
      - 'ErrorVTable { object_drop : object_drop :: < MessageError < M > > , object_ref : object_ref :: < MessageError < M > > , object_boxed : object_boxed :: < MessageError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < MessageError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"MessageError", "M"})

### Analyzing expressions using type: 'MIN_ALIGN' ###

--- AST Node Type: Call ---
  Expressions using 'MIN_ALIGN' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'Bump :: < MIN_ALIGN > :: dealloc (self , ptr , layout)' (Used Types: {"MIN_ALIGN"})
    Depth 4: (Count: 2)
      - 'Bump :: < MIN_ALIGN > :: grow (self , ptr , old_layout , new_layout)' (Used Types: {"MIN_ALIGN"})
      - 'Bump :: < MIN_ALIGN > :: shrink (self , ptr , old_layout , new_layout)' (Used Types: {"MIN_ALIGN"})

--- AST Node Type: MethodCall ---
  Expressions using 'MIN_ALIGN' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'Bump :: < MIN_ALIGN > :: grow (self , ptr , old_layout , new_layout) . map (| p | unsafe { NonNull :: new_unchecked (ptr :: slice_from_raw_parts_mut (p . as_ptr () , new_layout . size ()) ,) }) . map_err (| _ | AllocError)' (Used Types: {"MIN_ALIGN"})
      - 'Bump :: < MIN_ALIGN > :: shrink (self , ptr , old_layout , new_layout) . map (| p | unsafe { NonNull :: new_unchecked (ptr :: slice_from_raw_parts_mut (p . as_ptr () , new_layout . size ()) ,) }) . map_err (| _ | AllocError)' (Used Types: {"MIN_ALIGN"})
    Depth 3: (Count: 2)
      - 'Bump :: < MIN_ALIGN > :: grow (self , ptr , old_layout , new_layout) . map (| p | unsafe { NonNull :: new_unchecked (ptr :: slice_from_raw_parts_mut (p . as_ptr () , new_layout . size ()) ,) })' (Used Types: {"MIN_ALIGN"})
      - 'Bump :: < MIN_ALIGN > :: shrink (self , ptr , old_layout , new_layout) . map (| p | unsafe { NonNull :: new_unchecked (ptr :: slice_from_raw_parts_mut (p . as_ptr () , new_layout . size ()) ,) })' (Used Types: {"MIN_ALIGN"})

--- AST Node Type: Path ---
  Expressions using 'MIN_ALIGN' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'Bump :: < MIN_ALIGN > :: dealloc' (Used Types: {"MIN_ALIGN"})
    Depth 5: (Count: 2)
      - 'Bump :: < MIN_ALIGN > :: grow' (Used Types: {"MIN_ALIGN"})
      - 'Bump :: < MIN_ALIGN > :: shrink' (Used Types: {"MIN_ALIGN"})

### Analyzing expressions using type: 'ManuallyDrop' ###

--- AST Node Type: Block ---
  Expressions using 'ManuallyDrop' with 4 other type(s):
    Depth 3: (Count: 2)
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"C", "ErrorImpl", "ContextError", "ManuallyDrop", "E"})
      - '{ let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"C", "ContextError", "ErrorImpl", "ManuallyDrop", "Error"})

--- AST Node Type: If ---
  Expressions using 'ManuallyDrop' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > () ; drop (unsafe { unerased_own . boxed () }) ; }' (Used Types: {"ErrorImpl", "ContextError", "E", "C", "ManuallyDrop"})
      - 'if TypeId :: of :: < C > () == target { let unerased_own = e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > () ; drop (unsafe { unerased_own . boxed () }) ; } else { let unerased_own = e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > () ; let unerased = unsafe { unerased_own . boxed () } ; let inner = unerased . _object . error . inner ; drop (unerased) ; let vtable = unsafe { vtable (inner . ptr) } ; unsafe { (vtable . object_drop_rest) (inner , target) } ; }' (Used Types: {"ErrorImpl", "C", "ManuallyDrop", "Error", "ContextError"})

--- AST Node Type: MethodCall ---
  Expressions using 'ManuallyDrop' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'e . cast :: < ErrorImpl < ManuallyDrop < E > > > ()' (Used Types: {"ErrorImpl", "E", "ManuallyDrop"})
  Expressions using 'ManuallyDrop' with 4 other type(s):
    Depth 3: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , E > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "C", "ContextError", "E"})
      - 'e . cast :: < ErrorImpl < ContextError < ManuallyDrop < C > , Error > > > ()' (Used Types: {"ContextError", "ManuallyDrop", "C", "Error", "ErrorImpl"})
    Depth 4: (Count: 2)
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < E > > > > ()' (Used Types: {"ContextError", "ErrorImpl", "ManuallyDrop", "E", "C"})
      - 'e . cast :: < ErrorImpl < ContextError < C , ManuallyDrop < Error > > > > ()' (Used Types: {"ManuallyDrop", "ErrorImpl", "Error", "C", "ContextError"})

### Analyzing expressions using type: 'MaxRecursionReached' ###

--- AST Node Type: Block ---
  Expressions using 'MaxRecursionReached' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'MaxRecursionReached' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'MaxRecursionReached' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'MaxRecursionReached' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'MaxRecursionReached' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'MaxRecursionReached' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'MaxRecursionReached' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

### Analyzing expressions using type: 'MaybeUninit' ###

--- AST Node Type: Block ---
  Expressions using 'MaybeUninit' with 3 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8"})
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using 'MaybeUninit' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'Vec :: < MaybeUninit < T > > :: from_raw_parts (ptr . cast () , len , cap)' (Used Types: {"T", "MaybeUninit"})
      - 'slice :: from_raw_parts (ptr as * const mem :: MaybeUninit < u8 > , len)' (Used Types: {"MaybeUninit", "* const mem :: MaybeUninit < u8 >"})
  Expressions using 'MaybeUninit' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data })' (Used Types: {"Item", "A", "* mut A :: Item", "MaybeUninit"})
  Expressions using 'MaybeUninit' with 4 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut u8", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit"})
  Expressions using 'MaybeUninit' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Cast ---
  Expressions using 'MaybeUninit' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'ptr as * const mem :: MaybeUninit < u8 >' (Used Types: {"* const mem :: MaybeUninit < u8 >", "MaybeUninit"})
  Expressions using 'MaybeUninit' with 2 other type(s):
    Depth 8: (Count: 1)
      - 'buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

--- AST Node Type: Closure ---
  Expressions using 'MaybeUninit' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "* mut u8"})
  Expressions using 'MaybeUninit' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: If ---
  Expressions using 'MaybeUninit' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})
  Expressions using 'MaybeUninit' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if len <= Self :: inline_capacity () { SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , } } else { let mut b = slice . to_vec () ; let cap = b . capacity () ; let ptr = NonNull :: new (b . as_mut_ptr ()) . expect ("Vec always contain non null pointers.") ; mem :: forget (b) ; SmallVec { capacity : cap , data : SmallVecData :: from_heap (ptr , len) , } }' (Used Types: {"MaybeUninit", "Item", "A", "* mut A :: Item"})

--- AST Node Type: MethodCall ---
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using 'MaybeUninit' with 4 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "& str"})
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using 'MaybeUninit' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Path ---
  Expressions using 'MaybeUninit' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Vec :: < MaybeUninit < T > > :: from_raw_parts' (Used Types: {"MaybeUninit", "T"})

--- AST Node Type: Reference ---
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Struct ---
  Expressions using 'MaybeUninit' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'SmallVec { capacity : len , data : SmallVecData :: from_inline (unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }) , }' (Used Types: {"MaybeUninit", "A", "* mut A :: Item", "Item"})

--- AST Node Type: Unary ---
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using 'MaybeUninit' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'unsafe { let (ptr , len) = self . raw . next () ? ; let slice = slice :: from_raw_parts (ptr as * const mem :: MaybeUninit < u8 > , len) ; Some (slice) }' (Used Types: {"* const mem :: MaybeUninit < u8 >", "MaybeUninit"})
      - 'unsafe { let ptr = vec . as_mut_ptr () ; let len = vec . len () ; let cap = vec . capacity () ; mem :: forget (vec) ; Vec :: < MaybeUninit < T > > :: from_raw_parts (ptr . cast () , len , cap) }' (Used Types: {"MaybeUninit", "T"})
  Expressions using 'MaybeUninit' with 2 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] }' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})
  Expressions using 'MaybeUninit' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'unsafe { let mut data : MaybeUninit < A > = MaybeUninit :: uninit () ; ptr :: copy_nonoverlapping (slice . as_ptr () , data . as_mut_ptr () as * mut A :: Item , len ,) ; data }' (Used Types: {"A", "Item", "* mut A :: Item", "MaybeUninit"})
  Expressions using 'MaybeUninit' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: 'MessageError' ###

--- AST Node Type: Path ---
  Expressions using 'MessageError' with 1 other type(s):
    Depth 4: (Count: 4)
      - 'object_boxed :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_drop :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_reallocate_boxed :: < MessageError < M > >' (Used Types: {"MessageError", "M"})
      - 'object_ref :: < MessageError < M > >' (Used Types: {"M", "MessageError"})

--- AST Node Type: Reference ---
  Expressions using 'MessageError' with 1 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < MessageError < M > > , object_ref : object_ref :: < MessageError < M > > , object_boxed : object_boxed :: < MessageError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < MessageError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"M", "MessageError"})

--- AST Node Type: Struct ---
  Expressions using 'MessageError' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < MessageError < M > > , object_ref : object_ref :: < MessageError < M > > , object_boxed : object_boxed :: < MessageError < M > > , object_reallocate_boxed : object_reallocate_boxed :: < MessageError < M > > , object_downcast : object_downcast :: < M > , object_drop_rest : object_drop_front :: < M > , }' (Used Types: {"MessageError", "M"})

### Analyzing expressions using type: 'NInt' ###

--- AST Node Type: Block ---
  Expressions using 'NInt' with 5 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})

### Analyzing expressions using type: 'NonZeroUsize' ###

--- AST Node Type: Call ---
  Expressions using 'NonZeroUsize' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'Ok :: < NonZeroUsize , Void > (f ())' (Used Types: {"Void", "NonZeroUsize"})

--- AST Node Type: Closure ---
  Expressions using 'NonZeroUsize' with 1 other type(s):
    Depth 4: (Count: 1)
      - '| | Ok :: < NonZeroUsize , Void > (f ())' (Used Types: {"NonZeroUsize", "Void"})

--- AST Node Type: Match ---
  Expressions using 'NonZeroUsize' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match self . get_or_try_init (| | Ok :: < NonZeroUsize , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"Void", "NonZeroUsize"})

--- AST Node Type: MethodCall ---
  Expressions using 'NonZeroUsize' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'self . get_or_try_init (| | Ok :: < NonZeroUsize , Void > (f ()))' (Used Types: {"Void", "NonZeroUsize"})

--- AST Node Type: Path ---
  Expressions using 'NonZeroUsize' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'Ok :: < NonZeroUsize , Void >' (Used Types: {"NonZeroUsize", "Void"})

### Analyzing expressions using type: 'NopLogger' ###

--- AST Node Type: If ---
  Expressions using 'NopLogger' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'if STATE . load (Ordering :: Acquire) != INITIALIZED { static NOP : NopLogger = NopLogger ; & NOP } else { unsafe { LOGGER } }' (Used Types: {"NopLogger"})

### Analyzing expressions using type: 'Null' ###

--- AST Node Type: Block ---
  Expressions using 'Null' with 4 other type(s):
    Depth 2: (Count: 2)
      - '{ # [doc = " A type which contributes nothing when adding (i.e. a zero)"] pub struct Null ; impl < T > Add < T > for Null { type Output = T ; fn add (self , rhs : T) -> Self :: Output { rhs } } impl FoldAdd for ATerm { type Output = Null ; } }' (Used Types: {"ATerm", "T", "Self", "Output", "Null"})
      - '{ # [doc = " A type which contributes nothing when multiplying (i.e. a one)"] pub struct Null ; impl < T > Mul < T > for Null { type Output = T ; fn mul (self , rhs : T) -> Self :: Output { rhs } } impl FoldMul for ATerm { type Output = Null ; } }' (Used Types: {"Self", "Null", "T", "Output", "ATerm"})

### Analyzing expressions using type: 'Ok' ###

--- AST Node Type: Block ---
  Expressions using 'Ok' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
  Expressions using 'Ok' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})

### Analyzing expressions using type: 'Option' ###

--- AST Node Type: Block ---
  Expressions using 'Option' with 6 other type(s):
    Depth 2: (Count: 8)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using 'Option' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'Option' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'Option' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Option' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Option' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Option' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Option' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})
  Expressions using 'Option' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: 'OsStr' ###

--- AST Node Type: Block ---
  Expressions using 'OsStr' with 3 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: OsStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: OsStr > , T2 : AsRef < :: std :: ffi :: OsStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: OsStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: OsStr > , T2 : AsMut < :: std :: ffi :: OsStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"T2", "T1", "Either", "OsStr"})

### Analyzing expressions using type: 'Output' ###

--- AST Node Type: Block ---
  Expressions using 'Output' with 4 other type(s):
    Depth 2: (Count: 2)
      - '{ # [doc = " A type which contributes nothing when adding (i.e. a zero)"] pub struct Null ; impl < T > Add < T > for Null { type Output = T ; fn add (self , rhs : T) -> Self :: Output { rhs } } impl FoldAdd for ATerm { type Output = Null ; } }' (Used Types: {"ATerm", "T", "Self", "Output", "Null"})
      - '{ # [doc = " A type which contributes nothing when multiplying (i.e. a one)"] pub struct Null ; impl < T > Mul < T > for Null { type Output = T ; fn mul (self , rhs : T) -> Self :: Output { rhs } } impl FoldMul for ATerm { type Output = Null ; } }' (Used Types: {"Self", "Null", "T", "Output", "ATerm"})

### Analyzing expressions using type: 'PInt' ###

--- AST Node Type: Block ---
  Expressions using 'PInt' with 5 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})

--- AST Node Type: Call ---
  Expressions using 'PInt' with 1 other type(s):
    Depth 3: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi (self , PInt :: new ())' (Used Types: {"U", "PInt"})
      - '< f64 as Pow < PInt < U > > > :: powi (self , PInt :: new ())' (Used Types: {"PInt", "U"})

--- AST Node Type: MethodCall ---
  Expressions using 'PInt' with 1 other type(s):
    Depth 2: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi (self , PInt :: new ()) . recip ()' (Used Types: {"U", "PInt"})
      - '< f64 as Pow < PInt < U > > > :: powi (self , PInt :: new ()) . recip ()' (Used Types: {"U", "PInt"})

--- AST Node Type: Path ---
  Expressions using 'PInt' with 1 other type(s):
    Depth 4: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi' (Used Types: {"PInt", "U"})
      - '< f64 as Pow < PInt < U > > > :: powi' (Used Types: {"PInt", "U"})

### Analyzing expressions using type: 'Path' ###

--- AST Node Type: Block ---
  Expressions using 'Path' with 3 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < :: std :: path :: Path > > () { } fn propagate_ref < T1 : AsRef < :: std :: path :: Path > , T2 : AsRef < :: std :: path :: Path > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: path :: Path > > () { } fn propagate_mut < T1 : AsMut < :: std :: path :: Path > , T2 : AsMut < :: std :: path :: Path > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Path", "T2", "Either", "T1"})

### Analyzing expressions using type: 'PathBuf' ###

--- AST Node Type: If ---
  Expressions using 'PathBuf' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'if config . contains (& DirEntryAttr :: DosPath) { let mut result_path : PathBuf ; match path . canonicalize () { Ok (new_path) => { result_path = new_path ; } Err (_) => { if let Some (parent_path) = path . parent () { if let Some (name) = path . file_name () { result_path = parent_path . canonicalize () ? ; result_path . push (name) ; } else { return Err (Error :: new (ErrorKind :: Other , "Error get part name path") ,) ; } } else { return Err (Error :: new (ErrorKind :: Other , "Error get parent path") ,) ; } } } let path = result_path . as_os_str () . to_os_string () . into_string () ? ; item . insert (DirEntryAttr :: DosPath , DirEntryValue :: String (path)) ; }' (Used Types: {"PathBuf"})
      - 'if config . contains (& DirEntryAttr :: Path) { let mut result_path : PathBuf ; match path . canonicalize () { Ok (new_path) => { result_path = new_path ; } Err (_) => { if let Some (parent_path) = path . parent () { if let Some (name) = path . file_name () { result_path = parent_path . canonicalize () ? ; result_path . push (name) ; } else { return Err (Error :: new (ErrorKind :: Other , "Error get part name path") ,) ; } } else { return Err (Error :: new (ErrorKind :: Other , "Error get parent path") ,) ; } } } let mut path = result_path . as_os_str () . to_os_string () . into_string () ? ; if path . find ("\\\\?\\") == Some (0) { path = path [4 ..] . to_string () ; } item . insert (DirEntryAttr :: Path , DirEntryValue :: String (path)) ; }' (Used Types: {"PathBuf"})

### Analyzing expressions using type: 'PhantomData' ###

--- AST Node Type: Block ---
  Expressions using 'PhantomData' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'PhantomData' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: If ---
  Expressions using 'PhantomData' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

### Analyzing expressions using type: 'Port' ###

--- AST Node Type: If ---
  Expressions using 'Port' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . required_libs . is_empty () { let ports = match load_ports (& vcpkg_target) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } } ; if ports . get (& port_name . to_owned ()) . is_none () { return Err (Error :: LibNotFound (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("package {0} is not installed for vcpkg triplet {1}" , port_name . to_owned () , vcpkg_target . target_triplet . triplet ,) ,) }) ,) ,) ; } let mut required_ports : BTreeMap < String , Port > = BTreeMap :: new () ; let mut ports_to_scan = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,) ; while ! ports_to_scan . is_empty () { let port_name = ports_to_scan . pop () . unwrap () ; if required_ports . contains_key (& port_name) { continue ; } if let Some (port) = ports . get (& port_name) { for dep in & port . deps { ports_to_scan . push (dep . clone ()) ; } required_ports . insert (port_name . clone () , (* port) . clone ()) ; remove_item (& mut required_port_order , & port_name) ; required_port_order . push (port_name) ; } else { } } if self . required_libs . is_empty () { for port_name in & required_port_order { let port = required_ports . get (port_name) . unwrap () ; self . required_libs . extend (port . libs . iter () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; self . required_dlls . extend (port . dlls . iter () . cloned () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; } } }' (Used Types: {"[_]", "Port", "_", "BTreeMap"})

### Analyzing expressions using type: 'Position' ###

--- AST Node Type: Array ---
  Expressions using 'Position' with 0 other type(s):
    Depth 9: (Count: 1)
      - '[< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Position"})

--- AST Node Type: Block ---
  Expressions using 'Position' with 10 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
  Expressions using 'Position' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})

--- AST Node Type: Call ---
  Expressions using 'Position' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Position"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Position"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Position"})

--- AST Node Type: Closure ---
  Expressions using 'Position' with 0 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Position"})

--- AST Node Type: Reference ---
  Expressions using 'Position' with 0 other type(s):
    Depth 8: (Count: 1)
      - '& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Position"})

--- AST Node Type: Unknown ---
  Expressions using 'Position' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Position"})

### Analyzing expressions using type: 'Prestat' ###

--- AST Node Type: Call ---
  Expressions using 'Prestat' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Prestat > :: uninit ()' (Used Types: {"Prestat"})
  Expressions using 'Prestat' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat))' (Used Types: {"Prestat", "* const Prestat"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat)' (Used Types: {"Prestat", "* const Prestat"})

--- AST Node Type: Cast ---
  Expressions using 'Prestat' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Prestat' (Used Types: {"* const Prestat", "Prestat"})

--- AST Node Type: Match ---
  Expressions using 'Prestat' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Prestat)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"* const Prestat", "Prestat"})

--- AST Node Type: Path ---
  Expressions using 'Prestat' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Prestat > :: uninit' (Used Types: {"Prestat"})

### Analyzing expressions using type: 'PropertiesI' ###

--- AST Node Type: Call ---
  Expressions using 'PropertiesI' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'core :: mem :: size_of :: < PropertiesI > ()' (Used Types: {"PropertiesI"})

--- AST Node Type: Path ---
  Expressions using 'PropertiesI' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: size_of :: < PropertiesI >' (Used Types: {"PropertiesI"})

### Analyzing expressions using type: 'Q' ###

--- AST Node Type: Assign ---
  Expressions using 'Q' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'hashes [i] = make_hash :: < Q , S > (& self . hash_builder , ks [i])' (Used Types: {"Q", "S"})

--- AST Node Type: Call ---
  Expressions using 'Q' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'make_hash :: < Q , S > (& self . hash_builder , k)' (Used Types: {"S", "Q"})
      - 'make_hash :: < Q , S > (& self . hash_builder , key)' (Used Types: {"Q", "S"})
      - 'make_hash :: < Q , S > (& self . map . hash_builder , k)' (Used Types: {"S", "Q"})
    Depth 3: (Count: 1)
      - 'make_hash :: < Q , S > (hash_builder , & val . 0)' (Used Types: {"S", "Q"})
    Depth 4: (Count: 1)
      - 'make_hash :: < Q , S > (& self . hash_builder , ks [i])' (Used Types: {"S", "Q"})

--- AST Node Type: Closure ---
  Expressions using 'Q' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'move | val | make_hash :: < Q , S > (hash_builder , & val . 0)' (Used Types: {"Q", "S"})

--- AST Node Type: ForLoop ---
  Expressions using 'Q' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'for i in 0 .. N { hashes [i] = make_hash :: < Q , S > (& self . hash_builder , ks [i]) ; }' (Used Types: {"Q", "S"})

--- AST Node Type: If ---
  Expressions using 'Q' with 1 other type(s):
    Depth 2: (Count: 5)
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get (hash , equivalent_key (k)) { Some ((_ , v)) => Some (v) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get (hash , equivalent_key (k)) { Some ((key , value)) => Some ((key , value)) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get_mut (hash , equivalent_key (k)) { Some (& mut (_ , ref mut v)) => Some (v) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get_mut (hash , equivalent_key (k)) { Some (& mut (ref key , ref mut value)) => Some ((key , value)) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; self . table . get (hash , equivalent_key (k)) . is_some () } else { false }' (Used Types: {"Q", "S"})

--- AST Node Type: Path ---
  Expressions using 'Q' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'make_hash :: < Q , S >' (Used Types: {"S", "Q"})

### Analyzing expressions using type: 'QuoteError' ###

--- AST Node Type: Call ---
  Expressions using 'QuoteError' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ') ,)' (Used Types: {"Result", "[u8]", "Cow", "Vec", "QuoteError"})

--- AST Node Type: MethodCall ---
  Expressions using 'QuoteError' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ')' (Used Types: {"QuoteError", "Cow", "Vec", "Result", "[u8]"})
    Depth 5: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > ()' (Used Types: {"QuoteError", "[u8]", "Cow", "Result", "Vec"})

--- AST Node Type: Unknown ---
  Expressions using 'QuoteError' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ?' (Used Types: {"Vec", "Result", "QuoteError", "Cow", "[u8]"})

### Analyzing expressions using type: 'R' ###

--- AST Node Type: Block ---
  Expressions using 'R' with 0 other type(s):
    Depth 6: (Count: 1)
      - '{ _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) }' (Used Types: {"R"})
  Expressions using 'R' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'R' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'R' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})

--- AST Node Type: Call ---
  Expressions using 'R' with 0 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,)' (Used Types: {"R"})
    Depth 7: (Count: 2)
      - '< R as _serde :: Deserialize > :: deserialize (__deserializer)' (Used Types: {"R"})
      - '_serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,)' (Used Types: {"R"})
    Depth 8: (Count: 1)
      - '_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant)' (Used Types: {"R"})
  Expressions using 'R' with 2 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,)' (Used Types: {"Either", "L", "R"})

--- AST Node Type: If ---
  Expressions using 'R' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; }' (Used Types: {"R"})

--- AST Node Type: Let ---
  Expressions using 'R' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,)' (Used Types: {"R"})

--- AST Node Type: Match ---
  Expressions using 'R' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } }' (Used Types: {"R", "L"})

--- AST Node Type: Path ---
  Expressions using 'R' with 0 other type(s):
    Depth 8: (Count: 1)
      - '< R as _serde :: Deserialize > :: deserialize' (Used Types: {"R"})
    Depth 9: (Count: 1)
      - '_serde :: de :: VariantAccess :: newtype_variant :: < R >' (Used Types: {"R"})
  Expressions using 'R' with 2 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: __private :: PhantomData :: < Either < L , R > >' (Used Types: {"L", "Either", "R"})

--- AST Node Type: Struct ---
  Expressions using 'R' with 2 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , }' (Used Types: {"Either", "R", "L"})

### Analyzing expressions using type: 'Repetition' ###

--- AST Node Type: Block ---
  Expressions using 'Repetition' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Repetition' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Repetition' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Repetition' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Repetition' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'Repetition' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'RepetitionKind' ###

--- AST Node Type: Array ---
  Expressions using 'RepetitionKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "RepetitionKind"})

--- AST Node Type: Block ---
  Expressions using 'RepetitionKind' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
  Expressions using 'RepetitionKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})

--- AST Node Type: Call ---
  Expressions using 'RepetitionKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "RepetitionKind"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "RepetitionKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"RepetitionKind", "Span"})

--- AST Node Type: Closure ---
  Expressions using 'RepetitionKind' with 1 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "RepetitionKind"})

--- AST Node Type: Reference ---
  Expressions using 'RepetitionKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"RepetitionKind", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'RepetitionKind' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"RepetitionKind"})

### Analyzing expressions using type: 'RepetitionOp' ###

--- AST Node Type: Array ---
  Expressions using 'RepetitionOp' with 3 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Box", "Ast", "Span"})

--- AST Node Type: Block ---
  Expressions using 'RepetitionOp' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
  Expressions using 'RepetitionOp' with 14 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})

--- AST Node Type: Call ---
  Expressions using 'RepetitionOp' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Box", "RepetitionOp", "Ast"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"RepetitionOp", "Box", "Span", "Ast"})

--- AST Node Type: Closure ---
  Expressions using 'RepetitionOp' with 3 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "RepetitionOp", "Ast", "Span"})

--- AST Node Type: Reference ---
  Expressions using 'RepetitionOp' with 3 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'RepetitionOp' with 0 other type(s):
    Depth 10: (Count: 1)
      - '< RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ?' (Used Types: {"RepetitionOp"})

### Analyzing expressions using type: 'RepetitionRange' ###

--- AST Node Type: Block ---
  Expressions using 'RepetitionRange' with 0 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"RepetitionRange"})
  Expressions using 'RepetitionRange' with 10 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'RepetitionRange' with 11 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})

--- AST Node Type: Call ---
  Expressions using 'RepetitionRange' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"RepetitionRange"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"RepetitionRange"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"RepetitionRange"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"RepetitionRange"})

--- AST Node Type: Closure ---
  Expressions using 'RepetitionRange' with 0 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"RepetitionRange"})

--- AST Node Type: Unknown ---
  Expressions using 'RepetitionRange' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"RepetitionRange"})

### Analyzing expressions using type: 'Result' ###

--- AST Node Type: Block ---
  Expressions using 'Result' with 1 other type(s):
    Depth 4: (Count: 2)
      - '{ let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - '{ let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
  Expressions using 'Result' with 6 other type(s):
    Depth 2: (Count: 9)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using 'Result' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'Result' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'Result' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'Result' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'Result' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Result' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Result' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Result' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Result' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})
  Expressions using 'Result' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'Result' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Result' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ') ,)' (Used Types: {"Result", "[u8]", "Cow", "Vec", "QuoteError"})

--- AST Node Type: ForLoop ---
  Expressions using 'Result' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'for file in dir_content . files { let to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; let mut result_copy : Result < u64 > ; let mut work = true ; while work { result_copy = super :: file :: copy (& file , & path , & file_options) ; match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } }' (Used Types: {"Result"})
      - 'for file in dir_content . files { let to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; let mut result_copy : Result < u64 > ; let mut work = true ; while work { { result_copy = super :: file :: move_file (& file , & path , & file_options) ; match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } }' (Used Types: {"Result"})
  Expressions using 'Result' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'for file in dir_content . files { let mut to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_name = path . file_name () ; if file_name . is_none () { return Err (Error :: new (ErrorKind :: Other , "No file name")) ; } let file_name = file_name . unwrap () ; to . push (file_name) ; let mut file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = Path :: new (& file) . metadata () ? . len () ; let mut result_copy : Result < u64 > ; let mut work = true ; let copied_bytes = result ; while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: copy_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for file in dir_content . files { let mut to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_name = path . file_name () ; if file_name . is_none () { return Err (Error :: new (ErrorKind :: Other , "No file name")) ; } let file_name = file_name . unwrap () ; to . push (file_name) ; let mut file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = Path :: new (& file) . metadata () ? . len () ; let mut result_copy : Result < u64 > ; let mut work = true ; let copied_bytes = result ; while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: move_file_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { is_remove = false ; file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for item in list_paths { if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: copy_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for item in list_paths { if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: move_dir_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } } }' (Used Types: {"TransitProcess", "Result"})

--- AST Node Type: If ---
  Expressions using 'Result' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: copy_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"Result", "TransitProcess"})
      - 'if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: move_dir_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
  Expressions using 'Result' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: Match ---
  Expressions using 'Result' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'match paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) }) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } }' (Used Types: {"Vec", "Result", "_"})

--- AST Node Type: MethodCall ---
  Expressions using 'Result' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'iter . into_iter () . map (| x | x . ok_or (())) . collect_in :: < Result < _ , _ > > (alloc) . ok ()' (Used Types: {"_", "Result"})
    Depth 3: (Count: 1)
      - 'iter . into_iter () . map (| x | x . ok_or (())) . collect_in :: < Result < _ , _ > > (alloc)' (Used Types: {"Result", "_"})
  Expressions using 'Result' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) })' (Used Types: {"Result", "_", "Vec"})
    Depth 4: (Count: 1)
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > ()' (Used Types: {"Result", "Vec", "_"})
  Expressions using 'Result' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ')' (Used Types: {"QuoteError", "Cow", "Vec", "Result", "[u8]"})
    Depth 5: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > ()' (Used Types: {"QuoteError", "[u8]", "Cow", "Result", "Vec"})

--- AST Node Type: Unknown ---
  Expressions using 'Result' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ?' (Used Types: {"Vec", "Result", "QuoteError", "Cow", "[u8]"})

### Analyzing expressions using type: 'Rng' ###

--- AST Node Type: Block ---
  Expressions using 'Rng' with 3 other type(s):
    Depth 7: (Count: 1)
      - '{ | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"!", "LazyStorage", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Rng", "()", "LazyStorage", "Cell"})
    Depth 9: (Count: 1)
      - '{ # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"!", "Rng", "Cell", "LazyStorage"})
  Expressions using 'Rng' with 4 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline] fn __init () -> Cell < Rng > { Cell :: new (Rng (random_seed () . unwrap_or (DEFAULT_RNG_SEED))) } unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) } }' (Used Types: {"LazyStorage", "()", "Rng", "!", "Cell"})

--- AST Node Type: Call ---
  Expressions using 'Rng' with 1 other type(s):
    Depth 7: (Count: 1)
      - ':: std :: mem :: needs_drop :: < Cell < Rng > > ()' (Used Types: {"Rng", "Cell"})
  Expressions using 'Rng' with 4 other type(s):
    Depth 4: (Count: 1)
      - ':: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } })' (Used Types: {"Cell", "()", "!", "LazyStorage", "Rng"})

--- AST Node Type: Closure ---
  Expressions using 'Rng' with 3 other type(s):
    Depth 7: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"LazyStorage", "()", "Rng", "Cell"})
    Depth 8: (Count: 1)
      - '| init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) }' (Used Types: {"Cell", "!", "LazyStorage", "Rng"})

--- AST Node Type: If ---
  Expressions using 'Rng' with 4 other type(s):
    Depth 6: (Count: 1)
      - 'if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } }' (Used Types: {"()", "LazyStorage", "Rng", "!", "Cell"})

--- AST Node Type: Path ---
  Expressions using 'Rng' with 1 other type(s):
    Depth 8: (Count: 1)
      - ':: std :: mem :: needs_drop :: < Cell < Rng > >' (Used Types: {"Rng", "Cell"})

--- AST Node Type: Unknown ---
  Expressions using 'Rng' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }' (Used Types: {"Cell", "Rng", "()", "LazyStorage", "!"})

--- AST Node Type: Unsafe ---
  Expressions using 'Rng' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < Cell < Rng > > () { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , () , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } else { | init | { # [thread_local] static VAL : :: std :: thread :: local_impl :: LazyStorage < Cell < Rng > , ! , > = :: std :: thread :: local_impl :: LazyStorage :: new () ; VAL . get_or_init (init , __init) } } }) }' (Used Types: {"!", "LazyStorage", "Rng", "()", "Cell"})

### Analyzing expressions using type: 'Roflags' ###

--- AST Node Type: Block ---
  Expressions using 'Roflags' with 3 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) }' (Used Types: {"Roflags", "Size", "* const Size", "* const Roflags"})

--- AST Node Type: Call ---
  Expressions using 'Roflags' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Roflags > :: uninit ()' (Used Types: {"Roflags"})
  Expressions using 'Roflags' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags)' (Used Types: {"* const Roflags", "Roflags"})
  Expressions using 'Roflags' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,))' (Used Types: {"Size", "* const Roflags", "Roflags", "* const Size"})

--- AST Node Type: Cast ---
  Expressions using 'Roflags' with 1 other type(s):
    Depth 7: (Count: 1)
      - 'rp1 . as_mut_ptr () as i32 as * const Roflags' (Used Types: {"Roflags", "* const Roflags"})

--- AST Node Type: Match ---
  Expressions using 'Roflags' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Roflags", "* const Roflags", "* const Size", "Size"})

--- AST Node Type: Path ---
  Expressions using 'Roflags' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Roflags > :: uninit' (Used Types: {"Roflags"})

--- AST Node Type: Tuple ---
  Expressions using 'Roflags' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)' (Used Types: {"* const Roflags", "* const Size", "Roflags", "Size"})

### Analyzing expressions using type: 'RowId' ###

--- AST Node Type: Call ---
  Expressions using 'RowId' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'HybridGrowingHashmapChar :: < RowId > :: default ()' (Used Types: {"RowId"})

--- AST Node Type: Path ---
  Expressions using 'RowId' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'HybridGrowingHashmapChar :: < RowId > :: default' (Used Types: {"RowId"})

### Analyzing expressions using type: 'S' ###

--- AST Node Type: Assign ---
  Expressions using 'S' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'hashes [i] = make_hash :: < Q , S > (& self . hash_builder , ks [i])' (Used Types: {"Q", "S"})

--- AST Node Type: Call ---
  Expressions using 'S' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'test_extend :: < S > ()' (Used Types: {"S"})
  Expressions using 'S' with 1 other type(s):
    Depth 2: (Count: 6)
      - 'make_hash :: < K , S > (& self . hash_builder , & k)' (Used Types: {"S", "K"})
      - 'make_hash :: < K , S > (& self . hash_builder , & key)' (Used Types: {"K", "S"})
      - 'make_hash :: < K , S > (self . hash_builder , & key)' (Used Types: {"K", "S"})
      - 'make_hash :: < Q , S > (& self . hash_builder , k)' (Used Types: {"S", "Q"})
      - 'make_hash :: < Q , S > (& self . hash_builder , key)' (Used Types: {"Q", "S"})
      - 'make_hash :: < Q , S > (& self . map . hash_builder , k)' (Used Types: {"S", "Q"})
    Depth 3: (Count: 1)
      - 'make_hash :: < Q , S > (hash_builder , & val . 0)' (Used Types: {"S", "Q"})
    Depth 4: (Count: 1)
      - 'make_hash :: < Q , S > (& self . hash_builder , ks [i])' (Used Types: {"S", "Q"})
  Expressions using 'S' with 2 other type(s):
    Depth 3: (Count: 3)
      - 'make_hasher :: < _ , V , S > (& self . hash_builder)' (Used Types: {"V", "S", "_"})
      - 'make_hasher :: < _ , V , S > (& self . table . hash_builder)' (Used Types: {"_", "S", "V"})
      - 'make_hasher :: < _ , V , S > (self . hash_builder)' (Used Types: {"_", "V", "S"})

--- AST Node Type: Closure ---
  Expressions using 'S' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'move | val | make_hash :: < Q , S > (hash_builder , & val . 0)' (Used Types: {"Q", "S"})

--- AST Node Type: ForLoop ---
  Expressions using 'S' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'for i in 0 .. N { hashes [i] = make_hash :: < Q , S > (& self . hash_builder , ks [i]) ; }' (Used Types: {"Q", "S"})

--- AST Node Type: If ---
  Expressions using 'S' with 1 other type(s):
    Depth 2: (Count: 5)
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get (hash , equivalent_key (k)) { Some ((_ , v)) => Some (v) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get (hash , equivalent_key (k)) { Some ((key , value)) => Some ((key , value)) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get_mut (hash , equivalent_key (k)) { Some (& mut (_ , ref mut v)) => Some (v) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; match self . table . get_mut (hash , equivalent_key (k)) { Some (& mut (ref key , ref mut value)) => Some ((key , value)) , None => None , } } else { None }' (Used Types: {"Q", "S"})
      - 'if ! self . table . is_empty () { let hash = make_hash :: < Q , S > (& self . hash_builder , k) ; self . table . get (hash , equivalent_key (k)) . is_some () } else { false }' (Used Types: {"Q", "S"})

--- AST Node Type: MethodCall ---
  Expressions using 'S' with 2 other type(s):
    Depth 2: (Count: 11)
      - 'self . table . insert (hash , (k , v) , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"S", "V", "_"})
      - 'self . table . insert (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder))' (Used Types: {"S", "_", "V"})
      - 'self . table . insert_entry (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder) ,)' (Used Types: {"_", "V", "S"})
      - 'self . table . reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'self . table . shrink_to (0 , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "_", "S"})
      - 'self . table . shrink_to (min_capacity , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "S", "_"})
      - 'self . table . table . insert (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'self . table . table . insert (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"V", "S", "_"})
      - 'self . table . try_reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'table . insert_entry (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'table . insert_entry (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})

--- AST Node Type: Path ---
  Expressions using 'S' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'test_extend :: < S >' (Used Types: {"S"})
  Expressions using 'S' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'make_hash :: < K , S >' (Used Types: {"K", "S"})
      - 'make_hash :: < Q , S >' (Used Types: {"S", "Q"})
  Expressions using 'S' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'make_hasher :: < _ , V , S >' (Used Types: {"_", "V", "S"})

### Analyzing expressions using type: 'Self' ###

--- AST Node Type: Async ---
  Expressions using 'Self' with 1 other type(s):
    Depth 1: (Count: 1)
      - 'async { match WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await { Ok (results) => results , Err (_) => { :: core :: panicking :: panic_fmt (format_args ! ("internal error: entered unreachable code: {0}" , format_args ! ("cancellation is not exposed API-wise, should not be possible" ,) ,) ,) ; } } }' (Used Types: {"Self", "SubtaskOps"})

--- AST Node Type: Await ---
  Expressions using 'Self' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Binary ---
  Expressions using 'Self' with 0 other type(s):
    Depth 1: (Count: 1)
      - 'mem :: size_of :: < Self > () == 0' (Used Types: {"Self"})

--- AST Node Type: Block ---
  Expressions using 'Self' with 2 other type(s):
    Depth 2: (Count: 8)
      - '{ impl :: scale_info :: TypeInfo for ATerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("ATerm" , "typenum::array")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for type arrays."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "ATerm"})
      - '{ impl :: scale_info :: TypeInfo for B0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B0" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"B0", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for B1 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B1" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 1."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "B1"})
      - '{ impl :: scale_info :: TypeInfo for Equal { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Equal" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Equal`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Equal", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for Greater { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Greater" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Greater`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "Greater"})
      - '{ impl :: scale_info :: TypeInfo for Less { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Less" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Less`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Less"})
      - '{ impl :: scale_info :: TypeInfo for UTerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UTerm" , "typenum::uint")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for `UInt`; it always comes after the most significant" , "bit. `UTerm` by itself represents zero, which is aliased to `U0`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"UTerm", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for Z0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Z0" , "typenum::int")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level signed integer 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Z0"})
  Expressions using 'Self' with 4 other type(s):
    Depth 2: (Count: 2)
      - '{ # [doc = " A type which contributes nothing when adding (i.e. a zero)"] pub struct Null ; impl < T > Add < T > for Null { type Output = T ; fn add (self , rhs : T) -> Self :: Output { rhs } } impl FoldAdd for ATerm { type Output = Null ; } }' (Used Types: {"ATerm", "T", "Self", "Output", "Null"})
      - '{ # [doc = " A type which contributes nothing when multiplying (i.e. a one)"] pub struct Null ; impl < T > Mul < T > for Null { type Output = T ; fn mul (self , rhs : T) -> Self :: Output { rhs } } impl FoldMul for ATerm { type Output = Null ; } }' (Used Types: {"Self", "Null", "T", "Output", "ATerm"})
  Expressions using 'Self' with 5 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})
  Expressions using 'Self' with 6 other type(s):
    Depth 2: (Count: 11)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})
  Expressions using 'Self' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using 'Self' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})
  Expressions using 'Self' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'Self' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'Self' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Self' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Self' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Self' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Self' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})
  Expressions using 'Self' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'Self' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Self' with 0 other type(s):
    Depth 1: (Count: 1)
      - 'mem :: needs_drop :: < Self > ()' (Used Types: {"Self"})
    Depth 2: (Count: 4)
      - '(move | | -> Self { Buffer :: new () }) ()' (Used Types: {"Self"})
      - '(move | | -> Self { let bytes = [MaybeUninit :: < u8 > :: uninit () ; 24] ; Buffer { bytes } }) ()' (Used Types: {"Self"})
      - 'core :: any :: type_name :: < Self > ()' (Used Types: {"Self"})
      - 'mem :: size_of :: < Self > ()' (Used Types: {"Self"})
    Depth 7: (Count: 1)
      - 'mem :: align_of :: < Self > ()' (Used Types: {"Self"})
  Expressions using 'Self' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params })' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Cast ---
  Expressions using 'Self' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'ptr as * mut Self' (Used Types: {"* mut Self", "Self"})
    Depth 7: (Count: 1)
      - 'self as * const Self' (Used Types: {"Self", "* const Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 6: (Count: 4)
      - 'self as * const Self as * const AtomicUsize' (Used Types: {"Self", "* const AtomicUsize", "* const Self", "AtomicUsize"})
      - 'self as * const Self as * const crate :: AtomicU32' (Used Types: {"Self", "AtomicU32", "* const Self", "* const crate :: AtomicU32"})
      - 'self as * const Self as * const crate :: AtomicU64' (Used Types: {"Self", "* const Self", "AtomicU64", "* const crate :: AtomicU64"})
      - 'self as * const Self as * const imp :: AtomicU8' (Used Types: {"AtomicU8", "* const Self", "* const imp :: AtomicU8", "Self"})
    Depth 7: (Count: 10)
      - 'self as * const Self as * const UnsafeCell < i16 >' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i32 >' (Used Types: {"* const UnsafeCell < i32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i64 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i64 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < i8 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i8 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < isize >' (Used Types: {"* const UnsafeCell < isize >", "UnsafeCell", "* const Self", "Self"})
      - 'self as * const Self as * const UnsafeCell < u16 >' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < u16 >"})
      - 'self as * const Self as * const UnsafeCell < u32 >' (Used Types: {"* const UnsafeCell < u32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u64 >' (Used Types: {"* const UnsafeCell < u64 >", "Self", "* const Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u8 >' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u8 >"})
      - 'self as * const Self as * const UnsafeCell < usize >' (Used Types: {"* const UnsafeCell < usize >", "UnsafeCell", "* const Self", "Self"})
  Expressions using 'Self' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: Closure ---
  Expressions using 'Self' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'move | | -> Self { Buffer :: new () }' (Used Types: {"Self"})
      - 'move | | -> Self { let bytes = [MaybeUninit :: < u8 > :: uninit () ; 24] ; Buffer { bytes } }' (Used Types: {"Self"})

--- AST Node Type: If ---
  Expressions using 'Self' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'if true { match (& ptr . align_offset (mem :: align_of :: < Self > ()) , & 0) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; }' (Used Types: {"Self"})
  Expressions using 'Self' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: Match ---
  Expressions using 'Self' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'match (& ptr . align_offset (mem :: align_of :: < Self > ()) , & 0) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } }' (Used Types: {"Self"})
  Expressions using 'Self' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await { Ok (results) => results , Err (_) => { :: core :: panicking :: panic_fmt (format_args ! ("internal error: entered unreachable code: {0}" , format_args ! ("cancellation is not exposed API-wise, should not be possible" ,) ,) ,) ; } }' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: MethodCall ---
  Expressions using 'Self' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'ptr . align_offset (mem :: align_of :: < Self > ())' (Used Types: {"Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 3: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >)) . get ()' (Used Types: {"* const UnsafeCell < i16 >", "UnsafeCell", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >)) . get ()' (Used Types: {"* const Self", "* const UnsafeCell < i32 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >)) . get ()' (Used Types: {"* const UnsafeCell < i8 >", "Self", "* const Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >)) . get ()' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >)) . get ()' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >)) . get ()' (Used Types: {"UnsafeCell", "* const UnsafeCell < u64 >", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >)) . get ()' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u8 >"})
      - '(* (self as * const Self as * const UnsafeCell < usize >)) . get ()' (Used Types: {"Self", "* const UnsafeCell < usize >", "UnsafeCell", "* const Self"})
  Expressions using 'Self' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using 'Self' with 0 other type(s):
    Depth 3: (Count: 2)
      - '(move | | -> Self { Buffer :: new () })' (Used Types: {"Self"})
      - '(move | | -> Self { let bytes = [MaybeUninit :: < u8 > :: uninit () ; 24] ; Buffer { bytes } })' (Used Types: {"Self"})
  Expressions using 'Self' with 1 other type(s):
    Depth 5: (Count: 1)
      - '(ptr as * mut Self)' (Used Types: {"Self", "* mut Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 4: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >))' (Used Types: {"* const Self", "* const UnsafeCell < i16 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >))' (Used Types: {"UnsafeCell", "Self", "* const UnsafeCell < i32 >", "* const Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >))' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i64 >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >))' (Used Types: {"* const UnsafeCell < i8 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >))' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < isize >"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >))' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >))' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >))' (Used Types: {"* const UnsafeCell < u64 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >))' (Used Types: {"* const Self", "* const UnsafeCell < u8 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < usize >))' (Used Types: {"* const Self", "* const UnsafeCell < usize >", "UnsafeCell", "Self"})
    Depth 5: (Count: 4)
      - '(self as * const Self as * const AtomicUsize)' (Used Types: {"AtomicUsize", "* const Self", "Self", "* const AtomicUsize"})
      - '(self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "Self", "AtomicU32", "* const crate :: AtomicU32"})
      - '(self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "* const crate :: AtomicU64", "Self", "AtomicU64"})
      - '(self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})
    Depth 6: (Count: 10)
      - '(self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < i16 >"})
      - '(self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i32 >", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i8 >"})
      - '(self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"* const Self", "* const UnsafeCell < isize >", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"* const UnsafeCell < u32 >", "UnsafeCell", "* const Self", "Self"})
      - '(self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '(self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const Self", "UnsafeCell", "* const UnsafeCell < u8 >", "Self"})
      - '(self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"* const UnsafeCell < usize >", "Self", "* const Self", "UnsafeCell"})
  Expressions using 'Self' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Path ---
  Expressions using 'Self' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: needs_drop :: < Self >' (Used Types: {"Self"})
    Depth 3: (Count: 2)
      - 'core :: any :: type_name :: < Self >' (Used Types: {"Self"})
      - 'mem :: size_of :: < Self >' (Used Types: {"Self"})
    Depth 8: (Count: 1)
      - 'mem :: align_of :: < Self >' (Used Types: {"Self"})
  Expressions using 'Self' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Reference ---
  Expressions using 'Self' with 0 other type(s):
    Depth 5: (Count: 1)
      - '& ptr . align_offset (mem :: align_of :: < Self > ())' (Used Types: {"Self"})
  Expressions using 'Self' with 1 other type(s):
    Depth 3: (Count: 1)
      - '& * (ptr as * mut Self)' (Used Types: {"* mut Self", "Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 3: (Count: 4)
      - '& * (self as * const Self as * const AtomicUsize)' (Used Types: {"* const AtomicUsize", "* const Self", "Self", "AtomicUsize"})
      - '& * (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"* const Self", "* const crate :: AtomicU32", "Self", "AtomicU32"})
      - '& * (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"Self", "AtomicU64", "* const crate :: AtomicU64", "* const Self"})
      - '& * (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"Self", "* const imp :: AtomicU8", "* const Self", "AtomicU8"})

--- AST Node Type: Tuple ---
  Expressions using 'Self' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(& ptr . align_offset (mem :: align_of :: < Self > ()) , & 0)' (Used Types: {"Self"})

--- AST Node Type: Unary ---
  Expressions using 'Self' with 1 other type(s):
    Depth 4: (Count: 1)
      - '* (ptr as * mut Self)' (Used Types: {"Self", "* mut Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 4: (Count: 4)
      - '* (self as * const Self as * const AtomicUsize)' (Used Types: {"Self", "* const Self", "* const AtomicUsize", "AtomicUsize"})
      - '* (self as * const Self as * const crate :: AtomicU32)' (Used Types: {"AtomicU32", "Self", "* const Self", "* const crate :: AtomicU32"})
      - '* (self as * const Self as * const crate :: AtomicU64)' (Used Types: {"* const Self", "AtomicU64", "* const crate :: AtomicU64", "Self"})
      - '* (self as * const Self as * const imp :: AtomicU8)' (Used Types: {"* const imp :: AtomicU8", "* const Self", "AtomicU8", "Self"})
    Depth 5: (Count: 10)
      - '* (self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"Self", "* const UnsafeCell < i16 >", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"* const UnsafeCell < i64 >", "Self", "* const Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i8 >", "* const Self", "Self"})
      - '* (self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"UnsafeCell", "* const Self", "* const UnsafeCell < isize >", "Self"})
      - '* (self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '* (self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '* (self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const UnsafeCell < u8 >", "Self", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < usize >"})
  Expressions using 'Self' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using 'Self' with 1 other type(s):
    Depth 2: (Count: 1)
      - '# [allow (clippy :: cast_ptr_alignment)] unsafe { & * (ptr as * mut Self) }' (Used Types: {"Self", "* mut Self"})
  Expressions using 'Self' with 3 other type(s):
    Depth 2: (Count: 14)
      - 'unsafe { & * (self as * const Self as * const AtomicUsize) }' (Used Types: {"* const Self", "Self", "* const AtomicUsize", "AtomicUsize"})
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU32) }' (Used Types: {"* const Self", "AtomicU32", "* const crate :: AtomicU32", "Self"})
      - 'unsafe { & * (self as * const Self as * const crate :: AtomicU64) }' (Used Types: {"* const Self", "AtomicU64", "Self", "* const crate :: AtomicU64"})
      - 'unsafe { & * (self as * const Self as * const imp :: AtomicU8) }' (Used Types: {"AtomicU8", "Self", "* const Self", "* const imp :: AtomicU8"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i16 >)) . get () }' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i32 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i64 >)) . get () }' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < i64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i8 >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i8 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < isize >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u16 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < u16 >", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u32 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u64 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u8 >)) . get () }' (Used Types: {"* const UnsafeCell < u8 >", "UnsafeCell", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < usize >)) . get () }' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < usize >", "* const Self"})
  Expressions using 'Self' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

### Analyzing expressions using type: 'SetFlags' ###

--- AST Node Type: Block ---
  Expressions using 'SetFlags' with 11 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'SetFlags' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'SetFlags' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'SetFlags' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'SetFlags' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Unknown ---
  Expressions using 'SetFlags' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'Size' ###

--- AST Node Type: Block ---
  Expressions using 'Size' with 1 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)) }' (Used Types: {"Size", "* const Size"})
  Expressions using 'Size' with 3 other type(s):
    Depth 3: (Count: 1)
      - '{ Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) }' (Used Types: {"Roflags", "Size", "* const Size", "* const Roflags"})

--- AST Node Type: Call ---
  Expressions using 'Size' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Size > :: uninit ()' (Used Types: {"Size"})
  Expressions using 'Size' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size))' (Used Types: {"* const Size", "Size"})
    Depth 4: (Count: 2)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,))' (Used Types: {"* const Size", "Size"})
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size)' (Used Types: {"Size", "* const Size"})
    Depth 6: (Count: 1)
      - 'core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size)' (Used Types: {"Size", "* const Size"})
  Expressions using 'Size' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,))' (Used Types: {"Size", "* const Roflags", "Roflags", "* const Size"})

--- AST Node Type: Cast ---
  Expressions using 'Size' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Size' (Used Types: {"* const Size", "Size"})
    Depth 7: (Count: 1)
      - 'rp1 . as_mut_ptr () as i32 as * const Size' (Used Types: {"Size", "* const Size"})

--- AST Node Type: Match ---
  Expressions using 'Size' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"Size", "* const Size"})
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Size", "* const Size"})
  Expressions using 'Size' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => { Ok ((core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)) } _ => Err (Errno (ret as u16)) , }' (Used Types: {"Roflags", "* const Roflags", "* const Size", "Size"})

--- AST Node Type: Path ---
  Expressions using 'Size' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Size > :: uninit' (Used Types: {"Size"})

--- AST Node Type: Tuple ---
  Expressions using 'Size' with 1 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Size) ,)' (Used Types: {"Size", "* const Size"})
  Expressions using 'Size' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Size) , core :: ptr :: read (rp1 . as_mut_ptr () as i32 as * const Roflags) ,)' (Used Types: {"* const Roflags", "* const Size", "Roflags", "Size"})

### Analyzing expressions using type: 'Span' ###

--- AST Node Type: Array ---
  Expressions using 'Span' with 0 other type(s):
    Depth 9: (Count: 1)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span"})
  Expressions using 'Span' with 1 other type(s):
    Depth 9: (Count: 11)
      - '[< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ErrorKind", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "AssertionKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassAsciiKind", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassPerlKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Flags", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"FlagsItemKind", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Literal", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "LiteralKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "RepetitionKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"ClassUnicodeKind", "Span"})
  Expressions using 'Span' with 2 other type(s):
    Depth 9: (Count: 3)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "Ast"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "ClassSetItem"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "FlagsItem", "Span"})
  Expressions using 'Span' with 3 other type(s):
    Depth 9: (Count: 3)
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSet", "Span", "Box", "ClassSetBinaryOpKind"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"GroupKind", "Box", "Ast", "Span"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Box", "Ast", "Span"})

--- AST Node Type: Block ---
  Expressions using 'Span' with 0 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) }' (Used Types: {"Span"})
  Expressions using 'Span' with 8 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"Span", "ClassSetRange", "ClassPerl", "Box", "ClassUnicode", "Literal", "ClassBracketed", "ClassAscii", "ClassSetUnion"})
  Expressions using 'Span' with 11 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Literal", "Group", "ClassBracketed", "ClassUnicode", "Repetition", "Alternation", "Concat", "SetFlags", "Span", "Box"})
  Expressions using 'Span' with 12 other type(s):
    Depth 2: (Count: 11)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Span' with 13 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
  Expressions using 'Span' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Span' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Span' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

--- AST Node Type: Call ---
  Expressions using 'Span' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Span"})
    Depth 6: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span"})
    Depth 7: (Count: 2)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,)' (Used Types: {"Span"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,)' (Used Types: {"Span"})
  Expressions using 'Span' with 1 other type(s):
    Depth 4: (Count: 11)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ErrorKind", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "AssertionKind"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ClassAsciiKind", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "ClassPerlKind"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Flags"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"FlagsItemKind", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Literal", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "LiteralKind"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "RepetitionKind"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"ClassSet", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,)' (Used Types: {"Span", "ClassUnicodeKind"})
    Depth 6: (Count: 11)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ErrorKind", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"AssertionKind", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassAsciiKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassPerlKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Flags", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "FlagsItemKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Literal", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "LiteralKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "RepetitionKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSet", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"ClassUnicodeKind", "Span"})
    Depth 7: (Count: 11)
      - 'arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ErrorKind"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"AssertionKind", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassAsciiKind"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassPerlKind"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Flags", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"Span", "FlagsItemKind"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "Literal"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"LiteralKind", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"RepetitionKind", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"ClassSet", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,)' (Used Types: {"Span", "ClassUnicodeKind"})
  Expressions using 'Span' with 2 other type(s):
    Depth 4: (Count: 3)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "Span", "ClassSetItem"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 6: (Count: 3)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSetItem", "Span", "Vec"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 7: (Count: 3)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"ClassSetItem", "Vec", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Vec", "Span", "FlagsItem"})
  Expressions using 'Span' with 3 other type(s):
    Depth 4: (Count: 3)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Box", "ClassSetBinaryOpKind", "ClassSet"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})
    Depth 6: (Count: 3)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "Span", "ClassSet", "ClassSetBinaryOpKind"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"GroupKind", "Ast", "Box", "Span"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Box", "RepetitionOp", "Ast"})
    Depth 7: (Count: 3)
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "ClassSetBinaryOpKind", "Box", "ClassSet"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Box", "Span", "GroupKind", "Ast"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"RepetitionOp", "Box", "Span", "Ast"})
  Expressions using 'Span' with 8 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "ClassSetRange", "ClassPerl", "Box", "ClassAscii", "Literal", "Span", "ClassBracketed", "ClassSetUnion"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"ClassAscii", "ClassSetUnion", "ClassBracketed", "ClassUnicode", "Box", "Literal", "ClassSetRange", "Span", "ClassPerl"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Span", "ClassUnicode", "Literal", "Box", "ClassPerl", "ClassSetRange", "ClassBracketed", "ClassSetUnion", "ClassAscii"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"ClassAscii", "ClassPerl", "Box", "ClassBracketed", "Span", "Literal", "ClassSetRange", "ClassUnicode", "ClassSetUnion"})
  Expressions using 'Span' with 11 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"ClassUnicode", "Box", "Literal", "Repetition", "Alternation", "Assertion", "SetFlags", "ClassPerl", "ClassBracketed", "Span", "Concat", "Group"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"Concat", "Group", "ClassUnicode", "Assertion", "SetFlags", "Span", "Literal", "Box", "ClassBracketed", "ClassPerl", "Repetition", "Alternation"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"Group", "ClassPerl", "Span", "SetFlags", "ClassUnicode", "Concat", "Box", "Literal", "ClassBracketed", "Assertion", "Repetition", "Alternation"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"Assertion", "Box", "ClassUnicode", "Group", "Span", "ClassPerl", "Literal", "SetFlags", "ClassBracketed", "Repetition", "Alternation", "Concat"})

--- AST Node Type: Closure ---
  Expressions using 'Span' with 0 other type(s):
    Depth 5: (Count: 1)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span"})
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) }' (Used Types: {"Span"})
  Expressions using 'Span' with 1 other type(s):
    Depth 5: (Count: 11)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ErrorKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "AssertionKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassAsciiKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "ClassPerlKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Flags"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"FlagsItemKind", "Span"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Literal"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "LiteralKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "RepetitionKind"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSet", "Span"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,)' (Used Types: {"Span", "ClassUnicodeKind"})
  Expressions using 'Span' with 2 other type(s):
    Depth 5: (Count: 3)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Span", "Ast"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "ClassSetItem", "Span"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"FlagsItem", "Span", "Vec"})
  Expressions using 'Span' with 3 other type(s):
    Depth 5: (Count: 3)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "GroupKind", "Box", "Ast"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Box", "RepetitionOp", "Ast", "Span"})
  Expressions using 'Span' with 8 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassSetRange", "ClassBracketed", "Literal", "ClassPerl", "ClassUnicode", "Box", "ClassSetUnion", "Span", "ClassAscii"})
  Expressions using 'Span' with 11 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"ClassPerl", "Assertion", "Span", "Repetition", "Literal", "Group", "ClassBracketed", "SetFlags", "Box", "ClassUnicode", "Alternation", "Concat"})

--- AST Node Type: Reference ---
  Expressions using 'Span' with 0 other type(s):
    Depth 8: (Count: 1)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span"})
  Expressions using 'Span' with 1 other type(s):
    Depth 8: (Count: 11)
      - '& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ErrorKind", "Span"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"AssertionKind", "Span"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassAsciiKind"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassPerlKind", "Span"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Flags", "Span"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "FlagsItemKind"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Literal"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "LiteralKind"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"RepetitionKind", "Span"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "ClassSet"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,]' (Used Types: {"Span", "ClassUnicodeKind"})
  Expressions using 'Span' with 2 other type(s):
    Depth 8: (Count: 3)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Span", "Vec"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSetItem", "Span", "Vec"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "Span", "FlagsItem"})
  Expressions using 'Span' with 3 other type(s):
    Depth 8: (Count: 3)
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Box", "ClassSetBinaryOpKind", "Span", "ClassSet"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "GroupKind", "Span", "Box"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"RepetitionOp", "Ast", "Box", "Span"})

--- AST Node Type: Unknown ---
  Expressions using 'Span' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ?' (Used Types: {"Span"})
    Depth 10: (Count: 1)
      - '< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Span"})
  Expressions using 'Span' with 8 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"ClassSetRange", "Span", "ClassPerl", "ClassUnicode", "ClassBracketed", "Box", "ClassSetUnion", "Literal", "ClassAscii"})
  Expressions using 'Span' with 11 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SetFlags", "ClassBracketed", "Group", "Concat", "Literal", "ClassPerl", "Repetition", "Span", "Alternation", "Assertion", "Box", "ClassUnicode"})

### Analyzing expressions using type: 'SpecialLiteralKind' ###

--- AST Node Type: Block ---
  Expressions using 'SpecialLiteralKind' with 1 other type(s):
    Depth 9: (Count: 1)
      - '{ Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
  Expressions using 'SpecialLiteralKind' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using 'SpecialLiteralKind' with 12 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})

--- AST Node Type: Call ---
  Expressions using 'SpecialLiteralKind' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,)' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})
    Depth 5: (Count: 1)
      - 'arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,)' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
    Depth 7: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,)' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})
    Depth 10: (Count: 1)
      - 'Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,)' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})

--- AST Node Type: Closure ---
  Expressions using 'SpecialLiteralKind' with 1 other type(s):
    Depth 8: (Count: 1)
      - '| depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) }' (Used Types: {"HexLiteralKind", "SpecialLiteralKind"})

--- AST Node Type: Unknown ---
  Expressions using 'SpecialLiteralKind' with 1 other type(s):
    Depth 6: (Count: 1)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ?' (Used Types: {"SpecialLiteralKind", "HexLiteralKind"})

### Analyzing expressions using type: 'Status' ###

--- AST Node Type: Binary ---
  Expressions using 'Status' with 0 other type(s):
    Depth 2: (Count: 1)
      - '8usize * core :: mem :: size_of :: < Status > ()' (Used Types: {"Status"})

--- AST Node Type: Call ---
  Expressions using 'Status' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: size_of :: < Status > ()' (Used Types: {"Status"})

--- AST Node Type: Path ---
  Expressions using 'Status' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: size_of :: < Status >' (Used Types: {"Status"})

### Analyzing expressions using type: 'Storage' ###

--- AST Node Type: Binary ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 6: (Count: 3)
      - '(bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of :: < Storage > ()' (Used Types: {"Storage"})
      - 'bit_offset / 8 < core :: mem :: size_of :: < Storage > ()' (Used Types: {"Storage"})
      - 'index / 8 < core :: mem :: size_of :: < Storage > ()' (Used Types: {"Storage"})

--- AST Node Type: Call ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 7: (Count: 1)
      - 'core :: mem :: size_of :: < Storage > ()' (Used Types: {"Storage"})

--- AST Node Type: If ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 2: (Count: 3)
      - 'if true { if ! ((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()" ,) } }' (Used Types: {"Storage"})
      - 'if true { if ! (bit_offset / 8 < core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: bit_offset / 8 < core::mem::size_of::<Storage>()" ,) } }' (Used Types: {"Storage"})
      - 'if true { if ! (index / 8 < core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: index / 8 < core::mem::size_of::<Storage>()" ,) } }' (Used Types: {"Storage"})
    Depth 3: (Count: 3)
      - 'if ! ((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>()" ,) }' (Used Types: {"Storage"})
      - 'if ! (bit_offset / 8 < core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: bit_offset / 8 < core::mem::size_of::<Storage>()" ,) }' (Used Types: {"Storage"})
      - 'if ! (index / 8 < core :: mem :: size_of :: < Storage > ()) { :: core :: panicking :: panic ("assertion failed: index / 8 < core::mem::size_of::<Storage>()" ,) }' (Used Types: {"Storage"})

--- AST Node Type: Paren ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 5: (Count: 3)
      - '((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})
      - '(bit_offset / 8 < core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})
      - '(index / 8 < core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})

--- AST Node Type: Path ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 8: (Count: 1)
      - 'core :: mem :: size_of :: < Storage >' (Used Types: {"Storage"})

--- AST Node Type: Unary ---
  Expressions using 'Storage' with 0 other type(s):
    Depth 4: (Count: 3)
      - '! ((bit_offset + (bit_width as usize)) / 8 <= core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})
      - '! (bit_offset / 8 < core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})
      - '! (index / 8 < core :: mem :: size_of :: < Storage > ())' (Used Types: {"Storage"})

### Analyzing expressions using type: 'SubtaskOps' ###

--- AST Node Type: Async ---
  Expressions using 'SubtaskOps' with 1 other type(s):
    Depth 1: (Count: 1)
      - 'async { match WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await { Ok (results) => results , Err (_) => { :: core :: panicking :: panic_fmt (format_args ! ("internal error: entered unreachable code: {0}" , format_args ! ("cancellation is not exposed API-wise, should not be possible" ,) ,) ,) ; } } }' (Used Types: {"Self", "SubtaskOps"})

--- AST Node Type: Await ---
  Expressions using 'SubtaskOps' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Call ---
  Expressions using 'SubtaskOps' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params })' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Match ---
  Expressions using 'SubtaskOps' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match WaitableOperation :: < SubtaskOps < Self > , > :: new (Start { params }) . await { Ok (results) => results , Err (_) => { :: core :: panicking :: panic_fmt (format_args ! ("internal error: entered unreachable code: {0}" , format_args ! ("cancellation is not exposed API-wise, should not be possible" ,) ,) ,) ; } }' (Used Types: {"SubtaskOps", "Self"})

--- AST Node Type: Path ---
  Expressions using 'SubtaskOps' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'WaitableOperation :: < SubtaskOps < Self > , > :: new' (Used Types: {"SubtaskOps", "Self"})

### Analyzing expressions using type: 'T' ###

--- AST Node Type: Assign ---
  Expressions using 'T' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'self . end = arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"T", "* const i8", "* mut T"})

--- AST Node Type: Binary ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'mem :: size_of :: < T > () != 0' (Used Types: {"T"})
    Depth 5: (Count: 2)
      - 'mem :: size_of :: < T > () * self . cap' (Used Types: {"T"})
      - 'mem :: size_of :: < T > () == 0' (Used Types: {"T"})
    Depth 6: (Count: 2)
      - 'core :: mem :: size_of :: < T > () != 0 || self . len () <= usize :: MAX - slice . len ()' (Used Types: {"T"})
      - 'core :: mem :: size_of :: < T > () == 0 || self . capacity () >= self . len () + slice . len ()' (Used Types: {"T"})
    Depth 7: (Count: 2)
      - 'core :: mem :: size_of :: < T > () != 0' (Used Types: {"T"})
      - 'core :: mem :: size_of :: < T > () == 0' (Used Types: {"T"})
    Depth 9: (Count: 1)
      - 'offs == mem :: size_of :: < T > ()' (Used Types: {"T"})

--- AST Node Type: Block ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 2)
      - '{ unsafe { let align = mem :: align_of :: < T > () ; let size = mem :: size_of :: < T > () * self . cap ; Some (Layout :: from_size_align_unchecked (size , align)) } }' (Used Types: {"T"})
      - '{ unsafe { let mut self_ = guard (self , | self_ | { self_ . clear_no_drop () ; } ,) ; self_ . table . drop_elements :: < T > () ; if self_ . buckets () != source . buckets () { let new_inner = match RawTableInner :: new_uninitialized (& self_ . alloc , Self :: TABLE_LAYOUT , source . buckets () , Fallibility :: Infallible ,) { Ok (table) => table , Err (_) => hint :: unreachable_unchecked () , } ; let mut old_inner = mem :: replace (& mut self_ . table , new_inner) ; if ! old_inner . is_empty_singleton () { old_inner . free_buckets (& self_ . alloc , Self :: TABLE_LAYOUT) ; } } self_ . clone_from_spec (source) ; ScopeGuard :: into_inner (self_) ; } }' (Used Types: {"T"})
    Depth 4: (Count: 3)
      - '{ if true { if ! (offs == mem :: size_of :: < T > ()) { :: core :: panicking :: panic ("assertion failed: offs == mem::size_of::<T>()" ,) } } k }' (Used Types: {"T"})
      - '{ let align = mem :: align_of :: < T > () ; let layout = Layout :: from_size_align (alloc_size , align) . unwrap () ; let result = if zeroed { a . alloc_zeroed (layout) } else { Alloc :: alloc (& mut a , layout) } ; match result { Ok (ptr) => ptr . cast () , Err (_) => handle_alloc_error (layout) , } }' (Used Types: {"T"})
      - '{ let new_cap = if elem_size > (! 0) / 8 { 1 } else { 4 } ; match self . a . alloc_array :: < T > (new_cap) { Ok (ptr) => (new_cap , ptr) , Err (_) => { handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ()) } } }' (Used Types: {"T"})
    Depth 6: (Count: 1)
      - '{ handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ()) }' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 4: (Count: 1)
      - '{ begin . add (self . len ()) as * const T }' (Used Types: {"* const T", "T"})
  Expressions using 'T' with 4 other type(s):
    Depth 2: (Count: 2)
      - '{ # [doc = " A type which contributes nothing when adding (i.e. a zero)"] pub struct Null ; impl < T > Add < T > for Null { type Output = T ; fn add (self , rhs : T) -> Self :: Output { rhs } } impl FoldAdd for ATerm { type Output = Null ; } }' (Used Types: {"ATerm", "T", "Self", "Output", "Null"})
      - '{ # [doc = " A type which contributes nothing when multiplying (i.e. a one)"] pub struct Null ; impl < T > Mul < T > for Null { type Output = T ; fn mul (self , rhs : T) -> Self :: Output { rhs } } impl FoldMul for ATerm { type Output = Null ; } }' (Used Types: {"Self", "Null", "T", "Output", "ATerm"})

--- AST Node Type: Call ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 8)
      - 'Layout :: array :: < T > (n)' (Used Types: {"T"})
      - 'Layout :: new :: < T > ()' (Used Types: {"T"})
      - 'TableLayout :: new :: < T > ()' (Used Types: {"T"})
      - '_IOC (_IOC_READ , ty , nr , size_of :: < T > ())' (Used Types: {"T"})
      - '_IOC (_IOC_READ | _IOC_WRITE , ty , nr , size_of :: < T > ())' (Used Types: {"T"})
      - '_IOC (_IOC_WRITE , ty , nr , size_of :: < T > ())' (Used Types: {"T"})
      - 'error :: request_ref :: < T > (err)' (Used Types: {"T"})
      - 'mem :: align_of :: < T > ()' (Used Types: {"T"})
    Depth 3: (Count: 8)
      - 'Layout :: array :: < T > (n_new)' (Used Types: {"T"})
      - 'Layout :: array :: < T > (n_old)' (Used Types: {"T"})
      - 'Vec :: < T > :: from_raw_parts (ptr . cast () , len , cap)' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self)' (Used Types: {"T"})
      - 'invalid_mut (mem :: align_of :: < T > ())' (Used Types: {"T"})
      - 'layout_array :: < T > (capacity)' (Used Types: {"T"})
      - 'mem :: needs_drop :: < T > ()' (Used Types: {"T"})
      - 'size_of :: < T > ()' (Used Types: {"T"})
    Depth 4: (Count: 4)
      - 'Layout :: array :: < T > (len)' (Used Types: {"T"})
      - 'NonNull :: < T > :: dangling ()' (Used Types: {"T"})
      - 'core :: mem :: size_of :: < T > ()' (Used Types: {"T"})
      - 'mem :: size_of :: < T > ()' (Used Types: {"T"})
    Depth 5: (Count: 2)
      - 'Layout :: array :: < T > (new_cap)' (Used Types: {"T"})
      - 'hasher (table . bucket :: < T > (index) . as_ref ())' (Used Types: {"T"})
    Depth 7: (Count: 1)
      - 'handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ())' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 2)
      - '< imp :: AtomicPtr < T > > :: is_lock_free ()' (Used Types: {"T", "AtomicPtr"})
      - 'ptr :: copy_nonoverlapping (other as * const T , self . as_mut_ptr () . add (len) , count ,)' (Used Types: {"T", "* const T"})
    Depth 3: (Count: 3)
      - 'NonNull :: new (ptr as * mut T)' (Used Types: {"T", "* mut T"})
      - 'Vec :: < MaybeUninit < T > > :: from_raw_parts (ptr . cast () , len , cap)' (Used Types: {"T", "MaybeUninit"})
      - 'slice :: from_raw_parts_mut (self . ptr as * mut T , self . len ())' (Used Types: {"* mut T", "T"})
    Depth 4: (Count: 1)
      - 'Ok (Box :: from_raw (raw as * mut T))' (Used Types: {"* mut T", "T"})
    Depth 5: (Count: 4)
      - '< * const T > :: cast_mut (value)' (Used Types: {"T", "* const T"})
      - 'Box :: from_raw (raw as * mut T)' (Used Types: {"* mut T", "T"})
      - 'Ok :: < T , Void > (f ())' (Used Types: {"T", "Void"})
      - 'Some (| ptr | ptr :: drop_in_place (ptr as * mut T))' (Used Types: {"* mut T", "T"})
    Depth 7: (Count: 1)
      - 'ptr :: drop_in_place (ptr as * mut T)' (Used Types: {"T", "* mut T"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve (& mut self . map , additional)' (Used Types: {"T", "(T , ())", "()"})
    Depth 5: (Count: 2)
      - 'Ok :: < & 'a T , Void > (f ())' (Used Types: {"Void", "& 'a T", "T"})
      - 'Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Cast ---
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'b . deref_mut () . 0 as * mut T' (Used Types: {"* mut T", "T"})
      - 'p . as_ptr () as * mut T' (Used Types: {"T", "* mut T"})
      - 'self . ptr . as_ptr () as * const T' (Used Types: {"* const T", "T"})
    Depth 3: (Count: 3)
      - '(* self) as * const T' (Used Types: {"* const T", "T"})
      - 'other as * const T' (Used Types: {"T", "* const T"})
      - 'ptr as * const T' (Used Types: {"T", "* const T"})
    Depth 4: (Count: 2)
      - 'ptr as * mut T' (Used Types: {"* mut T", "T"})
      - 'self . ptr as * mut T' (Used Types: {"* mut T", "T"})
    Depth 5: (Count: 1)
      - 'begin . add (self . len ()) as * const T' (Used Types: {"* const T", "T"})
    Depth 6: (Count: 1)
      - 'raw as * mut T' (Used Types: {"* mut T", "T"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'ptr as * const T as * mut T' (Used Types: {"* const T", "T", "* mut T"})
    Depth 3: (Count: 1)
      - 'slice . as_mut_ptr () as * mut [T ; N]' (Used Types: {"* mut [T ; N]", "T", "[T ; N]"})
    Depth 4: (Count: 1)
      - 'arith_offset (begin as * const i8 , self . len () as isize) as * const T' (Used Types: {"* const T", "* const i8", "T"})
    Depth 6: (Count: 2)
      - 'arith_offset (self . end as * const i8 , - 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
      - 'arith_offset (self . ptr as * const i8 , 1) as * mut T' (Used Types: {"* const i8", "* mut T", "T"})
  Expressions using 'T' with 3 other type(s):
    Depth 2: (Count: 3)
      - '(* self) as * const T as * const c_void' (Used Types: {"* const T", "c_void", "T", "* const c_void"})
      - 'self as * const _ as * const T' (Used Types: {"* const _", "* const T", "_", "T"})
      - 'self as * mut _ as * mut T' (Used Types: {"* mut _", "* mut T", "T", "_"})
  Expressions using 'T' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: Closure ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 1)
      - '| (k , offs) | { if true { if ! (offs == mem :: size_of :: < T > ()) { :: core :: panicking :: panic ("assertion failed: offs == mem::size_of::<T>()" ,) } } k }' (Used Types: {"T"})
    Depth 4: (Count: 1)
      - '| table , index | hasher (table . bucket :: < T > (index) . as_ref ())' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 4: (Count: 2)
      - '| _ : * mut T | ()' (Used Types: {"T", "* mut T"})
      - '| | Ok :: < T , Void > (f ())' (Used Types: {"Void", "T"})
    Depth 6: (Count: 1)
      - '| ptr | ptr :: drop_in_place (ptr as * mut T)' (Used Types: {"* mut T", "T"})
  Expressions using 'T' with 2 other type(s):
    Depth 4: (Count: 2)
      - '| | Ok :: < & 'a T , Void > (f ())' (Used Types: {"& 'a T", "T", "Void"})
      - '| | Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "Void", "T"})

--- AST Node Type: Field ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'Layout :: new :: < T > () . repeat (new_cap) . unwrap () . 0' (Used Types: {"T"})

--- AST Node Type: ForLoop ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'for item in self . iter :: < T > () { item . drop () ; }' (Used Types: {"T"})

--- AST Node Type: If ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 10)
      - 'if ! self . is_empty_singleton () { unsafe { self . drop_elements :: < T > () ; self . free_buckets (alloc , table_layout) ; } }' (Used Types: {"T"})
      - 'if T :: IS_ZERO_SIZED { invalid_mut (mem :: align_of :: < T > ()) } else { unsafe { self . ptr . as_ptr () . sub (1) } }' (Used Types: {"T"})
      - 'if T :: NEEDS_DROP && self . items != 0 { for item in self . iter :: < T > () { item . drop () ; } }' (Used Types: {"T"})
      - 'if amount == 0 { unsafe { let a = self . a ; self . dealloc_buffer () ; ptr :: write (self , RawVec :: new_in (a)) ; } } else if self . cap != amount { unsafe { let old_size = elem_size * self . cap ; let new_size = elem_size * amount ; let align = mem :: align_of :: < T > () ; let old_layout = Layout :: from_size_align_unchecked (old_size , align ,) ; match self . a . realloc (self . ptr . cast () , old_layout , new_size) { Ok (p) => self . ptr = p . cast () , Err (_) => { handle_alloc_error (Layout :: from_size_align_unchecked (new_size , align) ,) } } } self . cap = amount ; }' (Used Types: {"T"})
      - 'if mem :: needs_drop :: < T > () { for item in & mut self . iter { unsafe { item . drop () ; } } }' (Used Types: {"T"})
      - 'if mem :: size_of :: < T > () == 0 { ! 0 } else { self . cap }' (Used Types: {"T"})
      - 'if mem :: size_of :: < T > () == 0 { (self . end as usize) . wrapping_sub (self . ptr as usize) } else { unsafe { offset_from (self . end , self . ptr) as usize } }' (Used Types: {"T"})
      - 'if self . cap == 0 { None } else { unsafe { let align = mem :: align_of :: < T > () ; let size = mem :: size_of :: < T > () * self . cap ; Some (Layout :: from_size_align_unchecked (size , align)) } }' (Used Types: {"T"})
      - 'if true { if ! (core :: mem :: size_of :: < T > () != 0 || self . len () <= usize :: MAX - slice . len ()) { :: core :: panicking :: panic ("assertion failed: core::mem::size_of::<T>() != 0 || self.len() <= usize::MAX - slice.len()" ,) } }' (Used Types: {"T"})
      - 'if true { if ! (core :: mem :: size_of :: < T > () == 0 || self . capacity () >= self . len () + slice . len ()) { :: core :: panicking :: panic ("assertion failed: core::mem::size_of::<T>() == 0 || self.capacity() >= self.len() + slice.len()" ,) } }' (Used Types: {"T"})
    Depth 3: (Count: 4)
      - 'if ! (core :: mem :: size_of :: < T > () != 0 || self . len () <= usize :: MAX - slice . len ()) { :: core :: panicking :: panic ("assertion failed: core::mem::size_of::<T>() != 0 || self.len() <= usize::MAX - slice.len()" ,) }' (Used Types: {"T"})
      - 'if ! (core :: mem :: size_of :: < T > () == 0 || self . capacity () >= self . len () + slice . len ()) { :: core :: panicking :: panic ("assertion failed: core::mem::size_of::<T>() == 0 || self.capacity() >= self.len() + slice.len()" ,) }' (Used Types: {"T"})
      - 'if alloc_size == 0 { NonNull :: < T > :: dangling () } else { let align = mem :: align_of :: < T > () ; let layout = Layout :: from_size_align (alloc_size , align) . unwrap () ; let result = if zeroed { a . alloc_zeroed (layout) } else { Alloc :: alloc (& mut a , layout) } ; match result { Ok (ptr) => ptr . cast () , Err (_) => handle_alloc_error (layout) , } }' (Used Types: {"T"})
      - 'if self . cap != amount { unsafe { let old_size = elem_size * self . cap ; let new_size = elem_size * amount ; let align = mem :: align_of :: < T > () ; let old_layout = Layout :: from_size_align_unchecked (old_size , align ,) ; match self . a . realloc (self . ptr . cast () , old_layout , new_size) { Ok (p) => self . ptr = p . cast () , Err (_) => { handle_alloc_error (Layout :: from_size_align_unchecked (new_size , align) ,) } } } self . cap = amount ; }' (Used Types: {"T"})
    Depth 5: (Count: 1)
      - 'if true { if ! (offs == mem :: size_of :: < T > ()) { :: core :: panicking :: panic ("assertion failed: offs == mem::size_of::<T>()" ,) } }' (Used Types: {"T"})
    Depth 6: (Count: 1)
      - 'if ! (offs == mem :: size_of :: < T > ()) { :: core :: panicking :: panic ("assertion failed: offs == mem::size_of::<T>()" ,) }' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'if min_buckets < self . buckets () { if self . table . items == 0 { let new_inner = RawTableInner :: with_capacity (& self . alloc , Self :: TABLE_LAYOUT , min_size ,) ; let mut old_inner = mem :: replace (& mut self . table , new_inner) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { if self . resize (min_size , hasher , Fallibility :: Infallible) . is_err () { hint :: unreachable_unchecked () } } } }' (Used Types: {"T", "_"})
      - 'if min_size == 0 { let mut old_inner = mem :: replace (& mut self . table , RawTableInner :: NEW) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } return ; }' (Used Types: {"T", "_"})
      - 'if source . table . is_empty_singleton () { let mut old_inner = mem :: replace (& mut self . table , RawTableInner :: NEW) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { let mut self_ = guard (self , | self_ | { self_ . clear_no_drop () ; } ,) ; self_ . table . drop_elements :: < T > () ; if self_ . buckets () != source . buckets () { let new_inner = match RawTableInner :: new_uninitialized (& self_ . alloc , Self :: TABLE_LAYOUT , source . buckets () , Fallibility :: Infallible ,) { Ok (table) => table , Err (_) => hint :: unreachable_unchecked () , } ; let mut old_inner = mem :: replace (& mut self_ . table , new_inner) ; if ! old_inner . is_empty_singleton () { old_inner . free_buckets (& self_ . alloc , Self :: TABLE_LAYOUT) ; } } self_ . clone_from_spec (source) ; ScopeGuard :: into_inner (self_) ; } }' (Used Types: {"T", "_"})
    Depth 3: (Count: 1)
      - 'if self . table . items == 0 { let new_inner = RawTableInner :: with_capacity (& self . alloc , Self :: TABLE_LAYOUT , min_size ,) ; let mut old_inner = mem :: replace (& mut self . table , new_inner) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { if self . resize (min_size , hasher , Fallibility :: Infallible) . is_err () { hint :: unreachable_unchecked () } } }' (Used Types: {"T", "_"})
    Depth 4: (Count: 1)
      - 'if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None }' (Used Types: {"* mut T", "T"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if slice . len () == N { let mut slice = ManuallyDrop :: new (slice) ; let ptr = slice . as_mut_ptr () as * mut [T ; N] ; Ok (unsafe { Box :: from_raw (ptr) }) } else { Err (slice) }' (Used Types: {"T", "* mut [T ; N]", "[T ; N]"})
    Depth 3: (Count: 2)
      - 'if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T }' (Used Types: {"* const i8", "* const T", "T"})
      - 'if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"* const i8", "* mut T", "T"})
    Depth 4: (Count: 3)
      - 'if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* const T", "* mut T", "T"})
      - 'if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "* const i8", "* mut T"})
    Depth 5: (Count: 1)
      - 'if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; }' (Used Types: {"* mut T", "T", "* const T"})
  Expressions using 'T' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "dyn Any", "* mut dyn Any", "T"})
  Expressions using 'T' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "(dyn Any + Send)", "T", "* mut (dyn Any + Send)", "dyn Any + Send"})
    Depth 3: (Count: 1)
      - 'if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "_", "* const i8", "* const _", "* mut T"})

--- AST Node Type: Match ---
  Expressions using 'T' with 0 other type(s):
    Depth 1: (Count: 3)
      - 'match (Layout :: array :: < T > (n_old) , Layout :: array :: < T > (n_new)) { (Ok (ref k_old) , Ok (ref k_new) ,) if k_old . size () > 0 && k_new . size () > 0 => { if true { if ! (k_old . align () == k_new . align ()) { :: core :: panicking :: panic ("assertion failed: k_old.align() == k_new.align()" ,) } } self . realloc (ptr . cast () , * k_old , k_new . size ()) . map (NonNull :: cast) } _ => Err (AllocErr) , }' (Used Types: {"T"})
      - 'match Layout :: array :: < T > (n) { Ok (k) if k . size () > 0 => { self . dealloc (ptr . cast () , k) ; Ok (()) } _ => Err (AllocErr) , }' (Used Types: {"T"})
      - 'match Layout :: array :: < T > (n) { Ok (layout) if layout . size () > 0 => { unsafe { self . alloc (layout) . map (| p | p . cast ()) } } _ => Err (AllocErr) , }' (Used Types: {"T"})
    Depth 3: (Count: 1)
      - 'match self . current_layout () { Some (cur) => { let new_cap = 2 * self . cap ; let new_size = new_cap * elem_size ; alloc_guard (new_size) . unwrap_or_else (| _ | capacity_overflow ()) ; let ptr_res = self . a . realloc (self . ptr . cast () , cur , new_size) ; match ptr_res { Ok (ptr) => (new_cap , ptr . cast ()) , Err (_) => { handle_alloc_error (Layout :: from_size_align_unchecked (new_size , cur . align ()) ,) } } } None => { let new_cap = if elem_size > (! 0) / 8 { 1 } else { 4 } ; match self . a . alloc_array :: < T > (new_cap) { Ok (ptr) => (new_cap , ptr) , Err (_) => { handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ()) } } } }' (Used Types: {"T"})
    Depth 5: (Count: 1)
      - 'match self . a . alloc_array :: < T > (new_cap) { Ok (ptr) => (new_cap , ptr) , Err (_) => { handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ()) } }' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match self . get_or_try_init (| | Ok :: < T , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"T", "Void"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'match self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"& 'a T", "T", "Void"})
      - 'match self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"Void", "T", "Box"})

--- AST Node Type: MethodCall ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 14)
      - 'Layout :: array :: < T > (len) . unwrap_or_else (| _ | oom ())' (Used Types: {"T"})
      - 'Layout :: new :: < T > () . repeat (n) . map (| (k , offs) | { if true { if ! (offs == mem :: size_of :: < T > ()) { :: core :: panicking :: panic ("assertion failed: offs == mem::size_of::<T>()" ,) } } k })' (Used Types: {"T"})
      - 'base_ptr . cast :: < T > ()' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self) . write_to (sink)' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self) . write_to_parts (sink)' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self) . write_to_string ()' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self) . writeable_borrow ()' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow (self) . writeable_length_hint ()' (Used Types: {"T"})
      - 'layout_array :: < T > (capacity) . unwrap ()' (Used Types: {"T"})
      - 'self . alloc_layout (layout) . cast :: < T > ()' (Used Types: {"T"})
      - 'self . fetch_byte_add (val . wrapping_mul (core :: mem :: size_of :: < T > ()) , order)' (Used Types: {"T"})
      - 'self . fetch_byte_sub (val . wrapping_mul (core :: mem :: size_of :: < T > ()) , order)' (Used Types: {"T"})
      - 'self . table . resize_inner (& self . alloc , capacity , & | table , index | hasher (table . bucket :: < T > (index) . as_ref ()) , fallibility , Self :: TABLE_LAYOUT ,)' (Used Types: {"T"})
      - 'self . try_alloc_layout (layout) ? . cast :: < T > ()' (Used Types: {"T"})
    Depth 3: (Count: 5)
      - 'Layout :: array :: < T > (len) . map_err (| _ | AllocErr)' (Used Types: {"T"})
      - 'Layout :: new :: < T > () . repeat (n)' (Used Types: {"T"})
      - 'mem :: size_of :: < T > () . checked_mul (n) . ok_or (CollectionAllocErr :: CapacityOverflow)' (Used Types: {"T"})
      - 'self . is :: < T > ()' (Used Types: {"T"})
      - 'val . wrapping_mul (core :: mem :: size_of :: < T > ())' (Used Types: {"T"})
    Depth 4: (Count: 5)
      - 'Layout :: array :: < T > (new_cap) . map_err (| _ | CapacityOverflow)' (Used Types: {"T"})
      - 'Layout :: new :: < T > () . repeat (new_cap) . unwrap ()' (Used Types: {"T"})
      - 'mem :: size_of :: < T > () . checked_mul (n)' (Used Types: {"T"})
      - 'self . drop_elements :: < T > ()' (Used Types: {"T"})
      - 'self . iter :: < T > ()' (Used Types: {"T"})
    Depth 5: (Count: 2)
      - 'Layout :: new :: < T > () . repeat (new_cap)' (Used Types: {"T"})
      - 'self_ . table . drop_elements :: < T > ()' (Used Types: {"T"})
    Depth 6: (Count: 2)
      - 'self . a . alloc_array :: < T > (new_cap)' (Used Types: {"T"})
      - 'table . bucket :: < T > (index) . as_ref ()' (Used Types: {"T"})
    Depth 7: (Count: 1)
      - 'table . bucket :: < T > (index)' (Used Types: {"T"})
    Depth 8: (Count: 1)
      - 'Layout :: array :: < T > (new_cap) . unwrap ()' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'NonNull :: new (ptr as * mut T) . map (Self)' (Used Types: {"* mut T", "T"})
    Depth 3: (Count: 3)
      - 'self . get_or_try_init (| | Ok :: < T , Void > (f ()))' (Used Types: {"Void", "T"})
      - 'self . table . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT)' (Used Types: {"_", "T"})
      - 'self . table . reserve_rehash_inner (& self . alloc , additional , & | table , index | hasher (table . bucket :: < T > (index) . as_ref ()) , fallibility , Self :: TABLE_LAYOUT , if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None } ,)' (Used Types: {"* mut T", "T"})
    Depth 4: (Count: 2)
      - 'old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT)' (Used Types: {"_", "T"})
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,)' (Used Types: {"* const T", "T"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ()) . map_err (< * mut T > :: cast_const)' (Used Types: {"T", "* mut T", "* const T"})
    Depth 3: (Count: 3)
      - 'self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ()))' (Used Types: {"Void", "& 'a T", "T"})
      - 'self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ()))' (Used Types: {"Box", "T", "Void"})
      - 'self . inner . compare_exchange (ptr :: null_mut () , < * const T > :: cast_mut (value) , Ordering :: Release , Ordering :: Acquire ,) . map (| _ : * mut T | ())' (Used Types: {"* const T", "* mut T", "T"})
  Expressions using 'T' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using 'T' with 0 other type(s):
    Depth 5: (Count: 2)
      - '(core :: mem :: size_of :: < T > () != 0 || self . len () <= usize :: MAX - slice . len ())' (Used Types: {"T"})
      - '(core :: mem :: size_of :: < T > () == 0 || self . capacity () >= self . len () + slice . len ())' (Used Types: {"T"})
    Depth 8: (Count: 1)
      - '(offs == mem :: size_of :: < T > ())' (Used Types: {"T"})
  Expressions using 'T' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Path ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 4)
      - 'Layout :: new :: < T >' (Used Types: {"T"})
      - 'TableLayout :: new :: < T >' (Used Types: {"T"})
      - 'error :: request_ref :: < T >' (Used Types: {"T"})
      - 'mem :: align_of :: < T >' (Used Types: {"T"})
    Depth 4: (Count: 5)
      - 'Vec :: < T > :: from_raw_parts' (Used Types: {"T"})
      - 'core :: borrow :: Borrow :: < T > :: borrow' (Used Types: {"T"})
      - 'layout_array :: < T >' (Used Types: {"T"})
      - 'mem :: needs_drop :: < T >' (Used Types: {"T"})
      - 'size_of :: < T >' (Used Types: {"T"})
    Depth 5: (Count: 4)
      - 'Layout :: array :: < T >' (Used Types: {"T"})
      - 'NonNull :: < T > :: dangling' (Used Types: {"T"})
      - 'core :: mem :: size_of :: < T >' (Used Types: {"T"})
      - 'mem :: size_of :: < T >' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 1)
      - '< imp :: AtomicPtr < T > > :: IS_ALWAYS_LOCK_FREE' (Used Types: {"AtomicPtr", "T"})
    Depth 3: (Count: 2)
      - '< * mut T > :: cast_const' (Used Types: {"* mut T", "T"})
      - '< imp :: AtomicPtr < T > > :: is_lock_free' (Used Types: {"AtomicPtr", "T"})
    Depth 4: (Count: 1)
      - 'Vec :: < MaybeUninit < T > > :: from_raw_parts' (Used Types: {"MaybeUninit", "T"})
    Depth 6: (Count: 2)
      - '< * const T > :: cast_mut' (Used Types: {"T", "* const T"})
      - 'Ok :: < T , Void >' (Used Types: {"T", "Void"})
  Expressions using 'T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (T , ()) > :: extend_reserve' (Used Types: {"(T , ())", "T", "()"})
    Depth 6: (Count: 2)
      - 'Ok :: < & 'a T , Void >' (Used Types: {"& 'a T", "T", "Void"})
      - 'Ok :: < Box < T > , Void >' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Reference ---
  Expressions using 'T' with 0 other type(s):
    Depth 3: (Count: 1)
      - '& | table , index | hasher (table . bucket :: < T > (index) . as_ref ())' (Used Types: {"T"})

--- AST Node Type: Tuple ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 2)
      - '(Layout :: array :: < T > (n_old) , Layout :: array :: < T > (n_new))' (Used Types: {"T"})
      - '(mem :: size_of :: < T > () , mem :: align_of :: < T > ())' (Used Types: {"T"})

--- AST Node Type: Unary ---
  Expressions using 'T' with 0 other type(s):
    Depth 4: (Count: 2)
      - '! (core :: mem :: size_of :: < T > () != 0 || self . len () <= usize :: MAX - slice . len ())' (Used Types: {"T"})
      - '! (core :: mem :: size_of :: < T > () == 0 || self . capacity () >= self . len () + slice . len ())' (Used Types: {"T"})
    Depth 7: (Count: 1)
      - '! (offs == mem :: size_of :: < T > ())' (Used Types: {"T"})
  Expressions using 'T' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unknown ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'Layout :: array :: < T > (len) . map_err (| _ | AllocErr) ?' (Used Types: {"T"})
      - 'mem :: size_of :: < T > () . checked_mul (n) . ok_or (CollectionAllocErr :: CapacityOverflow) ?' (Used Types: {"T"})
    Depth 3: (Count: 1)
      - 'Layout :: array :: < T > (new_cap) . map_err (| _ | CapacityOverflow) ?' (Used Types: {"T"})

--- AST Node Type: Unsafe ---
  Expressions using 'T' with 0 other type(s):
    Depth 2: (Count: 8)
      - 'unsafe { let elem_size = mem :: size_of :: < T > () ; if ! (elem_size != 0) { { :: core :: panicking :: panic_fmt (format_args ! ("capacity overflow") ,) ; } } let (new_cap , uniq) = match self . current_layout () { Some (cur) => { let new_cap = 2 * self . cap ; let new_size = new_cap * elem_size ; alloc_guard (new_size) . unwrap_or_else (| _ | capacity_overflow ()) ; let ptr_res = self . a . realloc (self . ptr . cast () , cur , new_size) ; match ptr_res { Ok (ptr) => (new_cap , ptr . cast ()) , Err (_) => { handle_alloc_error (Layout :: from_size_align_unchecked (new_size , cur . align ()) ,) } } } None => { let new_cap = if elem_size > (! 0) / 8 { 1 } else { 4 } ; match self . a . alloc_array :: < T > (new_cap) { Ok (ptr) => (new_cap , ptr) , Err (_) => { handle_alloc_error (Layout :: array :: < T > (new_cap) . unwrap ()) } } } } ; self . ptr = uniq ; self . cap = new_cap ; }' (Used Types: {"T"})
      - 'unsafe { let elem_size = mem :: size_of :: < T > () ; let alloc_size = cap . checked_mul (elem_size) . unwrap_or_else (| | capacity_overflow ()) ; alloc_guard (alloc_size) . unwrap_or_else (| _ | capacity_overflow ()) ; let ptr = if alloc_size == 0 { NonNull :: < T > :: dangling () } else { let align = mem :: align_of :: < T > () ; let layout = Layout :: from_size_align (alloc_size , align) . unwrap () ; let result = if zeroed { a . alloc_zeroed (layout) } else { Alloc :: alloc (& mut a , layout) } ; match result { Ok (ptr) => ptr . cast () , Err (_) => handle_alloc_error (layout) , } } ; RawVec { ptr , cap , a } }' (Used Types: {"T"})
      - 'unsafe { let elem_size = mem :: size_of :: < T > () ; let old_layout = match self . current_layout () { Some (layout) => layout , None => return false , } ; if ! (elem_size != 0) { { :: core :: panicking :: panic_fmt (format_args ! ("capacity overflow") ,) ; } } let new_cap = 2 * self . cap ; let new_size = new_cap * elem_size ; alloc_guard (new_size) . unwrap_or_else (| _ | capacity_overflow ()) ; match self . a . grow_in_place (self . ptr . cast () , old_layout , new_size) { Ok (_) => { self . cap = new_cap ; true } Err (_) => false , } }' (Used Types: {"T"})
      - 'unsafe { let needs_move = mem :: size_of :: < T > () != 0 ; if needs_move && this . idx < this . old_len && this . del > 0 { let ptr = this . vec . as_mut_ptr () ; let src = ptr . add (this . idx) ; let dst = src . sub (this . del) ; let tail_len = this . old_len - this . idx ; src . copy_to (dst , tail_len) ; } let new_len = this . old_len - this . del ; this . vec . set_len (new_len) ; }' (Used Types: {"T"})
      - 'unsafe { let old_layout = match self . current_layout () { Some (layout) => layout , None => return false , } ; if self . cap () . wrapping_sub (used_cap) >= needed_extra_cap { return false ; } let new_cap = self . amortized_new_size (used_cap , needed_extra_cap) . unwrap_or_else (| _ | capacity_overflow ()) ; let new_layout = Layout :: new :: < T > () . repeat (new_cap) . unwrap () . 0 ; alloc_guard (new_layout . size ()) . unwrap_or_else (| _ | capacity_overflow ()) ; match self . a . grow_in_place (self . ptr . cast () , old_layout , new_layout . size ()) { Ok (_) => { self . cap = new_cap ; true } Err (_) => false , } }' (Used Types: {"T"})
      - 'unsafe { let ptr = storage . as_mut_ptr () ; let len = storage . len () ; let cap = storage . capacity () ; mem :: forget (storage) ; Vec :: < T > :: from_raw_parts (ptr . cast () , len , cap) }' (Used Types: {"T"})
      - 'unsafe { self_ . table . drop_elements :: < T > () ; }' (Used Types: {"T"})
      - 'unsafe { use crate :: AllocErr ; let new_cap = match strategy { Exact => { used_cap . checked_add (needed_extra_cap) . ok_or (CapacityOverflow) ? } Amortized => self . amortized_new_size (used_cap , needed_extra_cap) ? , } ; let new_layout = Layout :: array :: < T > (new_cap) . map_err (| _ | CapacityOverflow) ? ; alloc_guard (new_layout . size ()) ? ; let res = match self . current_layout () { Some (layout) => { if true { if ! (new_layout . align () == layout . align ()) { :: core :: panicking :: panic ("assertion failed: new_layout.align() == layout.align()" ,) } } self . a . realloc (self . ptr . cast () , layout , new_layout . size ()) } None => Alloc :: alloc (& mut self . a , new_layout) , } ; if let (Err (AllocErr) , Infallible) = (& res , fallibility) { handle_alloc_error (new_layout) ; } self . ptr = res ? . cast () ; self . cap = new_cap ; Ok (()) }' (Used Types: {"T"})
    Depth 3: (Count: 1)
      - 'unsafe { self . drop_elements :: < T > () ; self . free_buckets (alloc , table_layout) ; }' (Used Types: {"T"})
    Depth 4: (Count: 3)
      - 'unsafe { let align = mem :: align_of :: < T > () ; let size = mem :: size_of :: < T > () * self . cap ; Some (Layout :: from_size_align_unchecked (size , align)) }' (Used Types: {"T"})
      - 'unsafe { let mut self_ = guard (self , | self_ | { self_ . clear_no_drop () ; } ,) ; self_ . table . drop_elements :: < T > () ; if self_ . buckets () != source . buckets () { let new_inner = match RawTableInner :: new_uninitialized (& self_ . alloc , Self :: TABLE_LAYOUT , source . buckets () , Fallibility :: Infallible ,) { Ok (table) => table , Err (_) => hint :: unreachable_unchecked () , } ; let mut old_inner = mem :: replace (& mut self_ . table , new_inner) ; if ! old_inner . is_empty_singleton () { old_inner . free_buckets (& self_ . alloc , Self :: TABLE_LAYOUT) ; } } self_ . clone_from_spec (source) ; ScopeGuard :: into_inner (self_) ; }' (Used Types: {"T"})
      - 'unsafe { let old_size = elem_size * self . cap ; let new_size = elem_size * amount ; let align = mem :: align_of :: < T > () ; let old_layout = Layout :: from_size_align_unchecked (old_size , align ,) ; match self . a . realloc (self . ptr . cast () , old_layout , new_size) { Ok (p) => self . ptr = p . cast () , Err (_) => { handle_alloc_error (Layout :: from_size_align_unchecked (new_size , align) ,) } } }' (Used Types: {"T"})
  Expressions using 'T' with 1 other type(s):
    Depth 2: (Count: 6)
      - 'unsafe { let hole : * mut T = & mut self [index] ; let last = ptr :: read (self . get_unchecked (self . len - 1)) ; self . len -= 1 ; ptr :: replace (hole , last) }' (Used Types: {"* mut T", "T"})
      - 'unsafe { let p = self . alloc_layout (layout) ; let p = p . as_ptr () as * mut T ; inner_writer (p , f) ; & mut * p }' (Used Types: {"* mut T", "T"})
      - 'unsafe { let ptr = vec . as_mut_ptr () ; let len = vec . len () ; let cap = vec . capacity () ; mem :: forget (vec) ; Vec :: < MaybeUninit < T > > :: from_raw_parts (ptr . cast () , len , cap) }' (Used Types: {"MaybeUninit", "T"})
      - 'unsafe { self . table . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; }' (Used Types: {"T", "_"})
      - 'unsafe { self . table . reserve_rehash_inner (& self . alloc , additional , & | table , index | hasher (table . bucket :: < T > (index) . as_ref ()) , fallibility , Self :: TABLE_LAYOUT , if T :: NEEDS_DROP { Some (| ptr | ptr :: drop_in_place (ptr as * mut T)) } else { None } ,) }' (Used Types: {"T", "* mut T"})
      - 'unsafe { slice :: from_raw_parts_mut (self . ptr as * mut T , self . len ()) }' (Used Types: {"* mut T", "T"})
    Depth 3: (Count: 1)
      - 'unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; }' (Used Types: {"T", "_"})
  Expressions using 'T' with 2 other type(s):
    Depth 2: (Count: 4)
      - 'unsafe { if self . end == self . ptr { None } else if mem :: size_of :: < T > () == 0 { self . end = arith_offset (self . end as * const i8 , - 1) as * mut T ; Some (mem :: zeroed ()) } else { self . end = self . end . offset (- 1) ; Some (ptr :: read (self . end)) } }' (Used Types: {"T", "* const i8", "* mut T"})
      - 'unsafe { let begin = self . as_mut_ptr () ; let end = if mem :: size_of :: < T > () == 0 { arith_offset (begin as * const i8 , self . len () as isize) as * const T } else { begin . add (self . len ()) as * const T } ; mem :: forget (self) ; IntoIter { phantom : PhantomData , ptr : begin , end , } }' (Used Types: {"* const T", "T", "* const i8"})
      - 'unsafe { let slice = slice :: from_raw_parts_mut (self . as_mut_ptr () , self . len) ; let output : Box < 'bump , [T] > = Box :: from_raw (slice) ; mem :: forget (self) ; output }' (Used Types: {"T", "Box", "[T]"})
      - 'unsafe { while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } } None }' (Used Types: {"T", "* const T", "* mut T"})
  Expressions using 'T' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"dyn Any", "* mut dyn Any", "T", "* mut T"})
  Expressions using 'T' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) } }' (Used Types: {"* const _", "_", "* mut T", "T", "* const i8"})
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"* mut T", "T", "* mut (dyn Any + Send)", "(dyn Any + Send)", "dyn Any + Send"})
  Expressions using 'T' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

--- AST Node Type: While ---
  Expressions using 'T' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'while self . idx != self . old_len { let i = self . idx ; self . idx += 1 ; let v = slice :: from_raw_parts_mut (self . vec . as_mut_ptr () , self . old_len ,) ; if (self . pred) (& mut v [i]) { self . del += 1 ; return Some (ptr :: read (& v [i])) ; } else if self . del > 0 { let del = self . del ; let src : * const T = & v [i] ; let dst : * mut T = & mut v [i - del] ; ptr :: copy_nonoverlapping (src , dst , 1) ; } }' (Used Types: {"T", "* mut T", "* const T"})

### Analyzing expressions using type: 'T1' ###

--- AST Node Type: Block ---
  Expressions using 'T1' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < str > > () { } fn propagate_ref < T1 : AsRef < str > , T2 : AsRef < str > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < str > > () { } fn propagate_mut < T1 : AsMut < str > , T2 : AsMut < str > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Either", "T1", "T2"})
  Expressions using 'T1' with 3 other type(s):
    Depth 2: (Count: 3)
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: CStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: CStr > , T2 : AsRef < :: std :: ffi :: CStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: CStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: CStr > , T2 : AsMut < :: std :: ffi :: CStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"CStr", "T2", "T1", "Either"})
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: OsStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: OsStr > , T2 : AsRef < :: std :: ffi :: OsStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: OsStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: OsStr > , T2 : AsMut < :: std :: ffi :: OsStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"T2", "T1", "Either", "OsStr"})
      - '{ fn check_ref < T : AsRef < :: std :: path :: Path > > () { } fn propagate_ref < T1 : AsRef < :: std :: path :: Path > , T2 : AsRef < :: std :: path :: Path > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: path :: Path > > () { } fn propagate_mut < T1 : AsMut < :: std :: path :: Path > , T2 : AsMut < :: std :: path :: Path > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Path", "T2", "Either", "T1"})

--- AST Node Type: Call ---
  Expressions using 'T1' with 2 other type(s):
    Depth 4: (Count: 2)
      - 'check_mut :: < Either < T1 , T2 > > ()' (Used Types: {"T1", "T2", "Either"})
      - 'check_ref :: < Either < T1 , T2 > > ()' (Used Types: {"T2", "Either", "T1"})
  Expressions using 'T1' with 3 other type(s):
    Depth 3: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T2", "T1", "Either"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T1", "Either", "T2"})

--- AST Node Type: Path ---
  Expressions using 'T1' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'check_mut :: < Either < T1 , T2 > >' (Used Types: {"Either", "T1", "T2"})
      - 'check_ref :: < Either < T1 , T2 > >' (Used Types: {"T1", "T2", "Either"})
  Expressions using 'T1' with 3 other type(s):
    Depth 4: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ >' (Used Types: {"T2", "T1", "Either", "_"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ >' (Used Types: {"_", "T2", "Either", "T1"})

### Analyzing expressions using type: 'T2' ###

--- AST Node Type: Block ---
  Expressions using 'T2' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ fn check_ref < T : AsRef < str > > () { } fn propagate_ref < T1 : AsRef < str > , T2 : AsRef < str > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < str > > () { } fn propagate_mut < T1 : AsMut < str > , T2 : AsMut < str > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Either", "T1", "T2"})
  Expressions using 'T2' with 3 other type(s):
    Depth 2: (Count: 3)
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: CStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: CStr > , T2 : AsRef < :: std :: ffi :: CStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: CStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: CStr > , T2 : AsMut < :: std :: ffi :: CStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"CStr", "T2", "T1", "Either"})
      - '{ fn check_ref < T : AsRef < :: std :: ffi :: OsStr > > () { } fn propagate_ref < T1 : AsRef < :: std :: ffi :: OsStr > , T2 : AsRef < :: std :: ffi :: OsStr > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: ffi :: OsStr > > () { } fn propagate_mut < T1 : AsMut < :: std :: ffi :: OsStr > , T2 : AsMut < :: std :: ffi :: OsStr > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"T2", "T1", "Either", "OsStr"})
      - '{ fn check_ref < T : AsRef < :: std :: path :: Path > > () { } fn propagate_ref < T1 : AsRef < :: std :: path :: Path > , T2 : AsRef < :: std :: path :: Path > > () { check_ref :: < Either < T1 , T2 > > () } fn check_mut < T : AsMut < :: std :: path :: Path > > () { } fn propagate_mut < T1 : AsMut < :: std :: path :: Path > , T2 : AsMut < :: std :: path :: Path > > () { check_mut :: < Either < T1 , T2 > > () } }' (Used Types: {"Path", "T2", "Either", "T1"})

--- AST Node Type: Call ---
  Expressions using 'T2' with 2 other type(s):
    Depth 4: (Count: 2)
      - 'check_mut :: < Either < T1 , T2 > > ()' (Used Types: {"T1", "T2", "Either"})
      - 'check_ref :: < Either < T1 , T2 > > ()' (Used Types: {"T2", "Either", "T1"})
  Expressions using 'T2' with 3 other type(s):
    Depth 3: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T2", "T1", "Either"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T1", "Either", "T2"})

--- AST Node Type: Path ---
  Expressions using 'T2' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'check_mut :: < Either < T1 , T2 > >' (Used Types: {"Either", "T1", "T2"})
      - 'check_ref :: < Either < T1 , T2 > >' (Used Types: {"T1", "T2", "Either"})
  Expressions using 'T2' with 3 other type(s):
    Depth 4: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ >' (Used Types: {"T2", "T1", "Either", "_"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ >' (Used Types: {"_", "T2", "Either", "T1"})

### Analyzing expressions using type: 'TArr' ###

--- AST Node Type: Block ---
  Expressions using 'TArr' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

### Analyzing expressions using type: 'Timestamp' ###

--- AST Node Type: Call ---
  Expressions using 'Timestamp' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'MaybeUninit :: < Timestamp > :: uninit ()' (Used Types: {"Timestamp"})
  Expressions using 'Timestamp' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp))' (Used Types: {"* const Timestamp", "Timestamp"})
    Depth 4: (Count: 1)
      - 'core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp)' (Used Types: {"* const Timestamp", "Timestamp"})

--- AST Node Type: Cast ---
  Expressions using 'Timestamp' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'rp0 . as_mut_ptr () as i32 as * const Timestamp' (Used Types: {"Timestamp", "* const Timestamp"})

--- AST Node Type: Match ---
  Expressions using 'Timestamp' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match ret { 0 => Ok (core :: ptr :: read (rp0 . as_mut_ptr () as i32 as * const Timestamp)) , _ => Err (Errno (ret as u16)) , }' (Used Types: {"Timestamp", "* const Timestamp"})

--- AST Node Type: Path ---
  Expressions using 'Timestamp' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'MaybeUninit :: < Timestamp > :: uninit' (Used Types: {"Timestamp"})

### Analyzing expressions using type: 'TransitProcess' ###

--- AST Node Type: Block ---
  Expressions using 'TransitProcess' with 0 other type(s):
    Depth 4: (Count: 2)
      - '{ let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: copy_with_progress (& file , & path , & file_options , _progress_handler ,) ; }' (Used Types: {"TransitProcess"})
      - '{ let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: move_file_with_progress (& file , & path , & file_options , _progress_handler ,) ; }' (Used Types: {"TransitProcess"})
    Depth 6: (Count: 2)
      - '{ let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; }' (Used Types: {"TransitProcess"})
      - '{ let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; }' (Used Types: {"TransitProcess"})
  Expressions using 'TransitProcess' with 1 other type(s):
    Depth 4: (Count: 2)
      - '{ let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - '{ let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})

--- AST Node Type: Closure ---
  Expressions using 'TransitProcess' with 0 other type(s):
    Depth 4: (Count: 1)
      - '| info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result }' (Used Types: {"TransitProcess"})
    Depth 5: (Count: 1)
      - '| info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; }' (Used Types: {"TransitProcess"})
    Depth 7: (Count: 1)
      - '| info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; }' (Used Types: {"TransitProcess"})

--- AST Node Type: ForLoop ---
  Expressions using 'TransitProcess' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'for file in dir_content . files { let mut to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_name = path . file_name () ; if file_name . is_none () { return Err (Error :: new (ErrorKind :: Other , "No file name")) ; } let file_name = file_name . unwrap () ; to . push (file_name) ; let mut file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = Path :: new (& file) . metadata () ? . len () ; let mut result_copy : Result < u64 > ; let mut work = true ; let copied_bytes = result ; while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: copy_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for file in dir_content . files { let mut to = to . to_path_buf () ; let tp = Path :: new (& file) . strip_prefix (from) ? ; let path = to . join (& tp) ; let file_name = path . file_name () ; if file_name . is_none () { return Err (Error :: new (ErrorKind :: Other , "No file name")) ; } let file_name = file_name . unwrap () ; to . push (file_name) ; let mut file_options = super :: file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = Path :: new (& file) . metadata () ? . len () ; let mut result_copy : Result < u64 > ; let mut work = true ; let copied_bytes = result ; while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: move_file_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { is_remove = false ; file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for item in list_paths { if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: copy_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } } }' (Used Types: {"TransitProcess", "Result"})
      - 'for item in list_paths { if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: move_dir_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } } }' (Used Types: {"TransitProcess", "Result"})

--- AST Node Type: If ---
  Expressions using 'TransitProcess' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: copy_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"Result", "TransitProcess"})
      - 'if item . is_dir () { if let Some (dir_name) = item . components () . last () { if let Ok (dir_name) = dir_name . as_os_str () . to_os_string () . into_string () { info_process . dir_name = dir_name ; } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFolder , "Invalid folder from")) ; } let copied_bytes = result ; let dir_options = options . clone () ; let handler = | info : dir :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . state = info . state ; let result = progress_handler (info_process . clone ()) ; match result { dir :: TransitProcessResult :: OverwriteAll => options . overwrite = true , dir :: TransitProcessResult :: SkipAll => options . skip_exist = true , _ => { } } result } ; result += dir :: move_dir_with_progress (item , & to , & dir_options , handler) ? ; } else { let mut file_options = file :: CopyOptions { overwrite : options . overwrite , skip_exist : options . skip_exist , buffer_size : options . buffer_size , } ; if let Some (file_name) = item . file_name () { if let Some (file_name) = file_name . to_str () { info_process . file_name = file_name . to_string () ; } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name") ,) ; } } else { return Err (Error :: new (ErrorKind :: InvalidFileName , "Invalid file name")) ; } info_process . file_bytes_copied = 0 ; info_process . file_total_bytes = item . metadata () ? . len () ; let copied_bytes = result ; let file_name = to . as_ref () . join (info_process . file_name . clone ()) ; let mut work = true ; let mut result_copy : Result < u64 > ; while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } } }' (Used Types: {"TransitProcess", "Result"})

--- AST Node Type: While ---
  Expressions using 'TransitProcess' with 0 other type(s):
    Depth 3: (Count: 2)
      - 'while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: copy_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } }' (Used Types: {"TransitProcess"})
      - 'while work { { let _progress_handler = | info : super :: file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = super :: file :: move_file_with_progress (& file , & path , & file_options , _progress_handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { is_remove = false ; file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } TransitProcessResult :: Skip => { is_remove = false ; file_options . skip_exist = true ; } TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } TransitProcessResult :: Retry => { } TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } }' (Used Types: {"TransitProcess"})
    Depth 5: (Count: 2)
      - 'while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: copy_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } }' (Used Types: {"TransitProcess"})
      - 'while work { { let handler = | info : file :: TransitProcess | { info_process . copied_bytes = copied_bytes + info . copied_bytes ; info_process . file_bytes_copied = info . copied_bytes ; progress_handler (info_process . clone ()) ; } ; result_copy = file :: move_file_with_progress (item , & file_name , & file_options , handler ,) ; } match result_copy { Ok (val) => { result += val ; work = false ; } Err (err) => { match err . kind { ErrorKind :: AlreadyExists => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { file_options . overwrite = true ; } dir :: TransitProcessResult :: OverwriteAll => { file_options . overwrite = true ; options . overwrite = true ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } ErrorKind :: PermissionDenied => { let mut info_process = info_process . clone () ; info_process . state = dir :: TransitState :: Exists ; let user_decide = progress_handler (info_process) ; match user_decide { dir :: TransitProcessResult :: Overwrite => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: OverwriteAll => { return Err (Error :: new (ErrorKind :: Other , "Overwrite denied for this situation!" ,) ,) ; } dir :: TransitProcessResult :: Skip => { file_options . skip_exist = true ; } dir :: TransitProcessResult :: SkipAll => { file_options . skip_exist = true ; options . skip_exist = true ; } dir :: TransitProcessResult :: Retry => { } dir :: TransitProcessResult :: ContinueOrAbort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } dir :: TransitProcessResult :: Abort => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } _ => { let err_msg = err . to_string () ; return Err (Error :: new (err . kind , err_msg . as_str ())) ; } } } } }' (Used Types: {"TransitProcess"})

### Analyzing expressions using type: 'Type' ###

--- AST Node Type: Block ---
  Expressions using 'Type' with 2 other type(s):
    Depth 2: (Count: 8)
      - '{ impl :: scale_info :: TypeInfo for ATerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("ATerm" , "typenum::array")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for type arrays."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "ATerm"})
      - '{ impl :: scale_info :: TypeInfo for B0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B0" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"B0", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for B1 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("B1" , "typenum::bit")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level bit 1."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "B1"})
      - '{ impl :: scale_info :: TypeInfo for Equal { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Equal" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Equal`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Equal", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for Greater { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Greater" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Greater`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Self", "Type", "Greater"})
      - '{ impl :: scale_info :: TypeInfo for Less { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Less" , "typenum")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["A potential output from `Cmp`, this is the type equivalent to the enum variant" , "`core::cmp::Ordering::Less`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Less"})
      - '{ impl :: scale_info :: TypeInfo for UTerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UTerm" , "typenum::uint")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for `UInt`; it always comes after the most significant" , "bit. `UTerm` by itself represents zero, which is aliased to `U0`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"UTerm", "Type", "Self"})
      - '{ impl :: scale_info :: TypeInfo for Z0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Z0" , "typenum::int")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level signed integer 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Z0"})
  Expressions using 'Type' with 5 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})
  Expressions using 'Type' with 6 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

### Analyzing expressions using type: 'U' ###

--- AST Node Type: Array ---
  Expressions using 'U' with 0 other type(s):
    Depth 9: (Count: 1)
      - '[:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]' (Used Types: {"U"})
  Expressions using 'U' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]' (Used Types: {"U", "B"})

--- AST Node Type: Block ---
  Expressions using 'U' with 0 other type(s):
    Depth 8: (Count: 1)
      - '{ f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }' (Used Types: {"U"})
  Expressions using 'U' with 5 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})
  Expressions using 'U' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})

--- AST Node Type: Call ---
  Expressions using 'U' with 0 other type(s):
    Depth 2: (Count: 6)
      - '< U as Unsigned > :: to_i128 ()' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i16 ()' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i32 ()' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i64 ()' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i8 ()' (Used Types: {"U"})
      - '< U as Unsigned > :: to_isize ()' (Used Types: {"U"})
    Depth 8: (Count: 1)
      - ':: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,])' (Used Types: {"U"})
    Depth 10: (Count: 1)
      - ':: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,)' (Used Types: {"U"})
  Expressions using 'U' with 1 other type(s):
    Depth 3: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi (self , PInt :: new ())' (Used Types: {"U", "PInt"})
      - '< f64 as Pow < PInt < U > > > :: powi (self , PInt :: new ())' (Used Types: {"PInt", "U"})
    Depth 8: (Count: 1)
      - ':: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,])' (Used Types: {"B", "U"})
  Expressions using 'U' with 2 other type(s):
    Depth 3: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32 ()' (Used Types: {"UInt", "U", "B"})
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_"})
  Expressions using 'U' with 3 other type(s):
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_", "B"})

--- AST Node Type: Closure ---
  Expressions using 'U' with 0 other type(s):
    Depth 6: (Count: 1)
      - '| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])' (Used Types: {"U"})
    Depth 7: (Count: 1)
      - '| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }' (Used Types: {"U"})

--- AST Node Type: MethodCall ---
  Expressions using 'U' with 0 other type(s):
    Depth 5: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& []))' (Used Types: {"U"})
    Depth 6: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) })' (Used Types: {"U"})
    Depth 7: (Count: 1)
      - 'f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])' (Used Types: {"U"})
    Depth 8: (Count: 1)
      - 'f . ty :: < U > () . name ("n") . type_name ("U")' (Used Types: {"U"})
    Depth 9: (Count: 2)
      - 'f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."])' (Used Types: {"U"})
      - 'f . ty :: < U > () . name ("n")' (Used Types: {"U"})
    Depth 10: (Count: 2)
      - 'f . ty :: < U > ()' (Used Types: {"U"})
      - 'f . ty :: < U > () . name ("msb") . type_name ("U")' (Used Types: {"U"})
  Expressions using 'U' with 1 other type(s):
    Depth 2: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi (self , PInt :: new ()) . recip ()' (Used Types: {"U", "PInt"})
      - '< f64 as Pow < PInt < U > > > :: powi (self , PInt :: new ()) . recip ()' (Used Types: {"U", "PInt"})
    Depth 5: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) })' (Used Types: {"U", "B"})
  Expressions using 'U' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . pow (< UInt < U , B > as Unsigned > :: to_u32 ())' (Used Types: {"U", "UInt", "B"})
    Depth 4: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"_", "U", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"[_]", "_", "U"})
    Depth 5: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."])' (Used Types: {"U", "_", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."])' (Used Types: {"U", "_", "[_]"})
    Depth 6: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"_", "[_]", "U"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"U", "_", "[_]"})
  Expressions using 'U' with 3 other type(s):
    Depth 4: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,)' (Used Types: {"B", "U", "[_]", "_"})
    Depth 5: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,)' (Used Types: {"U", "B", "_", "[_]"})
    Depth 6: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,)' (Used Types: {"[_]", "_", "B", "U"})

--- AST Node Type: Path ---
  Expressions using 'U' with 0 other type(s):
    Depth 3: (Count: 6)
      - '< U as Unsigned > :: to_i128' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i16' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i32' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i64' (Used Types: {"U"})
      - '< U as Unsigned > :: to_i8' (Used Types: {"U"})
      - '< U as Unsigned > :: to_isize' (Used Types: {"U"})
  Expressions using 'U' with 1 other type(s):
    Depth 4: (Count: 2)
      - '< f32 as Pow < PInt < U > > > :: powi' (Used Types: {"PInt", "U"})
      - '< f64 as Pow < PInt < U > > > :: powi' (Used Types: {"PInt", "U"})
  Expressions using 'U' with 2 other type(s):
    Depth 4: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32' (Used Types: {"B", "UInt", "U"})

### Analyzing expressions using type: 'U1' ###

--- AST Node Type: Call ---
  Expressions using 'U1' with 1 other type(s):
    Depth 2: (Count: 1)
      - '< U1 as Shl < I > > :: shl (U1 :: new () , i)' (Used Types: {"U1", "I"})

--- AST Node Type: Path ---
  Expressions using 'U1' with 1 other type(s):
    Depth 3: (Count: 1)
      - '< U1 as Shl < I > > :: shl' (Used Types: {"I", "U1"})

### Analyzing expressions using type: 'UInt' ###

--- AST Node Type: Block ---
  Expressions using 'UInt' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})

--- AST Node Type: Call ---
  Expressions using 'UInt' with 2 other type(s):
    Depth 3: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32 ()' (Used Types: {"UInt", "U", "B"})

--- AST Node Type: MethodCall ---
  Expressions using 'UInt' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'self . pow (< UInt < U , B > as Unsigned > :: to_u32 ())' (Used Types: {"U", "UInt", "B"})

--- AST Node Type: Path ---
  Expressions using 'UInt' with 2 other type(s):
    Depth 4: (Count: 1)
      - '< UInt < U , B > as Unsigned > :: to_u32' (Used Types: {"B", "UInt", "U"})

### Analyzing expressions using type: 'UTerm' ###

--- AST Node Type: Block ---
  Expressions using 'UTerm' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for UTerm { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UTerm" , "typenum::uint")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The terminating type for `UInt`; it always comes after the most significant" , "bit. `UTerm` by itself represents zero, which is aliased to `U0`." ,] ,) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"UTerm", "Type", "Self"})

### Analyzing expressions using type: 'UnsafeCell' ###

--- AST Node Type: Cast ---
  Expressions using 'UnsafeCell' with 3 other type(s):
    Depth 7: (Count: 10)
      - 'self as * const Self as * const UnsafeCell < i16 >' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i32 >' (Used Types: {"* const UnsafeCell < i32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < i64 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i64 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < i8 >' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < i8 >", "* const Self"})
      - 'self as * const Self as * const UnsafeCell < isize >' (Used Types: {"* const UnsafeCell < isize >", "UnsafeCell", "* const Self", "Self"})
      - 'self as * const Self as * const UnsafeCell < u16 >' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < u16 >"})
      - 'self as * const Self as * const UnsafeCell < u32 >' (Used Types: {"* const UnsafeCell < u32 >", "* const Self", "Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u64 >' (Used Types: {"* const UnsafeCell < u64 >", "Self", "* const Self", "UnsafeCell"})
      - 'self as * const Self as * const UnsafeCell < u8 >' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u8 >"})
      - 'self as * const Self as * const UnsafeCell < usize >' (Used Types: {"* const UnsafeCell < usize >", "UnsafeCell", "* const Self", "Self"})
  Expressions using 'UnsafeCell' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'self as * const Self as * const UnsafeCell < * mut T >' (Used Types: {"* const Self", "UnsafeCell", "* mut T", "T", "Self", "* const UnsafeCell < * mut T >"})

--- AST Node Type: MethodCall ---
  Expressions using 'UnsafeCell' with 3 other type(s):
    Depth 3: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >)) . get ()' (Used Types: {"* const UnsafeCell < i16 >", "UnsafeCell", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >)) . get ()' (Used Types: {"* const Self", "* const UnsafeCell < i32 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >)) . get ()' (Used Types: {"* const UnsafeCell < i8 >", "Self", "* const Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >)) . get ()' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >)) . get ()' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >)) . get ()' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >)) . get ()' (Used Types: {"UnsafeCell", "* const UnsafeCell < u64 >", "* const Self", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >)) . get ()' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u8 >"})
      - '(* (self as * const Self as * const UnsafeCell < usize >)) . get ()' (Used Types: {"Self", "* const UnsafeCell < usize >", "UnsafeCell", "* const Self"})
  Expressions using 'UnsafeCell' with 5 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >)) . get ()' (Used Types: {"* const UnsafeCell < * mut T >", "* const Self", "* mut T", "Self", "UnsafeCell", "T"})

--- AST Node Type: Paren ---
  Expressions using 'UnsafeCell' with 3 other type(s):
    Depth 4: (Count: 10)
      - '(* (self as * const Self as * const UnsafeCell < i16 >))' (Used Types: {"* const Self", "* const UnsafeCell < i16 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < i32 >))' (Used Types: {"UnsafeCell", "Self", "* const UnsafeCell < i32 >", "* const Self"})
      - '(* (self as * const Self as * const UnsafeCell < i64 >))' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i64 >", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < i8 >))' (Used Types: {"* const UnsafeCell < i8 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < isize >))' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < isize >"})
      - '(* (self as * const Self as * const UnsafeCell < u16 >))' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < u16 >"})
      - '(* (self as * const Self as * const UnsafeCell < u32 >))' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < u32 >"})
      - '(* (self as * const Self as * const UnsafeCell < u64 >))' (Used Types: {"* const UnsafeCell < u64 >", "* const Self", "Self", "UnsafeCell"})
      - '(* (self as * const Self as * const UnsafeCell < u8 >))' (Used Types: {"* const Self", "* const UnsafeCell < u8 >", "UnsafeCell", "Self"})
      - '(* (self as * const Self as * const UnsafeCell < usize >))' (Used Types: {"* const Self", "* const UnsafeCell < usize >", "UnsafeCell", "Self"})
    Depth 6: (Count: 10)
      - '(self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"UnsafeCell", "* const Self", "Self", "* const UnsafeCell < i16 >"})
      - '(self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i32 >", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i64 >"})
      - '(self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < i8 >"})
      - '(self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"* const Self", "* const UnsafeCell < isize >", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '(self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"* const UnsafeCell < u32 >", "UnsafeCell", "* const Self", "Self"})
      - '(self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '(self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const Self", "UnsafeCell", "* const UnsafeCell < u8 >", "Self"})
      - '(self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"* const UnsafeCell < usize >", "Self", "* const Self", "UnsafeCell"})
  Expressions using 'UnsafeCell' with 5 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const Self as * const UnsafeCell < * mut T >))' (Used Types: {"UnsafeCell", "T", "* const Self", "Self", "* const UnsafeCell < * mut T >", "* mut T"})
    Depth 6: (Count: 1)
      - '(self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "UnsafeCell", "Self", "* const UnsafeCell < * mut T >", "* mut T", "T"})

--- AST Node Type: Unary ---
  Expressions using 'UnsafeCell' with 3 other type(s):
    Depth 5: (Count: 10)
      - '* (self as * const Self as * const UnsafeCell < i16 >)' (Used Types: {"Self", "* const UnsafeCell < i16 >", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i32 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < i64 >)' (Used Types: {"* const UnsafeCell < i64 >", "Self", "* const Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < i8 >)' (Used Types: {"UnsafeCell", "* const UnsafeCell < i8 >", "* const Self", "Self"})
      - '* (self as * const Self as * const UnsafeCell < isize >)' (Used Types: {"UnsafeCell", "* const Self", "* const UnsafeCell < isize >", "Self"})
      - '* (self as * const Self as * const UnsafeCell < u16 >)' (Used Types: {"* const UnsafeCell < u16 >", "* const Self", "Self", "UnsafeCell"})
      - '* (self as * const Self as * const UnsafeCell < u32 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - '* (self as * const Self as * const UnsafeCell < u64 >)' (Used Types: {"Self", "* const Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - '* (self as * const Self as * const UnsafeCell < u8 >)' (Used Types: {"* const UnsafeCell < u8 >", "Self", "UnsafeCell", "* const Self"})
      - '* (self as * const Self as * const UnsafeCell < usize >)' (Used Types: {"Self", "UnsafeCell", "* const Self", "* const UnsafeCell < usize >"})
  Expressions using 'UnsafeCell' with 5 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const Self as * const UnsafeCell < * mut T >)' (Used Types: {"* const Self", "* const UnsafeCell < * mut T >", "Self", "* mut T", "T", "UnsafeCell"})

--- AST Node Type: Unsafe ---
  Expressions using 'UnsafeCell' with 3 other type(s):
    Depth 2: (Count: 10)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i16 >)) . get () }' (Used Types: {"Self", "* const Self", "* const UnsafeCell < i16 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i32 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < i32 >", "Self", "* const Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i64 >)) . get () }' (Used Types: {"UnsafeCell", "Self", "* const Self", "* const UnsafeCell < i64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < i8 >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < i8 >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < isize >)) . get () }' (Used Types: {"* const Self", "Self", "* const UnsafeCell < isize >", "UnsafeCell"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u16 >)) . get () }' (Used Types: {"UnsafeCell", "* const UnsafeCell < u16 >", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u32 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u32 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u64 >)) . get () }' (Used Types: {"* const Self", "Self", "UnsafeCell", "* const UnsafeCell < u64 >"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < u8 >)) . get () }' (Used Types: {"* const UnsafeCell < u8 >", "UnsafeCell", "* const Self", "Self"})
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < usize >)) . get () }' (Used Types: {"Self", "UnsafeCell", "* const UnsafeCell < usize >", "* const Self"})
  Expressions using 'UnsafeCell' with 5 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { (* (self as * const Self as * const UnsafeCell < * mut T >)) . get () }' (Used Types: {"T", "UnsafeCell", "* mut T", "* const UnsafeCell < * mut T >", "* const Self", "Self"})

### Analyzing expressions using type: 'Unstructured' ###

--- AST Node Type: Block ---
  Expressions using 'Unstructured' with 6 other type(s):
    Depth 2: (Count: 8)
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for AssertionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 12u64) >> 32 { 0u64 => AssertionKind :: StartLine , 1u64 => AssertionKind :: EndLine , 2u64 => AssertionKind :: StartText , 3u64 => AssertionKind :: EndText , 4u64 => AssertionKind :: WordBoundary , 5u64 => AssertionKind :: NotWordBoundary , 6u64 => AssertionKind :: WordBoundaryStart , 7u64 => AssertionKind :: WordBoundaryEnd , 8u64 => AssertionKind :: WordBoundaryStartAngle , 9u64 => AssertionKind :: WordBoundaryEndAngle , 10u64 => AssertionKind :: WordBoundaryStartHalf , 11u64 => AssertionKind :: WordBoundaryEndHalf , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "AssertionKind", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Self", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAsciiKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 14u64) >> 32 { 0u64 => ClassAsciiKind :: Alnum , 1u64 => ClassAsciiKind :: Alpha , 2u64 => ClassAsciiKind :: Ascii , 3u64 => ClassAsciiKind :: Blank , 4u64 => ClassAsciiKind :: Cntrl , 5u64 => ClassAsciiKind :: Digit , 6u64 => ClassAsciiKind :: Graph , 7u64 => ClassAsciiKind :: Lower , 8u64 => ClassAsciiKind :: Print , 9u64 => ClassAsciiKind :: Punct , 10u64 => ClassAsciiKind :: Space , 11u64 => ClassAsciiKind :: Upper , 12u64 => ClassAsciiKind :: Word , 13u64 => ClassAsciiKind :: Xdigit , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "ClassAsciiKind", "Option", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerlKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassPerlKind :: Digit , 1u64 => ClassPerlKind :: Space , 2u64 => ClassPerlKind :: Word , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "ClassPerlKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassSetBinaryOpKind :: Intersection , 1u64 => ClassSetBinaryOpKind :: Difference , 2u64 => ClassSetBinaryOpKind :: SymmetricDifference , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"ClassSetBinaryOpKind", "(usize , :: core :: option :: Option < usize >)", "Option", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicodeOpKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => ClassUnicodeOpKind :: Equal , 1u64 => ClassUnicodeOpKind :: Colon , 2u64 => ClassUnicodeOpKind :: NotEqual , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Result", "ClassUnicodeOpKind", "Unstructured", "Self", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flag { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => Flag :: CaseInsensitive , 1u64 => Flag :: MultiLine , 2u64 => Flag :: DotMatchesNewLine , 3u64 => Flag :: SwapGreed , 4u64 => Flag :: Unicode , 5u64 => Flag :: CRLF , 6u64 => Flag :: IgnoreWhitespace , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Result", "Option", "Self", "Flag"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for HexLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 3u64) >> 32 { 0u64 => HexLiteralKind :: X , 1u64 => HexLiteralKind :: UnicodeShort , 2u64 => HexLiteralKind :: UnicodeLong , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "Unstructured", "Option"})
      - '{ # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SpecialLiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ?) * 7u64) >> 32 { 0u64 => SpecialLiteralKind :: Bell , 1u64 => SpecialLiteralKind :: FormFeed , 2u64 => SpecialLiteralKind :: Tab , 3u64 => SpecialLiteralKind :: LineFeed , 4u64 => SpecialLiteralKind :: CarriageReturn , 5u64 => SpecialLiteralKind :: VerticalTab , 6u64 => SpecialLiteralKind :: Space , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { < u32 as arbitrary :: Arbitrary > :: size_hint (depth) } } }' (Used Types: {"SpecialLiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Result"})
  Expressions using 'Unstructured' with 10 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Position : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Position { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (u) ? , line : arbitrary :: Arbitrary :: arbitrary (u) ? , column : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Position , | mut u | { Ok (Position { offset : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , line : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , column : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < usize as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "Cell", "EagerStorage", "Position", "Self", "Option", "Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (u) ? , arbitrary :: Arbitrary :: arbitrary (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionRange , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { RepetitionRange :: Exactly (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { RepetitionRange :: AtLeast (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { RepetitionRange :: Bounded (arbitrary :: Arbitrary :: arbitrary (& mut u) ? , arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Cell", "EagerStorage", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "Result", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Option", "MaxRecursionReached", "RepetitionRange"})
  Expressions using 'Unstructured' with 11 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Comment : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Comment { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (u) ? , comment : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Comment , | mut u | { Ok (Comment { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comment : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Self", "& mut arbitrary :: Unstructured < 'arbitrary >", "Cell", "Comment", "LocalKey", "Option", "Result", "Span", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ErrorKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ErrorKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ErrorKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 34u64) >> 32 { 0u64 => ErrorKind :: CaptureLimitExceeded , 1u64 => ErrorKind :: ClassEscapeInvalid , 2u64 => ErrorKind :: ClassRangeInvalid , 3u64 => ErrorKind :: ClassRangeLiteral , 4u64 => ErrorKind :: ClassUnclosed , 5u64 => ErrorKind :: DecimalEmpty , 6u64 => ErrorKind :: DecimalInvalid , 7u64 => ErrorKind :: EscapeHexEmpty , 8u64 => ErrorKind :: EscapeHexInvalid , 9u64 => ErrorKind :: EscapeHexInvalidDigit , 10u64 => ErrorKind :: EscapeUnexpectedEof , 11u64 => ErrorKind :: EscapeUnrecognized , 12u64 => ErrorKind :: FlagDanglingNegation , 13u64 => { ErrorKind :: FlagDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 14u64 => { ErrorKind :: FlagRepeatedNegation { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 15u64 => ErrorKind :: FlagUnexpectedEof , 16u64 => ErrorKind :: FlagUnrecognized , 17u64 => { ErrorKind :: GroupNameDuplicate { original : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 18u64 => ErrorKind :: GroupNameEmpty , 19u64 => ErrorKind :: GroupNameInvalid , 20u64 => ErrorKind :: GroupNameUnexpectedEof , 21u64 => ErrorKind :: GroupUnclosed , 22u64 => ErrorKind :: GroupUnopened , 23u64 => { ErrorKind :: NestLimitExceeded (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 24u64 => ErrorKind :: RepetitionCountInvalid , 25u64 => ErrorKind :: RepetitionCountDecimalEmpty , 26u64 => ErrorKind :: RepetitionCountUnclosed , 27u64 => ErrorKind :: RepetitionMissing , 28u64 => ErrorKind :: SpecialWordBoundaryUnclosed , 29u64 => ErrorKind :: SpecialWordBoundaryUnrecognized , 30u64 => ErrorKind :: SpecialWordOrRepetitionUnexpectedEof , 31u64 => ErrorKind :: UnicodeClassInvalid , 32u64 => ErrorKind :: UnsupportedBackreference , 33u64 => ErrorKind :: UnsupportedLookAround , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "EagerStorage", "Cell", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "ErrorKind", "Unstructured", "Option", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItemKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItemKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItemKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => FlagsItemKind :: Negation , 1u64 => { FlagsItemKind :: Flag (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flag as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Flag", "Result", "Self", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "FlagsItemKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "Cell", "Option", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 4u64) >> 32 { 0u64 => RepetitionKind :: ZeroOrOne , 1u64 => RepetitionKind :: ZeroOrMore , 2u64 => RepetitionKind :: OneOrMore , 3u64 => { RepetitionKind :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< RepetitionRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Option", "Cell", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "Unstructured", "Result", "Self", "LocalKey", "RepetitionKind", "MaxRecursionReached", "(usize , :: core :: option :: Option < usize >)", "RepetitionRange"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Span : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Span { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Span , | mut u | { Ok (Span { start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Position as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Option", "Self", "Position", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Span"})
  Expressions using 'Unstructured' with 12 other type(s):
    Depth 2: (Count: 14)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Assertion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Assertion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Assertion , | mut u | { Ok (Assertion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < AssertionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Assertion", "MaxRecursionReached", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "Span", "Result", "LocalKey", "Option", "AssertionKind", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassAscii : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassAscii { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassAscii , | mut u | { Ok (ClassAscii { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassAsciiKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Span", "ClassAsciiKind", "Unstructured", "LocalKey", "EagerStorage", "Result", "Cell", "ClassAscii", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "(usize , :: core :: option :: Option < usize >)", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassBracketed : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassBracketed { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassBracketed , | mut u | { Ok (ClassBracketed { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSet as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Span", "LocalKey", "MaxRecursionReached", "Option", "Unstructured", "ClassSet", "& mut arbitrary :: Unstructured < 'arbitrary >", "EagerStorage", "ClassBracketed", "Result", "(usize , :: core :: option :: Option < usize >)", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassPerl : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassPerl { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassPerl , | mut u | { Ok (ClassPerl { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassPerlKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassPerl", "Span", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassPerlKind", "LocalKey", "EagerStorage", "Result", "Cell", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "Unstructured"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSet : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSet { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 2u64) >> 32 { 0u64 => ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSet , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 2u64) >> 32 { 0u64 => { ClassSet :: Item (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSet :: BinaryOp (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< ClassSetItem as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetBinaryOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"ClassSetItem", "ClassSetBinaryOp", "Result", "MaxRecursionReached", "Unstructured", "EagerStorage", "Cell", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "Self", "ClassSet"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetRange : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetRange { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (u) ? , start : arbitrary :: Arbitrary :: arbitrary (u) ? , end : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetRange , | mut u | { Ok (ClassSetRange { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , start : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , end : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "(usize , :: core :: option :: Option < usize >)", "Option", "Literal", "Span", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "LocalKey", "ClassSetRange", "Unstructured", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassUnicode : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassUnicode { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (u) ? , negated : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassUnicode , | mut u | { Ok (ClassUnicode { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , negated : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassUnicodeKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Span", "Option", "ClassUnicodeKind", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "LocalKey", "Cell", "Result", "ClassUnicode", "Self", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Error : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Error { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (u) ? , span : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Error , | mut u | { Ok (Error { kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , pattern : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , span : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< ErrorKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < String as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "LocalKey", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Cell", "Error", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "MaxRecursionReached", "ErrorKind", "Span"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_FlagsItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for FlagsItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_FlagsItem , | mut u | { Ok (FlagsItem { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < FlagsItemKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Unstructured", "EagerStorage", "Self", "FlagsItemKind", "Result", "(usize , :: core :: option :: Option < usize >)", "Span", "LocalKey", "Cell", "FlagsItem", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_GroupKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for GroupKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (u) ? , name : arbitrary :: Arbitrary :: arbitrary (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_GroupKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 3u64) >> 32 { 0u64 => { GroupKind :: CaptureIndex (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { GroupKind :: CaptureName { starts_with_p : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , name : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , } } 2u64 => { GroupKind :: NonCapturing (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< u32 as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < CaptureName as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Flags", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Unstructured", "Result", "LocalKey", "EagerStorage", "(usize , :: core :: option :: Option < usize >)", "MaxRecursionReached", "CaptureName", "Cell", "GroupKind"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Literal : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Literal { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , c : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Literal , | mut u | { Ok (Literal { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , c : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < LiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < char as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Literal", "Span", "MaxRecursionReached", "LiteralKind", "Unstructured", "Cell", "EagerStorage", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Self", "Option"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_LiteralKind : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for LiteralKind { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_LiteralKind , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 7u64) >> 32 { 0u64 => LiteralKind :: Verbatim , 1u64 => LiteralKind :: Meta , 2u64 => LiteralKind :: Superfluous , 3u64 => LiteralKind :: Octal , 4u64 => { LiteralKind :: HexFixed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { LiteralKind :: HexBrace (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { LiteralKind :: Special (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [])) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< HexLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< SpecialLiteralKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"EagerStorage", "Unstructured", "Cell", "MaxRecursionReached", "Option", "(usize , :: core :: option :: Option < usize >)", "HexLiteralKind", "LiteralKind", "& mut arbitrary :: Unstructured < 'arbitrary >", "LocalKey", "Result", "SpecialLiteralKind", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_RepetitionOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for RepetitionOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_RepetitionOp , | mut u | { Ok (RepetitionOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ,) } } }' (Used Types: {"Self", "Unstructured", "Result", "(usize , :: core :: option :: Option < usize >)", "RepetitionOp", "LocalKey", "Option", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >", "Span", "RepetitionKind", "Cell", "EagerStorage"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_SetFlags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for SetFlags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , flags : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_SetFlags , | mut u | { Ok (SetFlags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , flags : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Flags as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "MaxRecursionReached", "EagerStorage", "Flags", "Span", "Cell", "Result", "Self", "Unstructured", "LocalKey", "SetFlags"})
  Expressions using 'Unstructured' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Unstructured' with 14 other type(s):
    Depth 2: (Count: 3)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetBinaryOp : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetBinaryOp { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (u) ? , rhs : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetBinaryOp , | mut u | { Ok (ClassSetBinaryOp { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , lhs : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , rhs : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < ClassSetBinaryOpKind as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < ClassSet , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "Unstructured", "Span", "Cell", "MaxRecursionReached", "ClassSetBinaryOp", "(usize , :: core :: option :: Option < usize >)", "ClassSetBinaryOpKind", "Box", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassSet", "Result", "LocalKey", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Group : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Group { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (u) ? , kind : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Group , | mut u | { Ok (Group { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , kind : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < GroupKind as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"EagerStorage", "Group", "Box", "Cell", "LocalKey", "Option", "Result", "Span", "Unstructured", "Self", "(usize , :: core :: option :: Option < usize >)", "Ast", "& mut arbitrary :: Unstructured < 'arbitrary >", "GroupKind", "MaxRecursionReached"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Repetition : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Repetition { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (u) ? , op : arbitrary :: Arbitrary :: arbitrary (u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (u) ? , ast : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Repetition , | mut u | { Ok (Repetition { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , op : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , greedy : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , ast : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < RepetitionOp as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? , < bool as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Box < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Option", "& mut arbitrary :: Unstructured < 'arbitrary >", "Self", "Repetition", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "Span", "EagerStorage", "Result", "Box", "Cell", "Ast", "MaxRecursionReached", "LocalKey", "RepetitionOp"})
  Expressions using 'Unstructured' with 19 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetItem : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetItem { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary (u) ?) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary (u) ?) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetItem , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 8u64) >> 32 { 0u64 => { ClassSetItem :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 1u64 => { ClassSetItem :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 2u64 => { ClassSetItem :: Range (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 3u64 => { ClassSetItem :: Ascii (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 4u64 => { ClassSetItem :: Unicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { ClassSetItem :: Perl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { ClassSetItem :: Bracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { ClassSetItem :: Union (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Literal as arbitrary :: Arbitrary > :: try_size_hint (depth) ?] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetRange as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassAscii as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassUnicode as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassPerl as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< ClassSetUnion as arbitrary :: Arbitrary > :: try_size_hint (depth ,) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"Self", "Literal", "ClassSetUnion", "ClassPerl", "Span", "Unstructured", "ClassSetItem", "Cell", "MaxRecursionReached", "Box", "& mut arbitrary :: Unstructured < 'arbitrary >", "(usize , :: core :: option :: Option < usize >)", "ClassBracketed", "Result", "Option", "ClassSetRange", "ClassUnicode", "LocalKey", "EagerStorage", "ClassAscii"})
  Expressions using 'Unstructured' with 22 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Ast : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Ast { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (u) ? ,) * 12u64) >> 32 { 0u64 => Ast :: Empty (arbitrary :: Arbitrary :: arbitrary (u) ?) , 1u64 => Ast :: Flags (arbitrary :: Arbitrary :: arbitrary (u) ?) , 2u64 => Ast :: Literal (arbitrary :: Arbitrary :: arbitrary (u) ?) , 3u64 => Ast :: Dot (arbitrary :: Arbitrary :: arbitrary (u) ?) , 4u64 => Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary (u) ?) , 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary (u) ?) } 6u64 => Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary (u) ?) , 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary (u) ?) } 8u64 => Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary (u) ?) , 9u64 => Ast :: Group (arbitrary :: Arbitrary :: arbitrary (u) ?) , 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary (u) ?) } 11u64 => Ast :: Concat (arbitrary :: Arbitrary :: arbitrary (u) ?) , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Ast , | mut u | { Ok (match (u64 :: from (< u32 as arbitrary :: Arbitrary > :: arbitrary (& mut u) ? ,) * 12u64) >> 32 { 0u64 => { Ast :: Empty (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 1u64 => { Ast :: Flags (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 2u64 => { Ast :: Literal (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 3u64 => { Ast :: Dot (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 4u64 => { Ast :: Assertion (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 5u64 => { Ast :: ClassUnicode (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 6u64 => { Ast :: ClassPerl (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 7u64 => { Ast :: ClassBracketed (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 8u64 => { Ast :: Repetition (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 9u64 => { Ast :: Group (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } 10u64 => { Ast :: Alternation (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? ,) } 11u64 => { Ast :: Concat (arbitrary :: Arbitrary :: arbitrary_take_rest (u) ?) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ,) } ,) } fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { Ok (arbitrary :: size_hint :: and (< u32 as arbitrary :: Arbitrary > :: size_hint (depth) , arbitrary :: size_hint :: try_recursion_guard (depth , | depth | { Ok (arbitrary :: size_hint :: or_all (& [Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < SetFlags , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Literal , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Span > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Assertion , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassUnicode , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassPerl , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < ClassBracketed , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Repetition , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Group > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Alternation , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? , Ok (arbitrary :: size_hint :: and_all (& [< Box < Concat > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ? ,] ,) ,) } ,) ? ,) ,) } } }' (Used Types: {"LocalKey", "EagerStorage", "Option", "Alternation", "SetFlags", "Box", "Span", "Concat", "Assertion", "& mut arbitrary :: Unstructured < 'arbitrary >", "ClassBracketed", "Unstructured", "Self", "ClassUnicode", "Group", "Cell", "Ast", "MaxRecursionReached", "ClassPerl", "Result", "(usize , :: core :: option :: Option < usize >)", "Repetition", "Literal"})

### Analyzing expressions using type: 'V' ###

--- AST Node Type: Array ---
  Expressions using 'V' with 1 other type(s):
    Depth 9: (Count: 1)
      - '[:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]' (Used Types: {"V", "A"})

--- AST Node Type: Block ---
  Expressions using 'V' with 0 other type(s):
    Depth 8: (Count: 1)
      - '{ f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }' (Used Types: {"V"})
  Expressions using 'V' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

--- AST Node Type: Call ---
  Expressions using 'V' with 0 other type(s):
    Depth 10: (Count: 1)
      - ':: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,)' (Used Types: {"V"})
  Expressions using 'V' with 1 other type(s):
    Depth 8: (Count: 1)
      - ':: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,])' (Used Types: {"A", "V"})
  Expressions using 'V' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve (self , additional)' (Used Types: {"(K , V)", "K", "V"})
    Depth 3: (Count: 3)
      - 'make_hasher :: < _ , V , S > (& self . hash_builder)' (Used Types: {"V", "S", "_"})
      - 'make_hasher :: < _ , V , S > (& self . table . hash_builder)' (Used Types: {"_", "S", "V"})
      - 'make_hasher :: < _ , V , S > (self . hash_builder)' (Used Types: {"_", "V", "S"})
  Expressions using 'V' with 3 other type(s):
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,)' (Used Types: {"[_]", "_", "A", "V"})

--- AST Node Type: Closure ---
  Expressions using 'V' with 0 other type(s):
    Depth 7: (Count: 1)
      - '| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }' (Used Types: {"V"})

--- AST Node Type: MethodCall ---
  Expressions using 'V' with 0 other type(s):
    Depth 6: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) })' (Used Types: {"V"})
    Depth 9: (Count: 1)
      - 'f . ty :: < V > () . name ("first") . type_name ("V") . docs (& [])' (Used Types: {"V"})
    Depth 10: (Count: 1)
      - 'f . ty :: < V > () . name ("first") . type_name ("V")' (Used Types: {"V"})
  Expressions using 'V' with 1 other type(s):
    Depth 5: (Count: 1)
      - ':: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& []))' (Used Types: {"V", "A"})
  Expressions using 'V' with 2 other type(s):
    Depth 2: (Count: 11)
      - 'self . table . insert (hash , (k , v) , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"S", "V", "_"})
      - 'self . table . insert (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder))' (Used Types: {"S", "_", "V"})
      - 'self . table . insert_entry (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder) ,)' (Used Types: {"_", "V", "S"})
      - 'self . table . reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'self . table . shrink_to (0 , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "_", "S"})
      - 'self . table . shrink_to (min_capacity , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "S", "_"})
      - 'self . table . table . insert (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'self . table . table . insert (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"V", "S", "_"})
      - 'self . table . try_reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'table . insert_entry (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'table . insert_entry (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
  Expressions using 'V' with 3 other type(s):
    Depth 4: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,)' (Used Types: {"[_]", "V", "A", "_"})
    Depth 5: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,)' (Used Types: {"A", "[_]", "V", "_"})
    Depth 6: (Count: 1)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,)' (Used Types: {"V", "A", "_", "[_]"})

--- AST Node Type: Path ---
  Expressions using 'V' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'Extend :: < (K , V) > :: extend_reserve' (Used Types: {"(K , V)", "V", "K"})
    Depth 4: (Count: 1)
      - 'make_hasher :: < _ , V , S >' (Used Types: {"_", "V", "S"})

### Analyzing expressions using type: 'Value' ###

--- AST Node Type: Block ---
  Expressions using 'Value' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using 'Value' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Value' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'KeyValues (& None :: < (kv :: Key , kv :: Value) >)' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: If ---
  Expressions using 'Value' with 11 other type(s):
    Depth 2: (Count: 1)
      - 'if deserializer . is_human_readable () { struct FlagsVisitor < B > (core :: marker :: PhantomData < B >) ; impl < 'de , B : Flags > Visitor < 'de > for FlagsVisitor < B > where B :: Bits : ParseHex , { type Value = B ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ > ,) -> fmt :: Result { formatter . write_str ("a string value of `|` separated flags") } fn visit_str < E : Error > (self , flags : & str) -> Result < Self :: Value , E > { parser :: from_str (flags) . map_err (| e | E :: custom (e)) } } deserializer . deserialize_str (FlagsVisitor (Default :: default ())) } else { let bits = B :: Bits :: deserialize (deserializer) ? ; Ok (B :: from_bits_retain (bits)) }' (Used Types: {"B", "& Self", "E", "Bits", "Result", "PhantomData", "& str", "& mut fmt :: Formatter < '_ >", "FlagsVisitor", "Self", "Value", "Formatter"})

--- AST Node Type: Path ---
  Expressions using 'Value' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'None :: < (kv :: Key , kv :: Value) >' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

--- AST Node Type: Reference ---
  Expressions using 'Value' with 2 other type(s):
    Depth 5: (Count: 1)
      - '& None :: < (kv :: Key , kv :: Value) >' (Used Types: {"Value", "(kv :: Key , kv :: Value)", "Key"})

--- AST Node Type: Struct ---
  Expressions using 'Value' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'RecordBuilder { record : Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , } , }' (Used Types: {"(kv :: Key , kv :: Value)", "Value", "Key"})
    Depth 3: (Count: 1)
      - 'Record { args : format_args ! ("") , metadata : Metadata :: builder () . build () , module_path : None , file : None , line : None , key_values : KeyValues (& None :: < (kv :: Key , kv :: Value) >) , }' (Used Types: {"(kv :: Key , kv :: Value)", "Key", "Value"})

### Analyzing expressions using type: 'ValueType' ###

--- AST Node Type: Call ---
  Expressions using 'ValueType' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'std :: mem :: replace (self . map . as_mut () . expect ("callers have to ensure map is allocated") , :: alloc :: vec :: from_elem (GrowingHashmapMapElemChar :: < ValueType > :: default () , new_size as usize ,) ,)' (Used Types: {"ValueType"})
    Depth 3: (Count: 1)
      - ':: alloc :: vec :: from_elem (GrowingHashmapMapElemChar :: < ValueType > :: default () , new_size as usize ,)' (Used Types: {"ValueType"})
    Depth 4: (Count: 1)
      - 'GrowingHashmapMapElemChar :: < ValueType > :: default ()' (Used Types: {"ValueType"})

--- AST Node Type: Path ---
  Expressions using 'ValueType' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'GrowingHashmapMapElemChar :: < ValueType > :: default' (Used Types: {"ValueType"})

### Analyzing expressions using type: 'Vec' ###

--- AST Node Type: Array ---
  Expressions using 'Vec' with 2 other type(s):
    Depth 9: (Count: 4)
      - '[< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Vec", "Comment"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "Ast"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Span", "Vec", "ClassSetItem"})
      - '[< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "FlagsItem", "Span"})

--- AST Node Type: Assign ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 8: (Count: 1)
      - '__field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,)' (Used Types: {"Block", "Vec"})

--- AST Node Type: Binary ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})
    Depth 6: (Count: 2)
      - 'dll . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"_", "Vec"})
      - 'lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})
    Depth 7: (Count: 1)
      - 'lib . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})

--- AST Node Type: Block ---
  Expressions using 'Vec' with 2 other type(s):
    Depth 7: (Count: 1)
      - '{ if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; }' (Used Types: {"Error", "Vec", "Block"})
  Expressions using 'Vec' with 13 other type(s):
    Depth 2: (Count: 5)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Alternation : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Alternation { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Alternation , | mut u | { Ok (Alternation { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"(usize , :: core :: option :: Option < usize >)", "Option", "Span", "LocalKey", "Cell", "Vec", "Self", "Ast", "Alternation", "Result", "Unstructured", "EagerStorage", "MaxRecursionReached", "& mut arbitrary :: Unstructured < 'arbitrary >"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_ClassSetUnion : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for ClassSetUnion { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_ClassSetUnion , | mut u | { Ok (ClassSetUnion { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"ClassSetUnion", "MaxRecursionReached", "Span", "Cell", "LocalKey", "Unstructured", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "& mut arbitrary :: Unstructured < 'arbitrary >", "Result", "Vec", "Option", "ClassSetItem", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Concat : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Concat { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (u) ? , asts : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Concat , | mut u | { Ok (Concat { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , asts : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"Unstructured", "Cell", "Result", "(usize , :: core :: option :: Option < usize >)", "EagerStorage", "Span", "Concat", "Ast", "MaxRecursionReached", "Option", "LocalKey", "& mut arbitrary :: Unstructured < 'arbitrary >", "Vec", "Self"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_Flags : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for Flags { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (u) ? , items : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_Flags , | mut u | { Ok (Flags { span : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , items : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "FlagsItem", "(usize , :: core :: option :: Option < usize >)", "Vec", "EagerStorage", "Self", "Unstructured", "Result", "MaxRecursionReached", "Flags", "Span", "LocalKey", "Cell"})
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})
  Expressions using 'Vec' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 7: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq)' (Used Types: {"Block", "Vec"})
    Depth 9: (Count: 1)
      - '_serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,)' (Used Types: {"Vec", "Block"})
  Expressions using 'Vec' with 2 other type(s):
    Depth 4: (Count: 4)
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Ast", "Vec", "Comment"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "Span", "ClassSetItem"})
      - 'arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 6: (Count: 4)
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Comment", "Ast", "Vec"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"ClassSetItem", "Span", "Vec"})
      - 'Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "FlagsItem", "Span"})
    Depth 7: (Count: 4)
      - 'arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Ast", "Vec", "Comment"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Span", "Vec", "Ast"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"ClassSetItem", "Vec", "Span"})
      - 'arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,)' (Used Types: {"Vec", "Span", "FlagsItem"})
  Expressions using 'Vec' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ') ,)' (Used Types: {"Result", "[u8]", "Cow", "Vec", "QuoteError"})

--- AST Node Type: Closure ---
  Expressions using 'Vec' with 2 other type(s):
    Depth 5: (Count: 4)
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Ast", "Comment"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "Span", "Ast"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"Vec", "ClassSetItem", "Span"})
      - '| depth | Ok (arbitrary :: size_hint :: and_all (& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,)' (Used Types: {"FlagsItem", "Span", "Vec"})

--- AST Node Type: ForLoop ---
  Expressions using 'Vec' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'for _iter in 0 .. 3 { let mut required_lib_order : Vec < String > = Vec :: new () ; for lib in & libs { required_lib_order . push (lib . to_owned ()) ; if let Some (pc_file) = self . locate_pc_file_by_lib (lib) { for dep in & pc_file . deps { if let Some (dep_pc_file) = self . files . get (dep) { for dep_lib in & dep_pc_file . libs { if let Some (removed) = remove_item (& mut required_lib_order , dep_lib ,) { required_lib_order . push (removed) ; } } } } } } match (& libs . len () , & required_lib_order . len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if required_lib_order == libs { return libs ; } libs = required_lib_order ; }' (Used Types: {"Vec"})
  Expressions using 'Vec' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'for line in file . lines () { let line = line . unwrap () ; let file_path = Path :: new (& line) ; if let Ok (dll) = file_path . strip_prefix (& dll_prefix) { if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; } } else if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } } }' (Used Types: {"Vec", "_"})
      - 'for line in file . lines () { let line = line . unwrap () ; let parts = line . splitn (2 , ": ") . clone () . collect :: < Vec < _ > > () ; if parts . len () == 2 { current . insert (parts [0] . trim () . into () , parts [1] . trim () . into ()) ; } else if line . len () == 0 { port_info . push (current . clone ()) ; current . clear () ; } else { } }' (Used Types: {"Vec", "_"})

--- AST Node Type: If ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'if let Ok (dll) = file_path . strip_prefix (& dll_prefix) { if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; } } else if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } }' (Used Types: {"Vec", "_"})
    Depth 4: (Count: 2)
      - 'if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; }' (Used Types: {"Vec", "_"})
      - 'if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } }' (Used Types: {"Vec", "_"})
    Depth 5: (Count: 1)
      - 'if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } }' (Used Types: {"Vec", "_"})

--- AST Node Type: Match ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } }' (Used Types: {"Vec", "Block"})
  Expressions using 'Vec' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'match paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) }) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } }' (Used Types: {"Vec", "Result", "_"})
  Expressions using 'Vec' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } }' (Used Types: {"IgnoredAny", "Error", "Vec", "Block"})

--- AST Node Type: MethodCall ---
  Expressions using 'Vec' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'self . args . iter () . map (| arg | quote_if_needed (arg . to_string_lossy () . to_string ())) . collect :: < Vec < String > > () . join (" ")' (Used Types: {"Vec"})
      - 'self . env_vars . iter () . map (| (env , arg) | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0}={1}" , env . to_string_lossy () , arg . to_string_lossy ()) ,) })) . collect :: < Vec < String > > () . join (" ")' (Used Types: {"Vec"})
    Depth 3: (Count: 2)
      - 'self . args . iter () . map (| arg | quote_if_needed (arg . to_string_lossy () . to_string ())) . collect :: < Vec < String > > ()' (Used Types: {"Vec"})
      - 'self . env_vars . iter () . map (| (env , arg) | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0}={1}" , env . to_string_lossy () , arg . to_string_lossy ()) ,) })) . collect :: < Vec < String > > ()' (Used Types: {"Vec"})
  Expressions using 'Vec' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'a . lm_into_iter () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
      - 'b . lm_into_iter () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
    Depth 3: (Count: 1)
      - 'line . splitn (2 , ": ") . clone () . collect :: < Vec < _ > > ()' (Used Types: {"_", "Vec"})
    Depth 7: (Count: 1)
      - 'dll . components () . collect :: < Vec < _ > > () . len ()' (Used Types: {"Vec", "_"})
    Depth 8: (Count: 2)
      - 'dll . components () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
      - 'lib . components () . collect :: < Vec < _ > > () . len ()' (Used Types: {"_", "Vec"})
    Depth 9: (Count: 1)
      - 'lib . components () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
  Expressions using 'Vec' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) })' (Used Types: {"Result", "_", "Vec"})
    Depth 4: (Count: 1)
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > ()' (Used Types: {"Result", "Vec", "_"})
  Expressions using 'Vec' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ')' (Used Types: {"QuoteError", "Cow", "Vec", "Result", "[u8]"})
    Depth 5: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > ()' (Used Types: {"QuoteError", "[u8]", "Cow", "Result", "Vec"})

--- AST Node Type: Path ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 8: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , >' (Used Types: {"Vec", "Block"})

--- AST Node Type: Reference ---
  Expressions using 'Vec' with 2 other type(s):
    Depth 8: (Count: 4)
      - '& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Comment", "Vec", "Ast"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Ast", "Span", "Vec"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"ClassSetItem", "Span", "Vec"})
      - '& [< Span as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,]' (Used Types: {"Vec", "Span", "FlagsItem"})

--- AST Node Type: Unknown ---
  Expressions using 'Vec' with 1 other type(s):
    Depth 6: (Count: 1)
      - '_serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ?' (Used Types: {"Vec", "Block"})
    Depth 10: (Count: 5)
      - '< Vec < Ast > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Vec", "Ast"})
      - '< Vec < ClassSetItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Vec", "ClassSetItem"})
      - '< Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"Comment", "Vec"})
      - '< Vec < FlagsItem , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ?' (Used Types: {"FlagsItem", "Vec"})
      - '_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ?' (Used Types: {"Vec", "Block"})
  Expressions using 'Vec' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ?' (Used Types: {"Vec", "Result", "QuoteError", "Cow", "[u8]"})

--- AST Node Type: While ---
  Expressions using 'Vec' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"__Field", "IgnoredAny", "Error", "Block", "Vec"})

### Analyzing expressions using type: 'Void' ###

--- AST Node Type: Call ---
  Expressions using 'Void' with 1 other type(s):
    Depth 5: (Count: 2)
      - 'Ok :: < NonZeroUsize , Void > (f ())' (Used Types: {"Void", "NonZeroUsize"})
      - 'Ok :: < T , Void > (f ())' (Used Types: {"T", "Void"})
  Expressions using 'Void' with 2 other type(s):
    Depth 5: (Count: 2)
      - 'Ok :: < & 'a T , Void > (f ())' (Used Types: {"Void", "& 'a T", "T"})
      - 'Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Closure ---
  Expressions using 'Void' with 1 other type(s):
    Depth 4: (Count: 2)
      - '| | Ok :: < NonZeroUsize , Void > (f ())' (Used Types: {"NonZeroUsize", "Void"})
      - '| | Ok :: < T , Void > (f ())' (Used Types: {"Void", "T"})
  Expressions using 'Void' with 2 other type(s):
    Depth 4: (Count: 2)
      - '| | Ok :: < & 'a T , Void > (f ())' (Used Types: {"& 'a T", "T", "Void"})
      - '| | Ok :: < Box < T > , Void > (f ())' (Used Types: {"Box", "Void", "T"})

--- AST Node Type: Match ---
  Expressions using 'Void' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'match self . get_or_try_init (| | Ok :: < NonZeroUsize , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"Void", "NonZeroUsize"})
      - 'match self . get_or_try_init (| | Ok :: < T , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"T", "Void"})
  Expressions using 'Void' with 2 other type(s):
    Depth 2: (Count: 2)
      - 'match self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"& 'a T", "T", "Void"})
      - 'match self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ())) { Ok (val) => val , Err (void) => match void { } }' (Used Types: {"Void", "T", "Box"})

--- AST Node Type: MethodCall ---
  Expressions using 'Void' with 1 other type(s):
    Depth 3: (Count: 2)
      - 'self . get_or_try_init (| | Ok :: < NonZeroUsize , Void > (f ()))' (Used Types: {"Void", "NonZeroUsize"})
      - 'self . get_or_try_init (| | Ok :: < T , Void > (f ()))' (Used Types: {"Void", "T"})
  Expressions using 'Void' with 2 other type(s):
    Depth 3: (Count: 2)
      - 'self . get_or_try_init (| | Ok :: < & 'a T , Void > (f ()))' (Used Types: {"Void", "& 'a T", "T"})
      - 'self . get_or_try_init (| | Ok :: < Box < T > , Void > (f ()))' (Used Types: {"Box", "T", "Void"})

--- AST Node Type: Path ---
  Expressions using 'Void' with 1 other type(s):
    Depth 6: (Count: 2)
      - 'Ok :: < NonZeroUsize , Void >' (Used Types: {"NonZeroUsize", "Void"})
      - 'Ok :: < T , Void >' (Used Types: {"T", "Void"})
  Expressions using 'Void' with 2 other type(s):
    Depth 6: (Count: 2)
      - 'Ok :: < & 'a T , Void >' (Used Types: {"& 'a T", "T", "Void"})
      - 'Ok :: < Box < T > , Void >' (Used Types: {"Box", "T", "Void"})

### Analyzing expressions using type: 'WithComments' ###

--- AST Node Type: Block ---
  Expressions using 'WithComments' with 13 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (non_upper_case_globals)] const RECURSIVE_COUNT_WithComments : :: std :: thread :: LocalKey < :: core :: cell :: Cell < u32 > , > = { const __INIT : :: core :: cell :: Cell < u32 > = { :: core :: cell :: Cell :: new (0) } ; unsafe { :: std :: thread :: LocalKey :: new (const { if :: std :: mem :: needs_drop :: < :: core :: cell :: Cell < u32 > > () { | _ | { # [thread_local] static VAL : :: std :: thread :: local_impl :: EagerStorage < :: core :: cell :: Cell < u32 > , > = :: std :: thread :: local_impl :: EagerStorage :: new (__INIT) ; VAL . get () } } else { | _ | { # [thread_local] static VAL : :: core :: cell :: Cell < u32 > = __INIT ; & VAL } } }) } } ; # [automatically_derived] impl < 'arbitrary > arbitrary :: Arbitrary < 'arbitrary > for WithComments { fn arbitrary (u : & mut arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (u) ? , comments : arbitrary :: Arbitrary :: arbitrary (u) ? , }) } ,) } fn arbitrary_take_rest (mut u : arbitrary :: Unstructured < 'arbitrary > ,) -> arbitrary :: Result < Self > { arbitrary :: details :: with_recursive_count (u , & RECURSIVE_COUNT_WithComments , | mut u | { Ok (WithComments { ast : arbitrary :: Arbitrary :: arbitrary (& mut u) ? , comments : arbitrary :: Arbitrary :: arbitrary_take_rest (u) ? , }) } ,) } # [inline] fn size_hint (depth : usize) -> (usize , :: core :: option :: Option < usize >) { Self :: try_size_hint (depth) . unwrap_or_default () } # [inline] fn try_size_hint (depth : usize ,) -> :: core :: result :: Result < (usize , :: core :: option :: Option < usize >) , arbitrary :: MaxRecursionReached , > { arbitrary :: size_hint :: try_recursion_guard (depth , | depth | Ok (arbitrary :: size_hint :: and_all (& [< Ast as arbitrary :: Arbitrary > :: try_size_hint (depth) ? , < Vec < Comment , > as arbitrary :: Arbitrary > :: try_size_hint (depth) ? ,] ,) ,) ,) } } }' (Used Types: {"MaxRecursionReached", "Self", "Ast", "Comment", "Vec", "Unstructured", "LocalKey", "(usize , :: core :: option :: Option < usize >)", "& mut arbitrary :: Unstructured < 'arbitrary >", "Option", "Result", "Cell", "EagerStorage", "WithComments"})

### Analyzing expressions using type: 'Z0' ###

--- AST Node Type: Block ---
  Expressions using 'Z0' with 2 other type(s):
    Depth 2: (Count: 1)
      - '{ impl :: scale_info :: TypeInfo for Z0 { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("Z0" , "typenum::int")) . type_params (:: alloc :: vec :: Vec :: new ()) . docs (& ["The type-level signed integer 0."]) . composite (:: scale_info :: build :: Fields :: unit ()) } } }' (Used Types: {"Type", "Self", "Z0"})

### Analyzing expressions using type: '[& 'static str]' ###

--- AST Node Type: Block ---
  Expressions using '[& 'static str]' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '[& 'static str]' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '[A :: Item]' ###

--- AST Node Type: Call ---
  Expressions using '[A :: Item]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice)' (Used Types: {"& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]", "Item"})

--- AST Node Type: If ---
  Expressions using '[A :: Item]' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"[A :: Item]", "& mut [u8]", "[u8]", "Item", "& mut [A :: Item]"})
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item", "& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]"})

--- AST Node Type: Path ---
  Expressions using '[A :: Item]' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] >' (Used Types: {"& mut [u8]", "& mut [A :: Item]", "[u8]", "[A :: Item]", "Item"})

--- AST Node Type: Unsafe ---
  Expressions using '[A :: Item]' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) }' (Used Types: {"[u8]", "Item", "[A :: Item]", "& mut [A :: Item]", "& mut [u8]"})

### Analyzing expressions using type: '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' ###

--- AST Node Type: Block ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Call ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }) ()' (Used Types: {"Buffer", "I", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "& str", "MaybeUninit"})

--- AST Node Type: Closure ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string }' (Used Types: {"Buffer", "& str", "I", "* mut < I as private :: Sealed > :: Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: MethodCall ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 6: (Count: 1)
      - 'i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) })' (Used Types: {"Buffer", "MaybeUninit", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "I", "* mut < I as private :: Sealed > :: Buffer"})

--- AST Node Type: Paren ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 10: (Count: 1)
      - '(& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"Buffer", "MaybeUninit", "I", "* mut < I as private :: Sealed > :: Buffer", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 6 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let i = __arg1 ; let string = i . write (unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }) ; if string . len () > I :: MAX_STR_LEN { unsafe { hint :: unreachable_unchecked () } ; } string })' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "& str", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

--- AST Node Type: Reference ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 8: (Count: 1)
      - '& mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "Buffer", "MaybeUninit", "* mut < I as private :: Sealed > :: Buffer", "I"})

--- AST Node Type: Unary ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 9: (Count: 1)
      - '* (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer)' (Used Types: {"* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "* mut < I as private :: Sealed > :: Buffer", "Buffer", "MaybeUninit", "I"})

--- AST Node Type: Unsafe ---
  Expressions using '[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]' with 5 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { & mut * (& mut self . bytes as * mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN] as * mut < I as private :: Sealed > :: Buffer) }' (Used Types: {"* mut < I as private :: Sealed > :: Buffer", "Buffer", "I", "MaybeUninit", "* mut [MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; i128 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' ###

--- AST Node Type: Block ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 3 other type(s):
    Depth 5: (Count: 1)
      - '{ if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8"})

--- AST Node Type: Call ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 2: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }) ()' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut u8", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit"})

--- AST Node Type: Cast ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 8: (Count: 1)
      - 'buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

--- AST Node Type: Closure ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } }' (Used Types: {"[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "& str", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "* mut u8"})

--- AST Node Type: If ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 6: (Count: 1)
      - 'if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } }' (Used Types: {"MaybeUninit", "* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

--- AST Node Type: Paren ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 4 other type(s):
    Depth 3: (Count: 1)
      - '(move | | -> & str { if false { loop { } # [allow (unreachable_code)] { let __self = self ; } } let buf = __arg1 ; let is_nonnegative = self >= 0 ; let n = if is_nonnegative { self as u128 } else { (! (self as u128)) . wrapping_add (1) } ; let mut curr = buf . len () ; let buf_ptr = buf . as_mut_ptr () as * mut u8 ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf1 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf1 }) . len () ; if n != 0 { let target = buf . len () - 19 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; let (n , rem) = udiv128 :: udivmod_1e19 (n) ; let buf2 = unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] } ; curr -= rem . write (unsafe { & mut * buf2 }) . len () ; if n != 0 { let target = buf . len () - 38 ; unsafe { ptr :: write_bytes (buf_ptr . add (target) , b'0' , curr - target) ; } curr = target ; curr -= 1 ; unsafe { * buf_ptr . add (curr) = (n as u8) + b'0' ; } } } if ! is_nonnegative { curr -= 1 ; unsafe { * buf_ptr . add (curr) = b'-' ; } } let len = buf . len () - curr ; let bytes = unsafe { slice :: from_raw_parts (buf_ptr . add (curr) , len) } ; unsafe { str :: from_utf8_unchecked (bytes) } })' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "* mut u8", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "& str"})

--- AST Node Type: Unsafe ---
  Expressions using '[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]' with 2 other type(s):
    Depth 7: (Count: 1)
      - 'unsafe { buf_ptr . add (curr - u64 :: MAX_STR_LEN) as * mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN] }' (Used Types: {"* mut [MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]", "MaybeUninit", "[MaybeUninit < u8 > ; u64 :: MAX_STR_LEN]"})

### Analyzing expressions using type: '[T ; N]' ###

--- AST Node Type: Cast ---
  Expressions using '[T ; N]' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'slice . as_mut_ptr () as * mut [T ; N]' (Used Types: {"* mut [T ; N]", "T", "[T ; N]"})

--- AST Node Type: If ---
  Expressions using '[T ; N]' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if slice . len () == N { let mut slice = ManuallyDrop :: new (slice) ; let ptr = slice . as_mut_ptr () as * mut [T ; N] ; Ok (unsafe { Box :: from_raw (ptr) }) } else { Err (slice) }' (Used Types: {"T", "* mut [T ; N]", "[T ; N]"})

### Analyzing expressions using type: '[T]' ###

--- AST Node Type: Unsafe ---
  Expressions using '[T]' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { let slice = slice :: from_raw_parts_mut (self . as_mut_ptr () , self . len) ; let output : Box < 'bump , [T] > = Box :: from_raw (slice) ; mem :: forget (self) ; output }' (Used Types: {"T", "Box", "[T]"})

### Analyzing expressions using type: '[_]' ###

--- AST Node Type: Await ---
  Expressions using '[_]' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))) . await' (Used Types: {"_", "[_]"})

--- AST Node Type: Block ---
  Expressions using '[_]' with 1 other type(s):
    Depth 2: (Count: 1)
      - '{ let mut names = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("lib{0}.a" , name)) }) ,]) ,) ; if false { names . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0}.lib" , name)) }) ,) ; } names }' (Used Types: {"_", "[_]"})
    Depth 3: (Count: 3)
      - '{ if ! c . is_ascii () { return Ok (None) ; } match c { 'A' ..= 'Z' | 'a' ..= 'z' => { } _ => return Ok (None) , } let mut cls = hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,) ; cls . case_fold_simple () ; Ok (Some (Hir :: class (hir :: Class :: Bytes (cls)))) }' (Used Types: {"[_]", "_"})
      - '{ let sysroot = config . env_var_os ("PKG_CONFIG_SYSROOT_DIR") . or_else (| | config . env_var_os ("SYSROOT")) . map (PathBuf :: from) ; if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) } }' (Used Types: {"[_]", "_"})
      - '{ stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,) ; }' (Used Types: {"_", "[_]"})
    Depth 4: (Count: 1)
      - '{ if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } }' (Used Types: {"_", "[_]"})
    Depth 5: (Count: 1)
      - '{ < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) }' (Used Types: {"_", "[_]"})
    Depth 6: (Count: 1)
      - '{ < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) }' (Used Types: {"[_]", "_"})
  Expressions using '[_]' with 5 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})
  Expressions using '[_]' with 6 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

--- AST Node Type: Call ---
  Expressions using '[_]' with 1 other type(s):
    Depth 2: (Count: 4)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , Hir :: empty ())]) ,)' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , empty_ast ())]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , empty_set ())]) ,)' (Used Types: {"[_]", "_"})
      - 'Literal :: exact (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])))' (Used Types: {"_", "[_]"})
    Depth 3: (Count: 8)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("lib{0}.a" , name)) }) ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([PathBuf :: from ("/Library") , PathBuf :: from ("/System") ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([range]))' (Used Types: {"_", "[_]"})
      - 'Alternation (ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , })' (Used Types: {"[_]", "_"})
      - 'Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit])))' (Used Types: {"[_]", "_"})
      - 'Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start])))' (Used Types: {"_", "[_]"})
      - 'hir :: ClassUnicode :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,) ,)' (Used Types: {"_", "[_]"})
    Depth 4: (Count: 4)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit]))' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start]))' (Used Types: {"[_]", "_"})
      - 'hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,)' (Used Types: {"_", "[_]"})
    Depth 5: (Count: 4)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))' (Used Types: {"_", "[_]"})
      - 'HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,)' (Used Types: {"[_]", "_"})
    Depth 6: (Count: 3)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte]))' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,)' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot]))' (Used Types: {"_", "[_]"})
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()]))' (Used Types: {"[_]", "_"})
  Expressions using '[_]' with 2 other type(s):
    Depth 2: (Count: 3)
      - 'Source :: count (self as & [_])' (Used Types: {"_", "& [_]", "[_]"})
      - 'Source :: get (self as & [_] , key)' (Used Types: {"& [_]", "_", "[_]"})
      - 'Source :: visit (self as & [_] , visitor)' (Used Types: {"[_]", "_", "& [_]"})
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_"})
  Expressions using '[_]' with 3 other type(s):
    Depth 7: (Count: 2)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_", "B"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,)' (Used Types: {"[_]", "_", "A", "V"})

--- AST Node Type: Cast ---
  Expressions using '[_]' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'self as & [_]' (Used Types: {"[_]", "_", "& [_]"})

--- AST Node Type: Closure ---
  Expressions using '[_]' with 1 other type(s):
    Depth 3: (Count: 1)
      - '| arg | { if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } }' (Used Types: {"_", "[_]"})

--- AST Node Type: If ---
  Expressions using '[_]' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'if false { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([PathBuf :: from ("/Library") , PathBuf :: from ("/System") ,]) ,) } else { let sysroot = config . env_var_os ("PKG_CONFIG_SYSROOT_DIR") . or_else (| | config . env_var_os ("SYSROOT")) . map (PathBuf :: from) ; if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) } }' (Used Types: {"[_]", "_"})
      - 'if let Some (HirFrame :: Literal (ref mut literal)) = stack . last_mut () { literal . push (byte) ; } else { stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,) ; }' (Used Types: {"[_]", "_"})
      - 'if rs . len () == 1 && rs [0] . start == rs [0] . end { Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start]))) } else { None }' (Used Types: {"_", "[_]"})
      - 'if self . flags () . unicode () { let map = unicode :: SimpleCaseFolder :: new () . map (| f | f . overlaps (c , c)) . map_err (| _ | { self . error (span , ErrorKind :: UnicodeCaseUnavailable) }) ? ; if ! map { return Ok (None) ; } let mut cls = hir :: ClassUnicode :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,) ,) ; cls . try_case_fold_simple () . map_err (| _ | { self . error (span , ErrorKind :: UnicodeCaseUnavailable) }) ? ; Ok (Some (Hir :: class (hir :: Class :: Unicode (cls)))) } else { if ! c . is_ascii () { return Ok (None) ; } match c { 'A' ..= 'Z' | 'a' ..= 'z' => { } _ => return Ok (None) , } let mut cls = hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,) ; cls . case_fold_simple () ; Ok (Some (Hir :: class (hir :: Class :: Bytes (cls)))) }' (Used Types: {"[_]", "_"})
    Depth 4: (Count: 1)
      - 'if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) }' (Used Types: {"_", "[_]"})
    Depth 5: (Count: 2)
      - 'if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) }' (Used Types: {"_", "[_]"})
      - 'if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () }' (Used Types: {"_", "[_]"})
  Expressions using '[_]' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . required_libs . is_empty () { let ports = match load_ports (& vcpkg_target) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } } ; if ports . get (& port_name . to_owned ()) . is_none () { return Err (Error :: LibNotFound (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("package {0} is not installed for vcpkg triplet {1}" , port_name . to_owned () , vcpkg_target . target_triplet . triplet ,) ,) }) ,) ,) ; } let mut required_ports : BTreeMap < String , Port > = BTreeMap :: new () ; let mut ports_to_scan = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,) ; while ! ports_to_scan . is_empty () { let port_name = ports_to_scan . pop () . unwrap () ; if required_ports . contains_key (& port_name) { continue ; } if let Some (port) = ports . get (& port_name) { for dep in & port . deps { ports_to_scan . push (dep . clone ()) ; } required_ports . insert (port_name . clone () , (* port) . clone ()) ; remove_item (& mut required_port_order , & port_name) ; required_port_order . push (port_name) ; } else { } } if self . required_libs . is_empty () { for port_name in & required_port_order { let port = required_ports . get (port_name) . unwrap () ; self . required_libs . extend (port . libs . iter () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; self . required_dlls . extend (port . dlls . iter () . cloned () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; } } }' (Used Types: {"[_]", "Port", "_", "BTreeMap"})

--- AST Node Type: MethodCall ---
  Expressions using '[_]' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))) . await . pop ()' (Used Types: {"_", "[_]"})
      - 'stack . push (Alternation (ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , }) ,)' (Used Types: {"[_]", "_"})
      - 'words . iter () . flat_map (| arg | { if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } })' (Used Types: {"[_]", "_"})
    Depth 4: (Count: 2)
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value])))' (Used Types: {"[_]", "_"})
      - 'stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,)' (Used Types: {"_", "[_]"})
  Expressions using '[_]' with 2 other type(s):
    Depth 4: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"_", "U", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"[_]", "_", "U"})
    Depth 5: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."])' (Used Types: {"U", "_", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."])' (Used Types: {"U", "_", "[_]"})
    Depth 6: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"_", "[_]", "U"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"U", "_", "[_]"})
  Expressions using '[_]' with 3 other type(s):
    Depth 4: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,)' (Used Types: {"[_]", "V", "A", "_"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,)' (Used Types: {"B", "U", "[_]", "_"})
    Depth 5: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,)' (Used Types: {"A", "[_]", "V", "_"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,)' (Used Types: {"U", "B", "_", "[_]"})
    Depth 6: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,)' (Used Types: {"V", "A", "_", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,)' (Used Types: {"[_]", "_", "B", "U"})

--- AST Node Type: Path ---
  Expressions using '[_]' with 1 other type(s):
    Depth 6: (Count: 1)
      - '< [_] > :: into_vec' (Used Types: {"[_]", "_"})

--- AST Node Type: Struct ---
  Expressions using '[_]' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'Seq { literals : Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit]))) , }' (Used Types: {"_", "[_]"})
      - 'Utf8Sequences { range_stack : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([range])) , }' (Used Types: {"[_]", "_"})
    Depth 4: (Count: 1)
      - 'ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , }' (Used Types: {"[_]", "_"})

### Analyzing expressions using type: '[u8 ; ! CONTROLS . contains (0x20) as usize]' ###

--- AST Node Type: Path ---
  Expressions using '[u8 ; ! CONTROLS . contains (0x20) as usize]' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: transmute :: < [u8 ; ! CONTROLS . contains (0x20) as usize] , u8 >' (Used Types: {"[u8 ; ! CONTROLS . contains (0x20) as usize]"})

### Analyzing expressions using type: '[u8 ; ! CONTROLS . contains (0x7E) as usize]' ###

--- AST Node Type: Path ---
  Expressions using '[u8 ; ! CONTROLS . contains (0x7E) as usize]' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: transmute :: < [u8 ; ! CONTROLS . contains (0x7E) as usize] , u8 >' (Used Types: {"[u8 ; ! CONTROLS . contains (0x7E) as usize]"})

### Analyzing expressions using type: '[u8 ; 16]' ###

--- AST Node Type: Call ---
  Expressions using '[u8 ; 16]' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < [u8 ; 16] , Guid > (* bytes)' (Used Types: {"Guid", "[u8 ; 16]"})
  Expressions using '[u8 ; 16]' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self)' (Used Types: {"Guid", "[u8 ; 16]", "& Guid", "& [u8 ; 16]"})

--- AST Node Type: Path ---
  Expressions using '[u8 ; 16]' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < [u8 ; 16] , Guid >' (Used Types: {"Guid", "[u8 ; 16]"})
  Expressions using '[u8 ; 16]' with 3 other type(s):
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & Guid , & [u8 ; 16] >' (Used Types: {"Guid", "[u8 ; 16]", "& [u8 ; 16]", "& Guid"})

--- AST Node Type: Unsafe ---
  Expressions using '[u8 ; 16]' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < [u8 ; 16] , Guid > (* bytes) }' (Used Types: {"[u8 ; 16]", "Guid"})
  Expressions using '[u8 ; 16]' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & Guid , & [u8 ; 16] > (self) }' (Used Types: {"Guid", "& Guid", "[u8 ; 16]", "& [u8 ; 16]"})

### Analyzing expressions using type: '[u8 ; 1usize]' ###

--- AST Node Type: Call ---
  Expressions using '[u8 ; 1usize]' with 1 other type(s):
    Depth 3: (Count: 16)
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32 ,)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 2u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 6usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
    Depth 5: (Count: 8)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})

--- AST Node Type: Cast ---
  Expressions using '[u8 ; 1usize]' with 1 other type(s):
    Depth 4: (Count: 8)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})

--- AST Node Type: Path ---
  Expressions using '[u8 ; 1usize]' with 1 other type(s):
    Depth 4: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
    Depth 6: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})

--- AST Node Type: Unsafe ---
  Expressions using '[u8 ; 1usize]' with 1 other type(s):
    Depth 2: (Count: 16)
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 2u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 6usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})

### Analyzing expressions using type: '[u8 ; 2usize]' ###

--- AST Node Type: Call ---
  Expressions using '[u8 ; 2usize]' with 1 other type(s):
    Depth 3: (Count: 34)
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 10usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 11usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 12usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 13usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 14usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 15usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 3u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 13u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 2u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
    Depth 5: (Count: 16)
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})

--- AST Node Type: Cast ---
  Expressions using '[u8 ; 2usize]' with 1 other type(s):
    Depth 4: (Count: 18)
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})

--- AST Node Type: Path ---
  Expressions using '[u8 ; 2usize]' with 1 other type(s):
    Depth 4: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
    Depth 6: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})

--- AST Node Type: Unsafe ---
  Expressions using '[u8 ; 2usize]' with 1 other type(s):
    Depth 2: (Count: 36)
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 10usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 11usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 12usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 13usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 14usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 15usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 3u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 13u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 2u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})

### Analyzing expressions using type: '[u8 ; 4usize]' ###

--- AST Node Type: Call ---
  Expressions using '[u8 ; 4usize]' with 1 other type(s):
    Depth 3: (Count: 16)
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 30u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 29u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 27u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
    Depth 5: (Count: 8)
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})

--- AST Node Type: Cast ---
  Expressions using '[u8 ; 4usize]' with 1 other type(s):
    Depth 4: (Count: 8)
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})

--- AST Node Type: Path ---
  Expressions using '[u8 ; 4usize]' with 1 other type(s):
    Depth 4: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
    Depth 6: (Count: 1)
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})

--- AST Node Type: Unsafe ---
  Expressions using '[u8 ; 4usize]' with 1 other type(s):
    Depth 2: (Count: 16)
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 30u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 29u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 27u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})

### Analyzing expressions using type: '[u8 ; CONTROLS . contains (0x00) as usize]' ###

--- AST Node Type: Path ---
  Expressions using '[u8 ; CONTROLS . contains (0x00) as usize]' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: transmute :: < [u8 ; CONTROLS . contains (0x00) as usize] , u8 >' (Used Types: {"[u8 ; CONTROLS . contains (0x00) as usize]"})

### Analyzing expressions using type: '[u8 ; CONTROLS . contains (0x1F) as usize]' ###

--- AST Node Type: Path ---
  Expressions using '[u8 ; CONTROLS . contains (0x1F) as usize]' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: transmute :: < [u8 ; CONTROLS . contains (0x1F) as usize] , u8 >' (Used Types: {"[u8 ; CONTROLS . contains (0x1F) as usize]"})

### Analyzing expressions using type: '[u8 ; CONTROLS . contains (0x7F) as usize]' ###

--- AST Node Type: Path ---
  Expressions using '[u8 ; CONTROLS . contains (0x7F) as usize]' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'mem :: transmute :: < [u8 ; CONTROLS . contains (0x7F) as usize] , u8 >' (Used Types: {"[u8 ; CONTROLS . contains (0x7F) as usize]"})

### Analyzing expressions using type: '[u8]' ###

--- AST Node Type: Block ---
  Expressions using '[u8]' with 1 other type(s):
    Depth 3: (Count: 1)
      - '{ match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , } }' (Used Types: {"[u8]", "* const [u8]"})
    Depth 5: (Count: 1)
      - '{ let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) }' (Used Types: {"[u8]", "* const [u8]"})
  Expressions using '[u8]' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '[u8]' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using '[u8]' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'Box :: into_raw (Box :: < [u8] > :: default ())' (Used Types: {"[u8]"})
    Depth 6: (Count: 1)
      - 'Box :: < [u8] > :: default ()' (Used Types: {"[u8]"})
  Expressions using '[u8]' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'Box :: from_raw (Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str)' (Used Types: {"* mut str", "[u8]"})
  Expressions using '[u8]' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'Ok (words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ') ,)' (Used Types: {"Result", "[u8]", "Cow", "Vec", "QuoteError"})
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice)' (Used Types: {"& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]", "Item"})

--- AST Node Type: Cast ---
  Expressions using '[u8]' with 1 other type(s):
    Depth 4: (Count: 1)
      - 'Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str' (Used Types: {"[u8]", "* mut str"})
    Depth 7: (Count: 1)
      - 'bytes as * const [u8]' (Used Types: {"[u8]", "* const [u8]"})
  Expressions using '[u8]' with 3 other type(s):
    Depth 6: (Count: 1)
      - 'bytes as * const [u8] as * const CStr' (Used Types: {"* const CStr", "[u8]", "CStr", "* const [u8]"})

--- AST Node Type: If ---
  Expressions using '[u8]' with 2 other type(s):
    Depth 2: (Count: 1)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let slice : & [u8] = unsafe { core :: mem :: transmute (self . as_slice ()) } ; encoder . writer () . write (slice) ? ; } else { for item in self . iter () { item . encode (encoder) ? ; } }' (Used Types: {"& [u8]", "Item", "[u8]"})
  Expressions using '[u8]' with 4 other type(s):
    Depth 2: (Count: 2)
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: borrow_decode (decoder) ?) ; } }' (Used Types: {"[A :: Item]", "& mut [u8]", "[u8]", "Item", "& mut [A :: Item]"})
      - 'if unty :: type_equal :: < A :: Item , u8 > () { let ptr = vec . as_mut_ptr () ; unsafe { core :: ptr :: write_bytes (ptr , 0 , len) ; vec . set_len (len) ; } let slice = vec . as_mut_slice () ; let slice = unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) } ; decoder . reader () . read (slice) ? ; } else { for _ in 0 .. len { decoder . unclaim_bytes_read (core :: mem :: size_of :: < A :: Item > ()) ; vec . push (A :: Item :: decode (decoder) ?) ; } }' (Used Types: {"Item", "& mut [A :: Item]", "[A :: Item]", "[u8]", "& mut [u8]"})

--- AST Node Type: Match ---
  Expressions using '[u8]' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'match input { Cow :: Borrowed (bytes) => String :: from_utf8_lossy (bytes) , Cow :: Owned (bytes) => { match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , } } }' (Used Types: {"* const [u8]", "[u8]"})
    Depth 4: (Count: 1)
      - 'match String :: from_utf8_lossy (& bytes) { Cow :: Borrowed (utf8) => { let raw_utf8 : * const [u8] = utf8 . as_bytes () ; if true { if ! core :: ptr :: eq (raw_utf8 , & * bytes) { :: core :: panicking :: panic ("assertion failed: core::ptr::eq(raw_utf8, &*bytes)" ,) } } Cow :: Owned (unsafe { String :: from_utf8_unchecked (bytes) }) } Cow :: Owned (s) => Cow :: Owned (s) , }' (Used Types: {"[u8]", "* const [u8]"})

--- AST Node Type: MethodCall ---
  Expressions using '[u8]' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ? . join (& b' ')' (Used Types: {"QuoteError", "Cow", "Vec", "Result", "[u8]"})
    Depth 5: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > ()' (Used Types: {"QuoteError", "[u8]", "Cow", "Result", "Vec"})

--- AST Node Type: Paren ---
  Expressions using '[u8]' with 3 other type(s):
    Depth 5: (Count: 1)
      - '(bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "CStr", "* const [u8]", "[u8]"})

--- AST Node Type: Path ---
  Expressions using '[u8]' with 0 other type(s):
    Depth 7: (Count: 1)
      - 'Box :: < [u8] > :: default' (Used Types: {"[u8]"})
  Expressions using '[u8]' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] >' (Used Types: {"& mut [u8]", "& mut [A :: Item]", "[u8]", "[A :: Item]", "Item"})

--- AST Node Type: Reference ---
  Expressions using '[u8]' with 3 other type(s):
    Depth 3: (Count: 1)
      - '& * (bytes as * const [u8] as * const CStr)' (Used Types: {"[u8]", "* const [u8]", "* const CStr", "CStr"})

--- AST Node Type: Unary ---
  Expressions using '[u8]' with 3 other type(s):
    Depth 4: (Count: 1)
      - '* (bytes as * const [u8] as * const CStr)' (Used Types: {"* const CStr", "[u8]", "* const [u8]", "CStr"})

--- AST Node Type: Unknown ---
  Expressions using '[u8]' with 4 other type(s):
    Depth 4: (Count: 1)
      - 'words . into_iter () . map (| word | self . quote (word)) . collect :: < Result < Vec < Cow < [u8] > > , QuoteError > > () ?' (Used Types: {"Vec", "Result", "QuoteError", "Cow", "[u8]"})

--- AST Node Type: Unsafe ---
  Expressions using '[u8]' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { Box :: from_raw (Box :: into_raw (Box :: < [u8] > :: default ()) as * mut str) }' (Used Types: {"* mut str", "[u8]"})
  Expressions using '[u8]' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { & * (bytes as * const [u8] as * const CStr) }' (Used Types: {"CStr", "* const [u8]", "[u8]", "* const CStr"})
  Expressions using '[u8]' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < & mut [A :: Item] , & mut [u8] > (slice) }' (Used Types: {"[u8]", "Item", "[A :: Item]", "& mut [A :: Item]", "& mut [u8]"})

### Analyzing expressions using type: '_' ###

--- AST Node Type: Await ---
  Expressions using '_' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))) . await' (Used Types: {"_", "[_]"})

--- AST Node Type: Binary ---
  Expressions using '_' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'next_cmsg . add (1) as usize > max || next_cmsg as usize + CMSG_ALIGN ((* next_cmsg) . cmsg_len as _) as usize > max' (Used Types: {"_"})
    Depth 4: (Count: 1)
      - 'next_cmsg as usize + CMSG_ALIGN ((* next_cmsg) . cmsg_len as _) as usize > max' (Used Types: {"_"})
    Depth 5: (Count: 1)
      - 'next_cmsg as usize + CMSG_ALIGN ((* next_cmsg) . cmsg_len as _) as usize' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 3: (Count: 2)
      - '(* mhdr) . msg_controllen < size_of :: < cmsghdr > () as _' (Used Types: {"cmsghdr", "_"})
      - 'cmsg_len < size_of :: < cmsghdr > () as _' (Used Types: {"cmsghdr", "_"})
    Depth 4: (Count: 1)
      - 'self . ptr as * const _ == self . end' (Used Types: {"_", "* const _"})
    Depth 5: (Count: 1)
      - 'dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})
    Depth 6: (Count: 2)
      - 'dll . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"_", "Vec"})
      - 'lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})
    Depth 7: (Count: 1)
      - 'lib . components () . collect :: < Vec < _ > > () . len () == 1' (Used Types: {"Vec", "_"})

--- AST Node Type: Block ---
  Expressions using '_' with 0 other type(s):
    Depth 3: (Count: 12)
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as i128) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as u128) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as i16) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as u16) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as i32) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as u32) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as i8) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as u8) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as i64) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as u64) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as usize as _) as isize) }' (Used Types: {"_"})
      - '{ let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as usize as _) as usize) }' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 1)
      - '{ let mut names = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("lib{0}.a" , name)) }) ,]) ,) ; if false { names . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0}.lib" , name)) }) ,) ; } names }' (Used Types: {"_", "[_]"})
    Depth 3: (Count: 5)
      - '{ if ! c . is_ascii () { return Ok (None) ; } match c { 'A' ..= 'Z' | 'a' ..= 'z' => { } _ => return Ok (None) , } let mut cls = hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,) ; cls . case_fold_simple () ; Ok (Some (Hir :: class (hir :: Class :: Bytes (cls)))) }' (Used Types: {"[_]", "_"})
      - '{ let sysroot = config . env_var_os ("PKG_CONFIG_SYSROOT_DIR") . or_else (| | config . env_var_os ("SYSROOT")) . map (PathBuf :: from) ; if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) } }' (Used Types: {"[_]", "_"})
      - '{ stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,) ; }' (Used Types: {"_", "[_]"})
      - '{ unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) } }' (Used Types: {"* const _", "_"})
      - '{ unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) } }' (Used Types: {"* const _", "_"})
    Depth 4: (Count: 1)
      - '{ if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } }' (Used Types: {"_", "[_]"})
    Depth 5: (Count: 1)
      - '{ < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) }' (Used Types: {"_", "[_]"})
    Depth 6: (Count: 1)
      - '{ < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) }' (Used Types: {"[_]", "_"})
  Expressions using '_' with 5 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for NInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"_", "U", "[_]", "Self", "NInt", "Type"})
      - '{ impl < U : Unsigned + NonZero > :: scale_info :: TypeInfo for PInt < U > where U : :: scale_info :: TypeInfo + 'static , U : Unsigned + NonZero + :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,) } } }' (Used Types: {"PInt", "U", "[_]", "Self", "_", "Type"})
  Expressions using '_' with 6 other type(s):
    Depth 2: (Count: 2)
      - '{ impl < U , B > :: scale_info :: TypeInfo for UInt < U , B > where U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , U : :: scale_info :: TypeInfo + 'static , B : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,) } } }' (Used Types: {"U", "[_]", "_", "UInt", "Type", "Self", "B"})
      - '{ impl < V , A > :: scale_info :: TypeInfo for TArr < V , A > where V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , V : :: scale_info :: TypeInfo + 'static , A : :: scale_info :: TypeInfo + 'static , { type Identity = Self ; fn type_info () -> :: scale_info :: Type { :: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,) } } }' (Used Types: {"Self", "_", "[_]", "TArr", "A", "V", "Type"})

--- AST Node Type: Call ---
  Expressions using '_' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'isize :: wrapping_sub (p as _ , origin as _)' (Used Types: {"_"})
    Depth 5: (Count: 1)
      - 'CMSG_ALIGN (cmsg_len as _)' (Used Types: {"_"})
    Depth 7: (Count: 1)
      - 'CMSG_ALIGN ((* next_cmsg) . cmsg_len as _)' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 4)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , Hir :: empty ())]) ,)' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , empty_ast ())]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([mem :: replace (self , empty_set ())]) ,)' (Used Types: {"[_]", "_"})
      - 'Literal :: exact (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])))' (Used Types: {"_", "[_]"})
    Depth 3: (Count: 9)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("lib{0}.a" , name)) }) ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([PathBuf :: from ("/Library") , PathBuf :: from ("/System") ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([range]))' (Used Types: {"_", "[_]"})
      - 'Alternation (ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , })' (Used Types: {"[_]", "_"})
      - 'Ok (unsafe { & mut * (t as * mut _) })' (Used Types: {"_", "* mut _"})
      - 'Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit])))' (Used Types: {"[_]", "_"})
      - 'Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start])))' (Used Types: {"_", "[_]"})
      - 'hir :: ClassUnicode :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,) ,)' (Used Types: {"_", "[_]"})
    Depth 4: (Count: 5)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit]))' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start]))' (Used Types: {"[_]", "_"})
      - 'NonNull :: new_unchecked (self as * mut _)' (Used Types: {"* mut _", "_"})
      - 'hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,)' (Used Types: {"_", "[_]"})
    Depth 5: (Count: 7)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,)' (Used Types: {"[_]", "_"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))' (Used Types: {"_", "[_]"})
      - 'Err (AllocOrInitError :: Init (ptr :: read (e as * const _)))' (Used Types: {"* const _", "_"})
      - 'Err (ptr :: read (e as * const _))' (Used Types: {"* const _", "_"})
      - 'HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,)' (Used Types: {"[_]", "_"})
      - 'ptr :: read (elt as * const _)' (Used Types: {"_", "* const _"})
    Depth 6: (Count: 4)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte]))' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,)' (Used Types: {"_", "[_]"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot]))' (Used Types: {"_", "[_]"})
      - 'AllocOrInitError :: Init (ptr :: read (e as * const _))' (Used Types: {"* const _", "_"})
    Depth 7: (Count: 2)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()]))' (Used Types: {"[_]", "_"})
      - 'ptr :: read (e as * const _)' (Used Types: {"* const _", "_"})
  Expressions using '_' with 2 other type(s):
    Depth 2: (Count: 3)
      - 'Source :: count (self as & [_])' (Used Types: {"_", "& [_]", "[_]"})
      - 'Source :: get (self as & [_] , key)' (Used Types: {"& [_]", "_", "[_]"})
      - 'Source :: visit (self as & [_] , visitor)' (Used Types: {"[_]", "_", "& [_]"})
    Depth 3: (Count: 3)
      - 'make_hasher :: < _ , V , S > (& self . hash_builder)' (Used Types: {"V", "S", "_"})
      - 'make_hasher :: < _ , V , S > (& self . table . hash_builder)' (Used Types: {"_", "S", "V"})
      - 'make_hasher :: < _ , V , S > (self . hash_builder)' (Used Types: {"_", "V", "S"})
    Depth 7: (Count: 1)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_"})
  Expressions using '_' with 3 other type(s):
    Depth 3: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T2", "T1", "Either"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ > ()' (Used Types: {"_", "T1", "Either", "T2"})
    Depth 7: (Count: 2)
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,)' (Used Types: {"U", "[_]", "_", "B"})
      - '< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,)' (Used Types: {"[_]", "_", "A", "V"})

--- AST Node Type: Cast ---
  Expressions using '_' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'PF_SUSPEND_TASK_UINT as _' (Used Types: {"_"})
    Depth 3: (Count: 2)
      - 'origin as _' (Used Types: {"_"})
      - 'p as _' (Used Types: {"_"})
    Depth 4: (Count: 2)
      - 'CMSG_ALIGN (cmsg_len as _) as usize' (Used Types: {"_"})
      - 'other . as_slice () as _' (Used Types: {"_"})
    Depth 5: (Count: 12)
      - 'self . gen_mod_u128 (len as u128 as _) as i128' (Used Types: {"_"})
      - 'self . gen_mod_u128 (len as u128 as _) as u128' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u16 as _) as i16' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u16 as _) as u16' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u32 as _) as i32' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u32 as _) as u32' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u8 as _) as i8' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u8 as _) as u8' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as u64 as _) as i64' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as u64 as _) as u64' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as usize as _) as isize' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as usize as _) as usize' (Used Types: {"_"})
    Depth 6: (Count: 2)
      - 'CMSG_ALIGN ((* next_cmsg) . cmsg_len as _) as usize' (Used Types: {"_"})
      - 'cmsg_len as _' (Used Types: {"_"})
    Depth 7: (Count: 6)
      - 'len as u128 as _' (Used Types: {"_"})
      - 'len as u16 as _' (Used Types: {"_"})
      - 'len as u32 as _' (Used Types: {"_"})
      - 'len as u64 as _' (Used Types: {"_"})
      - 'len as u8 as _' (Used Types: {"_"})
      - 'len as usize as _' (Used Types: {"_"})
    Depth 8: (Count: 1)
      - '(* next_cmsg) . cmsg_len as _' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 1)
      - '& self . state as * const _ as usize' (Used Types: {"_", "* const _"})
    Depth 3: (Count: 2)
      - '& self . state as * const _' (Used Types: {"_", "* const _"})
      - 'self as * const _' (Used Types: {"* const _", "_"})
    Depth 4: (Count: 1)
      - 'size_of :: < cmsghdr > () as _' (Used Types: {"_", "cmsghdr"})
    Depth 5: (Count: 2)
      - 'self . ptr as * const _' (Used Types: {"_", "* const _"})
      - 'self as * mut _' (Used Types: {"_", "* mut _"})
    Depth 6: (Count: 1)
      - 'elt as * const _' (Used Types: {"* const _", "_"})
    Depth 8: (Count: 2)
      - 'e as * const _' (Used Types: {"_", "* const _"})
      - 't as * mut _' (Used Types: {"* mut _", "_"})
  Expressions using '_' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'self as & [_]' (Used Types: {"[_]", "_", "& [_]"})
  Expressions using '_' with 3 other type(s):
    Depth 2: (Count: 3)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize) as * mut cmsghdr' (Used Types: {"_", "* mut cmsghdr", "cmsghdr", "* mut u8"})
      - 'self as * const _ as * const T' (Used Types: {"* const _", "* const T", "_", "T"})
      - 'self as * mut _ as * mut T' (Used Types: {"* mut _", "* mut T", "T", "_"})

--- AST Node Type: Closure ---
  Expressions using '_' with 1 other type(s):
    Depth 3: (Count: 2)
      - '| arg | { if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } }' (Used Types: {"_", "[_]"})
      - '| elt | unsafe { ptr :: read (elt as * const _) }' (Used Types: {"* const _", "_"})

--- AST Node Type: ForLoop ---
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'for line in file . lines () { let line = line . unwrap () ; let file_path = Path :: new (& line) ; if let Ok (dll) = file_path . strip_prefix (& dll_prefix) { if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; } } else if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } } }' (Used Types: {"Vec", "_"})
      - 'for line in file . lines () { let line = line . unwrap () ; let parts = line . splitn (2 , ": ") . clone () . collect :: < Vec < _ > > () ; if parts . len () == 2 { current . insert (parts [0] . trim () . into () , parts [1] . trim () . into ()) ; } else if line . len () == 0 { port_info . push (current . clone ()) ; current . clear () ; } else { } }' (Used Types: {"Vec", "_"})

--- AST Node Type: If ---
  Expressions using '_' with 0 other type(s):
    Depth 2: (Count: 13)
      - 'if low == core :: i128 :: MIN && high == core :: i128 :: MAX { self . gen_u128 () as i128 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as i128) }' (Used Types: {"_"})
      - 'if low == core :: i16 :: MIN && high == core :: i16 :: MAX { self . gen_u32 () as i16 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as i16) }' (Used Types: {"_"})
      - 'if low == core :: i32 :: MIN && high == core :: i32 :: MAX { self . gen_u32 () as i32 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as i32) }' (Used Types: {"_"})
      - 'if low == core :: i64 :: MIN && high == core :: i64 :: MAX { self . gen_u64 () as i64 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as i64) }' (Used Types: {"_"})
      - 'if low == core :: i8 :: MIN && high == core :: i8 :: MAX { self . gen_u32 () as i8 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as i8) }' (Used Types: {"_"})
      - 'if low == core :: isize :: MIN && high == core :: isize :: MAX { self . gen_u64 () as isize } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as usize as _) as isize) }' (Used Types: {"_"})
      - 'if low == core :: u128 :: MIN && high == core :: u128 :: MAX { self . gen_u128 () as u128 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as u128) }' (Used Types: {"_"})
      - 'if low == core :: u16 :: MIN && high == core :: u16 :: MAX { self . gen_u32 () as u16 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as u16) }' (Used Types: {"_"})
      - 'if low == core :: u32 :: MIN && high == core :: u32 :: MAX { self . gen_u32 () as u32 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as u32) }' (Used Types: {"_"})
      - 'if low == core :: u64 :: MIN && high == core :: u64 :: MAX { self . gen_u64 () as u64 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as u64) }' (Used Types: {"_"})
      - 'if low == core :: u8 :: MIN && high == core :: u8 :: MAX { self . gen_u32 () as u8 } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as u8) }' (Used Types: {"_"})
      - 'if low == core :: usize :: MIN && high == core :: usize :: MAX { self . gen_u64 () as usize } else { let len = high . wrapping_sub (low) . wrapping_add (1) ; low . wrapping_add (self . gen_mod_u64 (len as usize as _) as usize) }' (Used Types: {"_"})
      - 'if next_cmsg . add (1) as usize > max || next_cmsg as usize + CMSG_ALIGN ((* next_cmsg) . cmsg_len as _) as usize > max { return ptr :: null_mut () ; }' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 9)
      - 'if (* mhdr) . msg_controllen < size_of :: < cmsghdr > () as _ { return ptr :: null_mut () ; }' (Used Types: {"_", "cmsghdr"})
      - 'if cmsg_len < size_of :: < cmsghdr > () as _ { return ptr :: null_mut () ; }' (Used Types: {"cmsghdr", "_"})
      - 'if false { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([PathBuf :: from ("/Library") , PathBuf :: from ("/System") ,]) ,) } else { let sysroot = config . env_var_os ("PKG_CONFIG_SYSROOT_DIR") . or_else (| | config . env_var_os ("SYSROOT")) . map (PathBuf :: from) ; if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) } }' (Used Types: {"[_]", "_"})
      - 'if let Some (HirFrame :: Literal (ref mut literal)) = stack . last_mut () { literal . push (byte) ; } else { stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,) ; }' (Used Types: {"[_]", "_"})
      - 'if min_buckets < self . buckets () { if self . table . items == 0 { let new_inner = RawTableInner :: with_capacity (& self . alloc , Self :: TABLE_LAYOUT , min_size ,) ; let mut old_inner = mem :: replace (& mut self . table , new_inner) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { if self . resize (min_size , hasher , Fallibility :: Infallible) . is_err () { hint :: unreachable_unchecked () } } } }' (Used Types: {"T", "_"})
      - 'if min_size == 0 { let mut old_inner = mem :: replace (& mut self . table , RawTableInner :: NEW) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } return ; }' (Used Types: {"T", "_"})
      - 'if rs . len () == 1 && rs [0] . start == rs [0] . end { Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([rs [0] . start]))) } else { None }' (Used Types: {"_", "[_]"})
      - 'if self . flags () . unicode () { let map = unicode :: SimpleCaseFolder :: new () . map (| f | f . overlaps (c , c)) . map_err (| _ | { self . error (span , ErrorKind :: UnicodeCaseUnavailable) }) ? ; if ! map { return Ok (None) ; } let mut cls = hir :: ClassUnicode :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassUnicodeRange :: new (c , c)]) ,) ,) ; cls . try_case_fold_simple () . map_err (| _ | { self . error (span , ErrorKind :: UnicodeCaseUnavailable) }) ? ; Ok (Some (Hir :: class (hir :: Class :: Unicode (cls)))) } else { if ! c . is_ascii () { return Ok (None) ; } match c { 'A' ..= 'Z' | 'a' ..= 'z' => { } _ => return Ok (None) , } let mut cls = hir :: ClassBytes :: new (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([hir :: ClassBytesRange :: new (u8 :: try_from (c) . unwrap () , u8 :: try_from (c) . unwrap () ,) ,]) ,) ,) ; cls . case_fold_simple () ; Ok (Some (Hir :: class (hir :: Class :: Bytes (cls)))) }' (Used Types: {"[_]", "_"})
      - 'if source . table . is_empty_singleton () { let mut old_inner = mem :: replace (& mut self . table , RawTableInner :: NEW) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { let mut self_ = guard (self , | self_ | { self_ . clear_no_drop () ; } ,) ; self_ . table . drop_elements :: < T > () ; if self_ . buckets () != source . buckets () { let new_inner = match RawTableInner :: new_uninitialized (& self_ . alloc , Self :: TABLE_LAYOUT , source . buckets () , Fallibility :: Infallible ,) { Ok (table) => table , Err (_) => hint :: unreachable_unchecked () , } ; let mut old_inner = mem :: replace (& mut self_ . table , new_inner) ; if ! old_inner . is_empty_singleton () { old_inner . free_buckets (& self_ . alloc , Self :: TABLE_LAYOUT) ; } } self_ . clone_from_spec (source) ; ScopeGuard :: into_inner (self_) ; } }' (Used Types: {"T", "_"})
    Depth 3: (Count: 2)
      - 'if let Ok (dll) = file_path . strip_prefix (& dll_prefix) { if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; } } else if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } }' (Used Types: {"Vec", "_"})
      - 'if self . table . items == 0 { let new_inner = RawTableInner :: with_capacity (& self . alloc , Self :: TABLE_LAYOUT , min_size ,) ; let mut old_inner = mem :: replace (& mut self . table , new_inner) ; unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; } } else { unsafe { if self . resize (min_size , hasher , Fallibility :: Infallible) . is_err () { hint :: unreachable_unchecked () } } }' (Used Types: {"T", "_"})
    Depth 4: (Count: 3)
      - 'if dll . extension () == Some (OsStr :: new ("dll")) && dll . components () . collect :: < Vec < _ > > () . len () == 1 { dll . to_str () . map (| s | dlls . push (s . to_owned ())) ; }' (Used Types: {"Vec", "_"})
      - 'if false { if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () } } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot . unwrap_or_else (| | PathBuf :: from ("/usr")) ,]) ,) }' (Used Types: {"_", "[_]"})
      - 'if let Ok (lib) = file_path . strip_prefix (& lib_prefix) { if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } } }' (Used Types: {"Vec", "_"})
    Depth 5: (Count: 3)
      - 'if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) }' (Used Types: {"_", "[_]"})
      - 'if let Some (sysroot) = sysroot { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([sysroot])) } else { :: alloc :: vec :: Vec :: new () }' (Used Types: {"_", "[_]"})
      - 'if lib . extension () == Some (OsStr :: new (& vcpkg_target . target_triplet . lib_suffix)) && lib . components () . collect :: < Vec < _ > > () . len () == 1 { if let Some (lib) = vcpkg_target . link_name_for_lib (lib) { libs . push (lib) ; } }' (Used Types: {"Vec", "_"})
  Expressions using '_' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . required_libs . is_empty () { let ports = match load_ports (& vcpkg_target) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } } ; if ports . get (& port_name . to_owned ()) . is_none () { return Err (Error :: LibNotFound (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("package {0} is not installed for vcpkg triplet {1}" , port_name . to_owned () , vcpkg_target . target_triplet . triplet ,) ,) }) ,) ,) ; } let mut required_ports : BTreeMap < String , Port > = BTreeMap :: new () ; let mut ports_to_scan = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([port_name . to_owned ()]) ,) ; while ! ports_to_scan . is_empty () { let port_name = ports_to_scan . pop () . unwrap () ; if required_ports . contains_key (& port_name) { continue ; } if let Some (port) = ports . get (& port_name) { for dep in & port . deps { ports_to_scan . push (dep . clone ()) ; } required_ports . insert (port_name . clone () , (* port) . clone ()) ; remove_item (& mut required_port_order , & port_name) ; required_port_order . push (port_name) ; } else { } } if self . required_libs . is_empty () { for port_name in & required_port_order { let port = required_ports . get (port_name) . unwrap () ; self . required_libs . extend (port . libs . iter () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; self . required_dlls . extend (port . dlls . iter () . cloned () . map (| s | { Path :: new (& s) . file_stem () . unwrap () . to_string_lossy () . into_owned () }) ,) ; } } }' (Used Types: {"[_]", "Port", "_", "BTreeMap"})
  Expressions using '_' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) }' (Used Types: {"T", "_", "* const i8", "* const _", "* mut T"})

--- AST Node Type: Match ---
  Expressions using '_' with 2 other type(s):
    Depth 2: (Count: 3)
      - 'match paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) }) { :: core :: result :: Result :: Ok (val) => val , :: core :: result :: Result :: Err (err) => { return :: core :: result :: Result :: Err (:: core :: convert :: From :: from (err)) ; } }' (Used Types: {"Vec", "Result", "_"})
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) } } }' (Used Types: {"* const _", "* mut _", "_"})
      - 'match unsafe { inner_result_ptr . as_mut () } { Ok (t) => Ok (unsafe { & mut * (t as * mut _) }) , Err (e) => { unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) } } }' (Used Types: {"* mut _", "_", "* const _"})

--- AST Node Type: MethodCall ---
  Expressions using '_' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'self . append_elements (other . as_slice () as _)' (Used Types: {"_"})
    Depth 4: (Count: 12)
      - 'low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as i128)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u128 (len as u128 as _) as u128)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as i16)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u16 as _) as u16)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as i32)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u32 as _) as u32)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as i8)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u32 (len as u8 as _) as u8)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as i64)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u64 (len as u64 as _) as u64)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u64 (len as usize as _) as isize)' (Used Types: {"_"})
      - 'low . wrapping_add (self . gen_mod_u64 (len as usize as _) as usize)' (Used Types: {"_"})
    Depth 6: (Count: 6)
      - 'self . gen_mod_u128 (len as u128 as _)' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u16 as _)' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u32 as _)' (Used Types: {"_"})
      - 'self . gen_mod_u32 (len as u8 as _)' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as u64 as _)' (Used Types: {"_"})
      - 'self . gen_mod_u64 (len as usize as _)' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 8)
      - 'a . lm_into_iter () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
      - 'b . lm_into_iter () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
      - 'iter . into_iter () . map (| x | x . ok_or (())) . collect_in :: < Result < _ , _ > > (alloc) . ok ()' (Used Types: {"_", "Result"})
      - 'self . iter . next () . map (| elt | unsafe { ptr :: read (elt as * const _) })' (Used Types: {"* const _", "_"})
      - 'self . iter . next_back () . map (| elt | unsafe { ptr :: read (elt as * const _) })' (Used Types: {"_", "* const _"})
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value]))) . await . pop ()' (Used Types: {"_", "[_]"})
      - 'stack . push (Alternation (ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , }) ,)' (Used Types: {"[_]", "_"})
      - 'words . iter () . flat_map (| arg | { if arg . starts_with ("-Wl,") { arg [4 ..] . split (',') . collect () } else { < [_] > :: into_vec (:: alloc :: boxed :: box_new ([arg . as_ref ()])) } })' (Used Types: {"[_]", "_"})
    Depth 3: (Count: 4)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize)' (Used Types: {"* mut u8", "_"})
      - 'iter . into_iter () . map (| x | x . ok_or (())) . collect_in :: < Result < _ , _ > > (alloc)' (Used Types: {"Result", "_"})
      - 'line . splitn (2 , ": ") . clone () . collect :: < Vec < _ > > ()' (Used Types: {"_", "Vec"})
      - 'self . table . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT)' (Used Types: {"_", "T"})
    Depth 4: (Count: 3)
      - 'old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT)' (Used Types: {"_", "T"})
      - 'self . write_all (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([value])))' (Used Types: {"[_]", "_"})
      - 'stack . push (HirFrame :: Literal (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([byte])) ,) ,)' (Used Types: {"_", "[_]"})
    Depth 7: (Count: 1)
      - 'dll . components () . collect :: < Vec < _ > > () . len ()' (Used Types: {"Vec", "_"})
    Depth 8: (Count: 2)
      - 'dll . components () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
      - 'lib . components () . collect :: < Vec < _ > > () . len ()' (Used Types: {"_", "Vec"})
    Depth 9: (Count: 1)
      - 'lib . components () . collect :: < Vec < _ > > ()' (Used Types: {"Vec", "_"})
  Expressions using '_' with 2 other type(s):
    Depth 2: (Count: 11)
      - 'self . table . insert (hash , (k , v) , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"S", "V", "_"})
      - 'self . table . insert (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder))' (Used Types: {"S", "_", "V"})
      - 'self . table . insert_entry (hash , (key , value) , make_hasher :: < _ , V , S > (self . hash_builder) ,)' (Used Types: {"_", "V", "S"})
      - 'self . table . reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'self . table . shrink_to (0 , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "_", "S"})
      - 'self . table . shrink_to (min_capacity , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"V", "S", "_"})
      - 'self . table . table . insert (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'self . table . table . insert (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"V", "S", "_"})
      - 'self . table . try_reserve (additional , make_hasher :: < _ , V , S > (& self . hash_builder))' (Used Types: {"_", "V", "S"})
      - 'table . insert_entry (self . hash , (self . key , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
      - 'table . insert_entry (self . hash , (self . key . into () , value) , make_hasher :: < _ , V , S > (& self . table . hash_builder) ,)' (Used Types: {"_", "S", "V"})
    Depth 3: (Count: 1)
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > () . map_err (| e | { Error :: VcpkgInstallation (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("could not read status file update filenames: {0}" , e ,) ,) }) ,) })' (Used Types: {"Result", "_", "Vec"})
    Depth 4: (Count: 3)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"_", "U", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."]) . composite (:: scale_info :: build :: Fields :: named () . field (| f | f . ty :: < U > () . name ("n") . type_name ("U") . docs (& [])) ,)' (Used Types: {"[_]", "_", "U"})
      - 'paths . map (| rde | rde . map (| de | de . path ())) . collect :: < Result < Vec < _ > , _ > > ()' (Used Types: {"Result", "Vec", "_"})
    Depth 5: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with negative sign."])' (Used Types: {"U", "_", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,) . docs (& ["Type-level signed integers with positive sign."])' (Used Types: {"U", "_", "[_]"})
    Depth 6: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("NInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"_", "[_]", "U"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("PInt" , "typenum::int")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) ,]) ,) ,)' (Used Types: {"U", "_", "[_]"})
  Expressions using '_' with 3 other type(s):
    Depth 4: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < V > () . name ("first") . type_name ("V") . docs (& []) }) . field (| f | f . ty :: < A > () . name ("rest") . type_name ("A") . docs (& [])) ,)' (Used Types: {"[_]", "V", "A", "_"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,) . composite (:: scale_info :: build :: Fields :: named () . field (| f | { f . ty :: < U > () . name ("msb") . type_name ("U") . docs (& ["The more significant bits of `Self`."]) }) . field (| f | { f . ty :: < B > () . name ("lsb") . type_name ("B") . docs (& ["The least significant bit of `Self`."]) }) ,)' (Used Types: {"B", "U", "[_]", "_"})
    Depth 5: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,) . docs (& ["`TArr` is a type that acts as an array of types. It is defined similarly to `UInt`, only its" , "values can be more than bits, and it is designed to act as an array. So you can only add two if" , "they have the same number of elements, for example." , "" , "This array is only really designed to contain `Integer` types. If you use it with others, you" , "may find it lacking functionality." ,] ,)' (Used Types: {"A", "[_]", "V", "_"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,) . docs (& ["`UInt` is defined recursively, where `B` is the least significant bit and `U` is the rest" , "of the number. Conceptually, `U` should be bound by the trait `Unsigned` and `B` should" , "be bound by the trait `Bit`, but enforcing these bounds causes linear instead of" , "logrithmic scaling in some places, so they are left off for now. They may be enforced in" , "future." , "" , "In order to keep numbers unique, leading zeros are not allowed, so `UInt<UTerm, B0>` is" , "forbidden." , "" , "# Example" , "```rust" , "use typenum::{UInt, UTerm, B0, B1};" , "" , "# #[allow(dead_code)]" , "type U6 = UInt<UInt<UInt<UTerm, B1>, B1>, B0>;" , "```" ,] ,)' (Used Types: {"U", "B", "_", "[_]"})
    Depth 6: (Count: 2)
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("TArr" , "typenum::array")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("V" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < V > ()) ,) , :: scale_info :: TypeParameter :: new ("A" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < A > ()) ,) ,]) ,) ,)' (Used Types: {"V", "A", "_", "[_]"})
      - ':: scale_info :: Type :: builder () . path (:: scale_info :: Path :: new ("UInt" , "typenum::uint")) . type_params (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([:: scale_info :: TypeParameter :: new ("U" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < U > ()) ,) , :: scale_info :: TypeParameter :: new ("B" , :: core :: option :: Option :: Some (:: scale_info :: meta_type :: < B > ()) ,) ,]) ,) ,)' (Used Types: {"[_]", "_", "B", "U"})

--- AST Node Type: Paren ---
  Expressions using '_' with 1 other type(s):
    Depth 7: (Count: 1)
      - '(t as * mut _)' (Used Types: {"_", "* mut _"})

--- AST Node Type: Path ---
  Expressions using '_' with 1 other type(s):
    Depth 6: (Count: 1)
      - '< [_] > :: into_vec' (Used Types: {"[_]", "_"})
  Expressions using '_' with 2 other type(s):
    Depth 4: (Count: 1)
      - 'make_hasher :: < _ , V , S >' (Used Types: {"_", "V", "S"})
  Expressions using '_' with 3 other type(s):
    Depth 4: (Count: 2)
      - 'check_array_mut :: < Either < T1 , T2 > , _ >' (Used Types: {"T2", "T1", "Either", "_"})
      - 'check_array_ref :: < Either < T1 , T2 > , _ >' (Used Types: {"_", "T2", "Either", "T1"})

--- AST Node Type: Reference ---
  Expressions using '_' with 1 other type(s):
    Depth 5: (Count: 1)
      - '& mut * (t as * mut _)' (Used Types: {"_", "* mut _"})

--- AST Node Type: Struct ---
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'Seq { literals : Some (< [_] > :: into_vec (:: alloc :: boxed :: box_new ([lit]))) , }' (Used Types: {"_", "[_]"})
      - 'Utf8Sequences { range_stack : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([range])) , }' (Used Types: {"[_]", "_"})
    Depth 3: (Count: 1)
      - 'Drain { tail_start : end , tail_len : len - end , iter : range_slice . iter () , vec : NonNull :: new_unchecked (self as * mut _) , }' (Used Types: {"_", "* mut _"})
    Depth 4: (Count: 1)
      - 'ast :: Alternation { span : Span :: new (concat . span . start , self . pos ()) , asts : < [_] > :: into_vec (:: alloc :: boxed :: box_new ([concat . into_ast ()]) ,) , }' (Used Types: {"[_]", "_"})

--- AST Node Type: Unary ---
  Expressions using '_' with 1 other type(s):
    Depth 6: (Count: 1)
      - '* (t as * mut _)' (Used Types: {"* mut _", "_"})

--- AST Node Type: Unsafe ---
  Expressions using '_' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { self . append_elements (other . as_slice () as _) ; other . set_len (0) ; }' (Used Types: {"_"})
  Expressions using '_' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'unsafe { let (ptr , len_ptr , _) = self . triple_mut () ; let ptr : * const _ = ptr . as_ptr () ; if * len_ptr == 0 { return None ; } let last_index = * len_ptr - 1 ; * len_ptr = last_index ; Some (ptr :: read (ptr . add (last_index))) }' (Used Types: {"* const _", "_"})
      - 'unsafe { self . set_len (start) ; let range_slice = slice :: from_raw_parts (self . as_ptr () . add (start) , end - start ,) ; Drain { tail_start : end , tail_len : len - end , iter : range_slice . iter () , vec : NonNull :: new_unchecked (self as * mut _) , } }' (Used Types: {"* mut _", "_"})
      - 'unsafe { self . table . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; }' (Used Types: {"T", "_"})
    Depth 3: (Count: 1)
      - 'unsafe { old_inner . drop_inner_table :: < T , _ > (& self . alloc , Self :: TABLE_LAYOUT) ; }' (Used Types: {"T", "_"})
    Depth 4: (Count: 4)
      - 'unsafe { & mut * (t as * mut _) }' (Used Types: {"_", "* mut _"})
      - 'unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (AllocOrInitError :: Init (ptr :: read (e as * const _))) }' (Used Types: {"_", "* const _"})
      - 'unsafe { if self . is_last_allocation (inner_result_ptr . cast ()) { let current_footer_p = self . current_chunk_footer . get () ; let current_ptr = & current_footer_p . as_ref () . ptr ; if current_footer_p == rewind_footer { current_ptr . set (rewind_ptr) ; } else { current_ptr . set (current_footer_p . as_ref () . data) ; } } Err (ptr :: read (e as * const _)) }' (Used Types: {"* const _", "_"})
      - 'unsafe { ptr :: read (elt as * const _) }' (Used Types: {"* const _", "_"})
  Expressions using '_' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'unsafe { if self . ptr as * const _ == self . end { None } else if mem :: size_of :: < T > () == 0 { self . ptr = arith_offset (self . ptr as * const i8 , 1) as * mut T ; Some (mem :: zeroed ()) } else { let old = self . ptr ; self . ptr = self . ptr . offset (1) ; Some (ptr :: read (old)) } }' (Used Types: {"* const _", "_", "* mut T", "T", "* const i8"})

### Analyzing expressions using type: '__A' ###

--- AST Node Type: Block ---
  Expressions using '__A' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__A' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '__BindgenBitfieldUnit' ###

--- AST Node Type: Call ---
  Expressions using '__BindgenBitfieldUnit' with 1 other type(s):
    Depth 3: (Count: 66)
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32 ,)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8 ,)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32 ,)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - ':: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32 ,)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 2u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 6usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 10usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 11usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 12usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 13usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 14usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 15usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 3u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 13u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 2u8 , val as u64)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 30u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 29u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 27u8 , val as u64)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
    Depth 5: (Count: 32)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8)' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8)' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8)' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8)' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})

--- AST Node Type: Cast ---
  Expressions using '__BindgenBitfieldUnit' with 1 other type(s):
    Depth 4: (Count: 34)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})

--- AST Node Type: Path ---
  Expressions using '__BindgenBitfieldUnit' with 1 other type(s):
    Depth 4: (Count: 3)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
    Depth 6: (Count: 3)
      - '< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - '< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})

--- AST Node Type: Unsafe ---
  Expressions using '__BindgenBitfieldUnit' with 1 other type(s):
    Depth 2: (Count: 68)
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 2u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 6usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 10usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 11usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 12usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 13usize , 1u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 14usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 15usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 3u8) as u16 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 13u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 4u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 8usize , 1u8) as u8 ,) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 1u8) as u16 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 9usize , 2u8) as u8 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 0usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 1usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 2usize , 30u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 1u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 3usize , 29u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 4usize , 1u8) as u32 ,) }' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { :: core :: mem :: transmute (< __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_get (& raw const (* this) . _bitfield_1 , 5usize , 27u8) as u32 ,) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 10usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 11usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 12usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 13usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 14usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 15usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 3u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 13u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u16 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 1usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 2u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 6usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 1u8 , val as u64) }' (Used Types: {"[u8 ; 4usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 1usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 2usize , 30u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 3usize , 29u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u32 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 4usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 5usize , 27u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 4usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 1usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 1usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 0usize , 4u8 , val as u64) }' (Used Types: {"[u8 ; 2usize]", "__BindgenBitfieldUnit"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 4usize , 4u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 8usize , 1u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})
      - 'unsafe { let val : u8 = :: core :: mem :: transmute (val) ; < __BindgenBitfieldUnit < [u8 ; 2usize] , > > :: raw_set (& raw mut (* this) . _bitfield_1 , 9usize , 2u8 , val as u64) }' (Used Types: {"__BindgenBitfieldUnit", "[u8 ; 2usize]"})

### Analyzing expressions using type: '__D' ###

--- AST Node Type: Block ---
  Expressions using '__D' with 7 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = < _serde :: __private :: de :: Content as _serde :: Deserialize > :: deserialize (__deserializer ,) ? ; let __deserializer = _serde :: __private :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< L as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Left ,) { return _serde :: __private :: Ok (__ok) ; } if let _serde :: __private :: Ok (__ok) = _serde :: __private :: Result :: map (< R as _serde :: Deserialize > :: deserialize (__deserializer) , Either :: Right ,) { return _serde :: __private :: Ok (__ok) ; } _serde :: __private :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum Either" ,) ,) } } }' (Used Types: {"L", "Either", "Result", "__D", "Content", "Self", "R", "Error"})
  Expressions using '__D' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__D' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '__E' ###

--- AST Node Type: Block ---
  Expressions using '__E' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__E' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '__Field' ###

--- AST Node Type: Block ---
  Expressions using '__Field' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__Field' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

--- AST Node Type: Call ---
  Expressions using '__Field' with 0 other type(s):
    Depth 8: (Count: 1)
      - '_serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map)' (Used Types: {"__Field"})

--- AST Node Type: Let ---
  Expressions using '__Field' with 0 other type(s):
    Depth 6: (Count: 1)
      - 'let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ?' (Used Types: {"__Field"})

--- AST Node Type: Path ---
  Expressions using '__Field' with 0 other type(s):
    Depth 9: (Count: 1)
      - '_serde :: de :: MapAccess :: next_key :: < __Field , >' (Used Types: {"__Field"})

--- AST Node Type: Unknown ---
  Expressions using '__Field' with 0 other type(s):
    Depth 7: (Count: 1)
      - '_serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ?' (Used Types: {"__Field"})

--- AST Node Type: While ---
  Expressions using '__Field' with 4 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"__Field", "IgnoredAny", "Error", "Block", "Vec"})

### Analyzing expressions using type: '__FieldVisitor' ###

--- AST Node Type: Block ---
  Expressions using '__FieldVisitor' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__FieldVisitor' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '__S' ###

--- AST Node Type: Block ---
  Expressions using '__S' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FixedBitSet { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FixedBitSet" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "data" , & self . data ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "length" , & self . length ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"__S", "& Self", "Ok", "Result", "Error", "FixedBitSet", "Self"})
  Expressions using '__S' with 8 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } Either :: Right (ref __field0) => { _serde :: Serialize :: serialize (__field0 , __serializer) } } } } }' (Used Types: {"Error", "& Self", "Self", "R", "Either", "Result", "Ok", "__S", "L"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < L , R > _serde :: Serialize for Either < L , R > where L : _serde :: Serialize , R : _serde :: Serialize , { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { match * self { Either :: Left (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 0u32 , "Left" , __field0 ,) } Either :: Right (ref __field0) => { _serde :: Serializer :: serialize_newtype_variant (__serializer , "Either" , 1u32 , "Right" , __field0 ,) } } } } }' (Used Types: {"& Self", "Ok", "Error", "__S", "R", "Either", "Self", "Result", "L"})

### Analyzing expressions using type: '__Visitor' ###

--- AST Node Type: Block ---
  Expressions using '__Visitor' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de , L , R > _serde :: Deserialize < 'de > for Either < L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "variant identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private :: Ok (__Field :: __field0) , 1u64 => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: invalid_value (_serde :: de :: Unexpected :: Unsigned (__value) , & "variant index 0 <= i < 2" ,) ,) } } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "Left" => _serde :: __private :: Ok (__Field :: __field0) , "Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"Left" => _serde :: __private :: Ok (__Field :: __field0) , b"Right" => _serde :: __private :: Ok (__Field :: __field1) , _ => { let __value = & _serde :: __private :: from_utf8_lossy (__value) ; _serde :: __private :: Err (_serde :: de :: Error :: unknown_variant (__value , VARIANTS) ,) } } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { marker : _serde :: __private :: PhantomData < Either < L , R > > , lifetime : _serde :: __private :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de , L , R > _serde :: de :: Visitor < 'de > for __Visitor < 'de , L , R > where L : _serde :: Deserialize < 'de > , R : _serde :: Deserialize < 'de > , { type Value = Either < L , R > ; fn expecting (& self , __formatter : & mut _serde :: __private :: Formatter ,) -> _serde :: __private :: fmt :: Result { _serde :: __private :: Formatter :: write_str (__formatter , "enum Either") } fn visit_enum < __A > (self , __data : __A ,) -> _serde :: __private :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: EnumAccess < 'de > , { match _serde :: de :: EnumAccess :: variant (__data) ? { (__Field :: __field0 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < L > (__variant) , Either :: Left ,) } (__Field :: __field1 , __variant) => { _serde :: __private :: Result :: map (_serde :: de :: VariantAccess :: newtype_variant :: < R > (__variant) , Either :: Right ,) } } } } # [doc (hidden)] const VARIANTS : & 'static [& 'static str] = & ["Left" , "Right"] ; _serde :: Deserializer :: deserialize_enum (__deserializer , "Either" , VARIANTS , __Visitor { marker : _serde :: __private :: PhantomData :: < Either < L , R > > , lifetime : _serde :: __private :: PhantomData , } ,) } } }' (Used Types: {"__E", "__D", "Self", "__FieldVisitor", "& [u8]", "()", "& 'static [& 'static str]", "[& 'static str]", "__Visitor", "Error", "& 'static str", "__Field", "R", "L", "& str", "[u8]", "__A", "Value", "Either", "Result", "Formatter", "PhantomData", "& mut _serde :: __private :: Formatter", "& 'de ()", "& Self"})
  Expressions using '__Visitor' with 26 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FixedBitSet { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "data" => _serde :: __private228 :: Ok (__Field :: __field0) , "length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"data" => _serde :: __private228 :: Ok (__Field :: __field0) , b"length" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FixedBitSet ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FixedBitSet" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Vec < Block > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < usize , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FixedBitSet with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Vec < Block > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < usize > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("data") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < Block > > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("length") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < usize > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("data") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("length") ? } } ; _serde :: __private228 :: Ok (FixedBitSet { data : __field0 , length : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["data" , "length"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FixedBitSet" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FixedBitSet > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& 'static str", "Error", "Option", "__Field", "__FieldVisitor", "[& 'static str]", "Self", "PhantomData", "& 'de ()", "& Self", "& [u8]", "& str", "FixedBitSet", "__E", "& mut _serde :: __private228 :: Formatter", "__D", "Formatter", "[u8]", "()", "__Visitor", "__A", "IgnoredAny", "& 'static [& 'static str]", "Result", "Vec", "Value", "Block"})

### Analyzing expressions using type: '__kernel_fd_set' ###

--- AST Node Type: Call ---
  Expressions using '__kernel_fd_set' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'core :: ptr :: write_bytes (bytes , 0 , size_of :: < __kernel_fd_set > ())' (Used Types: {"__kernel_fd_set"})
    Depth 3: (Count: 1)
      - 'size_of :: < __kernel_fd_set > ()' (Used Types: {"__kernel_fd_set"})

--- AST Node Type: Path ---
  Expressions using '__kernel_fd_set' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'size_of :: < __kernel_fd_set >' (Used Types: {"__kernel_fd_set"})

### Analyzing expressions using type: '__u16' ###

--- AST Node Type: Binary ---
  Expressions using '__u16' with 0 other type(s):
    Depth 2: (Count: 2)
      - '((TLS_1_2_VERSION_MAJOR as __u16) << 8) | (TLS_1_2_VERSION_MINOR as __u16)' (Used Types: {"__u16"})
      - '((TLS_1_3_VERSION_MAJOR as __u16) << 8) | (TLS_1_3_VERSION_MINOR as __u16)' (Used Types: {"__u16"})
    Depth 4: (Count: 2)
      - '(TLS_1_2_VERSION_MAJOR as __u16) << 8' (Used Types: {"__u16"})
      - '(TLS_1_3_VERSION_MAJOR as __u16) << 8' (Used Types: {"__u16"})

--- AST Node Type: Cast ---
  Expressions using '__u16' with 0 other type(s):
    Depth 4: (Count: 2)
      - 'TLS_1_2_VERSION_MINOR as __u16' (Used Types: {"__u16"})
      - 'TLS_1_3_VERSION_MINOR as __u16' (Used Types: {"__u16"})
    Depth 6: (Count: 2)
      - 'TLS_1_2_VERSION_MAJOR as __u16' (Used Types: {"__u16"})
      - 'TLS_1_3_VERSION_MAJOR as __u16' (Used Types: {"__u16"})

--- AST Node Type: Paren ---
  Expressions using '__u16' with 0 other type(s):
    Depth 3: (Count: 4)
      - '((TLS_1_2_VERSION_MAJOR as __u16) << 8)' (Used Types: {"__u16"})
      - '((TLS_1_3_VERSION_MAJOR as __u16) << 8)' (Used Types: {"__u16"})
      - '(TLS_1_2_VERSION_MINOR as __u16)' (Used Types: {"__u16"})
      - '(TLS_1_3_VERSION_MINOR as __u16)' (Used Types: {"__u16"})
    Depth 5: (Count: 2)
      - '(TLS_1_2_VERSION_MAJOR as __u16)' (Used Types: {"__u16"})
      - '(TLS_1_3_VERSION_MAJOR as __u16)' (Used Types: {"__u16"})

### Analyzing expressions using type: '__u64' ###

--- AST Node Type: Call ---
  Expressions using '__u64' with 0 other type(s):
    Depth 2: (Count: 1)
      - '_IOR :: < __u64 > (NSIO , 0x5)' (Used Types: {"__u64"})

--- AST Node Type: Path ---
  Expressions using '__u64' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOR :: < __u64 >' (Used Types: {"__u64"})

### Analyzing expressions using type: 'c_int' ###

--- AST Node Type: Call ---
  Expressions using 'c_int' with 0 other type(s):
    Depth 2: (Count: 35)
      - '_IOR :: < c_int > ('f' as u32 , 1)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > ('v' as u32 , 1)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (NSIO , 0x6)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (NSIO , 0x7)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (NSIO , 0x8)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (NSIO , 0x9)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 207)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 210)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 211)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 215)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 221)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 223)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 224)' (Used Types: {"c_int"})
      - '_IOR :: < c_int > (T_TYPE , 225)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > ('f' as u32 , 2)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > ('v' as u32 , 2)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (0x94 , 9)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (PTP_CLK_MAGIC , 13)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (PTP_CLK_MAGIC , 4)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 200)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 201)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 202)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 203)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 204)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 205)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 206)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 208)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 209)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 212)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 216)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 217)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 218)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 220)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 222)' (Used Types: {"c_int"})
      - '_IOW :: < c_int > (T_TYPE , 226)' (Used Types: {"c_int"})
  Expressions using 'c_int' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'Some (unsafe { core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1) })' (Used Types: {"unsafe extern \"C\" fn (crate :: ctypes :: c_int)", "c_int"})
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1)' (Used Types: {"c_int", "unsafe extern \"C\" fn (crate :: ctypes :: c_int)"})

--- AST Node Type: Cast ---
  Expressions using 'c_int' with 0 other type(s):
    Depth 2: (Count: 1)
      - 's as c_int' (Used Types: {"c_int"})

--- AST Node Type: Path ---
  Expressions using 'c_int' with 0 other type(s):
    Depth 3: (Count: 2)
      - '_IOR :: < c_int >' (Used Types: {"c_int"})
      - '_IOW :: < c_int >' (Used Types: {"c_int"})
  Expressions using 'c_int' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) >' (Used Types: {"unsafe extern \"C\" fn (crate :: ctypes :: c_int)", "c_int"})

--- AST Node Type: Unsafe ---
  Expressions using 'c_int' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1) }' (Used Types: {"c_int", "unsafe extern \"C\" fn (crate :: ctypes :: c_int)"})

### Analyzing expressions using type: 'c_long' ###

--- AST Node Type: Call ---
  Expressions using 'c_long' with 0 other type(s):
    Depth 2: (Count: 4)
      - '_IOR :: < c_long > ('f' as u32 , 1)' (Used Types: {"c_long"})
      - '_IOR :: < c_long > ('v' as u32 , 1)' (Used Types: {"c_long"})
      - '_IOW :: < c_long > ('f' as u32 , 2)' (Used Types: {"c_long"})
      - '_IOW :: < c_long > ('v' as u32 , 2)' (Used Types: {"c_long"})
    Depth 3: (Count: 1)
      - 'size_of :: < c_long > ()' (Used Types: {"c_long"})

--- AST Node Type: Cast ---
  Expressions using 'c_long' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'size_of :: < c_long > () as c_uint' (Used Types: {"c_long", "c_uint"})

--- AST Node Type: Path ---
  Expressions using 'c_long' with 0 other type(s):
    Depth 3: (Count: 2)
      - '_IOR :: < c_long >' (Used Types: {"c_long"})
      - '_IOW :: < c_long >' (Used Types: {"c_long"})
    Depth 4: (Count: 1)
      - 'size_of :: < c_long >' (Used Types: {"c_long"})

### Analyzing expressions using type: 'c_short' ###

--- AST Node Type: Cast ---
  Expressions using 'c_short' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'crate :: IFF_TAP as c_short' (Used Types: {"c_short"})
      - 'crate :: IFF_TUN as c_short' (Used Types: {"c_short"})

### Analyzing expressions using type: 'c_uchar' ###

--- AST Node Type: Cast ---
  Expressions using 'c_uchar' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'cmsg . offset (1) as * mut c_uchar' (Used Types: {"c_uchar", "* mut c_uchar"})
    Depth 4: (Count: 1)
      - 'cmsg as * mut c_uchar' (Used Types: {"c_uchar", "* mut c_uchar"})

--- AST Node Type: MethodCall ---
  Expressions using 'c_uchar' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut c_uchar) . add (size_of :: < cmsghdr > ())' (Used Types: {"cmsghdr", "* mut c_uchar", "c_uchar"})

--- AST Node Type: Paren ---
  Expressions using 'c_uchar' with 1 other type(s):
    Depth 3: (Count: 1)
      - '(cmsg as * mut c_uchar)' (Used Types: {"c_uchar", "* mut c_uchar"})

### Analyzing expressions using type: 'c_uint' ###

--- AST Node Type: Binary ---
  Expressions using 'c_uint' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'CMSG_ALIGN (size_of :: < crate :: cmsghdr > ()) as c_uint + length' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint + CMSG_ALIGN (len)' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint + len' (Used Types: {"cmsghdr", "c_uint"})

--- AST Node Type: Cast ---
  Expressions using 'c_uint' with 0 other type(s):
    Depth 2: (Count: 5)
      - 'O_CLOEXEC as c_uint' (Used Types: {"c_uint"})
      - 'O_EXCL as c_uint' (Used Types: {"c_uint"})
      - 'O_NONBLOCK as c_uint' (Used Types: {"c_uint"})
      - 'major as c_uint' (Used Types: {"c_uint"})
      - 'minor as c_uint' (Used Types: {"c_uint"})
  Expressions using 'c_uint' with 1 other type(s):
    Depth 2: (Count: 2)
      - '(CMSG_ALIGN (length as usize) + CMSG_ALIGN (size_of :: < crate :: cmsghdr > ())) as c_uint' (Used Types: {"cmsghdr", "c_uint"})
      - 'size_of :: < c_long > () as c_uint' (Used Types: {"c_long", "c_uint"})
    Depth 3: (Count: 2)
      - 'CMSG_ALIGN (size_of :: < crate :: cmsghdr > ()) as c_uint' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint' (Used Types: {"c_uint", "cmsghdr"})

### Analyzing expressions using type: 'c_void' ###

--- AST Node Type: Cast ---
  Expressions using 'c_void' with 1 other type(s):
    Depth 2: (Count: 3)
      - '! 0 as * mut c_void' (Used Types: {"* mut c_void", "c_void"})
      - '(* self) as * const c_void' (Used Types: {"c_void", "* const c_void"})
      - '- 1i64 as * mut c_void' (Used Types: {"c_void", "* mut c_void"})
  Expressions using 'c_void' with 3 other type(s):
    Depth 2: (Count: 1)
      - '(* self) as * const T as * const c_void' (Used Types: {"* const T", "c_void", "T", "* const c_void"})

### Analyzing expressions using type: 'can_frame' ###

--- AST Node Type: Call ---
  Expressions using 'can_frame' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'size_of :: < can_frame > ()' (Used Types: {"can_frame"})

--- AST Node Type: Path ---
  Expressions using 'can_frame' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'size_of :: < can_frame >' (Used Types: {"can_frame"})

### Analyzing expressions using type: 'canfd_frame' ###

--- AST Node Type: Call ---
  Expressions using 'canfd_frame' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'size_of :: < canfd_frame > ()' (Used Types: {"canfd_frame"})

--- AST Node Type: Path ---
  Expressions using 'canfd_frame' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'size_of :: < canfd_frame >' (Used Types: {"canfd_frame"})

### Analyzing expressions using type: 'canxl_frame' ###

--- AST Node Type: Call ---
  Expressions using 'canxl_frame' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'size_of :: < canxl_frame > ()' (Used Types: {"canxl_frame"})

--- AST Node Type: Path ---
  Expressions using 'canxl_frame' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'size_of :: < canxl_frame >' (Used Types: {"canxl_frame"})

### Analyzing expressions using type: 'cmsghdr' ###

--- AST Node Type: Binary ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 2)
      - '((* cmsg) . cmsg_len as usize) < size_of :: < cmsghdr > ()' (Used Types: {"cmsghdr"})
      - '(* mhdr) . msg_controllen as usize >= size_of :: < crate :: cmsghdr > ()' (Used Types: {"cmsghdr"})
    Depth 4: (Count: 1)
      - 'CMSG_ALIGN (length as usize) + CMSG_ALIGN (size_of :: < crate :: cmsghdr > ())' (Used Types: {"cmsghdr"})
  Expressions using 'cmsghdr' with 1 other type(s):
    Depth 2: (Count: 3)
      - 'CMSG_ALIGN (size_of :: < crate :: cmsghdr > ()) as c_uint + length' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint + CMSG_ALIGN (len)' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint + len' (Used Types: {"cmsghdr", "c_uint"})
    Depth 3: (Count: 2)
      - '(* mhdr) . msg_controllen < size_of :: < cmsghdr > () as _' (Used Types: {"cmsghdr", "_"})
      - 'cmsg_len < size_of :: < cmsghdr > () as _' (Used Types: {"cmsghdr", "_"})

--- AST Node Type: Block ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '{ core :: ptr :: null_mut :: < crate :: cmsghdr > () }' (Used Types: {"cmsghdr"})

--- AST Node Type: Call ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'core :: ptr :: null_mut :: < cmsghdr > ()' (Used Types: {"cmsghdr"})
    Depth 4: (Count: 2)
      - 'CMSG_ALIGN (size_of :: < crate :: cmsghdr > ())' (Used Types: {"cmsghdr"})
      - 'core :: ptr :: null_mut :: < crate :: cmsghdr > ()' (Used Types: {"cmsghdr"})
    Depth 5: (Count: 2)
      - 'size_of :: < cmsghdr > ()' (Used Types: {"cmsghdr"})
      - 'size_of :: < crate :: cmsghdr > ()' (Used Types: {"cmsghdr"})

--- AST Node Type: Cast ---
  Expressions using 'cmsghdr' with 1 other type(s):
    Depth 2: (Count: 3)
      - '(* mhdr) . msg_control as * mut cmsghdr' (Used Types: {"* mut cmsghdr", "cmsghdr"})
      - '(CMSG_ALIGN (length as usize) + CMSG_ALIGN (size_of :: < crate :: cmsghdr > ())) as c_uint' (Used Types: {"cmsghdr", "c_uint"})
      - '(cmsg as usize + super :: CMSG_ALIGN ((* cmsg) . cmsg_len as usize)) as * mut cmsghdr' (Used Types: {"* mut cmsghdr", "cmsghdr"})
    Depth 3: (Count: 2)
      - 'CMSG_ALIGN (size_of :: < crate :: cmsghdr > ()) as c_uint' (Used Types: {"c_uint", "cmsghdr"})
      - 'size_of :: < cmsghdr > () as c_uint' (Used Types: {"c_uint", "cmsghdr"})
    Depth 4: (Count: 1)
      - 'size_of :: < cmsghdr > () as _' (Used Types: {"_", "cmsghdr"})
  Expressions using 'cmsghdr' with 3 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut u8) . add (CMSG_ALIGN (cmsg_len as _) as usize) as * mut cmsghdr' (Used Types: {"_", "* mut cmsghdr", "cmsghdr", "* mut u8"})

--- AST Node Type: If ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 2: (Count: 3)
      - 'if ((* cmsg) . cmsg_len as usize) < size_of :: < cmsghdr > () { return core :: ptr :: null_mut :: < cmsghdr > () ; }' (Used Types: {"cmsghdr"})
      - 'if (* mhdr) . msg_controllen as usize >= size_of :: < crate :: cmsghdr > () { (* mhdr) . msg_control . cast :: < crate :: cmsghdr > () } else { core :: ptr :: null_mut :: < crate :: cmsghdr > () }' (Used Types: {"cmsghdr"})
      - 'if (next . wrapping_offset (1)) as usize > max || next as usize + super :: CMSG_ALIGN ((* next) . cmsg_len as usize) > max { core :: ptr :: null_mut :: < cmsghdr > () } else { next }' (Used Types: {"cmsghdr"})
  Expressions using 'cmsghdr' with 1 other type(s):
    Depth 2: (Count: 2)
      - 'if (* mhdr) . msg_controllen < size_of :: < cmsghdr > () as _ { return ptr :: null_mut () ; }' (Used Types: {"_", "cmsghdr"})
      - 'if cmsg_len < size_of :: < cmsghdr > () as _ { return ptr :: null_mut () ; }' (Used Types: {"cmsghdr", "_"})

--- AST Node Type: MethodCall ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(* mhdr) . msg_control . cast :: < crate :: cmsghdr > ()' (Used Types: {"cmsghdr"})
  Expressions using 'cmsghdr' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(cmsg as * mut c_uchar) . add (size_of :: < cmsghdr > ())' (Used Types: {"cmsghdr", "* mut c_uchar", "c_uchar"})

--- AST Node Type: Paren ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '(CMSG_ALIGN (length as usize) + CMSG_ALIGN (size_of :: < crate :: cmsghdr > ()))' (Used Types: {"cmsghdr"})

--- AST Node Type: Path ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'core :: ptr :: null_mut :: < cmsghdr >' (Used Types: {"cmsghdr"})
    Depth 5: (Count: 1)
      - 'core :: ptr :: null_mut :: < crate :: cmsghdr >' (Used Types: {"cmsghdr"})
    Depth 6: (Count: 2)
      - 'size_of :: < cmsghdr >' (Used Types: {"cmsghdr"})
      - 'size_of :: < crate :: cmsghdr >' (Used Types: {"cmsghdr"})

--- AST Node Type: Return ---
  Expressions using 'cmsghdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'return core :: ptr :: null_mut :: < cmsghdr > ()' (Used Types: {"cmsghdr"})

### Analyzing expressions using type: 'cpu_set_t' ###

--- AST Node Type: Call ---
  Expressions using 'cpu_set_t' with 0 other type(s):
    Depth 2: (Count: 1)
      - 'CPU_COUNT_S (size_of :: < cpu_set_t > () , cpuset)' (Used Types: {"cpu_set_t"})
    Depth 3: (Count: 1)
      - 'size_of :: < cpu_set_t > ()' (Used Types: {"cpu_set_t"})

--- AST Node Type: Path ---
  Expressions using 'cpu_set_t' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'size_of :: < cpu_set_t >' (Used Types: {"cpu_set_t"})

### Analyzing expressions using type: 'dev_t' ###

--- AST Node Type: Cast ---
  Expressions using 'dev_t' with 0 other type(s):
    Depth 2: (Count: 2)
      - 'major as crate :: dev_t' (Used Types: {"dev_t"})
      - 'minor as crate :: dev_t' (Used Types: {"dev_t"})

### Analyzing expressions using type: 'dyn Any' ###

--- AST Node Type: If ---
  Expressions using 'dyn Any' with 3 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "dyn Any", "* mut dyn Any", "T"})

--- AST Node Type: Unsafe ---
  Expressions using 'dyn Any' with 3 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut dyn Any = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"dyn Any", "* mut dyn Any", "T", "* mut T"})

### Analyzing expressions using type: 'dyn Any + Send' ###

--- AST Node Type: If ---
  Expressions using 'dyn Any + Send' with 4 other type(s):
    Depth 2: (Count: 1)
      - 'if self . is :: < T > () { unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) } } else { Err (self) }' (Used Types: {"* mut T", "(dyn Any + Send)", "T", "* mut (dyn Any + Send)", "dyn Any + Send"})

--- AST Node Type: Unsafe ---
  Expressions using 'dyn Any + Send' with 4 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let raw : * mut (dyn Any + Send) = Box :: into_raw (self) ; Ok (Box :: from_raw (raw as * mut T)) }' (Used Types: {"* mut T", "T", "* mut (dyn Any + Send)", "(dyn Any + Send)", "dyn Any + Send"})

### Analyzing expressions using type: 'dyn StdError + Send + Sync' ###

--- AST Node Type: Path ---
  Expressions using 'dyn StdError + Send + Sync' with 1 other type(s):
    Depth 4: (Count: 2)
      - 'object_downcast :: < Box < dyn StdError + Send + Sync > >' (Used Types: {"dyn StdError + Send + Sync", "Box"})
      - 'object_drop_front :: < Box < dyn StdError + Send + Sync > >' (Used Types: {"Box", "dyn StdError + Send + Sync"})

--- AST Node Type: Reference ---
  Expressions using 'dyn StdError + Send + Sync' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"BoxedError", "Box", "dyn StdError + Send + Sync"})

--- AST Node Type: Struct ---
  Expressions using 'dyn StdError + Send + Sync' with 2 other type(s):
    Depth 3: (Count: 1)
      - 'ErrorVTable { object_drop : object_drop :: < BoxedError > , object_ref : object_ref :: < BoxedError > , object_boxed : object_boxed :: < BoxedError > , object_reallocate_boxed : object_reallocate_boxed :: < BoxedError > , object_downcast : object_downcast :: < Box < dyn StdError + Send + Sync > > , object_drop_rest : object_drop_front :: < Box < dyn StdError + Send + Sync > > , }' (Used Types: {"Box", "BoxedError", "dyn StdError + Send + Sync"})

### Analyzing expressions using type: 'dyn core :: error :: Error' ###

--- AST Node Type: Call ---
  Expressions using 'dyn core :: error :: Error' with 1 other type(s):
    Depth 3: (Count: 4)
      - 'crate :: nightly :: request_ref_backtrace (& * boxed_error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& * error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& error as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'crate :: nightly :: request_ref_backtrace (& self as & dyn core :: error :: Error ,)' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

--- AST Node Type: Cast ---
  Expressions using 'dyn core :: error :: Error' with 1 other type(s):
    Depth 4: (Count: 4)
      - '& * boxed_error as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - '& * error as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - '& error as & dyn core :: error :: Error' (Used Types: {"& dyn core :: error :: Error", "dyn core :: error :: Error"})
      - '& self as & dyn core :: error :: Error' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

--- AST Node Type: Match ---
  Expressions using 'dyn core :: error :: Error' with 1 other type(s):
    Depth 2: (Count: 4)
      - 'match crate :: nightly :: request_ref_backtrace (& * boxed_error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"& dyn core :: error :: Error", "dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& * error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& error as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})
      - 'match crate :: nightly :: request_ref_backtrace (& self as & dyn core :: error :: Error ,) { Some (_) => None , None => Some (crate :: backtrace :: Backtrace :: capture ()) , }' (Used Types: {"dyn core :: error :: Error", "& dyn core :: error :: Error"})

### Analyzing expressions using type: 'file_clone_range' ###

--- AST Node Type: Call ---
  Expressions using 'file_clone_range' with 0 other type(s):
    Depth 2: (Count: 1)
      - '_IOW :: < crate :: file_clone_range > (0x94 , 13)' (Used Types: {"file_clone_range"})

--- AST Node Type: Path ---
  Expressions using 'file_clone_range' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOW :: < crate :: file_clone_range >' (Used Types: {"file_clone_range"})

### Analyzing expressions using type: 'mnt_ns_info' ###

--- AST Node Type: Call ---
  Expressions using 'mnt_ns_info' with 0 other type(s):
    Depth 2: (Count: 3)
      - '_IOR :: < mnt_ns_info > (NSIO , 10)' (Used Types: {"mnt_ns_info"})
      - '_IOR :: < mnt_ns_info > (NSIO , 11)' (Used Types: {"mnt_ns_info"})
      - '_IOR :: < mnt_ns_info > (NSIO , 12)' (Used Types: {"mnt_ns_info"})

--- AST Node Type: Path ---
  Expressions using 'mnt_ns_info' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOR :: < mnt_ns_info >' (Used Types: {"mnt_ns_info"})

### Analyzing expressions using type: 'pidfd_info' ###

--- AST Node Type: Call ---
  Expressions using 'pidfd_info' with 0 other type(s):
    Depth 2: (Count: 1)
      - '_IOWR :: < pidfd_info > (PIDFS_IOCTL_MAGIC , 11)' (Used Types: {"pidfd_info"})

--- AST Node Type: Path ---
  Expressions using 'pidfd_info' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOWR :: < pidfd_info >' (Used Types: {"pidfd_info"})

### Analyzing expressions using type: 'ptp_clock_caps' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_clock_caps' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOR :: < ptp_clock_caps , > (PTP_CLK_MAGIC , 1)' (Used Types: {"ptp_clock_caps"})
      - '_IOR :: < ptp_clock_caps , > (PTP_CLK_MAGIC , 10)' (Used Types: {"ptp_clock_caps"})

--- AST Node Type: Path ---
  Expressions using 'ptp_clock_caps' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOR :: < ptp_clock_caps , >' (Used Types: {"ptp_clock_caps"})

### Analyzing expressions using type: 'ptp_extts_request' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_extts_request' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOW :: < ptp_extts_request , > (PTP_CLK_MAGIC , 11)' (Used Types: {"ptp_extts_request"})
      - '_IOW :: < ptp_extts_request , > (PTP_CLK_MAGIC , 2)' (Used Types: {"ptp_extts_request"})

--- AST Node Type: Path ---
  Expressions using 'ptp_extts_request' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOW :: < ptp_extts_request , >' (Used Types: {"ptp_extts_request"})

### Analyzing expressions using type: 'ptp_perout_request' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_perout_request' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOW :: < ptp_perout_request , > (PTP_CLK_MAGIC , 12)' (Used Types: {"ptp_perout_request"})
      - '_IOW :: < ptp_perout_request , > (PTP_CLK_MAGIC , 3)' (Used Types: {"ptp_perout_request"})

--- AST Node Type: Path ---
  Expressions using 'ptp_perout_request' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOW :: < ptp_perout_request , >' (Used Types: {"ptp_perout_request"})

### Analyzing expressions using type: 'ptp_pin_desc' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_pin_desc' with 0 other type(s):
    Depth 2: (Count: 4)
      - '_IOW :: < ptp_pin_desc > (PTP_CLK_MAGIC , 16)' (Used Types: {"ptp_pin_desc"})
      - '_IOW :: < ptp_pin_desc > (PTP_CLK_MAGIC , 7)' (Used Types: {"ptp_pin_desc"})
      - '_IOWR :: < ptp_pin_desc > (PTP_CLK_MAGIC , 15)' (Used Types: {"ptp_pin_desc"})
      - '_IOWR :: < ptp_pin_desc > (PTP_CLK_MAGIC , 6)' (Used Types: {"ptp_pin_desc"})

--- AST Node Type: Path ---
  Expressions using 'ptp_pin_desc' with 0 other type(s):
    Depth 3: (Count: 2)
      - '_IOW :: < ptp_pin_desc >' (Used Types: {"ptp_pin_desc"})
      - '_IOWR :: < ptp_pin_desc >' (Used Types: {"ptp_pin_desc"})

### Analyzing expressions using type: 'ptp_sys_offset' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_sys_offset' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOW :: < ptp_sys_offset > (PTP_CLK_MAGIC , 14)' (Used Types: {"ptp_sys_offset"})
      - '_IOW :: < ptp_sys_offset > (PTP_CLK_MAGIC , 5)' (Used Types: {"ptp_sys_offset"})

--- AST Node Type: Path ---
  Expressions using 'ptp_sys_offset' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOW :: < ptp_sys_offset >' (Used Types: {"ptp_sys_offset"})

### Analyzing expressions using type: 'ptp_sys_offset_extended' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_sys_offset_extended' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOWR :: < ptp_sys_offset_extended , > (PTP_CLK_MAGIC , 18)' (Used Types: {"ptp_sys_offset_extended"})
      - '_IOWR :: < ptp_sys_offset_extended , > (PTP_CLK_MAGIC , 9)' (Used Types: {"ptp_sys_offset_extended"})

--- AST Node Type: Path ---
  Expressions using 'ptp_sys_offset_extended' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOWR :: < ptp_sys_offset_extended , >' (Used Types: {"ptp_sys_offset_extended"})

### Analyzing expressions using type: 'ptp_sys_offset_precise' ###

--- AST Node Type: Call ---
  Expressions using 'ptp_sys_offset_precise' with 0 other type(s):
    Depth 2: (Count: 2)
      - '_IOWR :: < ptp_sys_offset_precise , > (PTP_CLK_MAGIC , 17)' (Used Types: {"ptp_sys_offset_precise"})
      - '_IOWR :: < ptp_sys_offset_precise , > (PTP_CLK_MAGIC , 8)' (Used Types: {"ptp_sys_offset_precise"})

--- AST Node Type: Path ---
  Expressions using 'ptp_sys_offset_precise' with 0 other type(s):
    Depth 3: (Count: 1)
      - '_IOWR :: < ptp_sys_offset_precise , >' (Used Types: {"ptp_sys_offset_precise"})

### Analyzing expressions using type: 'sighandler_t' ###

--- AST Node Type: Cast ---
  Expressions using 'sighandler_t' with 0 other type(s):
    Depth 2: (Count: 3)
      - '! 0 as sighandler_t' (Used Types: {"sighandler_t"})
      - '0 as sighandler_t' (Used Types: {"sighandler_t"})
      - '1 as sighandler_t' (Used Types: {"sighandler_t"})

### Analyzing expressions using type: 'siginfo_f' ###

--- AST Node Type: Field ---
  Expressions using 'siginfo_f' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: MethodCall ---
  Expressions using 'siginfo_f' with 2 other type(s):
    Depth 6: (Count: 1)
      - '(self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: Paren ---
  Expressions using 'siginfo_f' with 2 other type(s):
    Depth 4: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ())' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

--- AST Node Type: Reference ---
  Expressions using 'siginfo_f' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& (* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"siginfo_t", "siginfo_f", "* const siginfo_t"})

--- AST Node Type: Unary ---
  Expressions using 'siginfo_f' with 2 other type(s):
    Depth 5: (Count: 1)
      - '* (self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

### Analyzing expressions using type: 'siginfo_sigfault' ###

--- AST Node Type: Field ---
  Expressions using 'siginfo_sigfault' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()) . si_addr' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})

--- AST Node Type: MethodCall ---
  Expressions using 'siginfo_sigfault' with 2 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_sigfault"})

--- AST Node Type: Paren ---
  Expressions using 'siginfo_sigfault' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ())' (Used Types: {"siginfo_sigfault", "* const siginfo_t", "siginfo_t"})

--- AST Node Type: Unary ---
  Expressions using 'siginfo_sigfault' with 2 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})

### Analyzing expressions using type: 'siginfo_t' ###

--- AST Node Type: Cast ---
  Expressions using 'siginfo_t' with 1 other type(s):
    Depth 8: (Count: 1)
      - 'self as * const siginfo_t' (Used Types: {"* const siginfo_t", "siginfo_t"})

--- AST Node Type: Field ---
  Expressions using 'siginfo_t' with 2 other type(s):
    Depth 2: (Count: 2)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()) . si_addr' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ()) . si_sigval' (Used Types: {"siginfo_timer", "siginfo_t", "* const siginfo_t"})
    Depth 3: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: MethodCall ---
  Expressions using 'siginfo_t' with 2 other type(s):
    Depth 5: (Count: 2)
      - '(self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_sigfault"})
      - '(self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_timer"})
    Depth 6: (Count: 1)
      - '(self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_f"})

--- AST Node Type: Paren ---
  Expressions using 'siginfo_t' with 1 other type(s):
    Depth 7: (Count: 1)
      - '(self as * const siginfo_t)' (Used Types: {"siginfo_t", "* const siginfo_t"})
  Expressions using 'siginfo_t' with 2 other type(s):
    Depth 3: (Count: 2)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ())' (Used Types: {"siginfo_sigfault", "* const siginfo_t", "siginfo_t"})
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ())' (Used Types: {"siginfo_timer", "* const siginfo_t", "siginfo_t"})
    Depth 4: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_f > ())' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

--- AST Node Type: Reference ---
  Expressions using 'siginfo_t' with 2 other type(s):
    Depth 2: (Count: 1)
      - '& (* (self as * const siginfo_t) . cast :: < siginfo_f > ()) . sifields' (Used Types: {"siginfo_t", "siginfo_f", "* const siginfo_t"})

--- AST Node Type: Unary ---
  Expressions using 'siginfo_t' with 2 other type(s):
    Depth 4: (Count: 2)
      - '* (self as * const siginfo_t) . cast :: < siginfo_sigfault > ()' (Used Types: {"* const siginfo_t", "siginfo_sigfault", "siginfo_t"})
      - '* (self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"siginfo_t", "siginfo_timer", "* const siginfo_t"})
    Depth 5: (Count: 1)
      - '* (self as * const siginfo_t) . cast :: < siginfo_f > ()' (Used Types: {"siginfo_t", "* const siginfo_t", "siginfo_f"})

### Analyzing expressions using type: 'siginfo_timer' ###

--- AST Node Type: Field ---
  Expressions using 'siginfo_timer' with 2 other type(s):
    Depth 2: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ()) . si_sigval' (Used Types: {"siginfo_timer", "siginfo_t", "* const siginfo_t"})

--- AST Node Type: MethodCall ---
  Expressions using 'siginfo_timer' with 2 other type(s):
    Depth 5: (Count: 1)
      - '(self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"* const siginfo_t", "siginfo_t", "siginfo_timer"})

--- AST Node Type: Paren ---
  Expressions using 'siginfo_timer' with 2 other type(s):
    Depth 3: (Count: 1)
      - '(* (self as * const siginfo_t) . cast :: < siginfo_timer > ())' (Used Types: {"siginfo_timer", "* const siginfo_t", "siginfo_t"})

--- AST Node Type: Unary ---
  Expressions using 'siginfo_timer' with 2 other type(s):
    Depth 4: (Count: 1)
      - '* (self as * const siginfo_t) . cast :: < siginfo_timer > ()' (Used Types: {"siginfo_t", "siginfo_timer", "* const siginfo_t"})

### Analyzing expressions using type: 'size_t' ###

--- AST Node Type: Binary ---
  Expressions using 'size_t' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(count as size_t + size_in_bits - 1) / 8' (Used Types: {"size_t"})
    Depth 6: (Count: 1)
      - 'count as size_t + size_in_bits - 1' (Used Types: {"size_t"})
    Depth 7: (Count: 1)
      - 'count as size_t + size_in_bits' (Used Types: {"size_t"})

--- AST Node Type: Cast ---
  Expressions using 'size_t' with 0 other type(s):
    Depth 2: (Count: 1)
      - '((count as size_t + size_in_bits - 1) / 8) as size_t' (Used Types: {"size_t"})
    Depth 8: (Count: 1)
      - 'count as size_t' (Used Types: {"size_t"})

--- AST Node Type: Paren ---
  Expressions using 'size_t' with 0 other type(s):
    Depth 3: (Count: 1)
      - '((count as size_t + size_in_bits - 1) / 8)' (Used Types: {"size_t"})
    Depth 5: (Count: 1)
      - '(count as size_t + size_in_bits - 1)' (Used Types: {"size_t"})

### Analyzing expressions using type: 'sock_fprog' ###

--- AST Node Type: Call ---
  Expressions using 'sock_fprog' with 0 other type(s):
    Depth 2: (Count: 3)
      - '_IOR :: < sock_fprog > (T_TYPE , 219)' (Used Types: {"sock_fprog"})
      - '_IOW :: < sock_fprog > (T_TYPE , 213)' (Used Types: {"sock_fprog"})
      - '_IOW :: < sock_fprog > (T_TYPE , 214)' (Used Types: {"sock_fprog"})

--- AST Node Type: Path ---
  Expressions using 'sock_fprog' with 0 other type(s):
    Depth 3: (Count: 2)
      - '_IOR :: < sock_fprog >' (Used Types: {"sock_fprog"})
      - '_IOW :: < sock_fprog >' (Used Types: {"sock_fprog"})

### Analyzing expressions using type: 'sockaddr' ###

--- AST Node Type: Cast ---
  Expressions using 'sockaddr' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'ee . offset (1) as * mut crate :: sockaddr' (Used Types: {"* mut crate :: sockaddr", "sockaddr"})

### Analyzing expressions using type: 'sockaddr_ll' ###

--- AST Node Type: Binary ---
  Expressions using 'sockaddr_ll' with 1 other type(s):
    Depth 2: (Count: 3)
      - '((size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"tpacket2_hdr", "sockaddr_ll"})
      - '((size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"tpacket3_hdr", "sockaddr_ll"})
      - '((size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"sockaddr_ll", "tpacket_hdr"})

--- AST Node Type: Call ---
  Expressions using 'sockaddr_ll' with 0 other type(s):
    Depth 3: (Count: 1)
      - 'size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"sockaddr_ll"})

--- AST Node Type: Path ---
  Expressions using 'sockaddr_ll' with 0 other type(s):
    Depth 4: (Count: 1)
      - 'size_of :: < crate :: sockaddr_ll >' (Used Types: {"sockaddr_ll"})

### Analyzing expressions using type: 'tpacket2_hdr' ###

--- AST Node Type: Binary ---
  Expressions using 'tpacket2_hdr' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket2_hdr"})
    Depth 6: (Count: 1)
      - 'size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1' (Used Types: {"tpacket2_hdr"})
    Depth 7: (Count: 1)
      - 'size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT' (Used Types: {"tpacket2_hdr"})
  Expressions using 'tpacket2_hdr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '((size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"tpacket2_hdr", "sockaddr_ll"})

--- AST Node Type: Call ---
  Expressions using 'tpacket2_hdr' with 0 other type(s):
    Depth 8: (Count: 1)
      - 'size_of :: < crate :: tpacket2_hdr > ()' (Used Types: {"tpacket2_hdr"})

--- AST Node Type: Paren ---
  Expressions using 'tpacket2_hdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '((size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1))' (Used Types: {"tpacket2_hdr"})
    Depth 5: (Count: 1)
      - '(size_of :: < crate :: tpacket2_hdr > () + TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket2_hdr"})

--- AST Node Type: Path ---
  Expressions using 'tpacket2_hdr' with 0 other type(s):
    Depth 9: (Count: 1)
      - 'size_of :: < crate :: tpacket2_hdr >' (Used Types: {"tpacket2_hdr"})

### Analyzing expressions using type: 'tpacket3_hdr' ###

--- AST Node Type: Binary ---
  Expressions using 'tpacket3_hdr' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket3_hdr"})
    Depth 6: (Count: 1)
      - 'size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1' (Used Types: {"tpacket3_hdr"})
    Depth 7: (Count: 1)
      - 'size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT' (Used Types: {"tpacket3_hdr"})
  Expressions using 'tpacket3_hdr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '((size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"tpacket3_hdr", "sockaddr_ll"})

--- AST Node Type: Call ---
  Expressions using 'tpacket3_hdr' with 0 other type(s):
    Depth 8: (Count: 1)
      - 'size_of :: < crate :: tpacket3_hdr > ()' (Used Types: {"tpacket3_hdr"})

--- AST Node Type: Paren ---
  Expressions using 'tpacket3_hdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '((size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1))' (Used Types: {"tpacket3_hdr"})
    Depth 5: (Count: 1)
      - '(size_of :: < crate :: tpacket3_hdr > () + TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket3_hdr"})

--- AST Node Type: Path ---
  Expressions using 'tpacket3_hdr' with 0 other type(s):
    Depth 9: (Count: 1)
      - 'size_of :: < crate :: tpacket3_hdr >' (Used Types: {"tpacket3_hdr"})

### Analyzing expressions using type: 'tpacket_hdr' ###

--- AST Node Type: Binary ---
  Expressions using 'tpacket_hdr' with 0 other type(s):
    Depth 4: (Count: 1)
      - '(size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket_hdr"})
    Depth 6: (Count: 1)
      - 'size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1' (Used Types: {"tpacket_hdr"})
    Depth 7: (Count: 1)
      - 'size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT' (Used Types: {"tpacket_hdr"})
  Expressions using 'tpacket_hdr' with 1 other type(s):
    Depth 2: (Count: 1)
      - '((size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1)) + size_of :: < crate :: sockaddr_ll > ()' (Used Types: {"sockaddr_ll", "tpacket_hdr"})

--- AST Node Type: Call ---
  Expressions using 'tpacket_hdr' with 0 other type(s):
    Depth 8: (Count: 1)
      - 'size_of :: < crate :: tpacket_hdr > ()' (Used Types: {"tpacket_hdr"})

--- AST Node Type: Paren ---
  Expressions using 'tpacket_hdr' with 0 other type(s):
    Depth 3: (Count: 1)
      - '((size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1) & ! (TPACKET_ALIGNMENT - 1))' (Used Types: {"tpacket_hdr"})
    Depth 5: (Count: 1)
      - '(size_of :: < crate :: tpacket_hdr > () + TPACKET_ALIGNMENT - 1)' (Used Types: {"tpacket_hdr"})

--- AST Node Type: Path ---
  Expressions using 'tpacket_hdr' with 0 other type(s):
    Depth 9: (Count: 1)
      - 'size_of :: < crate :: tpacket_hdr >' (Used Types: {"tpacket_hdr"})

### Analyzing expressions using type: 'unsafe extern "C" fn (crate :: ctypes :: c_int)' ###

--- AST Node Type: Call ---
  Expressions using 'unsafe extern "C" fn (crate :: ctypes :: c_int)' with 1 other type(s):
    Depth 2: (Count: 1)
      - 'Some (unsafe { core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1) })' (Used Types: {"unsafe extern \"C\" fn (crate :: ctypes :: c_int)", "c_int"})
    Depth 4: (Count: 1)
      - 'core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1)' (Used Types: {"c_int", "unsafe extern \"C\" fn (crate :: ctypes :: c_int)"})

--- AST Node Type: Path ---
  Expressions using 'unsafe extern "C" fn (crate :: ctypes :: c_int)' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) >' (Used Types: {"unsafe extern \"C\" fn (crate :: ctypes :: c_int)", "c_int"})

--- AST Node Type: Unsafe ---
  Expressions using 'unsafe extern "C" fn (crate :: ctypes :: c_int)' with 1 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { core :: mem :: transmute :: < usize , unsafe extern "C" fn (crate :: ctypes :: c_int) > (1) }' (Used Types: {"c_int", "unsafe extern \"C\" fn (crate :: ctypes :: c_int)"})

### Analyzing expressions using type: 'unsafe fn (* mut u128 , u128 , u128) -> u128' ###

--- AST Node Type: Block ---
  Expressions using 'unsafe fn (* mut u128 , u128 , u128) -> u128' with 5 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline (never)] unsafe fn atomic_compare_exchange_casp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } # [inline (never)] unsafe fn atomic_compare_exchange_casp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_casp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_relaxed (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Relaxed , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acquire (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Acquire , Ordering :: Acquire ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_release (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: Release , Ordering :: Relaxed ,) } } unsafe fn atomic_compare_exchange_ldxp_stxp_acqrel (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { unsafe { _atomic_compare_exchange_ldxp_stxp (dst , old , new , Ordering :: AcqRel , Ordering :: Acquire ,) } } unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "AtomicPtr", "()", "* mut ()", "FnTy"})
    Depth 5: (Count: 4)
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "FnTy", "()", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"AtomicPtr", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut u128", "* mut ()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"* mut u128", "* mut ()", "FnTy", "()", "unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()", "* mut u128", "AtomicPtr", "()", "FnTy"})

--- AST Node Type: Match ---
  Expressions using 'unsafe fn (* mut u128 , u128 , u128) -> u128' with 5 other type(s):
    Depth 4: (Count: 1)
      - 'match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"unsafe fn (* mut u128 , u128 , u128) -> u128", "AtomicPtr", "* mut ()", "FnTy", "()", "* mut u128"})

--- AST Node Type: Unsafe ---
  Expressions using 'unsafe fn (* mut u128 , u128 , u128) -> u128' with 5 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { let success = crate :: utils :: upgrade_success_ordering (success , failure ,) ; match success { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_relaxed } else { atomic_compare_exchange_ldxp_stxp_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acquire } else { atomic_compare_exchange_ldxp_stxp_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: Release => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_release } else { atomic_compare_exchange_ldxp_stxp_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } Ordering :: AcqRel | Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128 , u128 , u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , old : u128 , new : u128 ,) -> u128 { let func : FnTy = { if detect :: detect () . lse () { atomic_compare_exchange_casp_acqrel } else { atomic_compare_exchange_ldxp_stxp_acqrel } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , old , new) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , old , new) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128 , u128) -> u128", "* mut ()"})

### Analyzing expressions using type: 'unsafe fn (* mut u128 , u128)' ###

--- AST Node Type: Block ---
  Expressions using 'unsafe fn (* mut u128 , u128)' with 5 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline (never)] unsafe fn atomic_store_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_store_lse2_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_release (dst : * mut u128 , val : u128 ,) { unsafe { _atomic_store_stilp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse2_rcpc3_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_stilp (dst , val , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_store_lse128_release (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: Release) } } # [inline (never)] unsafe fn atomic_store_lse128_seqcst (dst : * mut u128 , val : u128) { unsafe { _atomic_store_swpp (dst , val , Ordering :: SeqCst) } } unsafe fn atomic_store_no_lse2_relaxed (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Relaxed) } } unsafe fn atomic_store_no_lse2_release (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: Release) } } unsafe fn atomic_store_no_lse2_seqcst (dst : * mut u128 , val : u128) { unsafe { atomic_store_no_lse2 (dst , val , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "()", "unsafe fn (* mut u128 , u128)", "FnTy", "* mut u128"})
    Depth 5: (Count: 3)
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()", "* mut ()"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut ()", "()", "* mut u128", "unsafe fn (* mut u128 , u128)", "AtomicPtr", "FnTy"})
      - '{ { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; }' (Used Types: {"* mut u128", "()", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut ()", "FnTy"})
    Depth 6: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "AtomicPtr", "* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "()"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"* mut u128", "()", "* mut ()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)"})
      - '{ type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) }' (Used Types: {"AtomicPtr", "* mut u128", "()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut ()"})

--- AST Node Type: Match ---
  Expressions using 'unsafe fn (* mut u128 , u128)' with 5 other type(s):
    Depth 4: (Count: 1)
      - 'match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut ()", "FnTy", "unsafe fn (* mut u128 , u128)", "* mut u128", "AtomicPtr", "()"})

--- AST Node Type: Unsafe ---
  Expressions using 'unsafe fn (* mut u128 , u128)' with 5 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { match order { Ordering :: Relaxed => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_store_lse2_relaxed } else { atomic_store_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: Release => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_release } else if cpuinfo . lse128 () { atomic_store_lse128_release } else { atomic_store_lse2_release } } else { atomic_store_no_lse2_release } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } Ordering :: SeqCst => { { type FnTy = unsafe fn (* mut u128 , u128) ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (dst : * mut u128 , val : u128) { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . lse128 () { atomic_store_lse128_seqcst } else if cpuinfo . rcpc3 () { atomic_store_lse2_rcpc3_seqcst } else { atomic_store_lse2_seqcst } } else { atomic_store_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (dst , val) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (dst , val) } ; } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"FnTy", "AtomicPtr", "unsafe fn (* mut u128 , u128)", "* mut u128", "* mut ()", "()"})

### Analyzing expressions using type: 'unsafe fn (* mut u128) -> u128' ###

--- AST Node Type: Block ---
  Expressions using 'unsafe fn (* mut u128) -> u128' with 5 other type(s):
    Depth 2: (Count: 1)
      - '{ # [inline (never)] unsafe fn atomic_load_lse2_relaxed (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Relaxed) } } # [inline (never)] unsafe fn atomic_load_lse2_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldp (src , Ordering :: SeqCst) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_acquire (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: Acquire) } } # [inline (never)] unsafe fn atomic_load_lse2_rcpc3_seqcst (src : * mut u128) -> u128 { unsafe { _atomic_load_ldiapp (src , Ordering :: SeqCst) } } unsafe fn atomic_load_no_lse2_relaxed (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Relaxed) } } unsafe fn atomic_load_no_lse2_acquire (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: Acquire) } } unsafe fn atomic_load_no_lse2_seqcst (src : * mut u128) -> u128 { unsafe { atomic_load_no_lse2 (src , Ordering :: SeqCst) } } unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } } }' (Used Types: {"AtomicPtr", "* mut ()", "* mut u128", "unsafe fn (* mut u128) -> u128", "()", "FnTy"})
    Depth 5: (Count: 3)
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut ()", "FnTy", "* mut u128", "AtomicPtr", "()", "unsafe fn (* mut u128) -> u128"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"* mut u128", "* mut ()", "unsafe fn (* mut u128) -> u128", "()", "AtomicPtr", "FnTy"})
      - '{ type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "* mut u128", "* mut ()", "FnTy", "()"})

--- AST Node Type: Match ---
  Expressions using 'unsafe fn (* mut u128) -> u128' with 5 other type(s):
    Depth 4: (Count: 1)
      - 'match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } }' (Used Types: {"* mut u128", "()", "FnTy", "AtomicPtr", "unsafe fn (* mut u128) -> u128", "* mut ()"})

--- AST Node Type: Unsafe ---
  Expressions using 'unsafe fn (* mut u128) -> u128' with 5 other type(s):
    Depth 3: (Count: 1)
      - 'unsafe { match order { Ordering :: Relaxed => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { atomic_load_lse2_relaxed } else { atomic_load_no_lse2_relaxed } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: Acquire => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_acquire } else { atomic_load_lse2_acquire } } else { atomic_load_no_lse2_acquire } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } Ordering :: SeqCst => { type FnTy = unsafe fn (* mut u128) -> u128 ; static FUNC : core :: sync :: atomic :: AtomicPtr < () > = core :: sync :: atomic :: AtomicPtr :: new (detect as * mut () ,) ; # [cold] unsafe fn detect (src : * mut u128) -> u128 { let func : FnTy = { let cpuinfo = detect :: detect () ; if cpuinfo . lse2 () { if cpuinfo . rcpc3 () { atomic_load_lse2_rcpc3_seqcst } else { atomic_load_lse2_seqcst } } else { atomic_load_no_lse2_seqcst } } ; FUNC . store (func as * mut () , core :: sync :: atomic :: Ordering :: Relaxed ,) ; unsafe { func (src) } } let func = { core :: mem :: transmute :: < * mut () , FnTy , > (FUNC . load (core :: sync :: atomic :: Ordering :: Relaxed)) } ; func (src) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } }' (Used Types: {"unsafe fn (* mut u128) -> u128", "AtomicPtr", "FnTy", "* mut ()", "* mut u128", "()"})
