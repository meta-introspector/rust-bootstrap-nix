Type Usage Report (Max Depth: 5)
================================================================

### Analyzing expressions using type: '& 'de ()' ###

--- AST Node Type: Block ---
  Expressions using '& 'de ()' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& 'de ()' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& 'de ()' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& 'static [& 'static str]' ###

--- AST Node Type: Block ---
  Expressions using '& 'static [& 'static str]' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& 'static [& 'static str]' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& 'static [& 'static str]' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& 'static str' ###

--- AST Node Type: Block ---
  Expressions using '& 'static str' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& 'static str' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& 'static str' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& Self' ###

--- AST Node Type: Block ---
  Expressions using '& Self' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})
  Expressions using '& Self' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& Self' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& Self' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& [u8]' ###

--- AST Node Type: Block ---
  Expressions using '& [u8]' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& [u8]' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& [u8]' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& mut _serde :: __private228 :: Formatter' ###

--- AST Node Type: Block ---
  Expressions using '& mut _serde :: __private228 :: Formatter' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& mut _serde :: __private228 :: Formatter' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& mut _serde :: __private228 :: Formatter' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '& str' ###

--- AST Node Type: Block ---
  Expressions using '& str' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '& str' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '& str' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '()' ###

--- AST Node Type: Block ---
  Expressions using '()' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '()' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '()' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'AstStatistics' ###

--- AST Node Type: Block ---
  Expressions using 'AstStatistics' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
  Expressions using 'AstStatistics' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Call ---
  Expressions using 'AstStatistics' with 0 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,)' (Used Types: {"AstStatistics"})

--- AST Node Type: Struct ---
  Expressions using 'AstStatistics' with 0 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , }' (Used Types: {"AstStatistics"})

### Analyzing expressions using type: 'Error' ###

--- AST Node Type: Block ---
  Expressions using 'Error' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})
  Expressions using 'Error' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Error' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Error' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: While ---
  Expressions using 'Error' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "IgnoredAny", "__Field"})
  Expressions using 'Error' with 3 other type(s):
    Depth 5: (Count: 2)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "Vec", "__Field", "IgnoredAny"})
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "Error", "__Field", "Option"})
  Expressions using 'Error' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'Formatter' ###

--- AST Node Type: Block ---
  Expressions using 'Formatter' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Formatter' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Formatter' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'FunctionInfo' ###

--- AST Node Type: Block ---
  Expressions using 'FunctionInfo' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
  Expressions using 'FunctionInfo' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'FunctionInfo' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Call ---
  Expressions using 'FunctionInfo' with 0 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,)' (Used Types: {"FunctionInfo"})

--- AST Node Type: Match ---
  Expressions using 'FunctionInfo' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"FunctionInfo", "Vec"})

--- AST Node Type: Struct ---
  Expressions using 'FunctionInfo' with 0 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , }' (Used Types: {"FunctionInfo"})

--- AST Node Type: While ---
  Expressions using 'FunctionInfo' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'HashMap' ###

--- AST Node Type: Block ---
  Expressions using 'HashMap' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Match ---
  Expressions using 'HashMap' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"HashMap"})

--- AST Node Type: While ---
  Expressions using 'HashMap' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'IgnoredAny' ###

--- AST Node Type: Block ---
  Expressions using 'IgnoredAny' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'IgnoredAny' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'IgnoredAny' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: While ---
  Expressions using 'IgnoredAny' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "IgnoredAny", "__Field"})
  Expressions using 'IgnoredAny' with 3 other type(s):
    Depth 5: (Count: 2)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "Vec", "__Field", "IgnoredAny"})
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "Error", "__Field", "Option"})
  Expressions using 'IgnoredAny' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'ImportInfo' ###

--- AST Node Type: Block ---
  Expressions using 'ImportInfo' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
  Expressions using 'ImportInfo' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
  Expressions using 'ImportInfo' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Call ---
  Expressions using 'ImportInfo' with 0 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,)' (Used Types: {"ImportInfo"})

--- AST Node Type: Match ---
  Expressions using 'ImportInfo' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"Vec", "ImportInfo"})

--- AST Node Type: Struct ---
  Expressions using 'ImportInfo' with 0 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , }' (Used Types: {"ImportInfo"})

--- AST Node Type: While ---
  Expressions using 'ImportInfo' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'Ok' ###

--- AST Node Type: Block ---
  Expressions using 'Ok' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})

### Analyzing expressions using type: 'Option' ###

--- AST Node Type: Block ---
  Expressions using 'Option' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Option' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Option' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Match ---
  Expressions using 'Option' with 0 other type(s):
    Depth 5: (Count: 4)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } }' (Used Types: {"Option"})
      - 'match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } }' (Used Types: {"Option"})
      - 'match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } }' (Used Types: {"Option"})
      - 'match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } }' (Used Types: {"Option"})

--- AST Node Type: While ---
  Expressions using 'Option' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "Error", "__Field", "Option"})

### Analyzing expressions using type: 'PhantomData' ###

--- AST Node Type: Block ---
  Expressions using 'PhantomData' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'PhantomData' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'PhantomData' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'Result' ###

--- AST Node Type: Block ---
  Expressions using 'Result' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})
  Expressions using 'Result' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Result' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Result' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'Self' ###

--- AST Node Type: Block ---
  Expressions using 'Self' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})
  Expressions using 'Self' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Self' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Self' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'Value' ###

--- AST Node Type: Block ---
  Expressions using 'Value' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'Value' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Value' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: 'VariableInfo' ###

--- AST Node Type: Block ---
  Expressions using 'VariableInfo' with 6 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})
  Expressions using 'VariableInfo' with 24 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using 'VariableInfo' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Call ---
  Expressions using 'VariableInfo' with 0 other type(s):
    Depth 4: (Count: 1)
      - '_serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,)' (Used Types: {"VariableInfo"})

--- AST Node Type: Match ---
  Expressions using 'VariableInfo' with 1 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"VariableInfo", "Vec"})

--- AST Node Type: Struct ---
  Expressions using 'VariableInfo' with 0 other type(s):
    Depth 5: (Count: 1)
      - '__Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , }' (Used Types: {"VariableInfo"})

--- AST Node Type: While ---
  Expressions using 'VariableInfo' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: 'Vec' ###

--- AST Node Type: Block ---
  Expressions using 'Vec' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using 'Vec' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: Match ---
  Expressions using 'Vec' with 0 other type(s):
    Depth 5: (Count: 1)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } }' (Used Types: {"Vec"})
  Expressions using 'Vec' with 1 other type(s):
    Depth 5: (Count: 3)
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"FunctionInfo", "Vec"})
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"Vec", "ImportInfo"})
      - 'match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } }' (Used Types: {"VariableInfo", "Vec"})

--- AST Node Type: While ---
  Expressions using 'Vec' with 3 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "Vec", "__Field", "IgnoredAny"})
  Expressions using 'Vec' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: '[& 'static str]' ###

--- AST Node Type: Block ---
  Expressions using '[& 'static str]' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '[& 'static str]' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '[& 'static str]' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '[u8]' ###

--- AST Node Type: Block ---
  Expressions using '[u8]' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '[u8]' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '[u8]' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '__A' ###

--- AST Node Type: Block ---
  Expressions using '__A' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__A' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__A' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '__D' ###

--- AST Node Type: Block ---
  Expressions using '__D' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__D' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__D' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '__E' ###

--- AST Node Type: Block ---
  Expressions using '__E' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__E' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__E' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '__Field' ###

--- AST Node Type: Block ---
  Expressions using '__Field' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__Field' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__Field' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

--- AST Node Type: While ---
  Expressions using '__Field' with 2 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "IgnoredAny", "__Field"})
  Expressions using '__Field' with 3 other type(s):
    Depth 5: (Count: 2)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"Error", "Vec", "__Field", "IgnoredAny"})
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "Error", "__Field", "Option"})
  Expressions using '__Field' with 7 other type(s):
    Depth 5: (Count: 1)
      - 'while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } }' (Used Types: {"IgnoredAny", "VariableInfo", "HashMap", "ImportInfo", "Error", "__Field", "FunctionInfo", "Vec"})

### Analyzing expressions using type: '__FieldVisitor' ###

--- AST Node Type: Block ---
  Expressions using '__FieldVisitor' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__FieldVisitor' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__FieldVisitor' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})

### Analyzing expressions using type: '__S' ###

--- AST Node Type: Block ---
  Expressions using '__S' with 6 other type(s):
    Depth 2: (Count: 4)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for AstStatistics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "AstStatistics" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "node_type_counts" , & self . node_type_counts ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "variable_declarations" , & self . variable_declarations ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "function_definitions" , & self . function_definitions ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "import_statements" , & self . import_statements ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Ok", "AstStatistics", "Error", "__S", "Self", "Result", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "visibility" , & self . visibility ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_count" , & self . arg_count ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "arg_types" , & self . arg_types ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "return_type" , & self . return_type ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_async" , & self . is_async ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_unsafe" , & self . is_unsafe ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_const" , & self . is_const ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "Self", "__S", "FunctionInfo", "& Self"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for ImportInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "ImportInfo" , false as usize + 1 + 1 + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "path" , & self . path ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "alias" , & self . alias ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_external" , & self . is_external ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "source_crate" , & self . source_crate ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_source_url" , & self . git_source_url ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "git_branch" , & self . git_branch ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"ImportInfo", "Self", "__S", "& Self", "Result", "Ok", "Error"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for VariableInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "VariableInfo" , false as usize + 1 + 1 + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "type_name" , & self . type_name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "is_mutable" , & self . is_mutable ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "scope" , & self . scope ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } }' (Used Types: {"Result", "Ok", "Error", "__S", "Self", "VariableInfo", "& Self"})

### Analyzing expressions using type: '__Visitor' ###

--- AST Node Type: Block ---
  Expressions using '__Visitor' with 24 other type(s):
    Depth 2: (Count: 2)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for ImportInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "path" => _serde :: __private228 :: Ok (__Field :: __field0) , "alias" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , "source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , "git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , "git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"path" => _serde :: __private228 :: Ok (__Field :: __field0) , b"alias" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_external" => _serde :: __private228 :: Ok (__Field :: __field2) , b"source_crate" => _serde :: __private228 :: Ok (__Field :: __field3) , b"git_source_url" => _serde :: __private228 :: Ok (__Field :: __field4) , b"git_branch" => _serde :: __private228 :: Ok (__Field :: __field5) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = ImportInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct ImportInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct ImportInfo with 6 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("path") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("alias") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_external" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source_crate" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_source_url" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("git_branch" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("path") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("alias") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_external") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("source_crate") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_source_url") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("git_branch") ? } } ; _serde :: __private228 :: Ok (ImportInfo { path : __field0 , alias : __field1 , is_external : __field2 , source_crate : __field3 , git_source_url : __field4 , git_branch : __field5 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["path" , "alias" , "is_external" , "source_crate" , "git_source_url" , "git_branch" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "ImportInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < ImportInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "()", "__Visitor", "IgnoredAny", "__FieldVisitor", "__D", "[u8]", "PhantomData", "__E", "& [u8]", "Value", "& 'de ()", "[& 'static str]", "__Field", "& 'static str", "Error", "Self", "& Self", "& 'static [& 'static str]", "Option", "Result", "ImportInfo", "Formatter", "__A", "& mut _serde :: __private228 :: Formatter"})
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for VariableInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , "is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , "scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"type_name" => _serde :: __private228 :: Ok (__Field :: __field1) , b"is_mutable" => _serde :: __private228 :: Ok (__Field :: __field2) , b"scope" => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = VariableInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct VariableInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct VariableInfo with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("type_name" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_mutable" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("scope") ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("type_name") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_mutable") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("scope") ? } } ; _serde :: __private228 :: Ok (VariableInfo { name : __field0 , type_name : __field1 , is_mutable : __field2 , scope : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "type_name" , "is_mutable" , "scope" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "VariableInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < VariableInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"& str", "__FieldVisitor", "& 'static [& 'static str]", "[& 'static str]", "__E", "& 'de ()", "Value", "& 'static str", "[u8]", "__D", "Self", "& [u8]", "Result", "VariableInfo", "& Self", "__Field", "Error", "__Visitor", "& mut _serde :: __private228 :: Formatter", "Formatter", "__A", "PhantomData", "Option", "IgnoredAny", "()"})
  Expressions using '__Visitor' with 25 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for FunctionInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , "arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , "arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , "return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , "is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , "is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , "is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"visibility" => _serde :: __private228 :: Ok (__Field :: __field1) , b"arg_count" => _serde :: __private228 :: Ok (__Field :: __field2) , b"arg_types" => _serde :: __private228 :: Ok (__Field :: __field3) , b"return_type" => _serde :: __private228 :: Ok (__Field :: __field4) , b"is_async" => _serde :: __private228 :: Ok (__Field :: __field5) , b"is_unsafe" => _serde :: __private228 :: Ok (__Field :: __field6) , b"is_const" => _serde :: __private228 :: Ok (__Field :: __field7) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = FunctionInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct FunctionInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < u32 , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < bool , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct FunctionInfo with 8 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < u32 > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < String > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < bool > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("visibility" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_count" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < u32 > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("arg_types" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < String > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_type" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_async" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_unsafe" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("is_const" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < bool > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("visibility") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_count") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("arg_types") ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("return_type") ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_async") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_unsafe") ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("is_const") ? } } ; _serde :: __private228 :: Ok (FunctionInfo { name : __field0 , visibility : __field1 , arg_count : __field2 , arg_types : __field3 , return_type : __field4 , is_async : __field5 , is_unsafe : __field6 , is_const : __field7 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "visibility" , "arg_count" , "arg_types" , "return_type" , "is_async" , "is_unsafe" , "is_const" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "FunctionInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < FunctionInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"__FieldVisitor", "[u8]", "__E", "Value", "& str", "& 'de ()", "Result", "Self", "__Visitor", "IgnoredAny", "& 'static str", "__D", "__Field", "& [u8]", "()", "__A", "Error", "Formatter", "FunctionInfo", "Vec", "[& 'static str]", "& Self", "& mut _serde :: __private228 :: Formatter", "PhantomData", "Option", "& 'static [& 'static str]"})
  Expressions using '__Visitor' with 29 other type(s):
    Depth 2: (Count: 1)
      - '{ # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for AstStatistics { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "node_type_counts" => _serde :: __private228 :: Ok (__Field :: __field0) , "variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } "function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } "import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"node_type_counts" => { _serde :: __private228 :: Ok (__Field :: __field0) } b"variable_declarations" => { _serde :: __private228 :: Ok (__Field :: __field1) } b"function_definitions" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"import_statements" => { _serde :: __private228 :: Ok (__Field :: __field3) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = AstStatistics ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct AstStatistics" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < HashMap < String , u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Vec < VariableInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Vec < FunctionInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Vec < ImportInfo > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct AstStatistics with 4 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < HashMap < String , u32 > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Vec < VariableInfo > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Vec < FunctionInfo > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Vec < ImportInfo > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("node_type_counts" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < HashMap < String , u32 > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("variable_declarations" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < VariableInfo > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("function_definitions" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < FunctionInfo > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("import_statements" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Vec < ImportInfo > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("node_type_counts") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("variable_declarations" ,) ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("function_definitions" ,) ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("import_statements") ? } } ; _serde :: __private228 :: Ok (AstStatistics { node_type_counts : __field0 , variable_declarations : __field1 , function_definitions : __field2 , import_statements : __field3 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["node_type_counts" , "variable_declarations" , "function_definitions" , "import_statements" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "AstStatistics" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < AstStatistics > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } }' (Used Types: {"AstStatistics", "VariableInfo", "& mut _serde :: __private228 :: Formatter", "__FieldVisitor", "__Visitor", "__A", "FunctionInfo", "& 'de ()", "__D", "__Field", "Result", "HashMap", "IgnoredAny", "Error", "& [u8]", "__E", "Value", "& Self", "[& 'static str]", "PhantomData", "Vec", "Self", "Formatter", "ImportInfo", "& 'static [& 'static str]", "& str", "[u8]", "& 'static str", "()", "Option"})
