use anyhow::{Context, Result};
use clap::Parser;
use std::path::PathBuf;
use std::fs;

mod metadata;

mod flake_lock;
mod expander;
mod manifest;
mod decl_parser;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the full_metadata.json file generated by cargo metadata.
    #[arg(long)]
    metadata_path: PathBuf,

    /// Directory where expanded code and metadata will be stored.
    #[arg(long)]
    output_dir: PathBuf,

    /// Clean the output directory before processing.
    #[arg(long, default_value_t = false)]
    clean: bool,

    /// Rustc version (e.g., "1.89.0").
    #[arg(long)]
    rustc_version: String,

    /// Rustc host triple (e.g., "aarch64-unknown-linux-gnu").
    #[arg(long)]
    rustc_host: String,

    /// Project root directory.
    #[arg(long)]
    project_root: PathBuf,

    /// Optional: Process only crates at a specific dependency layer.
    #[arg(long)]
    layer: Option<u32>,

    /// Optional: Process only a specific package by name.
    #[arg(long)]
    package: Option<String>,

    /// If true, print commands and actions without executing them.
    #[arg(long, default_value_t = false)]
    dry_run: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    if args.clean {
        if args.output_dir.exists() {
            fs::remove_dir_all(&args.output_dir)
                .context("Failed to clean output directory")?;
            println!("Cleaned output directory: {}", args.output_dir.display());
        }
    }

    // Ensure output directory exists
    fs::create_dir_all(&args.output_dir)
        .context("Failed to create output directory")?;

    let flake_lock_json = flake_lock::get_flake_lock_json().await?;

    let expanded_files_with_content = expander::expand_code(
        &args.metadata_path,
        &args.output_dir,
        &flake_lock_json,
        args.layer,
        args.package,
        args.dry_run,
    ).await?;

    let mut expanded_files_entries = Vec::new();

    for (mut entry, content) in expanded_files_with_content {
        println!("\n--- Declarations for {} ({}) ---", entry.package_name, entry.target_name);
        let (declarations, counts) = decl_parser::parse_declarations(&content);
        for decl in declarations {
            println!("  {:?} {} (lines {}-{})", decl.decl_type, decl.name, decl.span_start, decl.span_end);
        }
        println!("  --- Declaration Counts ---");
        for (decl_type, count) in &counts {
            println!("    {:?}: {}", decl_type, count);
        }
        entry.declaration_counts = counts;
        expanded_files_entries.push(entry);
    }

    let manifest = manifest::ExpandedManifest {
        rustc_version: args.rustc_version,
        rustc_host: args.rustc_host,
        project_root: args.project_root,
        expanded_files: expanded_files_entries,
    };

    let manifest_path = args.output_dir.join("expanded_manifest.json");
    let manifest_json = serde_json::to_string_pretty(&manifest)
        .context("Failed to serialize expanded manifest")?;
    fs::write(&manifest_path, manifest_json)
        .context(format!("Failed to write expanded manifest to {}", manifest_path.display()))?;

    println!("Generated expanded manifest: {}", manifest_path.display());

    // Call the new function to print the table
    print_expanded_files_table(&manifest);

    Ok(())
}

fn print_expanded_files_table(manifest: &manifest::ExpandedManifest) {
    println!("\n| ID | Type | Size (bytes) | Filename | Level |");
    println!("|---|---|---|---|---|");

    for entry in &manifest.expanded_files {
        let file_id = format!("{}-{}-{}", entry.package_name, entry.target_name, entry.target_type);
        let file_type = &entry.target_type;
        let file_size = entry.file_size;
        let filename = entry.expanded_rs_path.display();
        let level = entry.layer;
        println!("| {} | {} | {} | {} | {} |", file_id, file_type, file_size, filename, level);
    }
}
