use anyhow::{Context, Result};
use clap::Parser;
use std::path::PathBuf;
use std::fs;

mod metadata;

mod flake_lock;
mod expander;
mod manifest;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the full_metadata.json file generated by cargo metadata.
    #[arg(long)]
    metadata_path: PathBuf,

    /// Directory where expanded code and metadata will be stored.
    #[arg(long)]
    output_dir: PathBuf,

    /// Clean the output directory before processing.
    #[arg(long, default_value_t = false)]
    clean: bool,

    /// Rustc version (e.g., "1.89.0").
    #[arg(long)]
    rustc_version: String,

    /// Rustc host triple (e.g., "aarch64-unknown-linux-gnu").
    #[arg(long)]
    rustc_host: String,

    /// Project root directory.
    #[arg(long)]
    project_root: PathBuf,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    if args.clean {
        if args.output_dir.exists() {
            fs::remove_dir_all(&args.output_dir)
                .context("Failed to clean output directory")?;
            println!("Cleaned output directory: {}", args.output_dir.display());
        }
    }

    // Ensure output directory exists
    fs::create_dir_all(&args.output_dir)
        .context("Failed to create output directory")?;

    let flake_lock_json = flake_lock::get_flake_lock_json().await?;

    let expanded_files = expander::expand_code(
        &args.metadata_path,
        &args.output_dir,
        &flake_lock_json,
    ).await?;

    let manifest = manifest::ExpandedManifest {
        rustc_version: args.rustc_version,
        rustc_host: args.rustc_host,
        project_root: args.project_root,
        expanded_files,
    };

    let manifest_path = args.output_dir.join("expanded_manifest.json");
    let manifest_json = serde_json::to_string_pretty(&manifest)
        .context("Failed to serialize expanded manifest")?;
    fs::write(&manifest_path, manifest_json)
        .context(format!("Failed to write expanded manifest to {}", manifest_path.display()))?;

    println!("Generated expanded manifest: {}", manifest_path.display());

    Ok(())
}
