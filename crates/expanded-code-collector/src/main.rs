use anyhow::{Context, Result};
use clap::Parser;
use std::path::PathBuf;
use std::fs;

mod metadata;
mod expanded_metadata;
mod flake_lock;
mod expander;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the full_metadata.json file generated by cargo metadata.
    #[arg(long)]
    metadata_path: PathBuf,

    /// Directory where expanded code and metadata will be stored.
    #[arg(long)]
    output_dir: PathBuf,

    /// Clean the output directory before processing.
    #[arg(long, default_value_t = false)]
    clean: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    if args.clean {
        if args.output_dir.exists() {
            fs::remove_dir_all(&args.output_dir)
                .context("Failed to clean output directory")?;
            println!("Cleaned output directory: {}", args.output_dir.display());
        }
    }

    // Ensure output directory exists
    fs::create_dir_all(&args.output_dir)
        .context("Failed to create output directory")?;

    let flake_lock_json = flake_lock::get_flake_lock_json().await?;

    expander::expand_code(
        &args.metadata_path,
        &args.output_dir,
        &flake_lock_json,
    ).await?;

    Ok(())
}
