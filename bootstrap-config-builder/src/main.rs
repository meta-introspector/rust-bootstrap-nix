use anyhow::{Context, Result};
use clap::Parser;
use std::{
    fs,
    path::PathBuf,
    process::Command,
};

/// A tool to generate config.toml for the rust-bootstrap process by querying Nix flakes.
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// The bootstrap stage number (e.g., 0, 1, 2)
    #[arg()]
    stage: String,

    /// The target triple for the build (e.g., aarch64-unknown-linux-gnu)
    #[arg()]
    target: String,

    /// The path to the project root (where the top-level flake.nix is located)
    #[arg(long)]
    project_root: PathBuf,

    /// The host system (e.g., aarch64-linux)
    #[arg(long)]
    system: String,

    /// Output file path
    #[arg(long, short, default_value = "config.toml")]
    output: PathBuf,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // 1. Validate the project root
    let project_root = fs::canonicalize(&args.project_root)
        .with_context(|| format!("Failed to find absolute path for project root: {:?}", args.project_root))?;

    if !project_root.join("flake.nix").exists() {
        anyhow::bail!("flake.nix not found in the specified project root: {:?}", project_root);
    }
    let flake_path_str = project_root.to_str()
        .context("Project root path contains non-UTF8 characters")?;

    // 2. Query Nix for all required flake input paths
    let get_flake_input = |input_name: &str| -> Result<String> {
        let expr = format!(
            "(builtins.getFlake \"path:{}\").inputs.{}.outPath",
            flake_path_str,
            input_name
        );
        let output = Command::new("nix")
            .args(&["eval", "--raw", "--extra-experimental-features", "nix-command flakes", "--expr", &expr])
            .output()
            .with_context(|| format!("Failed to execute nix eval for input '{}'", input_name))?;

        if !output.status.success() {
            anyhow::bail!(
                "Nix command failed for input '{}':\n{}",
                input_name,
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(String::from_utf8(output.stdout)?.trim().to_string())
    };

    let nixpkgs_path = get_flake_input("nixpkgs")?;
    let rust_overlay_path = get_flake_input("rust-overlay")?;
    // These inputs might not exist in every flake, so we handle potential errors.
    let rust_bootstrap_nix_path = get_flake_input("rustBootstrapNix").unwrap_or_else(|_| "not-found".to_string());
    let configuration_nix_path = get_flake_input("configurationNix").unwrap_or_else(|_| "not-found".to_string());
    let rust_src_flake_path = get_flake_input("rustSrcFlake")?;


    // 3. Construct the config.toml content
    let config_content = format!(
        r###"# Generated by bootstrap-config-builder
#
# System: {}
# Project Root: {}

[nix]
nixpkgs_path = "{}"ust_overlay_path = "{}"ust_bootstrap_nix_path = "{}"
configuration_nix_path = "{}"
rust_src_flake_path = "{}"

[build]
stage = {}
target = "{}"
"###,
        args.system,
        flake_path_str,
        nixpkgs_path,
        rust_overlay_path,
        rust_bootstrap_nix_path,
        configuration_nix_path,
        rust_src_flake_path,
        args.stage,
        args.target
    );

    // 4. Write the output file
    fs::write(&args.output, config_content)
        .with_context(|| format!("Failed to write config to file: {:?}", args.output))?;

    println!("Successfully generated config file at: {:?}", args.output);

    Ok(())
}