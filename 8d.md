This document outlines the process for managing declarations within an 8-dimensional (8D) conceptual space.

Initially, all declaration names are hashed to detect potential collisions before file generation. These declarations are then organized into `type/name` directories. We can further process these names by splitting them into sub-words (e.g., from camelCase or snake_case) and mapping them into an 8D chord using an embedding function.

Each declaration is conceptualized as nesting up to 8 parameters or levels within a lattice structure. Most declarations will not share common bases, which naturally forms a group structure. The paths from a base declaration to its leaf-level components will vary, and these paths can be represented as coordinates within the 8D space.

In future stages, string constants will be replaced with references to them. These references will act as "Level 1 users" of "Layer 0 constants," establishing a clear dependency hierarchy. We will also calculate a minimal set of necessary `use` statements (includes) for each generated code unit. An advanced Minizinc solver can then be employed to determine the optimal placement of these declarations, potentially optimizing for factors like file size, access patterns, or dependency minimization.

### Bag of Words and Coordinate Grouping for Declarations

To further refine the organization and inclusion of declarations, we will implement a "bag of words" approach for each declaration and group them into "coordinates" with module paths. The goal is to create canonical include files for terms mapped into a prelude, with each module combining necessary types and functions. This process is crucial for understanding new terms or types introduced into the codebase.

**Revised Plan:**

1.  **Enhance `DeclsVisitor` to collect "bag of words":**
    *   For each `syn::Item` visited, collect all `syn::Ident` (identifiers) used within the item, distinguishing between types, functions, and other identifiers.
    *   Identify if an identifier is "external" (i.e., not defined within the current file or project, but imported).
    *   Store this "bag of words" alongside the `syn::Item` in the `DeclsVisitor`.

2.  **Introduce a `Declaration` struct:** Create a generic `Declaration` enum or struct that wraps the `syn::Item` and includes its associated "bag of words" and potentially other metadata.

3.  **Implement a Grouping/Coordination Logic:**
    *   After all declarations are extracted and their "bag of words" are determined, implement a logic to group them.
    *   The grouping criteria should aim for ~4KB chunks (a single disk block), using the "bag of words" as the primary input for grouping declarations with similar dependencies. This ensures efficient storage and retrieval.

4.  **Generate Module Paths for Groups:** For each group, generate a unique and descriptive module path (e.g., `prelude::group_hash_XXXX`).

5.  **Generate a "Canonical Prelude" File:** Create a main `prelude.rs` file that contains `pub use` statements for all the generated group modules.

6.  **Symbol Table and Primitive Registration:**
    *   Establish a symbol table (e.g., a dictionary or hash map) to register primitives (like Rust's built-in types).
    *   Populate this symbol table with modules, where each module represents a "lattice" or "gem" of related declarations. This will include Rust's standard library, this project's modules, and potentially external crates.
    *   This symbol table will serve as a baseline to identify new terms or types introduced in the codebase.