#![feature(panic_internals)]
#![feature(print_internals)]

use prelude::*;

# [doc = " A trait that abstracts over Aho-Corasick automata."] # [doc = ""] # [doc = " This trait primarily exists for niche use cases such as:"] # [doc = ""] # [doc = " * Using an NFA or DFA directly, bypassing the top-level"] # [doc = " [`AhoCorasick`](crate::AhoCorasick) searcher. Currently, these include"] # [doc = " [`noncontiguous::NFA`](crate::nfa::noncontiguous::NFA),"] # [doc = " [`contiguous::NFA`](crate::nfa::contiguous::NFA) and"] # [doc = " [`dfa::DFA`](crate::dfa::DFA)."] # [doc = " * Implementing your own custom search routine by walking the automaton"] # [doc = " yourself. This might be useful for implementing search on non-contiguous"] # [doc = " strings or streams."] # [doc = ""] # [doc = " For most use cases, it is not expected that users will need"] # [doc = " to use or even know about this trait. Indeed, the top level"] # [doc = " [`AhoCorasick`](crate::AhoCorasick) searcher does not expose any details"] # [doc = " about this trait, nor does it implement it itself."] # [doc = ""] # [doc = " Note that this trait defines a number of default methods, such as"] # [doc = " [`Automaton::try_find`] and [`Automaton::try_find_iter`], which implement"] # [doc = " higher level search routines in terms of the lower level automata API."] # [doc = ""] # [doc = " # Sealed"] # [doc = ""] # [doc = " Currently, this trait is sealed. That means users of this crate can write"] # [doc = " generic routines over this trait but cannot implement it themselves. This"] # [doc = " restriction may be lifted in the future, but sealing the trait permits"] # [doc = " adding new required methods in a backwards compatible fashion."] # [doc = ""] # [doc = " # Special states"] # [doc = ""] # [doc = " This trait encodes a notion of \"special\" states in an automaton. Namely,"] # [doc = " a state is treated as special if it is a dead, match or start state:"] # [doc = ""] # [doc = " * A dead state is a state that cannot be left once entered. All transitions"] # [doc = " on a dead state lead back to itself. The dead state is meant to be treated"] # [doc = " as a sentinel indicating that the search should stop and return a match if"] # [doc = " one has been found, and nothing otherwise."] # [doc = " * A match state is a state that indicates one or more patterns have"] # [doc = " matched. Depending on the [`MatchKind`] of the automaton, a search may"] # [doc = " stop once a match is seen, or it may continue looking for matches until"] # [doc = " it enters a dead state or sees the end of the haystack."] # [doc = " * A start state is a state that a search begins in. It is useful to know"] # [doc = " when a search enters a start state because it may mean that a prefilter can"] # [doc = " be used to skip ahead and quickly look for candidate matches. Unlike dead"] # [doc = " and match states, it is never necessary to explicitly handle start states"] # [doc = " for correctness. Indeed, in this crate, implementations of `Automaton`"] # [doc = " will only treat start states as \"special\" when a prefilter is enabled and"] # [doc = " active. Otherwise, treating it as special has no purpose and winds up"] # [doc = " slowing down the overall search because it results in ping-ponging between"] # [doc = " the main state transition and the \"special\" state logic."] # [doc = ""] # [doc = " Since checking whether a state is special by doing three different"] # [doc = " checks would be too expensive inside a fast search loop, the"] # [doc = " [`Automaton::is_special`] method is provided for quickly checking whether"] # [doc = " the state is special. The `Automaton::is_dead`, `Automaton::is_match` and"] # [doc = " `Automaton::is_start` predicates can then be used to determine which kind"] # [doc = " of special state it is."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " Most of the APIs on this trait should panic or give incorrect results"] # [doc = " if invalid inputs are given to it. For example, `Automaton::next_state`"] # [doc = " has unspecified behavior if the state ID given to it is not a valid"] # [doc = " state ID for the underlying automaton. Valid state IDs can only be"] # [doc = " retrieved in one of two ways: calling `Automaton::start_state` or calling"] # [doc = " `Automaton::next_state` with a valid state ID."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " This trait is not safe to implement so that code may rely on the"] # [doc = " correctness of implementations of this trait to avoid undefined behavior."] # [doc = " The primary correctness guarantees are:"] # [doc = ""] # [doc = " * `Automaton::start_state` always returns a valid state ID or an error or"] # [doc = " panics."] # [doc = " * `Automaton::next_state`, when given a valid state ID, always returns"] # [doc = " a valid state ID for all values of `anchored` and `byte`, or otherwise"] # [doc = " panics."] # [doc = ""] # [doc = " In general, the rest of the methods on `Automaton` need to uphold their"] # [doc = " contracts as well. For example, `Automaton::is_dead` should only returns"] # [doc = " true if the given state ID is actually a dead state."] # [doc = ""] # [doc = " Note that currently this crate does not rely on the safety property defined"] # [doc = " here to avoid undefined behavior. Instead, this was done to make it"] # [doc = " _possible_ to do in the future."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how one might implement a basic but correct search"] # [doc = " routine. We keep things simple by not using prefilters or worrying about"] # [doc = " anchored searches, but do make sure our search is correct for all possible"] # [doc = " [`MatchKind`] semantics. (The comments in the code below note the parts"] # [doc = " that are needed to support certain `MatchKind` semantics.)"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::Automaton,"] # [doc = "     nfa::noncontiguous::NFA,"] # [doc = "     Anchored, Match, MatchError, MatchKind,"] # [doc = " };"] # [doc = ""] # [doc = " // Run an unanchored search for 'aut' in 'haystack'. Return the first match"] # [doc = " // seen according to the automaton's match semantics. This returns an error"] # [doc = " // if the given automaton does not support unanchored searches."] # [doc = " fn find<A: Automaton>("] # [doc = "     aut: A,"] # [doc = "     haystack: &[u8],"] # [doc = " ) -> Result<Option<Match>, MatchError> {"] # [doc = "     let mut sid = aut.start_state(Anchored::No)?;"] # [doc = "     let mut at = 0;"] # [doc = "     let mut mat = None;"] # [doc = "     let get_match = |sid, at| {"] # [doc = "         let pid = aut.match_pattern(sid, 0);"] # [doc = "         let len = aut.pattern_len(pid);"] # [doc = "         Match::new(pid, (at - len)..at)"] # [doc = "     };"] # [doc = "     // Start states can be match states!"] # [doc = "     if aut.is_match(sid) {"] # [doc = "         mat = Some(get_match(sid, at));"] # [doc = "         // Standard semantics require matches to be reported as soon as"] # [doc = "         // they're seen. Otherwise, we continue until we see a dead state"] # [doc = "         // or the end of the haystack."] # [doc = "         if matches!(aut.match_kind(), MatchKind::Standard) {"] # [doc = "             return Ok(mat);"] # [doc = "         }"] # [doc = "     }"] # [doc = "     while at < haystack.len() {"] # [doc = "         sid = aut.next_state(Anchored::No, sid, haystack[at]);"] # [doc = "         if aut.is_special(sid) {"] # [doc = "             if aut.is_dead(sid) {"] # [doc = "                 return Ok(mat);"] # [doc = "             } else if aut.is_match(sid) {"] # [doc = "                 mat = Some(get_match(sid, at + 1));"] # [doc = "                 // As above, standard semantics require that we return"] # [doc = "                 // immediately once a match is found."] # [doc = "                 if matches!(aut.match_kind(), MatchKind::Standard) {"] # [doc = "                     return Ok(mat);"] # [doc = "                 }"] # [doc = "             }"] # [doc = "         }"] # [doc = "         at += 1;"] # [doc = "     }"] # [doc = "     Ok(mat)"] # [doc = " }"] # [doc = ""] # [doc = " // Show that it works for standard searches."] # [doc = " let nfa = NFA::new(&[\"samwise\", \"sam\"]).unwrap();"] # [doc = " assert_eq!(Some(Match::must(1, 0..3)), find(&nfa, b\"samwise\")?);"] # [doc = ""] # [doc = " // But also works when using leftmost-first. Notice how the match result"] # [doc = " // has changed!"] # [doc = " let nfa = NFA::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(&[\"samwise\", \"sam\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(Some(Match::must(0, 0..7)), find(&nfa, b\"samwise\")?);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub unsafe trait Automaton : private :: Sealed { # [doc = " Returns the starting state for the given anchor mode."] # [doc = ""] # [doc = " Upon success, the state ID returned is guaranteed to be valid for"] # [doc = " this automaton."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when the given search configuration is not"] # [doc = " supported by the underlying automaton. For example, if the underlying"] # [doc = " automaton only supports unanchored searches but the given configuration"] # [doc = " was set to an anchored search, then this must return an error."] fn start_state (& self , anchored : Anchored) -> Result < StateID , MatchError > ; # [doc = " Performs a state transition from `sid` for `byte` and returns the next"] # [doc = " state."] # [doc = ""] # [doc = " `anchored` should be [`Anchored::Yes`] when executing an anchored"] # [doc = " search and [`Anchored::No`] otherwise. For some implementations of"] # [doc = " `Automaton`, it is required to know whether the search is anchored"] # [doc = " or not in order to avoid following failure transitions. Other"] # [doc = " implementations may ignore `anchored` altogether and depend on"] # [doc = " `Automaton::start_state` returning a state that walks a different path"] # [doc = " through the automaton depending on whether the search is anchored or"] # [doc = " not."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This routine may panic or return incorrect results when the given state"] # [doc = " ID is invalid. A state ID is valid if and only if:"] # [doc = ""] # [doc = " 1. It came from a call to `Automaton::start_state`, or"] # [doc = " 2. It came from a previous call to `Automaton::next_state` with a"] # [doc = " valid state ID."] # [doc = ""] # [doc = " Implementations must treat all possible values of `byte` as valid."] # [doc = ""] # [doc = " Implementations may panic on unsupported values of `anchored`, but are"] # [doc = " not required to do so."] fn next_state (& self , anchored : Anchored , sid : StateID , byte : u8) -> StateID ; # [doc = " Returns true if the given ID represents a \"special\" state. A special"] # [doc = " state is a dead, match or start state."] # [doc = ""] # [doc = " Note that implementations may choose to return false when the given ID"] # [doc = " corresponds to a start state. Namely, it always correct to treat start"] # [doc = " states as non-special. Implementations must return true for states that"] # [doc = " are dead or contain matches."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_special (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a dead state."] # [doc = ""] # [doc = " A dead state is a type of \"sink\" in a finite state machine. It"] # [doc = " corresponds to a state whose transitions all loop back to itself. That"] # [doc = " is, once entered, it can never be left. In practice, it serves as a"] # [doc = " sentinel indicating that the search should terminate."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_dead (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a match state."] # [doc = ""] # [doc = " A match state is always associated with one or more pattern IDs that"] # [doc = " matched at the position in the haystack when the match state was"] # [doc = " entered. When a match state is entered, the match semantics dictate"] # [doc = " whether it should be returned immediately (for `MatchKind::Standard`)"] # [doc = " or if the search should continue (for `MatchKind::LeftmostFirst` and"] # [doc = " `MatchKind::LeftmostLongest`) until a dead state is seen or the end of"] # [doc = " the haystack has been reached."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_match (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a start state."] # [doc = ""] # [doc = " While it is never incorrect to ignore start states during a search"] # [doc = " (except for the start of the search of course), knowing whether one has"] # [doc = " entered a start state can be useful for certain classes of performance"] # [doc = " optimizations. For example, if one is in a start state, it may be legal"] # [doc = " to try to skip ahead and look for match candidates more quickly than"] # [doc = " would otherwise be accomplished by walking the automaton."] # [doc = ""] # [doc = " Implementations of `Automaton` in this crate \"unspecialize\" start"] # [doc = " states when a prefilter is not active or enabled. In this case, it"] # [doc = " is possible for `Automaton::is_special(sid)` to return false while"] # [doc = " `Automaton::is_start(sid)` returns true."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_start (& self , sid : StateID) -> bool ; # [doc = " Returns the match semantics that this automaton was built with."] fn match_kind (& self) -> MatchKind ; # [doc = " Returns the total number of matches for the given state ID."] # [doc = ""] # [doc = " This has unspecified behavior if the given ID does not refer to a match"] # [doc = " state."] fn match_len (& self , sid : StateID) -> usize ; # [doc = " Returns the pattern ID for the match state given by `sid` at the"] # [doc = " `index` given."] # [doc = ""] # [doc = " Typically, `index` is only ever greater than `0` when implementing an"] # [doc = " overlapping search. Otherwise, it's likely that your search only cares"] # [doc = " about reporting the first pattern ID in a match state."] # [doc = ""] # [doc = " This has unspecified behavior if the given ID does not refer to a match"] # [doc = " state, or if the index is greater than or equal to the total number of"] # [doc = " matches in this match state."] fn match_pattern (& self , sid : StateID , index : usize) -> PatternID ; # [doc = " Returns the total number of patterns compiled into this automaton."] fn patterns_len (& self) -> usize ; # [doc = " Returns the length of the pattern for the given ID."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid pattern"] # [doc = " ID. A pattern ID is valid if and only if it is less than"] # [doc = " `Automaton::patterns_len`."] fn pattern_len (& self , pid : PatternID) -> usize ; # [doc = " Returns the length, in bytes, of the shortest pattern in this"] # [doc = " automaton."] fn min_pattern_len (& self) -> usize ; # [doc = " Returns the length, in bytes, of the longest pattern in this automaton."] fn max_pattern_len (& self) -> usize ; # [doc = " Returns the heap memory usage, in bytes, used by this automaton."] fn memory_usage (& self) -> usize ; # [doc = " Returns a prefilter, if available, that can be used to accelerate"] # [doc = " searches for this automaton."] # [doc = ""] # [doc = " The typical way this is used is when the start state is entered during"] # [doc = " a search. When that happens, one can use a prefilter to skip ahead and"] # [doc = " look for candidate matches without having to walk the automaton on the"] # [doc = " bytes between candidates."] # [doc = ""] # [doc = " Typically a prefilter is only available when there are a small (<100)"] # [doc = " number of patterns built into the automaton."] fn prefilter (& self) -> Option < & Prefilter > ; # [doc = " Executes a non-overlapping search with this automaton using the given"] # [doc = " configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find`](crate::AhoCorasick::try_find)"] # [doc = " for more documentation and examples."] fn try_find (& self , input : & Input < '_ >) -> Result < Option < Match > , MatchError > { try_find_fwd (& self , input) } # [doc = " Executes a overlapping search with this automaton using the given"] # [doc = " configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_overlapping`](crate::AhoCorasick::try_find_overlapping)"] # [doc = " for more documentation and examples."] fn try_find_overlapping (& self , input : & Input < '_ > , state : & mut OverlappingState ,) -> Result < () , MatchError > { try_find_overlapping_fwd (& self , input , state) } # [doc = " Returns an iterator of non-overlapping matches with this automaton"] # [doc = " using the given configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_iter`](crate::AhoCorasick::try_find_iter)"] # [doc = " for more documentation and examples."] fn try_find_iter < 'a , 'h > (& 'a self , input : Input < 'h > ,) -> Result < FindIter < 'a , 'h , Self > , MatchError > where Self : Sized , { FindIter :: new (self , input) } # [doc = " Returns an iterator of overlapping matches with this automaton"] # [doc = " using the given configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_overlapping_iter`](crate::AhoCorasick::try_find_overlapping_iter)"] # [doc = " for more documentation and examples."] fn try_find_overlapping_iter < 'a , 'h > (& 'a self , input : Input < 'h > ,) -> Result < FindOverlappingIter < 'a , 'h , Self > , MatchError > where Self : Sized , { if ! self . match_kind () . is_standard () { return Err (MatchError :: unsupported_overlapping (self . match_kind ())) ; } if input . get_anchored () . is_anchored () { return Err (MatchError :: invalid_input_anchored ()) ; } let _ = self . start_state (input . get_anchored ()) ? ; let state = OverlappingState :: start () ; Ok (FindOverlappingIter { aut : self , input , state , }) } # [doc = " Replaces all non-overlapping matches in `haystack` with"] # [doc = " strings from `replace_with` depending on the pattern that"] # [doc = " matched. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all`](crate::AhoCorasick::try_replace_all)"] # [doc = " for more documentation and examples."] fn try_replace_all < B > (& self , haystack : & str , replace_with : & [B] ,) -> Result < String , MatchError > where Self : Sized , B : AsRef < str > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; let mut dst = String :: with_capacity (haystack . len ()) ; self . try_replace_all_with (haystack , & mut dst , | mat , _ , dst | { dst . push_str (replace_with [mat . pattern ()] . as_ref ()) ; true } ,) ? ; Ok (dst) } # [doc = " Replaces all non-overlapping matches in `haystack` with"] # [doc = " strings from `replace_with` depending on the pattern that"] # [doc = " matched. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_bytes`](crate::AhoCorasick::try_replace_all_bytes)"] # [doc = " for more documentation and examples."] fn try_replace_all_bytes < B > (& self , haystack : & [u8] , replace_with : & [B] ,) -> Result < Vec < u8 > , MatchError > where Self : Sized , B : AsRef < [u8] > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; let mut dst = Vec :: with_capacity (haystack . len ()) ; self . try_replace_all_with_bytes (haystack , & mut dst , | mat , _ , dst | { dst . extend (replace_with [mat . pattern ()] . as_ref ()) ; true } ,) ? ; Ok (dst) } # [doc = " Replaces all non-overlapping matches in `haystack` by calling the"] # [doc = " `replace_with` closure given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_with`](crate::AhoCorasick::try_replace_all_with)"] # [doc = " for more documentation and examples."] fn try_replace_all_with < F > (& self , haystack : & str , dst : & mut String , mut replace_with : F ,) -> Result < () , MatchError > where Self : Sized , F : FnMut (& Match , & str , & mut String) -> bool , { let mut last_match = 0 ; for m in self . try_find_iter (Input :: new (haystack)) ? { if ! haystack . is_char_boundary (m . start ()) || ! haystack . is_char_boundary (m . end ()) { continue ; } dst . push_str (& haystack [last_match .. m . start ()]) ; last_match = m . end () ; if ! replace_with (& m , & haystack [m . start () .. m . end ()] , dst) { break ; } } dst . push_str (& haystack [last_match ..]) ; Ok (()) } # [doc = " Replaces all non-overlapping matches in `haystack` by calling the"] # [doc = " `replace_with` closure given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_with_bytes`](crate::AhoCorasick::try_replace_all_with_bytes)"] # [doc = " for more documentation and examples."] fn try_replace_all_with_bytes < F > (& self , haystack : & [u8] , dst : & mut Vec < u8 > , mut replace_with : F ,) -> Result < () , MatchError > where Self : Sized , F : FnMut (& Match , & [u8] , & mut Vec < u8 >) -> bool , { let mut last_match = 0 ; for m in self . try_find_iter (Input :: new (haystack)) ? { dst . extend (& haystack [last_match .. m . start ()]) ; last_match = m . end () ; if ! replace_with (& m , & haystack [m . start () .. m . end ()] , dst) { break ; } } dst . extend (& haystack [last_match ..]) ; Ok (()) } # [doc = " Returns an iterator of non-overlapping matches with this automaton"] # [doc = " from the stream given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_find_iter`](crate::AhoCorasick::try_stream_find_iter)"] # [doc = " for more documentation and examples."] fn try_stream_find_iter < 'a , R : std :: io :: Read > (& 'a self , rdr : R ,) -> Result < StreamFindIter < 'a , Self , R > , MatchError > where Self : Sized , { Ok (StreamFindIter { it : StreamChunkIter :: new (self , rdr) ? , }) } # [doc = " Replaces all non-overlapping matches in `rdr` with strings from"] # [doc = " `replace_with` depending on the pattern that matched, and writes the"] # [doc = " result to `wtr`. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_replace_all`](crate::AhoCorasick::try_stream_replace_all)"] # [doc = " for more documentation and examples."] fn try_stream_replace_all < R , W , B > (& self , rdr : R , wtr : W , replace_with : & [B] ,) -> std :: io :: Result < () > where Self : Sized , R : std :: io :: Read , W : std :: io :: Write , B : AsRef < [u8] > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("streaming replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; self . try_stream_replace_all_with (rdr , wtr , | mat , _ , wtr | { wtr . write_all (replace_with [mat . pattern ()] . as_ref ()) } ,) } # [doc = " Replaces all non-overlapping matches in `rdr` by calling the"] # [doc = " `replace_with` closure given and writing the result to `wtr`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_replace_all_with`](crate::AhoCorasick::try_stream_replace_all_with)"] # [doc = " for more documentation and examples."] fn try_stream_replace_all_with < R , W , F > (& self , rdr : R , mut wtr : W , mut replace_with : F ,) -> std :: io :: Result < () > where Self : Sized , R : std :: io :: Read , W : std :: io :: Write , F : FnMut (& Match , & [u8] , & mut W) -> std :: io :: Result < () > , { let mut it = StreamChunkIter :: new (self , rdr) . map_err (| e | { let kind = std :: io :: ErrorKind :: Other ; std :: io :: Error :: new (kind , e) }) ? ; while let Some (result) = it . next () { let chunk = result ? ; match chunk { StreamChunk :: NonMatch { bytes , .. } => { wtr . write_all (bytes) ? ; } StreamChunk :: Match { bytes , mat } => { replace_with (& mat , bytes , & mut wtr) ? ; } } } Ok (()) } }