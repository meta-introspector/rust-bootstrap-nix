use crate::prelude::*;


/// This file was automatically generated by a refactoring script.
/// It contains the definition of `RustcLink` from `compile.rs`.

/// `RustcLink` copies all of the rlibs from the rustc build into the previous stage's sysroot.
/// This is necessary for tools using `rustc_private`, where the previous compiler will build
/// a tool against the next compiler.
/// To build a tool against a compiler, the rlibs of that compiler that it links against
/// must be in the sysroot of the compiler that's doing the compiling.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct RustcLink {
    /// The compiler whose rlibs we are copying around.
    pub compiler: Compiler,
    /// This is the compiler into whose sysroot we want to copy the rlibs into.
    pub previous_stage_compiler: Compiler,
    pub target: TargetSelection,
    /// Not actually used; only present to make sure the cache invalidation is correct.
    crates: Vec<String>,
}

impl RustcLink {
    fn from_rustc(rustc: Rustc, host_compiler: Compiler) -> Self {
        Self {
            compiler: host_compiler,
            previous_stage_compiler: rustc.compiler,
            target: rustc.target,
            crates: rustc.crates,
        }
    }
}

impl Step for RustcLink {
    type Output = ();

    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {
        run.never()
    }

    /// Same as `std_link`, only for librustc
    fn run(self, builder: &Builder<'_>) {
        let compiler = self.compiler;
        let previous_stage_compiler = self.previous_stage_compiler;
        let target = self.target;
        add_to_sysroot(
            builder,
            &builder.sysroot_target_libdir(previous_stage_compiler, target),
            &builder.sysroot_target_libdir(previous_stage_compiler, compiler.host),
            &librustc_stamp(builder, compiler, target),
        );
    }
}
