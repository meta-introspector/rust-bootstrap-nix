//! This file was automatically generated by a refactoring script.
//! It contains the definition of `Assemble` from `compile.rs`.

//use crate::core::build_steps::compile_modules::codegen_backend::copy_codegen_backends_to_sysroot;

#[derive(Debug, PartialOrd, Ord, Clone, Hash, PartialEq, Eq)]
pub struct Assemble {
    /// The compiler which we will produce in this step. Assemble itself will
    /// take care of ensuring that the necessary prerequisites to do so exist,
    /// that is, this target can be a stage2 compiler and Assemble will build
    /// previous stages for you.
    pub target_compiler: Compiler,
}

impl Step for Assemble {
    type Output = Compiler;
    const ONLY_HOSTS: bool = true;

    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {
        run.path("compiler/rustc").path("compiler")
    }

    fn make_run(run: RunConfig<'_>) {
        run.builder.ensure(Assemble {
            target_compiler: run.builder.compiler(run.builder.top_stage + 1, run.target),
        });
    }

    /// Prepare a new compiler from the artifacts in `stage`
    ///
    /// This will assemble a compiler in `build/$host/stage$stage`. The compiler
    /// must have been previously produced by the `stage - 1` builder.build
    /// compiler.
    fn run(self, builder: &Builder<'_>) -> Compiler {
        let target_compiler = self.target_compiler;

        if target_compiler.stage == 0 {
            assert_eq!(
                builder.config.build, target_compiler.host,
                "Cannot obtain compiler for non-native build triple at stage 0"
            );
            // The stage 0 compiler for the build triple is always pre-built.
            return target_compiler;
        }

        // We prepend this bin directory to the user PATH when linking Rust binaries. To
        // avoid shadowing the system LLD we rename the LLD we provide to `rust-lld`.
        let libdir = builder.sysroot_target_libdir(target_compiler, target_compiler.host);
        let libdir_bin = libdir.parent().unwrap().join("bin");
        t!(fs::create_dir_all(&libdir_bin));

        if builder.config.llvm_enabled(target_compiler.host) {
            let llvm::LlvmResult { llvm_config, .. } =
                builder.ensure(llvm::Llvm { target: target_compiler.host });
            if !builder.config.dry_run && builder.config.llvm_tools_enabled {
                let llvm_bin_dir =
                    command(llvm_config).arg("--bindir").run_capture_stdout(builder).stdout();
                let llvm_bin_dir = Path::new(llvm_bin_dir.trim());

                // Since we've already built the LLVM tools, install them to the sysroot.
                // This is the equivalent of installing the `llvm-tools-preview` component via
                // rustup, and lets developers use a locally built toolchain to
                // build projects that expect llvm tools to be present in the sysroot
                // (e.g. the `bootimage` crate).
                for tool in LLVM_TOOLS {
                    let tool_exe = exe(tool, target_compiler.host);
                    let src_path = llvm_bin_dir.join(&tool_exe);
                    // When using `download-ci-llvm`, some of the tools
                    // may not exist, so skip trying to copy them.
                    if src_path.exists() {
                        // There is a chance that these tools are being installed from an external LLVM.
                        // Use `Builder::resolve_symlink_and_copy` instead of `Builder::copy_link` to ensure
                        // we are copying the original file not the symlinked path, which causes issues for
                        // tarball distribution.
                        //
                        // See https://github.com/rust-lang/rust/issues/135554.
                        builder.resolve_symlink_and_copy(&src_path, &libdir_bin.join(&tool_exe));
                    }
                }
            }
        }

        let maybe_install_llvm_bitcode_linker = |compiler| {
            if builder.config.llvm_bitcode_linker_enabled {
                let src_path = builder.ensure(crate::core::build_steps::tool::LlvmBitcodeLinker {
                    compiler,
                    target: target_compiler.host,
                    extra_features: vec![],
                });
                let tool_exe = exe("llvm-bitcode-linker", target_compiler.host);
                builder.copy_link(&src_path, &libdir_bin.join(tool_exe));
            }
        };

        // If we're downloading a compiler from CI, we can use the same compiler for all stages other than 0.
        if builder.download_rustc() {
            builder.ensure(Std::new(target_compiler, target_compiler.host));
            let sysroot =
                builder.ensure(Sysroot { compiler: target_compiler, force_recompile: false });
            // Ensure that `libLLVM.so` ends up in the newly created target directory,
            // so that tools using `rustc_private` can use it.
            dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);
            // Lower stages use `ci-rustc-sysroot`, not stageN
            if target_compiler.stage == builder.top_stage {
                builder.info(&format!("Creating a sysroot for stage{stage} compiler (use `rustup toolchain link 'name' build/host/stage{stage}`)", stage=target_compiler.stage));
            }

            maybe_install_llvm_bitcode_linker(target_compiler);

            return target_compiler;
        }

        // Get the compiler that we'll use to bootstrap ourselves.
        //
        // Note that this is where the recursive nature of the bootstrap
        // happens, as this will request the previous stage's compiler on
        // downwards to stage 0.
        //
        // Also note that we're building a compiler for the host platform. We
        // only assume that we can run `build` artifacts, which means that to
        // produce some other architecture compiler we need to start from
        // `build` to get there.
        //
        // FIXME: It may be faster if we build just a stage 1 compiler and then
        //        use that to bootstrap this compiler forward.
        let mut build_compiler = builder.compiler(target_compiler.stage - 1, builder.config.build);

        // Build enzyme
        let enzyme_install = if builder.config.llvm_enzyme {
            Some(builder.ensure(llvm::Enzyme { target: build_compiler.host }))
        } else {
            None
        };

        if let Some(enzyme_install) = enzyme_install {
            let lib_ext = std::env::consts::DLL_EXTENSION;
            let src_lib = enzyme_install.join("build/Enzyme/libEnzyme-19").with_extension(lib_ext);
            let libdir = builder.sysroot_target_libdir(build_compiler, build_compiler.host);
            let target_libdir =
                builder.sysroot_target_libdir(target_compiler, target_compiler.host);
            let dst_lib = libdir.join("libEnzyme-19").with_extension(lib_ext);
            let target_dst_lib = target_libdir.join("libEnzyme-19").with_extension(lib_ext);
            builder.copy_link(&src_lib, &dst_lib);
            builder.copy_link(&src_lib, &target_dst_lib);
        }

        // Build the libraries for this compiler to link to (i.e., the libraries
        // it uses at runtime). NOTE: Crates the target compiler compiles don't
        // link to these. (FIXME: Is that correct? It seems to be correct most
        // of the time but I think we do link to these for stage2/bin compilers
        // when not performing a full bootstrap).
        let actual_stage = builder.ensure(Rustc::new(build_compiler, target_compiler.host));
        // Current build_compiler.stage might be uplifted instead of being built; so update it
        // to not fail while linking the artifacts.
        build_compiler.stage = actual_stage;

        for backend in builder.config.codegen_backends(target_compiler.host) {
            if backend == "llvm" {
                continue; // Already built as part of rustc
            }

            builder.ensure(CodegenBackend {
                compiler: build_compiler,
                target: target_compiler.host,
                backend: backend.clone(),
            });
        }

        let lld_install = if builder.config.lld_enabled {
            Some(builder.ensure(llvm::Lld { target: target_compiler.host }))
        } else {
            None
        };

        let stage = target_compiler.stage;
        let host = target_compiler.host;
        let (host_info, dir_name) = if build_compiler.host == host {
            ("".into(), "host".into())
        } else {
            (format!(" ({host})"), host.to_string())
        };
        // NOTE: "Creating a sysroot" is somewhat inconsistent with our internal terminology, since
        // sysroots can temporarily be empty until we put the compiler inside. However,
        // `ensure(Sysroot)` isn't really something that's user facing, so there shouldn't be any
        // ambiguity.
        let msg = format!(
            "Creating a sysroot for stage{stage} compiler{host_info} (use `rustup toolchain link 'name' build/{dir_name}/stage{stage}`)"
        );
        builder.info(&msg);

        // Link in all dylibs to the libdir
        let stamp = librustc_stamp(builder, build_compiler, target_compiler.host);
        let proc_macros = builder
            .read_stamp_file(&stamp)
            .into_iter()
            .filter_map(|(path, dependency_type)| {
                if dependency_type == DependencyType::Host {
                    Some(path.file_name().unwrap().to_owned().into_string().unwrap())
                } else {
                    None
                }
            })
            .collect::<HashSet<_>>();

        let sysroot = builder.sysroot(target_compiler);
        let rustc_libdir = builder.rustc_libdir(target_compiler);
        t!(fs::create_dir_all(&rustc_libdir));
        let src_libdir = builder.sysroot_target_libdir(build_compiler, host);
        for f in builder.read_dir(&src_libdir) {
            let filename = f.file_name().into_string().unwrap();

            let is_proc_macro = proc_macros.contains(&filename);
            let is_dylib_or_debug = is_dylib(&f.path()) || is_debug_info(&filename);

            // If we link statically to stdlib, do not copy the libstd dynamic library file
            // FIXME: Also do this for Windows once incremental post-optimization stage0 tests
            // work without std.dll (see https://github.com/rust-lang/rust/pull/131188).
            let can_be_rustc_dynamic_dep = if builder
                .link_std_into_rustc_driver(target_compiler.host)
                && !target_compiler.host.is_windows()
            {
                let is_std = filename.starts_with("std-") || filename.starts_with("libstd-");
                !is_std
            } else {
                true
            };

            if is_dylib_or_debug && can_be_rustc_dynamic_dep && !is_proc_macro {
                builder.copy_link(&f.path(), &rustc_libdir.join(&filename));
            }
        }

        copy_codegen_backends_to_sysroot(builder, build_compiler, target_compiler);

        if let Some(lld_install) = lld_install {
            let src_exe = exe("lld", target_compiler.host);
            let dst_exe = exe("rust-lld", target_compiler.host);
            builder.copy_link(&lld_install.join("bin").join(src_exe), &libdir_bin.join(dst_exe));
            let self_contained_lld_dir = libdir_bin.join("gcc-ld");
            t!(fs::create_dir_all(&self_contained_lld_dir));
            let lld_wrapper_exe = builder.ensure(crate::core::build_steps::tool::LldWrapper {
                compiler: build_compiler,
                target: target_compiler.host,
            });
            for name in crate::LLD_FILE_NAMES {
                builder.copy_link(
                    &lld_wrapper_exe,
                    &self_contained_lld_dir.join(exe(name, target_compiler.host)),
                );
            }
        }

        if builder.config.llvm_enabled(target_compiler.host) && builder.config.llvm_tools_enabled {
            // `llvm-strip` is used by rustc, which is actually just a symlink to `llvm-objcopy`, so
            // copy and rename `llvm-objcopy`.
            //
            // But only do so if llvm-tools are enabled, as bootstrap compiler might not contain any
            // LLVM tools, e.g. for cg_clif.
            // See <https://github.com/rust-lang/rust/issues/132719>.
            let src_exe = exe("llvm-objcopy", target_compiler.host);
            let dst_exe = exe("rust-objcopy", target_compiler.host);
            builder.copy_link(&libdir_bin.join(src_exe), &libdir_bin.join(dst_exe));
        }

        // In addition to `rust-lld` also install `wasm-component-ld` when
        // LLD is enabled. This is a relatively small binary that primarily
        // delegates to the `rust-lld` binary for linking and then runs
        // logic to create the final binary. This is used by the
        // `wasm32-wasip2` target of Rust.
        if builder.tool_enabled("wasm-component-ld") {
            let wasm_component_ld_exe =
                builder.ensure(crate::core::build_steps::tool::WasmComponentLd {
                    compiler: build_compiler,
                    target: target_compiler.host,
                });
            builder.copy_link(
                &wasm_component_ld_exe,
                &libdir_bin.join(wasm_component_ld_exe.file_name().unwrap()),
            );
        }

        maybe_install_llvm_bitcode_linker(build_compiler);

        // Ensure that `libLLVM.so` ends up in the newly build compiler directory,
        // so that it can be found when the newly built `rustc` is run.
        dist::maybe_install_llvm_runtime(builder, target_compiler.host, &sysroot);
        dist::maybe_install_llvm_target(builder, target_compiler.host, &sysroot);

        // Link the compiler binary itself into place
        let out_dir = builder.cargo_out(build_compiler, Mode::Rustc, host);
        let rustc = out_dir.join(exe("rustc-main", host));
        let bindir = sysroot.join("bin");
        t!(fs::create_dir_all(bindir));
        let compiler = builder.rustc(target_compiler);
        builder.copy_link(&rustc, &compiler);

        target_compiler
    }
}
