use clap::{Parser, Args, Command};
use std::path::PathBuf;
use std::string::String;
# [doc = " Command-line arguments for the prelude generator."] # [derive (Parser , Debug , Clone)] # [command (author , version , about , long_about = None)] pub struct Args { # [doc = " Run in dry-run mode, printing changes without modifying files."] # [arg (long)] pub dry_run : bool , # [doc = " The path to the workspace root."] # [arg (long , default_value = ".")] pub path : PathBuf , # [doc = " Comma-separated list of crate names to exclude from processing."] # [arg (long , value_delimiter = ',')] pub exclude_crates : Vec < String > , # [doc = " Generate a summary report of the prelude generation process."] # [arg (long , default_value_t = false)] pub report : bool , # [doc = " Path to a file to save/load processing results."] # [arg (long , default_value = "prelude_processing_results.json")] pub results_file : PathBuf , # [doc = " Generate a report on the prelude cache."] # [arg (long , default_value_t = false)] pub cache_report : bool , # [doc = " Timeout in seconds for the prelude generation process."] # [arg (long)] pub timeout : Option < u64 > , # [doc = " Force overwriting of files even if they exist."] # [arg (long , default_value_t = false)] pub force : bool , # [doc = " Generate a JSON report of all unique test cases found in the repository."] # [arg (long , default_value_t = false)] pub generate_test_report : bool , # [doc = " Path to the output file for the JSON test report. Only used if `generate_test_report` is true."] # [arg (long)] pub test_report_output_file : Option < PathBuf > , # [doc = " Generate a test verification script and report from a JSON test report."] # [arg (long , default_value_t = false)] pub compile_tests : bool , # [doc = " Path to the JSON test report input file. Required if `compile_tests` is true."] # [arg (long)] pub test_report_input_file : Option < PathBuf > , # [doc = " Path to the directory where the test verification script and report will be generated. Required if `compile_tests` is true."] # [arg (long)] pub test_verification_output_dir : Option < PathBuf > , # [doc = " Extract unique use statements and generate test files for a use statement parser."] # [arg (long , default_value_t = false)] pub extract_use_statements : bool , # [doc = " Path to the directory where generated use statement test files will be placed. Required if `extract_use_statements` is true."] # [arg (long)] pub use_statements_output_dir : Option < PathBuf > , # [doc = " Collect and process use statements"] # [clap (long , default_value_t = false)] pub collect_and_process_use_statements : bool , # [doc = " Generate a single test file with all unique use statements"] # [clap (long , default_value_t = false)] pub generate_aggregated_test_file : bool , # [doc = " Run the use statement processing pipeline"] # [clap (long , default_value_t = false)] pub run_pipeline : bool , # [doc = " Specify the stage of the pipeline to run"] # [clap (long)] pub stage : Option < String > , # [doc = " Process files in batches of this size"] # [clap (long)] pub batch_size : Option < usize > , # [doc = " The maximum number of batches to run"] # [clap (long)] pub batch_limit : Option < usize > , # [doc = " Process a single file"] # [clap (long)] pub file : Option < String > , # [doc = " Stop after processing N statements"] # [clap (long , value_parser , default_value_t = 0)] pub stop_after : usize , # [doc = " Timeout in seconds for each processing step"] # [clap (long , value_parser , default_value_t = 0)] pub step_timeout : u64 , # [doc = " Enable verbose output"] # [clap (short , long , action = clap :: ArgAction :: Count)] pub verbose : u8 , # [doc = " Path to the hf-validator executable."] # [arg (long)] pub hf_validator_path : Option < PathBuf > , # [doc = " Path to the main configuration file (config.toml)."] # [arg (long)] pub config_file_path : Option < PathBuf > , # [doc = " Verify the parsed configuration and exit."] # [arg (long , default_value_t = false)] pub verify_config : bool , # [doc = " Analyze the AST of Rust files in a given path."] # [arg (long , default_value_t = false)] pub analyze_ast : bool , # [doc = " The path to the Rust project or file to analyze AST for. Only used if `analyze_ast` is true."] # [arg (long)] pub ast_analysis_path : Option < PathBuf > , # [doc = " Extract all Level 0 declarations (constants) from all modules and write to a global module."] # [arg (long , default_value_t = false)] pub extract_global_level0_decls : bool , # [doc = " Path to the directory where individually generated Level 0 declaration files will be placed."] # [doc = " Only used if `extract_global_level0_decls` is true."] # [arg (long)] pub generated_decls_output_dir : Option < PathBuf > , # [doc = " Analyze the bag of words from all identifiers in the project."] # [arg (long , default_value_t = false)] pub analyze_bag_of_words : bool , # [doc = " Path to the output TOML file for the bag of words report. Only used if `analyze_bag_of_words` is true."] # [arg (long , default_value = "bag_of_words_report.toml")] pub bag_of_words_output_file : PathBuf , # [doc = " Extract and organize numerical constants into a hierarchical directory structure."] # [arg (long , default_value_t = false)] pub extract_numerical_constants : bool , # [doc = " Extract and organize string constants into a hierarchical directory structure."] # [arg (long , default_value_t = false)] pub extract_string_constants : bool , }