[
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/configuration-nix/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 30 packages to latest compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling utf8parse v0.2.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling heck v0.5.0\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling configuration-nix v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2)\nerror: Option 'edition' given more than once\n\nerror: could not compile `configuration-nix` (bin \"configuration-nix\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name configuration_nix --edition=2021 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7abb314799d9b9a3 -C extra-filename=-cc6c4eb66ea06bec --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps/libclap-aa9e4339195f7ff7.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/src/main.rs` (exit status: 1)\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 30 packages to latest compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling utf8parse v0.2.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling heck v0.5.0\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling configuration-nix v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2)\nerror: Option 'edition' given more than once\n\nerror: could not compile `configuration-nix` (bin \"configuration-nix\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name configuration_nix --edition=2021 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7abb314799d9b9a3 -C extra-filename=-cc6c4eb66ea06bec --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/target/debug/deps/libclap-aa9e4339195f7ff7.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp4PQ7X2/src/main.rs` (exit status: 1)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use crate::prelude::*;\npub mod prelude;\n//mod prelude;\nmod config_generator;\nmod config_params;\nfn main() {\n    let params = config_params::ConfigParams::parse();\n    config_generator::generate_config_toml(&params);\n}\n",
    "timestamp": "2025-10-31T21:55:53.269334264Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\n Downloading crates ...\n  Downloaded cc v1.2.44\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\n Downloading crates ...\n  Downloaded cc v1.2.44\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "\npub mod prelude;\n\npub mod utils; // Declare the utils module as public\npub mod preconditions; // Declare the preconditions module\n\npub mod args; // Declare the args module\npub mod config; // Declare the config module\n",
    "timestamp": "2025-10-31T21:55:55.757167284Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/bootstrap-config-generator.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\nfn main() -> Result<()> {\n    env_logger::init();\n    let args = Args::parse();\n    debug!(\"Raw CLI Arguments: {:?}\\n\", args);\n    let mut app_config = if let Some(config_file_path) = &args.config_file {\n        info!(\"Loading configuration from file: {:?}\\n\", config_file_path);\n        let config_content = fs::read_to_string(config_file_path)\n            .context(format!(\"Failed to read config file: {:?}\\n\", config_file_path))?;\n        toml::from_str(&config_content)\n            .context(format!(\"Failed to parse config file: {:?}\\n\", config_file_path))?\n    } else {\n        AppConfig::default()\n    };\n    app_config.merge_with_args(&args);\n    info!(\"Final merged configuration: {:?}\\n\", app_config);\n    if let Some(build_rustc_version) = app_config.build_rustc_version.clone() {\n        info!(\n            \"Lattice generation mode enabled for rustc version: {}\\n\",\n            build_rustc_version\n        );\n        let solana_rustc_path = app_config\n            .solana_rustc_path\n            .as_ref()\n            .context(\"solana_rustc_path is required for lattice generation\")?\n            .to_str()\n            .context(\"solana_rustc_path contains non-UTF8 characters\")?;\n        let cargo_path = app_config\n            .cargo_path\n            .as_ref()\n            .context(\"cargo_path is required for lattice generation\")?\n            .to_str()\n            .context(\"cargo_path contains non-UTF8 characters\")?;\n        let project_root = app_config\n            .project_root\n            .as_ref()\n            .context(\"project_root is required for lattice generation\")?\n            .to_str()\n            .context(\"project_root contains non-UTF8 characters\")?;\n        let rust_src_flake_path = app_config\n            .rust_src_flake_path\n            .as_ref()\n            .context(\"rust_src_flake_path is required for lattice generation\")?\n            .to_str()\n            .context(\"rust_src_flake_path contains non-UTF8 characters\")?;\n        let architecture = app_config.architecture.as_deref().unwrap_or(\"aarch64-linux\");\n        let stage = app_config.stage.as_deref().unwrap_or(\"stage0\");\n        let step = app_config.step.as_deref().unwrap_or(\"step1-configure\");\n        let resolved_build_rustc_path = find_nix_package_store_path(\n                \"rustc\",\n                Some(&build_rustc_version),\n            )?\n            .context(\n                format!(\"Could not find rustc path for version {}\", build_rustc_version),\n            )?;\n        let output_dir = PathBuf::from(\n            format!(\"flakes/{}/{}/{}/{}\", build_rustc_version, architecture, stage, step),\n        );\n        fs::create_dir_all(&output_dir)\n            .context(format!(\"Failed to create output directory: {:?}\", output_dir))?;\n        let flake_nix_path = output_dir.join(\"flake.nix\");\n        let flake_nix_content = format!(\n            r#\"{{\n  description = \"Test flake for rustc {}\";\n\n  inputs = {{\n    nixpkgs.url = \"github:meta-introspector/nixpkgs?ref=feature/CRQ-016-nixify\";\n  }};\n\n  outputs = {{ self, nixpkgs }}:\n    let\n      pkgs = import nixpkgs {{\n        system = \"{}\";\n      }};\n      rustcPath = \"{}\"; # This is the *source* rustc used to build the next stage\n    in\n    {{\n      devShells.{}.default = pkgs.mkShell {{\n        buildInputs = [\n          pkgs.cargo\n        ];\n        RUSTC = rustcPath;\n      }};\n    }};\n}}\"#,\n            build_rustc_version, architecture, solana_rustc_path, architecture\n        );\n        fs::write(&flake_nix_path, flake_nix_content)\n            .context(format!(\"Failed to write flake.nix to {:?}\\n\", flake_nix_path))?;\n        info!(\n            \"Generated flake.nix for rustc {} at {:?}\\n\", build_rustc_version,\n            flake_nix_path\n        );\n        let config_toml_path = output_dir\n            .join(format!(\"generated_config_{}.toml\", build_rustc_version));\n        let config_content = construct_config_content(\n            architecture,\n            project_root,\n            app_config\n                .nixpkgs_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_overlay_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_bootstrap_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .configuration_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            rust_src_flake_path,\n            stage,\n            app_config.target.as_deref().unwrap_or_default(),\n            app_config.rust_bootstrap_nix_flake_ref.as_deref().unwrap_or_default(),\n            app_config.rust_src_flake_ref.as_deref().unwrap_or_default(),\n            &resolved_build_rustc_path,\n            cargo_path,\n            app_config.rust_channel.as_deref().unwrap_or(\"stable\"),\n            app_config.rust_download_rustc.unwrap_or(false),\n            app_config.rust_parallel_compiler.unwrap_or(false),\n            app_config.rust_llvm_tools.unwrap_or(false),\n            app_config.rust_debuginfo_level.unwrap_or(0),\n            app_config.patch_binaries_for_nix.unwrap_or(false),\n            app_config.vendor.unwrap_or(false),\n            app_config\n                .build_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.build_jobs.unwrap_or(0),\n            app_config\n                .home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_prefix\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_sysconfdir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .dist_sign_folder\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.dist_upload_addr.as_deref().unwrap_or_default(),\n            app_config.llvm_download_ci_llvm.unwrap_or(false),\n            app_config.llvm_ninja.unwrap_or(false),\n            app_config.change_id.as_deref().unwrap_or_default(),\n        );\n        fs::write(&config_toml_path, config_content)\n            .context(\n                format!(\"Failed to write config.toml to {:?}\\n\", config_toml_path),\n            )?;\n        info!(\n            \"Generated config.toml for rustc {} at {:?}\\n\", build_rustc_version,\n            config_toml_path\n        );\n    } else {\n        info!(\n            \"Starting config generation for stage {:?} and target {:?}\\n\", app_config\n            .stage, app_config.target\n        );\n        info!(\"Running precondition checks...\\n\");\n        preconditions::check_nix_command_available()?;\n        info!(\"Nix command available.\\n\");\n        info!(\"Validating project root: {:?}\\n\", app_config.project_root);\n        let project_root = validate_project_root(\n            app_config.project_root.as_ref().context(\"Project root is required\")?,\n        )?;\n        let flake_path_str = project_root\n            .to_str()\n            .context(\"Project root path contains non-UTF8 characters\")?;\n        info!(\"Project root validated: {}\\n\", flake_path_str);\n        let rust_src_flake_path_lossy = app_config\n            .rust_src_flake_path\n            .as_ref()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_default();\n        debug!(\"rust_src_flake_path: {:?}\\n\", rust_src_flake_path_lossy);\n        preconditions::check_rust_toolchain_sysroot(&rust_src_flake_path_lossy)?;\n        info!(\"Rust toolchain sysroot check passed.\\n\");\n        info!(\"Constructing config.toml content...\\n\");\n        let config_content = construct_config_content(\n            app_config.system.as_deref().unwrap_or_default(),\n            flake_path_str,\n            app_config\n                .nixpkgs_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_overlay_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_bootstrap_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .configuration_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_src_flake_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.stage.as_deref().unwrap_or_default(),\n            app_config.target.as_deref().unwrap_or_default(),\n            app_config.rust_bootstrap_nix_flake_ref.as_deref().unwrap_or_default(),\n            app_config.rust_src_flake_ref.as_deref().unwrap_or_default(),\n            app_config\n                .rustc_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.rust_channel.as_deref().unwrap_or(\"stable\"),\n            app_config.rust_download_rustc.unwrap_or(false),\n            app_config.rust_parallel_compiler.unwrap_or(false),\n            app_config.rust_llvm_tools.unwrap_or(false),\n            app_config.rust_debuginfo_level.unwrap_or(0),\n            app_config.patch_binaries_for_nix.unwrap_or(false),\n            app_config.vendor.unwrap_or(false),\n            app_config\n                .build_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.build_jobs.unwrap_or(0),\n            app_config\n                .home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_prefix\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_sysconfdir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .dist_sign_folder\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.dist_upload_addr.as_deref().unwrap_or_default(),\n            app_config.llvm_download_ci_llvm.unwrap_or(false),\n            app_config.llvm_ninja.unwrap_or(false),\n            app_config.change_id.as_deref().unwrap_or_default(),\n        );\n        debug!(\"Generated config content:\\n{}\\n\", config_content);\n        if app_config.dry_run.unwrap_or(false) {\n            info!(\"Dry run enabled. Generated config will be printed to stdout.\\n\");\n            println!(\"{}\", config_content);\n        } else {\n            let output_path = app_config.output.unwrap_or_else(|| \"config.toml\".into());\n            info!(\"Writing generated config to file: {:?}\\n\", output_path);\n            fs::write(&output_path, config_content)\n                .context(\n                    format!(\"Failed to write config to file: {:?}\\n\", output_path),\n                )?;\n            info!(\"Config successfully written to {:?}\\n\", output_path);\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:55:57.163116763Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/flake-step-manager.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\n#[derive(Parser, Debug)]\n#[clap(author, version, about, long_about = None)]\nstruct Args {\n    #[clap(long)]\n    rust_version: String,\n    #[clap(long)]\n    arch: String,\n    #[clap(long)]\n    phase: String,\n    #[clap(long)]\n    step: String,\n}\nfn main() -> Result<()> {\n    let args = Args::parse();\n    println!(\"Parsed arguments:\");\n    println!(\"  Rust Version: {}\", args.rust_version);\n    println!(\"  Architecture: {}\", args.arch);\n    println!(\"  Phase: {}\", args.phase);\n    println!(\"  Step: {}\", args.step);\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:55:58.546747544Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/nix-dir.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\n\n#[derive(Debug, Deserialize)]\nstruct Config {\n    #[serde(default)]\n    nix_packages: HashMap<String, String>,\n}\n/// A tool to inspect Nix flakes and their attributes.\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    /// The flake reference to inspect (e.g., \"nixpkgs\", \"github:NixOS/nixpkgs/nixos-23.11\")\n    #[arg()]\n    flake_ref: Option<String>,\n    /// Output raw JSON from 'nix flake show' command.\n    #[arg(long, default_value_t = false)]\n    json: bool,\n    /// Path to the config.toml file to read for Nix package information.\n    #[arg(long, default_value = \"config.toml\")]\n    config_file: String,\n    /// List all rustc versions found in the Nix store.\n    #[arg(long, default_value_t = false)]\n    list_rustc_versions: bool,\n}\nfn main() -> Result<()> {\n    env_logger::init();\n    let args = Args::parse();\n    info!(\"Reading config file: {}\", args.config_file);\n    let config_content = fs::read_to_string(&args.config_file)\n        .with_context(|| format!(\"Failed to read config file: {}\", args.config_file))?;\n    let config = Some(\n        toml::from_str::<Config>(&config_content)\n            .with_context(|| {\n                format!(\"Failed to parse config file: {}\", args.config_file)\n            })?,\n    );\n    if let Some(c) = &config {\n        debug!(\"Parsed config: {:?}\", c);\n    }\n    if args.list_rustc_versions {\n        info!(\"Listing all rustc versions in Nix store.\");\n        let rustc_versions = get_all_rustc_paths_from_nix_store()?;\n        if rustc_versions.is_empty() {\n            println!(\"No rustc versions found in the Nix store.\");\n        } else {\n            println!(\"Found rustc versions:\");\n            for (path, version) in rustc_versions {\n                println!(\"  - Version: {}, Path: {}\", version, path);\n            }\n        }\n        return Ok(());\n    }\n    if let Some(flake_ref) = args.flake_ref {\n        info!(\"Inspecting Nix flake: {}\", flake_ref);\n        let mut command = Command::new(\"nix\");\n        command.args(&[\"flake\", \"show\", \"--json\", &flake_ref]);\n        debug!(\"Executing Nix command: {:?}\", command);\n        let output = command\n            .output()\n            .with_context(|| {\n                format!(\"Failed to execute nix flake show for '{}'\", flake_ref)\n            })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"Nix command failed for flake show '{}':\\n{}\\nStderr: {}\", flake_ref,\n                String::from_utf8_lossy(& output.stdout), String::from_utf8_lossy(&\n                output.stderr)\n            );\n        }\n        let json_output: Value = serde_json::from_slice(&output.stdout)\n            .with_context(|| \"Failed to parse nix flake show JSON output\")?;\n        if args.json {\n            println!(\"{}\", serde_json::to_string_pretty(& json_output) ?);\n        } else {\n            println!(\"Flake Attributes for {}:\", flake_ref);\n            if let Some(inputs) = json_output.get(\"inputs\") {\n                println!(\"\\nInputs:\");\n                if let Some(inputs_obj) = inputs.as_object() {\n                    for (key, _) in inputs_obj {\n                        println!(\"  - {}\", key);\n                    }\n                }\n            }\n            if let Some(outputs) = json_output.get(\"outputs\") {\n                println!(\"\\nOutputs:\");\n                if let Some(outputs_obj) = outputs.as_object() {\n                    for (system, system_outputs) in outputs_obj {\n                        println!(\"  {}:\", system);\n                        if let Some(system_outputs_obj) = system_outputs.as_object() {\n                            for (key, value) in system_outputs_obj {\n                                let output_type = value\n                                    .get(\"type\")\n                                    .and_then(|t| t.as_str())\n                                    .unwrap_or(\"unknown\");\n                                println!(\"    - {}: {}\", key, output_type);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if let Some(c) = &config {\n        println!(\"\\nNix Packages from config.toml:\");\n        for (pkg_name, pkg_version) in &c.nix_packages {\n            match find_nix_package_store_path(\n                pkg_name.as_str(),\n                Some(pkg_version.as_str()),\n            ) {\n                Ok(Some(path)) => println!(\"  - {}: {}\", pkg_name, path),\n                Ok(None) => {\n                    println!(\n                        \"  - {}: Not found in store (version: {})\", pkg_name, pkg_version\n                    )\n                }\n                Err(e) => eprintln!(\"  - Error finding {}: {}\", pkg_name, e),\n            }\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:56:00.173834366Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/flake-template-generator/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 43 packages to latest compatible versions\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling utf8parse v0.2.2\n   Compiling equivalent v1.0.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle-parse v0.2.7\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle v1.0.13\n   Compiling hashbrown v0.16.0\n   Compiling colorchoice v1.0.4\n   Compiling toml_write v0.1.2\n   Compiling anstream v0.6.21\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling indexmap v2.12.0\n   Compiling heck v0.5.0\n   Compiling winnow v0.7.13\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling flake-template-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9)\nerror: Option 'edition' given more than once\n\nerror: could not compile `flake-template-generator` (bin \"flake-template-generator\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name flake_template_generator --edition=2021 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e359d4ff595bf03c -C extra-filename=-d3214c794f4d048b --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libclap-48e1a20a69412286.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libserde-869763d06b848793.rlib --extern toml=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libtoml-08e3d31fc394dbc3.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/src/main.rs` (exit status: 1)\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 43 packages to latest compatible versions\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling utf8parse v0.2.2\n   Compiling equivalent v1.0.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle-parse v0.2.7\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle v1.0.13\n   Compiling hashbrown v0.16.0\n   Compiling colorchoice v1.0.4\n   Compiling toml_write v0.1.2\n   Compiling anstream v0.6.21\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling indexmap v2.12.0\n   Compiling heck v0.5.0\n   Compiling winnow v0.7.13\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling flake-template-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9)\nerror: Option 'edition' given more than once\n\nerror: could not compile `flake-template-generator` (bin \"flake-template-generator\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name flake_template_generator --edition=2021 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=e359d4ff595bf03c -C extra-filename=-d3214c794f4d048b --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libclap-48e1a20a69412286.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libserde-869763d06b848793.rlib --extern toml=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/target/debug/deps/libtoml-08e3d31fc394dbc3.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp0aUrV9/src/main.rs` (exit status: 1)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use crate::prelude::*;\npub mod prelude;\nuse crate::config_parser::parse_config;\nuse crate::file_writer::write_flake_and_config;\nuse crate::statix_checker::run_statix_check;\n//mod prelude;\nmod args;\nmod config_parser;\nmod flake_generator;\nmod file_writer;\nmod statix_checker;\npub use args :: Args ;\npub use serde :: { Deserialize , Serialize } ;\nuse crate::flake_generator::generate_flake_nix_content;\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = Args::parse();\n    let repo_root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n        .parent()\n        .unwrap()\n        .to_path_buf();\n    let absolute_output_dir = repo_root.join(&args.output_dir);\n    fs::create_dir_all(&absolute_output_dir)?;\n    let config = parse_config(&args.config_path)?;\n    let nixpkgs_url = if config.nix.nixpkgs_path.is_empty() {\n        \"github:meta-introspector/nixpkgs?ref=feature/CRQ-016-nixify\".to_string()\n    } else {\n        config.nix.nixpkgs_path\n    };\n    let system_arch = \"aarch64-linux\";\n    let flake_nix_content = generate_flake_nix_content(&nixpkgs_url, &system_arch);\n    let config_content = fs::read_to_string(&args.config_path)?;\n    write_flake_and_config(&absolute_output_dir, &flake_nix_content, &config_content)?;\n    let output_flake_nix_path = absolute_output_dir.join(\"flake.nix\");\n    run_statix_check(&absolute_output_dir, &output_flake_nix_path)?;\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:56:16.784824985Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/prelude-generator/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp8XCfMY)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp8XCfMY)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "pub mod args;\npub mod report;\npub mod generate_prelude;\npub mod modify_file;\npub mod modify_crate_root;\npub mod processor;\npub mod test_extractor;\npub mod pipeline;\npub mod use_extractor;\npub mod prelude_category_pipeline;\npub mod code_generator;\npub mod measurement;\npub mod parser;\npub mod decls_visitor;\npub mod bag_of_words_visitor;\npub mod config_parser;\npub mod cli;\npub mod use_statements;\npub mod utils;\npub mod error_handling;\npub mod error_collector;\npub mod declaration;\npub mod gem_parser;\npub mod ast_stats;\npub mod constant_storage;\npub mod declaration_processing;\npub mod command_handlers;\npub mod type_extractor;\n//pub mod global_level0_decls;\npub use args::Args;\n//pub use declaration_processing::{extract_level0_declarations, process_structs};\npub use report::generate_report;\npub use generate_prelude::generate_prelude;\npub use modify_file::modify_file;\npub use modify_crate_root::modify_crate_root;\npub use processor::process_crates;\npub use test_extractor::{collect_all_test_cases, generate_test_report_json, generate_test_verification_script_and_report, TestInfo};\npub use pipeline_traits::{AstStatistics, VariableInfo, FunctionInfo, ImportInfo};\npub use ast_decoder::AstTraversalFunctor;\n\npub use bag_of_words_visitor::{BagOfWordsVisitor, tokenize_ident_to_subwords};\n\n// Re-export necessary types from prelude_collector\npub use prelude_collector::{FileProcessingResult, FileProcessingStatus};\n",
    "timestamp": "2025-10-31T21:56:18.157785349Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/prelude-generator/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpJZ0rML)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpJZ0rML)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use prelude_generator::command_handlers;\nuse std::path::PathBuf;\nuse syn;\nuse tokio;\nuse prelude_generator::use_extractor::get_rustc_info;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let (args, config) = prelude_generator::cli::parse_arguments_and_config()?;\n\n    let project_root = if args.path == PathBuf::from(\".\") {\n        std::env::current_dir()?.parent().unwrap().to_path_buf()\n    } else {\n        args.path.clone()\n    };\n\n    let rustc_info = get_rustc_info()?;\n    let cache_dir = project_root.join(\".prelude_cache\");\n    tokio::fs::create_dir_all(&cache_dir).await?;\n\n    let mut all_numerical_constants: Vec<syn::ItemConst> = Vec::new();\n    let mut all_string_constants: Vec<syn::ItemConst> = Vec::new();\n\n    if args.analyze_ast {\n        crate::command_handlers::handle_analyze_ast(&args)?;\n        return Ok(()); // Exit after AST analysis if requested\n    }\n\n    if args.generate_test_report {\n        crate::command_handlers::handle_generate_test_report(&args)?;\n    }\n\n    if args.compile_tests {\n        crate::command_handlers::handle_compile_tests(&args)?;\n    }\n\n    if args.extract_use_statements {\n        crate::command_handlers::handle_extract_use_statements(&args)?;\n    }\n\n    if args.collect_and_process_use_statements {\n        crate::command_handlers::handle_collect_and_process_use_statements();\n    }\n\n    if args.generate_aggregated_test_file {\n        crate::command_handlers::handle_generate_aggregated_test_file();\n    }\n\n    if args.run_pipeline {\n        crate::command_handlers::handle_run_pipeline(&args, config.as_ref().unwrap()).await?;\n    }\n\n    if args.verify_config {\n        crate::command_handlers::handle_verify_config();\n    }\n\n    if args.extract_global_level0_decls {\n        crate::command_handlers::handle_extract_global_level0_decls(\n            &project_root,\n            &args,\n            &mut all_numerical_constants,\n            &mut all_string_constants,\n            &rustc_info,\n            &cache_dir,\n        ).await?;\n    }\n\n    // Process numerical constants\n    if args.extract_numerical_constants {\n        crate::command_handlers::handle_extract_numerical_constants(&project_root, &args, &all_numerical_constants).await?;\n    }\n\n    // Process string constants\n    if args.extract_string_constants {\n        crate::command_handlers::handle_extract_string_constants(&project_root, &args, &all_string_constants).await?;\n    }\n\n    if args.analyze_bag_of_words {\n        crate::command_handlers::handle_analyze_bag_of_words(&project_root, &args)?;\n    }\n\n    if args.calculate_layers {\n        crate::command_handlers::handle_calculate_layers(&project_root, &args).await?;\n    }\n\n    // If no specific command was executed, print help or a default message\n    if !args.analyze_ast && !args.generate_test_report && !args.compile_tests && !args.extract_use_statements && !args.collect_and_process_use_statements && !args.generate_aggregated_test_file && !args.run_pipeline && !args.verify_config && !args.extract_global_level0_decls && !args.analyze_bag_of_words && !args.extract_numerical_constants && !args.extract_string_constants && !args.calculate_layers {\n        println!(r\"No specific command executed. Use --help for options.\");\n    }\n\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:56:18.342876182Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/ast-decoder/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `pipeline-traits` as a dependency of package `ast-decoder v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpSU09Uv)`\n\nCaused by:\n  failed to load source for dependency `pipeline-traits`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `pipeline-traits` as a dependency of package `ast-decoder v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpSU09Uv)`\n\nCaused by:\n  failed to load source for dependency `pipeline-traits`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use anyhow::{Context, Result};\nuse std::path::PathBuf;\nuse std::pin::Pin;\nuse std::future::Future;\n\nuse syn::{self, visit::{self, Visit}, Item, Visibility};\nuse quote::quote;\n\n// Removed: use crate::measurement; as it's no longer in the same crate\nuse pipeline_traits::{PipelineFunctor, ParsedFile};\nuse pipeline_traits::{AstStatistics, VariableInfo, FunctionInfo};\n\n/// Helper struct to traverse the AST and collect statistics\nstruct AstVisitor {\n    stats: AstStatistics,\n    #[allow(dead_code)]\n    file_path: PathBuf,\n}\n\nimpl AstVisitor {\n    fn new(file_path: PathBuf) -> Self {\n        Self {\n            stats: AstStatistics::default(),\n            file_path,\n        }\n    }\n\n    fn increment_node_type_count(&mut self, node_type: &str) {\n        *self.stats.node_type_counts.entry(node_type.to_string()).or_insert(0) += 1;\n    }\n}\n\nimpl <'ast> Visit<'ast> for AstVisitor {\n    fn visit_item_fn(&mut self, i: &'ast syn::ItemFn) {\n        self.increment_node_type_count(\"function\");\n\n        let mut arg_types = Vec::new();\n        for arg in &i.sig.inputs {\n            if let syn::FnArg::Typed(pat_type) = arg {\n                arg_types.push(quote! { #pat_type.ty }.to_string());\n            }\n        }\n\n        let return_type = if let syn::ReturnType::Type(_, ty) = &i.sig.output {\n            quote! { #ty }.to_string()\n        } else {\n            \"()\".to_string()\n        };\n\n        let visibility_str = match &i.vis {\n            Visibility::Public(_) => \"public\".to_string(),\n            Visibility::Restricted(r) => format!(\"restricted({})\", quote!{#r.path}.to_string()),\n            Visibility::Inherited => \"private\".to_string(),\n            //_ => \"unknown\".to_string(), // Catch-all for any other variants\n        };\n\n        self.stats.function_definitions.push(FunctionInfo {\n            name: i.sig.ident.to_string(),\n            visibility: visibility_str,\n            arg_count: i.sig.inputs.len() as u32,\n            arg_types,\n            return_type,\n            is_async: i.sig.asyncness.is_some(),\n            is_unsafe: i.sig.unsafety.is_some(),\n            is_const: i.sig.constness.is_some(),\n        });\n\n        visit::visit_item_fn(self, i);\n    }\n\n    fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct) {\n        self.increment_node_type_count(\"struct\");\n        visit::visit_item_struct(self, i);\n    }\n\n    fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum) {\n        self.increment_node_type_count(\"enum\");\n        visit::visit_item_enum(self, i);\n    }\n\n    fn visit_item_trait(&mut self, i: &'ast syn::ItemTrait) {\n        self.increment_node_type_count(\"trait\");\n        visit::visit_item_trait(self, i);\n    }\n\n    fn visit_item_impl(&mut self, i: &'ast syn::ItemImpl) {\n        self.increment_node_type_count(\"impl\");\n        visit::visit_item_impl(self, i);\n    }\n\n    fn visit_item_use(&mut self, i: &'ast syn::ItemUse) {\n        self.increment_node_type_count(\"import\");\n        // TODO: Extract detailed ImportInfo\n        visit::visit_item_use(self, i);\n    }\n\n    fn visit_pat_ident(&mut self, i: &'ast syn::PatIdent) {\n        // This captures variable declarations like `let x = ...`\n        // It's tricky to get the type here without more context, but we can get the name.\n        self.increment_node_type_count(\"variable\");\n        // TODO: Extract type and mutability more accurately\n        self.stats.variable_declarations.push(VariableInfo {\n            name: i.ident.to_string(),\n            type_name: \"unknown\".to_string(), // Placeholder\n            is_mutable: i.by_ref.is_some() || i.mutability.is_some(),\n            scope: \"unknown\".to_string(), // Placeholder\n        });\n        visit::visit_pat_ident(self, i);\n    }\n\n    // Catch-all for other items to count them\n    fn visit_item(&mut self, i: &'ast syn::Item) {\n        match i {\n            Item::Const(_) => self.increment_node_type_count(\"const\"),\n            Item::Static(_) => self.increment_node_type_count(\"static\"),\n            Item::Mod(_) => self.increment_node_type_count(\"module\"),\n            Item::ForeignMod(_) => self.increment_node_type_count(\"foreign_module\"),\n            Item::Macro(_) => self.increment_node_type_count(\"macro_definition\"),\n            // Item::Macro2(_) => self.increment_node_type_count(\"macro_definition2\"), // Removed Item::Macro2\n            Item::Type(_) => self.increment_node_type_count(\"type_alias\"),\n            Item::Union(_) => self.increment_node_type_count(\"union\"),\n            _ => self.increment_node_type_count(\"other_item\"), // Fallback for items not explicitly handled\n        }\n        visit::visit_item(self, i);\n    }\n\n    // TODO: Add more specific visitors for expressions, statements, etc.\n}\n\n/// Functor to traverse the AST and collect statistics\npub struct AstTraversalFunctor;\n\nimpl PipelineFunctor<ParsedFile, AstStatistics> for AstTraversalFunctor {\n    fn map<'writer>(\n        &'writer self,\n        _writer: &'writer mut (impl tokio::io::AsyncWriteExt + Unpin + Send),\n        input: ParsedFile,\n    ) -> Pin<Box<dyn Future<Output = Result<AstStatistics>> + Send + 'writer>> {\n        Box::pin(async move {\n            // Removed: measurement::record_function_entry(\"AstTraversalFunctor::map\");\n            let ParsedFile(parsed_code, file_path) = input;\n\n            let stats = tokio::task::spawn_blocking(move || -> anyhow::Result<AstStatistics> {\n                let ast = syn::parse_file(&parsed_code).context(\"Failed to parse code into AST for traversal\")?;\n                let mut visitor = AstVisitor::new(file_path);\n                syn::visit::visit_file(&mut visitor, &ast);\n                Ok(visitor.stats)\n            }).await.context(\"Blocking task for AST parsing failed\")??;\n\n            // Removed: measurement::record_function_exit(\"AstTraversalFunctor::map\");\n            Ok(stats)\n        })\n    }\n}\n",
    "timestamp": "2025-10-31T21:56:19.605718056Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/pipeline-traits/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 37 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling libc v0.2.177\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling parking_lot_core v0.9.12\n   Compiling scopeguard v1.2.0\n   Compiling smallvec v1.15.1\n   Compiling serde_core v1.0.228\n   Compiling cfg-if v1.0.4\n   Compiling lock_api v0.4.14\n   Compiling serde v1.0.228\n   Compiling anyhow v1.0.100\n   Compiling bytes v1.10.1\n   Compiling pin-project-lite v0.2.16\n   Compiling syn v2.0.108\n   Compiling signal-hook-registry v1.4.6\n   Compiling mio v1.1.0\n   Compiling socket2 v0.6.1\n   Compiling parking_lot v0.12.5\n   Compiling serde_derive v1.0.228\n   Compiling tokio-macros v2.6.0\n   Compiling tokio v1.48.0\n   Compiling pipeline-traits v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU)\nerror: Option 'edition' given more than once\n\nerror: could not compile `pipeline-traits` (lib)\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name pipeline_traits --edition=2024 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=8b96acd11b4a5a46 -C extra-filename=-3014dd51fd1c0299 --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rmeta --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libserde-869763d06b848793.rmeta --extern tokio=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libtokio-a5b489558772ec23.rmeta -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/src/lib.rs` (exit status: 1)\nwarning: build failed, waiting for other jobs to finish...\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 37 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling libc v0.2.177\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling parking_lot_core v0.9.12\n   Compiling scopeguard v1.2.0\n   Compiling smallvec v1.15.1\n   Compiling serde_core v1.0.228\n   Compiling cfg-if v1.0.4\n   Compiling lock_api v0.4.14\n   Compiling serde v1.0.228\n   Compiling anyhow v1.0.100\n   Compiling bytes v1.10.1\n   Compiling pin-project-lite v0.2.16\n   Compiling syn v2.0.108\n   Compiling signal-hook-registry v1.4.6\n   Compiling mio v1.1.0\n   Compiling socket2 v0.6.1\n   Compiling parking_lot v0.12.5\n   Compiling serde_derive v1.0.228\n   Compiling tokio-macros v2.6.0\n   Compiling tokio v1.48.0\n   Compiling pipeline-traits v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU)\nerror: Option 'edition' given more than once\n\nerror: could not compile `pipeline-traits` (lib)\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name pipeline_traits --edition=2024 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=8b96acd11b4a5a46 -C extra-filename=-3014dd51fd1c0299 --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rmeta --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libserde-869763d06b848793.rmeta --extern tokio=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/target/debug/deps/libtokio-a5b489558772ec23.rmeta -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp77RpnU/src/lib.rs` (exit status: 1)\nwarning: build failed, waiting for other jobs to finish...\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use anyhow::Result;\nuse std::path::PathBuf;\nuse std::pin::Pin;\nuse std::future::Future;\nuse std::boxed::Box;\nuse std::fmt::Debug;\nuse std::collections::HashMap;\nuse serde::{Deserialize, Serialize};\n\npub mod use_statement_types;\npub use use_statement_types::{\n    GitDetails, GitInfo, GitInfoTrait,\n    NixDetails, NixInfo, NixInfoTrait,\n    RustDetails, RustDetailsInfo, RustDetailsInfoTrait,\n    CargoDetails, CargoInfo, CargoInfoTrait,\n    SynDetails, SynInfo, SynInfoTrait,\n    LlvmDetails, LlvmInfo, LlvmInfoTrait,\n    LinuxDetails, LinuxInfo, LinuxInfoTrait,\n};\n\n#[derive(Debug)]\npub struct RawFile(pub String, pub String);\n#[derive(Clone)]\npub struct ParsedFile(pub String, pub PathBuf);\n#[derive(Debug)]\npub struct UseStatements(pub Vec<String>);\n#[derive(Debug)]\npub struct ClassifiedUseStatements(pub Vec<UseStatement>);\n#[derive(Debug, Clone)]\npub struct ValidatedFile(pub String, pub PathBuf);\n\n// Functors (as a trait)\npub trait PipelineFunctor<Input: Send + 'static, Output: Send + 'static> {\n    fn map<'writer>(\n        &'writer self,\n        writer: &'writer mut (impl tokio::io::AsyncWriteExt + Unpin + Send),\n        input: Input,\n    ) -> Pin<Box<dyn Future<Output = Result<Output>> + Send + 'writer>>;\n}\n\n#[derive(Debug)]\npub struct UseStatement {\n    pub statement: String,\n    pub error: Option<String>,\n    // Composed traits\n    pub git_details: Option<GitDetails>,\n    pub nix_details: Option<NixDetails>,\n    pub rust_details: Option<RustDetails>,\n    pub cargo_details: Option<CargoDetails>,\n    pub syn_details: Option<SynDetails>,\n    pub llvm_details: Option<LlvmDetails>,\n    pub linux_details: Option<LinuxDetails>,\n}\n\n/// Information about a variable found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VariableInfo {\n    pub name: String,\n    pub type_name: String,\n    pub is_mutable: bool,\n    pub scope: String, // e.g., \"function\", \"module\", \"global\"\n}\n\n/// Information about a function found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionInfo {\n    pub name: String,\n    pub visibility: String, // e.g., \"public\", \"private\"\n    pub arg_count: u32,\n    pub arg_types: Vec<String>,\n    pub return_type: String,\n    pub is_async: bool,\n    pub is_unsafe: bool,\n    pub is_const: bool,\n}\n\n/// Information about an import statement found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ImportInfo {\n    pub path: String, // The full path of the import (e.g., \"std::collections::HashMap\")\n    pub alias: Option<String>,\n    pub is_external: bool,\n    pub source_crate: Option<String>,\n    pub git_source_url: Option<String>,\n    pub git_branch: Option<String>,\n}\n\n/// Comprehensive AST analysis data for a Rust project\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct AstStatistics {\n    pub node_type_counts: HashMap<String, u32>,\n    pub variable_declarations: Vec<VariableInfo>,\n    pub function_definitions: Vec<FunctionInfo>,\n    pub import_statements: Vec<ImportInfo>,\n    // Add more fields as needed, e.g., macro invocations, struct definitions\n}\n",
    "timestamp": "2025-10-31T21:56:37.733288831Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/generated/crates/prelude-collector/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 48 packages to latest compatible versions\n      Adding indoc v1.0.9 (available: v2.0.7)\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling version_check v0.9.5\n   Compiling typenum v1.19.0\n   Compiling serde v1.0.228\n   Compiling libc v0.2.177\n   Compiling generic-array v0.14.9\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.16.0\n   Compiling cfg-if v1.0.4\n   Compiling getrandom v0.3.4\n   Compiling rustix v1.1.2\n   Compiling indexmap v2.12.0\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.10.0\n   Compiling syn v2.0.108\n   Compiling serde_json v1.0.145\n   Compiling anyhow v1.0.100\n   Compiling block-buffer v0.10.4\n   Compiling crypto-common v0.1.6\n   Compiling toml_write v0.1.2\n   Compiling winnow v0.7.13\n   Compiling digest v0.10.7\n   Compiling cpufeatures v0.2.17\n   Compiling memchr v2.7.6\n   Compiling same-file v1.0.6\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling once_cell v1.21.3\n   Compiling fastrand v2.3.0\n   Compiling walkdir v2.5.0\n   Compiling tempfile v3.23.0\n   Compiling sha2 v0.10.9\n   Compiling indoc v1.0.9\n   Compiling serde_derive v1.0.228\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling prelude-collector v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN)\nerror: Option 'edition' given more than once\n\nerror: could not compile `prelude-collector` (lib)\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name prelude_collector --edition=2021 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=563c19f71a3eb907 -C extra-filename=-0bb7bfcda7fc6c2e --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rmeta --extern indoc=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libindoc-3fcebf55ef3be084.so --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libquote-ecfbecd938122db1.rmeta --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libserde-da43458380bcbbb2.rmeta --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libserde_json-f500fd01bb978a8a.rmeta --extern sha2=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libsha2-469e91796143860f.rmeta --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libsyn-c80c23c48b50a3f5.rmeta --extern tempfile=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libtempfile-05b1ca52e32dc17e.rmeta --extern toml=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libtoml-00a297eb852bca86.rmeta --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libwalkdir-f182331eb7ca4c76.rmeta -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/src/lib.rs` (exit status: 1)\nwarning: build failed, waiting for other jobs to finish...\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 48 packages to latest compatible versions\n      Adding indoc v1.0.9 (available: v2.0.7)\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling version_check v0.9.5\n   Compiling typenum v1.19.0\n   Compiling serde v1.0.228\n   Compiling libc v0.2.177\n   Compiling generic-array v0.14.9\n   Compiling equivalent v1.0.2\n   Compiling hashbrown v0.16.0\n   Compiling cfg-if v1.0.4\n   Compiling getrandom v0.3.4\n   Compiling rustix v1.1.2\n   Compiling indexmap v2.12.0\n   Compiling linux-raw-sys v0.11.0\n   Compiling bitflags v2.10.0\n   Compiling syn v2.0.108\n   Compiling serde_json v1.0.145\n   Compiling anyhow v1.0.100\n   Compiling block-buffer v0.10.4\n   Compiling crypto-common v0.1.6\n   Compiling toml_write v0.1.2\n   Compiling winnow v0.7.13\n   Compiling digest v0.10.7\n   Compiling cpufeatures v0.2.17\n   Compiling memchr v2.7.6\n   Compiling same-file v1.0.6\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling once_cell v1.21.3\n   Compiling fastrand v2.3.0\n   Compiling walkdir v2.5.0\n   Compiling tempfile v3.23.0\n   Compiling sha2 v0.10.9\n   Compiling indoc v1.0.9\n   Compiling serde_derive v1.0.228\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling prelude-collector v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN)\nerror: Option 'edition' given more than once\n\nerror: could not compile `prelude-collector` (lib)\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name prelude_collector --edition=2021 src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type lib --emit=dep-info,metadata,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=563c19f71a3eb907 -C extra-filename=-0bb7bfcda7fc6c2e --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rmeta --extern indoc=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libindoc-3fcebf55ef3be084.so --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libquote-ecfbecd938122db1.rmeta --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libserde-da43458380bcbbb2.rmeta --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libserde_json-f500fd01bb978a8a.rmeta --extern sha2=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libsha2-469e91796143860f.rmeta --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libsyn-c80c23c48b50a3f5.rmeta --extern tempfile=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libtempfile-05b1ca52e32dc17e.rmeta --extern toml=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libtoml-00a297eb852bca86.rmeta --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/target/debug/deps/libwalkdir-f182331eb7ca4c76.rmeta -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpyxscJN/src/lib.rs` (exit status: 1)\nwarning: build failed, waiting for other jobs to finish...\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use anyhow::{Context, Result};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::fs;\nuse std::path::{Path, PathBuf};\nuse std::process::Command;\nuse syn::{Item, UseTree}; // Add UseTree\nuse walkdir::WalkDir;\nuse tempfile;\nuse sha2::{Sha256, Digest};\nuse indoc::indoc;\n//use quote::quote;\nuse toml;\n\n// Struct to hold rustc version and host triple\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\nstruct RustcInfo {\n    version: String,\n    host: String,\n}\n\n// Helper to get rustc version and host triple\nfn get_rustc_info() -> Result<RustcInfo> {\n    let output = Command::new(\"rustc\")\n        .arg(\"--version\")\n        .arg(\"--verbose\")\n        .output()?;\n\n    if !output.status.success() {\n        anyhow::bail!(\n            \"rustc --version --verbose failed: {}\",\n            String::from_utf8_lossy(&output.stderr)\n        );\n    }\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    let version_line = stdout.lines().find(|line| line.starts_with(\"rustc \"));\n    let host_line = stdout.lines().find(|line| line.starts_with(\"host: \"));\n\n    let version = version_line\n        .and_then(|line| line.split_whitespace().nth(1))\n        .unwrap_or(\"unknown\")\n        .to_string();\n    let host = host_line\n        .and_then(|line| line.split_whitespace().nth(1))\n        .unwrap_or(\"unknown\")\n        .to_string();\n\n    Ok(RustcInfo { version, host })\n}\n\nfn expand_macros_and_parse(file_path: &Path, content: &str, rustc_info: &RustcInfo, cache_dir: &Path) -> Result<syn::File> {\n    // Calculate content hash\n    let mut hasher = Sha256::new();\n    hasher.update(content.as_bytes());\n    let content_hash = format!(\"{:x}\", hasher.finalize());\n\n    // Create a unique cache key based on file hash, rustc info, and rustc flags\n    let cache_key = format!(\n        \"expanded_{}_{}_{}_{}_{}\",\n        content_hash,\n        rustc_info.version,\n        rustc_info.host,\n        \"lib\", // --crate-type\n        \"2021\" // --edition\n    );\n    let cached_file_path = cache_dir.join(cache_key);\n\n    // Check if expanded code is already cached\n    if cached_file_path.exists() {\n        println!(\"      -> Using cached expanded code for: {}\", file_path.display());\n        let expanded_code = fs::read_to_string(&cached_file_path)\n            .with_context(|| format!(\"Failed to read cached expanded code for {}\", file_path.display()))?;\n        return syn::parse_file(&expanded_code).with_context(|| format!(\"Failed to parse cached expanded code for {}\", file_path.display()));\n    }\n\n    // If not cached, perform expansion by creating a temporary crate\n    let temp_crate_dir = tempfile::tempdir()?;\n    let temp_crate_path = temp_crate_dir.path();\n\n    // Create Cargo.toml for the temporary crate\n    let cargo_toml_content = indoc! {\n        r#\"\n        [package]\n        name = \"temp_crate\"\n        version = \"0.1.0\"\n        edition = \"2021\"\n\n        [dependencies]\n        serde = { version = \"1.0\", features = [\"derive\"] }\n        serde_json = \"1.0\"\n        anyhow = \"1.0\"\n        # Add other common dependencies that might contain macros\n        \"#\n    };\n    fs::write(temp_crate_path.join(\"Cargo.toml\"), cargo_toml_content)?;\n\n    // Create src directory\n    let temp_src_dir = temp_crate_path.join(\"src\");\n    fs::create_dir(&temp_src_dir)?;\n\n    // Write the original content to a file within the temporary crate\n    let temp_rs_file_name = file_path.file_name().unwrap_or_else(|| \"temp_file.rs\".as_ref());\n    let temp_rs_file_path = temp_src_dir.join(temp_rs_file_name);\n    fs::write(&temp_rs_file_path, content)?;\n\n    // Create lib.rs that includes the target file\n    let lib_rs_content = format!(\n        indoc! {\n            r#\"\n            #![allow(unused_imports)]\n            #![allow(dead_code)]\n            include!(\"{}\");\n            \"#\n        },\n        temp_rs_file_name.to_string_lossy() // Pass the full file name\n    );\n    fs::write(temp_src_dir.join(\"lib.rs\"), lib_rs_content)?;\n\n    println!(\"        -> PATH environment variable: {:?}\", std::env::var(\"PATH\"));\n    println!(\"        -> Running cargo rustc -Zunpretty=expanded for: {}\", file_path.display());\n    let output = Command::new(\"cargo\")\n        .arg(\"rustc\")\n        .arg(\"--\")\n        .arg(\"-Zunpretty=expanded\")\n        .arg(\"--crate-type\")\n        .arg(\"lib\")\n        .current_dir(temp_crate_path)\n        .output()?;\n\n    println!(\"        -> cargo rustc status for {}: {}\", file_path.display(), output.status);\n    println!(\"        -> cargo rustc stdout for {}: {}\\n\", file_path.display(), String::from_utf8_lossy(&output.stdout));\n    if !output.status.success() {\n        println!(\"        -> cargo rustc stderr for {}: {}\", file_path.display(), String::from_utf8_lossy(&output.stderr));\n        anyhow::bail!(\n            \"cargo rustc -Zunpretty=expanded failed for {}: {}\\nStderr: {}\",\n            file_path.display(),\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n    }\n\n    let expanded_code = String::from_utf8_lossy(&output.stdout).to_string();\n\n    // Extract the relevant expanded code for the specific file\n    // This is a heuristic and might need refinement.\n    let search_string = format!(\"// {}\\n\", temp_rs_file_name.to_string_lossy());\n    let start_index = expanded_code.find(&search_string).unwrap_or(0);\n    let end_index = expanded_code[start_index..].find(\"// \").map_or(expanded_code.len(), |i| start_index + i);\n    let relevant_expanded_code = expanded_code[start_index..end_index].to_string();\n\n    println!(\"        -> Writing expanded code to cache for: {}\", file_path.display());\n    // Cache the expanded code\n    fs::write(&cached_file_path, &relevant_expanded_code)\n        .with_context(|| format!(\"Failed to write expanded code to cache for {}\", file_path.display()))?;\n    println!(\"      -> Wrote expanded code to cache: {}\", cached_file_path.display());\n\n    println!(\"        -> Parsing expanded code for: {}\", file_path.display());\n    syn::parse_file(&relevant_expanded_code).with_context(|| format!(\"Failed to parse expanded code for {}\", file_path.display()))\n}\n\n#[derive(Deserialize, Debug)]\nstruct Metadata {\n    packages: Vec<Package>,\n    #[allow(dead_code)]\n    workspace_root: PathBuf,\n}\n\n#[derive(Deserialize, Debug)]\nstruct Package {\n    name: String,\n    manifest_path: PathBuf,\n}\n\n#[derive(Deserialize, Debug)]\nstruct CargoToml {\n    #[serde(default)]\n    lib: Option<LibSection>,\n}\n\n#[derive(Deserialize, Debug)]\nstruct LibSection {\n    #[serde(rename = \"proc-macro\", default)]\n    proc_macro: bool,\n}\n\nfn is_proc_macro_crate(crate_root: &Path) -> Result<bool> {\n    let cargo_toml_path = crate_root.join(\"Cargo.toml\");\n    if !cargo_toml_path.exists() {\n        return Ok(false);\n    }\n    let content = fs::read_to_string(&cargo_toml_path)\n        .context(format!(\"Failed to read Cargo.toml for {}\", crate_root.display()))?;\n    let cargo_toml: CargoToml = toml::from_str(&content)\n        .context(format!(\"Failed to parse Cargo.toml for {}\", crate_root.display()))?;\n\n    Ok(cargo_toml.lib.map_or(false, |lib| lib.proc_macro))\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct CollectedPreludeInfo {\n    pub crate_name: String,\n    pub crate_root: PathBuf,\n    pub prelude_content: String,\n    pub modified_files: Vec<PathBuf>,\n    pub crate_root_modified: bool,\n    pub file_processing_results: Vec<FileProcessingResult>,\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub enum FileProcessingStatus {\n    Success,\n    Skipped { reason: String },\n    Failed { error: String },\n}\n\n#[derive(Serialize, Deserialize, Debug)]\npub struct FileProcessingResult {\n    pub path: PathBuf,\n    pub status: FileProcessingStatus,\n}\n\n// Helper function to flatten UseTree into individual use paths\nfn flatten_use_tree(\n    base_path: &mut Vec<String>,\n    use_tree: &UseTree,\n    flat_uses: &mut HashSet<String>,\n) {\n    match use_tree {\n        UseTree::Path(path) => {\n            base_path.push(path.ident.to_string());\n            flatten_use_tree(base_path, &path.tree, flat_uses);\n            base_path.pop();\n        }\n        UseTree::Name(name) => {\n            let mut full_path = base_path.join(\"::\");\n            if !full_path.is_empty() {\n                full_path.push_str(\"::\");\n            }\n            full_path.push_str(&name.ident.to_string());\n            flat_uses.insert(format!(\"use {};\", full_path));\n        }\n        UseTree::Rename(rename) => {\n            let mut full_path = base_path.join(\"::\");\n            if !full_path.is_empty() {\n                full_path.push_str(\"::\");\n            }\n            full_path.push_str(&rename.ident.to_string());\n            flat_uses.insert(format!(\"use {} as {};\", full_path, rename.rename.to_string()));\n        }\n        UseTree::Glob(_glob) => {\n            let mut full_path = base_path.join(\"::\");\n            if !full_path.is_empty() {\n                full_path.push_str(\"::\");\n            }\n            full_path.push_str(\"*\");\n            flat_uses.insert(format!(\"use {};\", full_path));\n        }\n        UseTree::Group(group) => {\n            for tree in group.items.iter() {\n                flatten_use_tree(base_path, tree, flat_uses);\n            }\n        }\n    }\n}\n\npub fn collect_prelude_info(workspace_path: &Path, exclude_crates: &HashSet<String>) -> Result<Vec<CollectedPreludeInfo>> {\n    let rustc_info = get_rustc_info()?;\n    let cache_dir = workspace_path.join(\".prelude_cache\");\n    fs::create_dir_all(&cache_dir).context(\"Failed to create prelude cache directory\")?;\n\n    let output = Command::new(\"cargo\")\n        .arg(\"metadata\")\n        .arg(\"--no-deps\")\n        .arg(\"--format-version=1\")\n        .current_dir(workspace_path)\n        .output()?;\n\n    if !output.status.success() {\n        anyhow::bail!(\n            \"cargo metadata failed: {}\",\n            String::from_utf8_lossy(&output.stderr)\n        );\n    }\n\n    let metadata: Metadata = serde_json::from_slice(&output.stdout)?;\n    let mut collected_info = Vec::new();\n\n    for package in metadata.packages {\n        if exclude_crates.contains(&package.name) {\n            println!(\n                \"Skipping explicitly excluded crate: {} ({})\",\n                package.name,\n                package.manifest_path.display()\n            );\n            continue;\n        }\n\n        let crate_root = package.manifest_path.parent().unwrap().to_path_buf();\n        if is_proc_macro_crate(&crate_root)? {\n            println!(\n                \"Skipping procedural macro crate: {} ({})\",\n                package.name,\n                crate_root.display()\n            );\n            continue;\n        }\n\n        println!(\n            \"\\nCollecting prelude info for crate: {} ({})\",\n            package.name,\n            crate_root.display()\n        );\n\n        let src_dir = crate_root.join(\"src\");\n        if !src_dir.is_dir() {\n            println!(\"  -> No src directory found, skipping.\");\n            continue;\n        }\n\n        let mut use_statements = HashSet::new();\n        let mut rust_files = Vec::new();\n        let mut file_processing_results = Vec::new();\n\n        println!(\"  -> Starting file walk for crate: {}\", package.name);\n        for entry in WalkDir::new(&src_dir)\n            .into_iter()\n            .filter_map(|e| e.ok())\n            .filter(|e| {\n                let path = e.path();\n                path.extension().map_or(false, |ext| ext == \"rs\")\n                    && path.file_name().map_or(false, |name| name != \"prelude.rs\")\n            })\n        {\n            let path = entry.path();\n            rust_files.push(path.to_path_buf());\n            let content = match fs::read_to_string(path) {\n                Ok(c) => c,\n                Err(e) => {\n                    file_processing_results.push(FileProcessingResult {\n                        path: path.to_path_buf(),\n                        status: FileProcessingStatus::Failed { error: format!(\"Failed to read file: {}\", e) },\n                    });\n                    continue;\n                }\n            };\n\n            println!(\"    -> Expanding macros and parsing file: {}\", path.display());\n            let ast = match expand_macros_and_parse(path, &content, &rustc_info, &cache_dir) {\n                Ok(ast) => ast,\n                Err(e) => {\n                    file_processing_results.push(FileProcessingResult {\n                        path: path.to_path_buf(),\n                        status: FileProcessingStatus::Failed { error: format!(\"Failed to expand macros and parse: {}\", e) },\n                    });\n                    continue; // Skip this file and continue with the next\n                }\n            };\n            println!(\"    -> Successfully expanded macros and parsed file: {}\", path.display());\n\n            for item in &ast.items {\n                if let Item::Use(use_item) = item {\n                    let mut base_path = Vec::new();\n                    flatten_use_tree(&mut base_path, &use_item.tree, &mut use_statements);\n                }\n            }\n            file_processing_results.push(FileProcessingResult {\n                path: path.to_path_buf(),\n                status: FileProcessingStatus::Success,\n            });\n        }\n        println!(\"  -> Finished file walk for crate: {}\", package.name);\n\n        if use_statements.is_empty() {\n            file_processing_results.push(FileProcessingResult {\n                path: src_dir.to_path_buf(), // Representing the crate as a whole\n                status: FileProcessingStatus::Skipped { reason: \"No use statements found in crate\".to_string() },\n            });\n            continue;\n        }\n\n        let mut prelude_content = String::from(\n            \"// This file is auto-generated by prelude-generator. Do not edit.\\n\\n\",\n        );\n        let mut sorted_uses: Vec<_> = use_statements.iter().collect();\n        sorted_uses.sort();\n\n        for use_stmt in sorted_uses {\n            // The flatten_use_tree already adds \"use\" and \";\"\n            prelude_content.push_str(&format!(\"pub {}\", use_stmt));\n            prelude_content.push_str(\"\\n\");\n        }\n\n        // Determine if crate root needs modification (pub mod prelude;)\n        let mut crate_root_modified = false;\n        let lib_rs = src_dir.join(\"lib.rs\");\n        let main_rs = src_dir.join(\"main.rs\");\n        let crate_root_path = if lib_rs.exists() {\n            Some(lib_rs)\n        } else if main_rs.exists() {\n            Some(main_rs)\n        } else {\n            None\n        };\n\n        if let Some(path) = crate_root_path {\n            let content = fs::read_to_string(&path)?;\n            let ast = expand_macros_and_parse(&path, &content, &rustc_info, &cache_dir)?;\n            let mut has_prelude_mod = false;\n            for item in &ast.items {\n                if let Item::Mod(mod_item) = item {\n                    if mod_item.ident == \"prelude\" {\n                        has_prelude_mod = true;\n                        break;\n                    }\n                }\n            }\n            if !has_prelude_mod {\n                crate_root_modified = true;\n            }\n        }\n\n\n        collected_info.push(CollectedPreludeInfo {\n            crate_name: package.name,\n            crate_root,\n            prelude_content,\n            modified_files: rust_files,\n            crate_root_modified,\n            file_processing_results,\n        });\n    }\n\n    Ok(collected_info)\n}\n",
    "timestamp": "2025-10-31T21:56:59.858342364Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/rust-decl-splitter/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 17 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling unicode-ident v1.0.22\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling same-file v1.0.6\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling memchr v2.7.6\n   Compiling walkdir v2.5.0\n   Compiling lazy_static v1.5.0\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling rust-decl-splitter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG)\nerror: Option 'edition' given more than once\n\nerror: could not compile `rust-decl-splitter` (bin \"rust-decl-splitter\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name rust_decl_splitter --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f26c701a314b50c3 -C extra-filename=-ac9e78807e4539bc --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps --extern lazy_static=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/liblazy_static-cb92c169439ef4ae.rlib --extern proc_macro2=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libproc_macro2-9f5e97b8e7360518.rlib --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libquote-48f13151227b1885.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libserde-ca499a1725c86559.rlib --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libserde_json-f500fd01bb978a8a.rlib --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libsyn-43a37db4aefda905.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/src/main.rs` (exit status: 1)\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 17 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling unicode-ident v1.0.22\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling same-file v1.0.6\n   Compiling ryu v1.0.20\n   Compiling itoa v1.0.15\n   Compiling memchr v2.7.6\n   Compiling walkdir v2.5.0\n   Compiling lazy_static v1.5.0\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling rust-decl-splitter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG)\nerror: Option 'edition' given more than once\n\nerror: could not compile `rust-decl-splitter` (bin \"rust-decl-splitter\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name rust_decl_splitter --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=f26c701a314b50c3 -C extra-filename=-ac9e78807e4539bc --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps --extern lazy_static=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/liblazy_static-cb92c169439ef4ae.rlib --extern proc_macro2=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libproc_macro2-9f5e97b8e7360518.rlib --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libquote-48f13151227b1885.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libserde-ca499a1725c86559.rlib --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libserde_json-f500fd01bb978a8a.rlib --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libsyn-43a37db4aefda905.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRYaFXG/src/main.rs` (exit status: 1)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "pub mod prelude;\nmod measurement;\nuse crate::prelude::*;\nuse syn::parse_quote;\nfn to_snake_case(ident: &Ident) -> String {\n    let mut s = String::new();\n    for (i, char) in ident.to_string().chars().enumerate() {\n        if char.is_uppercase() && i != 0 {\n            s.push('_');\n        }\n        s.push(char.to_ascii_lowercase());\n    }\n    s\n}\nfn main() -> io::Result<()> {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n        eprintln!(\"Usage: {} <input_directory> <output_directory>\", args[0]);\n        return Ok(());\n    }\n    let input_dir = PathBuf::from(&args[1]);\n    let output_dir = PathBuf::from(&args[2]);\n    if !input_dir.is_dir() {\n        eprintln!(\"Error: Input directory does not exist or is not a directory.\");\n        return Ok(());\n    }\n    fs::create_dir_all(&output_dir)?;\n    for entry in WalkDir::new(&input_dir) {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() && path.extension().map_or(false, |ext| ext == \"rs\") {\n            println!(\"Processing file: {}\", path.display());\n            let content = fs::read_to_string(path)?;\n            match syn::parse_file(&content) {\n                Ok(file) => {\n                    println!(\"Successfully parsed: {}\", path.display());\n                    let relative_path = path.strip_prefix(&input_dir).unwrap();\n                    let output_file_dir = output_dir\n                        .join(relative_path.parent().unwrap_or(Path::new(\"\")));\n                    fs::create_dir_all(&output_file_dir)?;\n                    let mut original_file_content = String::new();\n                    for item in file.items {\n                        let (ident, item_code) = match item {\n                            Item::Fn(mut item_fn) => {\n                                let original_block = item_fn.block;\n                                let fn_ident = item_fn.sig.ident.clone();\n                                item_fn.block = parse_quote! {\n                                    {\n                                        measurement::record_function_entry(stringify!(#fn_ident));\n                                        let __result = #original_block;\n                                        measurement::record_function_exit(stringify!(#fn_ident));\n                                        __result\n                                    }\n                                };\n                                (\n                                    fn_ident,\n                                    quote! {\n                                        #item_fn\n                                    },\n                                )\n                            }\n                            Item::Struct(item_struct) => {\n                                (\n                                    item_struct.ident.clone(),\n                                    quote! {\n                                        # item_struct\n                                    },\n                                )\n                            }\n                            Item::Enum(item_enum) => {\n                                (\n                                    item_enum.ident.clone(),\n                                    quote! {\n                                        # item_enum\n                                    },\n                                )\n                            }\n                            Item::Trait(item_trait) => {\n                                (\n                                    item_trait.ident.clone(),\n                                    quote! {\n                                        # item_trait\n                                    },\n                                )\n                            }\n                            Item::Mod(item_mod) => {\n                                let original_item_mod = item_mod.clone();\n                                if original_item_mod.content.is_some() {\n                                    let mod_ident = original_item_mod.ident.clone();\n                                    let mod_name_snake = to_snake_case(&mod_ident);\n                                    let new_mod_file_path = output_file_dir\n                                        .join(format!(\"{}.rs\", mod_name_snake));\n                                    let new_mod_content = quote! {\n                                        # original_item_mod\n                                    };\n                                    fs::write(&new_mod_file_path, new_mod_content.to_string())?;\n                                    original_file_content\n                                        .push_str(&format!(\"pub mod {};\\n\", mod_name_snake));\n                                    continue;\n                                } else {\n                                    (\n                                        original_item_mod.ident.clone(),\n                                        quote! {\n                                            # original_item_mod\n                                        },\n                                    )\n                                }\n                            }\n                            Item::Impl(item_impl) => {\n                                let target_ident = match &*item_impl.self_ty {\n                                    syn::Type::Path(type_path) => {\n                                        type_path\n                                            .path\n                                            .segments\n                                            .last()\n                                            .map(|segment| segment.ident.clone())\n                                            .unwrap_or_else(|| Ident::new(\"unknown\", item_impl.span()))\n                                    }\n                                    _ => Ident::new(\"unknown\", item_impl.span()),\n                                };\n                                let snake_case_name = to_snake_case(&target_ident);\n                                let target_file_name = format!(\"{}.rs\", snake_case_name);\n                                let target_file_path = output_file_dir\n                                    .join(&target_file_name);\n                                println!(\n                                    \"  Moving impl block for {} to {}\", target_ident,\n                                    target_file_path.display()\n                                );\n                                let impl_code = quote! {\n                                    # item_impl\n                                };\n                                let mut existing_content = fs::read_to_string(\n                                        &target_file_path,\n                                    )\n                                    .unwrap_or_default();\n                                existing_content\n                                    .push_str(&format!(\"\\n{}\\n\", impl_code.to_string()));\n                                fs::write(&target_file_path, existing_content)?;\n                                continue;\n                            }\n                            Item::Use(_item_use) => {\n                                continue;\n                            }\n                            _ => {\n                                original_file_content\n                                    .push_str(&format!(\"{}\\n\", quote! { # item }));\n                                continue;\n                            }\n                        };\n                        let snake_case_name = to_snake_case(&ident);\n                        let new_file_name = format!(\"{}.rs\", snake_case_name);\n                        let new_file_path = output_file_dir.join(&new_file_name);\n                        println!(\n                            \"  Splitting {} into {}\", ident, new_file_path.display()\n                        );\n                        let new_file_name = format!(\"{}.rs\", snake_case_name);\n                        let new_file_path = output_file_dir.join(&new_file_name);\n\n                        let function_output_dir = output_file_dir.join(&snake_case_name); // Directory for this function\n                        fs::create_dir_all(&function_output_dir)?;\n\n                        let rollup_data_dir = function_output_dir.join(\"rollup_data\"); // rollup_data inside function dir\n                        fs::create_dir_all(&rollup_data_dir)?;\n\n                        let wrapped_code_path = rollup_data_dir.join(\"wrapped_code.rs\");\n\n                        let mut new_file_content = String::new();\n                        new_file_content.push_str(\"use prelude::*;\\n\");\n                        new_file_content.push_str(&item_code.to_string());\n                        fs::write(&wrapped_code_path, new_file_content)?; // Save as wrapped_code.rs\n\n                        // The original file now just re-exports from the function's directory\n                        fs::write(&new_file_path, format!(\"pub use {}::{};\\n\", snake_case_name, ident))?;\n                        original_file_content\n                            .push_str(\n                                &format!(\"pub use {}::{};\\n\", snake_case_name, ident),\n                            );\n                    }\n                    let original_output_path = output_dir.join(relative_path);\n                    fs::write(&original_output_path, original_file_content)?;\n                }\n                Err(e) => {\n                    eprintln!(\"Error parsing {}: {}\", path.display(), e);\n                }\n            }\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T21:57:14.663185379Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/rust-system-composer/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 35 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling utf8parse v0.2.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling heck v0.5.0\n   Compiling anyhow v1.0.100\n   Compiling same-file v1.0.6\n   Compiling walkdir v2.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling rust-system-composer v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu)\nerror: Option 'edition' given more than once\n\nerror: could not compile `rust-system-composer` (bin \"rust-system-composer\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name rust_system_composer --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6ae7119ffad3e39b -C extra-filename=-4888d2648147f616 --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rlib --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libclap-48e1a20a69412286.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/src/main.rs` (exit status: 1)\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 35 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling utf8parse v0.2.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling heck v0.5.0\n   Compiling anyhow v1.0.100\n   Compiling same-file v1.0.6\n   Compiling walkdir v2.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling rust-system-composer v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu)\nerror: Option 'edition' given more than once\n\nerror: could not compile `rust-system-composer` (bin \"rust-system-composer\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name rust_system_composer --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=6ae7119ffad3e39b -C extra-filename=-4888d2648147f616 --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps --extern anyhow=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libanyhow-ee6ff1c48ee5df9a.rlib --extern clap=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libclap-48e1a20a69412286.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpjwd5uu/src/main.rs` (exit status: 1)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "mod prelude;\nmod args;\n\nfn main() {\n    println!(\"Hello from rust-system-composer!\");\n    // You can use items from prelude and args here, e.g.:\n    // let args = args::Args::parse();\n    // prelude::some_function();\n}",
    "timestamp": "2025-10-31T21:57:27.731356468Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/metrics-reporter/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 30 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling libc v0.2.177\n   Compiling serde_core v1.0.228\n   Compiling getrandom v0.3.4\n   Compiling rustix v1.1.2\n   Compiling serde_json v1.0.145\n   Compiling cfg-if v1.0.4\n   Compiling serde v1.0.228\n   Compiling bitflags v2.10.0\n   Compiling linux-raw-sys v0.11.0\n   Compiling once_cell v1.21.3\n   Compiling same-file v1.0.6\n   Compiling itoa v1.0.15\n   Compiling memchr v2.7.6\n   Compiling syn v2.0.108\n   Compiling ryu v1.0.20\n   Compiling fastrand v2.3.0\n   Compiling walkdir v2.5.0\n   Compiling lazy_static v1.5.0\n   Compiling tempfile v3.23.0\n   Compiling serde_derive v1.0.228\n   Compiling metrics-reporter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO)\nerror: Option 'edition' given more than once\n\nerror: could not compile `metrics-reporter` (bin \"metrics-reporter\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name metrics_reporter --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7d24d6f43289fefc -C extra-filename=-c141799cee6c5bef --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps --extern lazy_static=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/liblazy_static-cb92c169439ef4ae.rlib --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libquote-ecfbecd938122db1.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libserde-da43458380bcbbb2.rlib --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libserde_json-f500fd01bb978a8a.rlib --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libsyn-c80c23c48b50a3f5.rlib --extern tempfile=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libtempfile-05b1ca52e32dc17e.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/src/main.rs` (exit status: 1)\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 30 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling libc v0.2.177\n   Compiling serde_core v1.0.228\n   Compiling getrandom v0.3.4\n   Compiling rustix v1.1.2\n   Compiling serde_json v1.0.145\n   Compiling cfg-if v1.0.4\n   Compiling serde v1.0.228\n   Compiling bitflags v2.10.0\n   Compiling linux-raw-sys v0.11.0\n   Compiling once_cell v1.21.3\n   Compiling same-file v1.0.6\n   Compiling itoa v1.0.15\n   Compiling memchr v2.7.6\n   Compiling syn v2.0.108\n   Compiling ryu v1.0.20\n   Compiling fastrand v2.3.0\n   Compiling walkdir v2.5.0\n   Compiling lazy_static v1.5.0\n   Compiling tempfile v3.23.0\n   Compiling serde_derive v1.0.228\n   Compiling metrics-reporter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO)\nerror: Option 'edition' given more than once\n\nerror: could not compile `metrics-reporter` (bin \"metrics-reporter\")\n\nCaused by:\n  process didn't exit successfully: `rustc --crate-name metrics_reporter --edition=2024 src/main.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type bin --emit=dep-info,link -C embed-bitcode=no -C debuginfo=2 --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=7d24d6f43289fefc -C extra-filename=-c141799cee6c5bef --out-dir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps -C incremental=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/incremental -L dependency=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps --extern lazy_static=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/liblazy_static-cb92c169439ef4ae.rlib --extern quote=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libquote-ecfbecd938122db1.rlib --extern serde=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libserde-da43458380bcbbb2.rlib --extern serde_json=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libserde_json-f500fd01bb978a8a.rlib --extern syn=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libsyn-c80c23c48b50a3f5.rlib --extern tempfile=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libtempfile-05b1ca52e32dc17e.rlib --extern walkdir=/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/target/debug/deps/libwalkdir-f182331eb7ca4c76.rlib -Zunpretty=expanded --crate-type lib --edition 2021 --emit mir /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpOYfPfO/src/main.rs` (exit status: 1)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use std::{\n    env, fs, io,\n    path::{PathBuf},\n    process::{Command, Stdio},\n};\nuse tempfile::tempdir;\nuse syn;\nuse quote::ToTokens;\n\nfn main() -> io::Result<()> {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n        eprintln!(\"Usage: {} <wrapped_code_path> <rollup_data_dir>\", args[0]);\n        return Ok(())\n    }\n\n    let wrapped_code_path = PathBuf::from(&args[1]);\n    let rollup_data_dir = PathBuf::from(&args[2]);\n\n    if !wrapped_code_path.is_file() {\n        eprintln!(\"Error: Wrapped code file does not exist: {}\", wrapped_code_path.display());\n        return Ok(())\n    }\n    if !rollup_data_dir.is_dir() {\n        eprintln!(\"Error: Rollup data directory does not exist: {}\", rollup_data_dir.display());\n        return Ok(())\n    }\n\n    // 1. Create a temporary Rust project\n    let temp_dir = tempdir()?;\n    let temp_project_path = temp_dir.path().join(\"temp_rust_project\");\n    Command::new(\"cargo\")\n        .arg(\"new\")\n        .arg(\"--bin\")\n        .arg(&temp_project_path)\n        .stdout(Stdio::null())\n        .stderr(Stdio::null())\n        .status()?;\n\n    // 2. Copy measurement.rs into this temporary project's src directory\n    let temp_src_path = temp_project_path.join(\"src\");\n\n    // Assuming measurement.rs is in the same directory as wrapped_code.rs for now,\n    // or we need a way to locate it. For this PoC, let's assume it's provided.\n    // In a real scenario, measurement.rs would be a dependency or part of a common library.\n    // For now, we'll copy it from rust-decl-splitter's src.\n    let measurement_rs_path = PathBuf::from(\"/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/rust-decl-splitter/src/measurement.rs\");\n    fs::copy(&measurement_rs_path, temp_src_path.join(\"measurement.rs\"))?;\n\n    let _function_name = wrapped_code_path\n        .parent() // Get the parent directory (rollup_data)\n        .unwrap()\n        .parent() // Get the parent directory (my_function_one)\n        .unwrap()\n        .file_name() // Get the file name (my_function_one)\n        .unwrap()\n        .to_str()\n        .unwrap()\n        .to_string();\n\n    let temp_wrapped_code_file_name = wrapped_code_path.file_name().unwrap(); // This is \"wrapped_code.rs\"\n    let temp_wrapped_code_dest_path = temp_src_path.join(temp_wrapped_code_file_name);\n\n    fs::copy(\n        &wrapped_code_path,\n        &temp_wrapped_code_dest_path, // Copy to wrapped_code.rs\n    )?;\n\n    let mut wrapped_code_content = fs::read_to_string(&temp_wrapped_code_dest_path)?;\n    wrapped_code_content = wrapped_code_content.replace(\"use prelude::*;\", \"\"); // Remove use prelude::*;\n    wrapped_code_content = wrapped_code_content.replace(\"use crate::measurement;\", \"\"); // Remove use crate::measurement;\n    fs::write(&temp_wrapped_code_dest_path, wrapped_code_content.clone())?;\n\n    // 3. Modify Cargo.toml of the temporary project\n    let temp_cargo_toml_path = temp_project_path.join(\"Cargo.toml\");\n    let mut cargo_toml_content = fs::read_to_string(&temp_cargo_toml_path)?;\n    cargo_toml_content = cargo_toml_content.replace(\n        \"[dependencies]\",\n        \"[dependencies]\\nserde = { version = \\\"1.0\\\", features = [\\\"derive\\\"] }\\nserde_json = \\\"1.0\\\"\nlazy_static = \\\"1.4.0\\\"\",\n    );\n    fs::write(&temp_cargo_toml_path, cargo_toml_content)?;\n\n    // 4. Create a main.rs in the temporary project that calls the function and prints JSON metrics\n    let function_name = wrapped_code_path\n        .parent() // Get the parent directory (rollup_data)\n        .unwrap()\n        .parent() // Get the parent directory (my_function_one)\n        .unwrap()\n        .file_name() // Get the file name (my_function_one)\n        .unwrap()\n        .to_str()\n        .unwrap()\n        .to_string();\n\n    let temp_main_rs_content = format!(\n        r#\"\nmod measurement; // Re-add mod measurement;\n{} // Directly include the wrapped_code content here\n\nfn main() {{\n    let result = {}(); // Call the function directly with no arguments\n    println!(\"Function call result: {{}}\", result);\n\n    let collected_metrics = measurement::get_collected_metrics();\n    let json_metrics = serde_json::to_string_pretty(&collected_metrics).expect(\"Failed to serialize metrics to JSON\");\n    println!(\"--- METRICS_START ---\\n{{}}\\n--- METRICS_END ---\", json_metrics);\n}}\n\"#,\n        wrapped_code_content, // Use the content that was already read and modified\n        function_name\n    );\n    fs::write(temp_src_path.join(\"main.rs\"), temp_main_rs_content)?;\n\n    // 5. Build and run this temporary project\n    let output = Command::new(\"cargo\")\n        .arg(\"run\")\n        .current_dir(&temp_project_path)\n        .stdout(Stdio::piped())\n        .stderr(Stdio::piped())\n        .output()?;\n\n    if !output.status.success() {\n        eprintln!(\n            \"Error running temporary project:\\nStdout: {}\\nStderr: {}\",\n            String::from_utf8_lossy(&output.stdout),\n            String::from_utf8_lossy(&output.stderr)\n        );\n        return Ok(())\n    }\n\n    let stdout = String::from_utf8_lossy(&output.stdout);\n    // 6. Capture the stdout, extract JSON metrics, and save to rollup_report.md\n    let metrics_start_tag = \"--- METRICS_START ---\";\n    let metrics_end_tag = \"--- METRICS_END ---\";\n\n    let mut rollup_report_content = String::new();\n    rollup_report_content.push_str(&format!(\"# Rollup Report for Function: {}\\n\\n\", function_name));\n    rollup_report_content.push_str(&format!(\"## Original Code (`{}`):\\n\", wrapped_code_path.display()));\n    rollup_report_content.push_str(\"```rust\\n\");\n    rollup_report_content.push_str(&wrapped_code_content); // Use the cleaned wrapped_code_content\n    rollup_report_content.push_str(\"\\n```\\n\\n\");\n\n    // Calculate line count\n    let line_count = wrapped_code_content.lines().count();\n    rollup_report_content.push_str(\"## Code Metrics:\\n\");\n    rollup_report_content.push_str(&format!(\"*   **Line Count:** {}\\n\\n\", line_count));\n\n    // Placeholder for Use Statement Analysis\n    let mut total_use_statements = 0;\n    let mut std_uses = 0;\n    let mut crate_uses = 0;\n    let mut external_uses = 0;\n\n    match syn::parse_file(&wrapped_code_content) {\n        Ok(ast) => {\n            for item in ast.items {\n                if let syn::Item::Use(use_item) = item {\n                    total_use_statements += 1;\n                    let use_path = use_item.tree.to_token_stream().to_string();\n                    if use_path.starts_with(\"std::\") {\n                        std_uses += 1;\n                    } else if use_path.starts_with(\"crate::\") {\n                        crate_uses += 1;\n                    } else {\n                        external_uses += 1;\n                    }\n                }\n            }\n        }\n        Err(e) => {\n            // Handle parsing error, maybe log it or include in the report\n            eprintln!(\"Error parsing wrapped code for use statement analysis: {}\", e);\n        }\n    }\n\n    rollup_report_content.push_str(\"## Use Statement Analysis:\\n\");\n    rollup_report_content.push_str(&format!(\"*   **Total Use Statements Processed:** {}\\n\", total_use_statements));\n    rollup_report_content.push_str(\"*   **Types of Use Statements:**\\n\");\n    rollup_report_content.push_str(&format!(\"    *   `std::`: {}\\n\", std_uses));\n    rollup_report_content.push_str(&format!(\"    *   `crate::`: {}\\n\", crate_uses));\n    rollup_report_content.push_str(&format!(\"    *   External Crates: {}\\n\\n\", external_uses));\n\n    if let Some(start_index) = stdout.find(metrics_start_tag) {\n        if let Some(end_index) = stdout.find(metrics_end_tag) {\n            let json_str = &stdout[start_index + metrics_start_tag.len()..end_index].trim();\n            rollup_report_content.push_str(\"## Performance Metrics:\\n\");\n            rollup_report_content.push_str(\"```json\\n\");\n            rollup_report_content.push_str(json_str);\n            rollup_report_content.push_str(\"\\n```\\n\");\n        }\n    }\n\n    fs::write(rollup_data_dir.join(\"rollup_report.md\"), rollup_report_content)?;\n    println!(\"Successfully generated rollup_report.md for {}\", wrapped_code_path.display());\n\n    Ok(())\n}",
    "timestamp": "2025-10-31T21:57:44.928086930Z",
    "context": null
  }
]