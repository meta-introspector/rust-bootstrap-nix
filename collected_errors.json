[
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/configuration-nix/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 30 packages to latest compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling utf8parse v0.2.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle v1.0.13\n   Compiling anstyle-query v1.1.4\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling heck v0.5.0\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling configuration-nix v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpPBK1Nj)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:2:1\n  |\n2 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_generator`\n --> src/main.rs:4:1\n  |\n4 | mod config_generator;\n  | ^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_generator`, create file \"src/config_generator.rs\" or \"src/config_generator/mod.rs\"\n  = note: if there is a `mod config_generator` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_params`\n --> src/main.rs:5:1\n  |\n5 | mod config_params;\n  | ^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_params`, create file \"src/config_params.rs\" or \"src/config_params/mod.rs\"\n  = note: if there is a `mod config_params` elsewhere in the crate already, import it with `use crate::...` instead\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:1:5\n  |\n1 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0583`.\nwarning: `configuration-nix` (bin \"configuration-nix\") generated 1 warning\nerror: could not compile `configuration-nix` (bin \"configuration-nix\") due to 3 previous errors; 1 warning emitted\n\nStdout: #![feature(prelude_import)]\n#[macro_use]\nextern crate std;\n#[prelude_import]\nuse std::prelude::rust_2021::*;\nuse crate::prelude::*;\npub mod prelude {}\n//mod prelude;\nmod config_generator {}\nmod config_params {}\nfn main() {\n    let params = config_params::ConfigParams::parse();\n    config_generator::generate_config_toml(&params);\n}\n\nStderr:     Updating crates.io index\n     Locking 30 packages to latest compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling utf8parse v0.2.2\n   Compiling colorchoice v1.0.4\n   Compiling anstyle v1.0.13\n   Compiling anstyle-query v1.1.4\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling heck v0.5.0\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling configuration-nix v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpPBK1Nj)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:2:1\n  |\n2 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_generator`\n --> src/main.rs:4:1\n  |\n4 | mod config_generator;\n  | ^^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_generator`, create file \"src/config_generator.rs\" or \"src/config_generator/mod.rs\"\n  = note: if there is a `mod config_generator` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_params`\n --> src/main.rs:5:1\n  |\n5 | mod config_params;\n  | ^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_params`, create file \"src/config_params.rs\" or \"src/config_params/mod.rs\"\n  = note: if there is a `mod config_params` elsewhere in the crate already, import it with `use crate::...` instead\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:1:5\n  |\n1 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nFor more information about this error, try `rustc --explain E0583`.\nwarning: `configuration-nix` (bin \"configuration-nix\") generated 1 warning\nerror: could not compile `configuration-nix` (bin \"configuration-nix\") due to 3 previous errors; 1 warning emitted\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use crate::prelude::*;\npub mod prelude;\n//mod prelude;\nmod config_generator;\nmod config_params;\nfn main() {\n    let params = config_params::ConfigParams::parse();\n    config_generator::generate_config_toml(&params);\n}\n",
    "timestamp": "2025-10-31T22:10:57.391896524Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "\npub mod prelude;\n\npub mod utils; // Declare the utils module as public\npub mod preconditions; // Declare the preconditions module\n\npub mod args; // Declare the args module\npub mod config; // Declare the config module\n",
    "timestamp": "2025-10-31T22:10:59.993820898Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/bootstrap-config-generator.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\nfn main() -> Result<()> {\n    env_logger::init();\n    let args = Args::parse();\n    debug!(\"Raw CLI Arguments: {:?}\\n\", args);\n    let mut app_config = if let Some(config_file_path) = &args.config_file {\n        info!(\"Loading configuration from file: {:?}\\n\", config_file_path);\n        let config_content = fs::read_to_string(config_file_path)\n            .context(format!(\"Failed to read config file: {:?}\\n\", config_file_path))?;\n        toml::from_str(&config_content)\n            .context(format!(\"Failed to parse config file: {:?}\\n\", config_file_path))?\n    } else {\n        AppConfig::default()\n    };\n    app_config.merge_with_args(&args);\n    info!(\"Final merged configuration: {:?}\\n\", app_config);\n    if let Some(build_rustc_version) = app_config.build_rustc_version.clone() {\n        info!(\n            \"Lattice generation mode enabled for rustc version: {}\\n\",\n            build_rustc_version\n        );\n        let solana_rustc_path = app_config\n            .solana_rustc_path\n            .as_ref()\n            .context(\"solana_rustc_path is required for lattice generation\")?\n            .to_str()\n            .context(\"solana_rustc_path contains non-UTF8 characters\")?;\n        let cargo_path = app_config\n            .cargo_path\n            .as_ref()\n            .context(\"cargo_path is required for lattice generation\")?\n            .to_str()\n            .context(\"cargo_path contains non-UTF8 characters\")?;\n        let project_root = app_config\n            .project_root\n            .as_ref()\n            .context(\"project_root is required for lattice generation\")?\n            .to_str()\n            .context(\"project_root contains non-UTF8 characters\")?;\n        let rust_src_flake_path = app_config\n            .rust_src_flake_path\n            .as_ref()\n            .context(\"rust_src_flake_path is required for lattice generation\")?\n            .to_str()\n            .context(\"rust_src_flake_path contains non-UTF8 characters\")?;\n        let architecture = app_config.architecture.as_deref().unwrap_or(\"aarch64-linux\");\n        let stage = app_config.stage.as_deref().unwrap_or(\"stage0\");\n        let step = app_config.step.as_deref().unwrap_or(\"step1-configure\");\n        let resolved_build_rustc_path = find_nix_package_store_path(\n                \"rustc\",\n                Some(&build_rustc_version),\n            )?\n            .context(\n                format!(\"Could not find rustc path for version {}\", build_rustc_version),\n            )?;\n        let output_dir = PathBuf::from(\n            format!(\"flakes/{}/{}/{}/{}\", build_rustc_version, architecture, stage, step),\n        );\n        fs::create_dir_all(&output_dir)\n            .context(format!(\"Failed to create output directory: {:?}\", output_dir))?;\n        let flake_nix_path = output_dir.join(\"flake.nix\");\n        let flake_nix_content = format!(\n            r#\"{{\n  description = \"Test flake for rustc {}\";\n\n  inputs = {{\n    nixpkgs.url = \"github:meta-introspector/nixpkgs?ref=feature/CRQ-016-nixify\";\n  }};\n\n  outputs = {{ self, nixpkgs }}:\n    let\n      pkgs = import nixpkgs {{\n        system = \"{}\";\n      }};\n      rustcPath = \"{}\"; # This is the *source* rustc used to build the next stage\n    in\n    {{\n      devShells.{}.default = pkgs.mkShell {{\n        buildInputs = [\n          pkgs.cargo\n        ];\n        RUSTC = rustcPath;\n      }};\n    }};\n}}\"#,\n            build_rustc_version, architecture, solana_rustc_path, architecture\n        );\n        fs::write(&flake_nix_path, flake_nix_content)\n            .context(format!(\"Failed to write flake.nix to {:?}\\n\", flake_nix_path))?;\n        info!(\n            \"Generated flake.nix for rustc {} at {:?}\\n\", build_rustc_version,\n            flake_nix_path\n        );\n        let config_toml_path = output_dir\n            .join(format!(\"generated_config_{}.toml\", build_rustc_version));\n        let config_content = construct_config_content(\n            architecture,\n            project_root,\n            app_config\n                .nixpkgs_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_overlay_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_bootstrap_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .configuration_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            rust_src_flake_path,\n            stage,\n            app_config.target.as_deref().unwrap_or_default(),\n            app_config.rust_bootstrap_nix_flake_ref.as_deref().unwrap_or_default(),\n            app_config.rust_src_flake_ref.as_deref().unwrap_or_default(),\n            &resolved_build_rustc_path,\n            cargo_path,\n            app_config.rust_channel.as_deref().unwrap_or(\"stable\"),\n            app_config.rust_download_rustc.unwrap_or(false),\n            app_config.rust_parallel_compiler.unwrap_or(false),\n            app_config.rust_llvm_tools.unwrap_or(false),\n            app_config.rust_debuginfo_level.unwrap_or(0),\n            app_config.patch_binaries_for_nix.unwrap_or(false),\n            app_config.vendor.unwrap_or(false),\n            app_config\n                .build_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.build_jobs.unwrap_or(0),\n            app_config\n                .home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_prefix\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_sysconfdir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .dist_sign_folder\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.dist_upload_addr.as_deref().unwrap_or_default(),\n            app_config.llvm_download_ci_llvm.unwrap_or(false),\n            app_config.llvm_ninja.unwrap_or(false),\n            app_config.change_id.as_deref().unwrap_or_default(),\n        );\n        fs::write(&config_toml_path, config_content)\n            .context(\n                format!(\"Failed to write config.toml to {:?}\\n\", config_toml_path),\n            )?;\n        info!(\n            \"Generated config.toml for rustc {} at {:?}\\n\", build_rustc_version,\n            config_toml_path\n        );\n    } else {\n        info!(\n            \"Starting config generation for stage {:?} and target {:?}\\n\", app_config\n            .stage, app_config.target\n        );\n        info!(\"Running precondition checks...\\n\");\n        preconditions::check_nix_command_available()?;\n        info!(\"Nix command available.\\n\");\n        info!(\"Validating project root: {:?}\\n\", app_config.project_root);\n        let project_root = validate_project_root(\n            app_config.project_root.as_ref().context(\"Project root is required\")?,\n        )?;\n        let flake_path_str = project_root\n            .to_str()\n            .context(\"Project root path contains non-UTF8 characters\")?;\n        info!(\"Project root validated: {}\\n\", flake_path_str);\n        let rust_src_flake_path_lossy = app_config\n            .rust_src_flake_path\n            .as_ref()\n            .map(|p| p.to_string_lossy().to_string())\n            .unwrap_or_default();\n        debug!(\"rust_src_flake_path: {:?}\\n\", rust_src_flake_path_lossy);\n        preconditions::check_rust_toolchain_sysroot(&rust_src_flake_path_lossy)?;\n        info!(\"Rust toolchain sysroot check passed.\\n\");\n        info!(\"Constructing config.toml content...\\n\");\n        let config_content = construct_config_content(\n            app_config.system.as_deref().unwrap_or_default(),\n            flake_path_str,\n            app_config\n                .nixpkgs_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_overlay_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_bootstrap_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .configuration_nix_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .rust_src_flake_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.stage.as_deref().unwrap_or_default(),\n            app_config.target.as_deref().unwrap_or_default(),\n            app_config.rust_bootstrap_nix_flake_ref.as_deref().unwrap_or_default(),\n            app_config.rust_src_flake_ref.as_deref().unwrap_or_default(),\n            app_config\n                .rustc_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_path\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.rust_channel.as_deref().unwrap_or(\"stable\"),\n            app_config.rust_download_rustc.unwrap_or(false),\n            app_config.rust_parallel_compiler.unwrap_or(false),\n            app_config.rust_llvm_tools.unwrap_or(false),\n            app_config.rust_debuginfo_level.unwrap_or(0),\n            app_config.patch_binaries_for_nix.unwrap_or(false),\n            app_config.vendor.unwrap_or(false),\n            app_config\n                .build_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.build_jobs.unwrap_or(0),\n            app_config\n                .home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .cargo_home_dir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_prefix\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .install_sysconfdir\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config\n                .dist_sign_folder\n                .as_deref()\n                .map(|p| p.to_str().unwrap_or_default())\n                .unwrap_or_default(),\n            app_config.dist_upload_addr.as_deref().unwrap_or_default(),\n            app_config.llvm_download_ci_llvm.unwrap_or(false),\n            app_config.llvm_ninja.unwrap_or(false),\n            app_config.change_id.as_deref().unwrap_or_default(),\n        );\n        debug!(\"Generated config content:\\n{}\\n\", config_content);\n        if app_config.dry_run.unwrap_or(false) {\n            info!(\"Dry run enabled. Generated config will be printed to stdout.\\n\");\n            println!(\"{}\", config_content);\n        } else {\n            let output_path = app_config.output.unwrap_or_else(|| \"config.toml\".into());\n            info!(\"Writing generated config to file: {:?}\\n\", output_path);\n            fs::write(&output_path, config_content)\n                .context(\n                    format!(\"Failed to write config to file: {:?}\\n\", output_path),\n                )?;\n            info!(\"Config successfully written to {:?}\\n\", output_path);\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:11:01.963096209Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/flake-step-manager.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\n#[derive(Parser, Debug)]\n#[clap(author, version, about, long_about = None)]\nstruct Args {\n    #[clap(long)]\n    rust_version: String,\n    #[clap(long)]\n    arch: String,\n    #[clap(long)]\n    phase: String,\n    #[clap(long)]\n    step: String,\n}\nfn main() -> Result<()> {\n    let args = Args::parse();\n    println!(\"Parsed arguments:\");\n    println!(\"  Rust Version: {}\", args.rust_version);\n    println!(\"  Architecture: {}\", args.arch);\n    println!(\"  Phase: {}\", args.phase);\n    println!(\"  Step: {}\", args.step);\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:11:04.340988448Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/bootstrap-config-builder/src/bin/nix-dir.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n\nStdout: \nStderr:     Updating crates.io index\n     Locking 112 packages to latest compatible versions\n      Adding git2 v0.18.3 (available: v0.20.2)\n      Adding toml v0.8.23 (available: v0.9.8)\n      Adding toml_edit v0.22.27 (available: v0.23.7)\nerror: extra arguments to `rustc` can only be passed to one target, consider filtering\nthe package by passing, e.g., `--lib` or `--bin NAME` to specify a single target\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "//use crate::prelude::*;\nuse bootstrap_config_builder::prelude::*;\n\n#[derive(Debug, Deserialize)]\nstruct Config {\n    #[serde(default)]\n    nix_packages: HashMap<String, String>,\n}\n/// A tool to inspect Nix flakes and their attributes.\n#[derive(Parser, Debug)]\n#[command(version, about, long_about = None)]\nstruct Args {\n    /// The flake reference to inspect (e.g., \"nixpkgs\", \"github:NixOS/nixpkgs/nixos-23.11\")\n    #[arg()]\n    flake_ref: Option<String>,\n    /// Output raw JSON from 'nix flake show' command.\n    #[arg(long, default_value_t = false)]\n    json: bool,\n    /// Path to the config.toml file to read for Nix package information.\n    #[arg(long, default_value = \"config.toml\")]\n    config_file: String,\n    /// List all rustc versions found in the Nix store.\n    #[arg(long, default_value_t = false)]\n    list_rustc_versions: bool,\n}\nfn main() -> Result<()> {\n    env_logger::init();\n    let args = Args::parse();\n    info!(\"Reading config file: {}\", args.config_file);\n    let config_content = fs::read_to_string(&args.config_file)\n        .with_context(|| format!(\"Failed to read config file: {}\", args.config_file))?;\n    let config = Some(\n        toml::from_str::<Config>(&config_content)\n            .with_context(|| {\n                format!(\"Failed to parse config file: {}\", args.config_file)\n            })?,\n    );\n    if let Some(c) = &config {\n        debug!(\"Parsed config: {:?}\", c);\n    }\n    if args.list_rustc_versions {\n        info!(\"Listing all rustc versions in Nix store.\");\n        let rustc_versions = get_all_rustc_paths_from_nix_store()?;\n        if rustc_versions.is_empty() {\n            println!(\"No rustc versions found in the Nix store.\");\n        } else {\n            println!(\"Found rustc versions:\");\n            for (path, version) in rustc_versions {\n                println!(\"  - Version: {}, Path: {}\", version, path);\n            }\n        }\n        return Ok(());\n    }\n    if let Some(flake_ref) = args.flake_ref {\n        info!(\"Inspecting Nix flake: {}\", flake_ref);\n        let mut command = Command::new(\"nix\");\n        command.args(&[\"flake\", \"show\", \"--json\", &flake_ref]);\n        debug!(\"Executing Nix command: {:?}\", command);\n        let output = command\n            .output()\n            .with_context(|| {\n                format!(\"Failed to execute nix flake show for '{}'\", flake_ref)\n            })?;\n        if !output.status.success() {\n            anyhow::bail!(\n                \"Nix command failed for flake show '{}':\\n{}\\nStderr: {}\", flake_ref,\n                String::from_utf8_lossy(& output.stdout), String::from_utf8_lossy(&\n                output.stderr)\n            );\n        }\n        let json_output: Value = serde_json::from_slice(&output.stdout)\n            .with_context(|| \"Failed to parse nix flake show JSON output\")?;\n        if args.json {\n            println!(\"{}\", serde_json::to_string_pretty(& json_output) ?);\n        } else {\n            println!(\"Flake Attributes for {}:\", flake_ref);\n            if let Some(inputs) = json_output.get(\"inputs\") {\n                println!(\"\\nInputs:\");\n                if let Some(inputs_obj) = inputs.as_object() {\n                    for (key, _) in inputs_obj {\n                        println!(\"  - {}\", key);\n                    }\n                }\n            }\n            if let Some(outputs) = json_output.get(\"outputs\") {\n                println!(\"\\nOutputs:\");\n                if let Some(outputs_obj) = outputs.as_object() {\n                    for (system, system_outputs) in outputs_obj {\n                        println!(\"  {}:\", system);\n                        if let Some(system_outputs_obj) = system_outputs.as_object() {\n                            for (key, value) in system_outputs_obj {\n                                let output_type = value\n                                    .get(\"type\")\n                                    .and_then(|t| t.as_str())\n                                    .unwrap_or(\"unknown\");\n                                println!(\"    - {}: {}\", key, output_type);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if let Some(c) = &config {\n        println!(\"\\nNix Packages from config.toml:\");\n        for (pkg_name, pkg_version) in &c.nix_packages {\n            match find_nix_package_store_path(\n                pkg_name.as_str(),\n                Some(pkg_version.as_str()),\n            ) {\n                Ok(Some(path)) => println!(\"  - {}: {}\", pkg_name, path),\n                Ok(None) => {\n                    println!(\n                        \"  - {}: Not found in store (version: {})\", pkg_name, pkg_version\n                    )\n                }\n                Err(e) => eprintln!(\"  - Error finding {}: {}\", pkg_name, e),\n            }\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:11:06.102700062Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/flake-template-generator/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 43 packages to latest compatible versions\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling utf8parse v0.2.2\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling equivalent v1.0.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle-parse v0.2.7\n   Compiling anstyle v1.0.13\n   Compiling hashbrown v0.16.0\n   Compiling colorchoice v1.0.4\n   Compiling anstream v0.6.21\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling indexmap v2.12.0\n   Compiling winnow v0.7.13\n   Compiling toml_write v0.1.2\n   Compiling heck v0.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling flake-template-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp7i5Vpe)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:2:1\n  |\n2 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `args`\n --> src/main.rs:7:1\n  |\n7 | mod args;\n  | ^^^^^^^^^\n  |\n  = help: to create the module `args`, create file \"src/args.rs\" or \"src/args/mod.rs\"\n  = note: if there is a `mod args` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_parser`\n --> src/main.rs:8:1\n  |\n8 | mod config_parser;\n  | ^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_parser`, create file \"src/config_parser.rs\" or \"src/config_parser/mod.rs\"\n  = note: if there is a `mod config_parser` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `flake_generator`\n --> src/main.rs:9:1\n  |\n9 | mod flake_generator;\n  | ^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `flake_generator`, create file \"src/flake_generator.rs\" or \"src/flake_generator/mod.rs\"\n  = note: if there is a `mod flake_generator` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `file_writer`\n  --> src/main.rs:10:1\n   |\n10 | mod file_writer;\n   | ^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `file_writer`, create file \"src/file_writer.rs\" or \"src/file_writer/mod.rs\"\n   = note: if there is a `mod file_writer` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `statix_checker`\n  --> src/main.rs:11:1\n   |\n11 | mod statix_checker;\n   | ^^^^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `statix_checker`, create file \"src/statix_checker.rs\" or \"src/statix_checker/mod.rs\"\n   = note: if there is a `mod statix_checker` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:17:21\n   |\n17 |     let repo_root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n   |                     ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 1 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:22:5\n   |\n22 |     fs::create_dir_all(&absolute_output_dir)?;\n   |     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 1 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:31:26\n   |\n31 |     let config_content = fs::read_to_string(&args.config_path)?;\n   |                          ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 1 + use std::fs;\n   |\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:1:5\n  |\n1 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nSome errors have detailed explanations: E0433, E0583.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `flake-template-generator` (bin \"flake-template-generator\") generated 1 warning\nerror: could not compile `flake-template-generator` (bin \"flake-template-generator\") due to 9 previous errors; 1 warning emitted\n\nStdout: #![feature(prelude_import)]\n#[macro_use]\nextern crate std;\n#[prelude_import]\nuse std::prelude::rust_2021::*;\nuse crate::prelude::*;\npub mod prelude {}\nuse crate::config_parser::parse_config;\nuse crate::file_writer::write_flake_and_config;\nuse crate::statix_checker::run_statix_check;\n//mod prelude;\nmod args {}\nmod config_parser {}\nmod flake_generator {}\nmod file_writer {}\nmod statix_checker {}\npub use args::Args;\npub use serde::{Deserialize, Serialize};\nuse crate::flake_generator::generate_flake_nix_content;\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = Args::parse();\n    let repo_root =\n        PathBuf::from(\"/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp7i5Vpe\").parent().unwrap().to_path_buf();\n    let absolute_output_dir = repo_root.join(&args.output_dir);\n    fs::create_dir_all(&absolute_output_dir)?;\n    let config = parse_config(&args.config_path)?;\n    let nixpkgs_url =\n        if config.nix.nixpkgs_path.is_empty() {\n            \"github:meta-introspector/nixpkgs?ref=feature/CRQ-016-nixify\".to_string()\n        } else { config.nix.nixpkgs_path };\n    let system_arch = \"aarch64-linux\";\n    let flake_nix_content =\n        generate_flake_nix_content(&nixpkgs_url, &system_arch);\n    let config_content = fs::read_to_string(&args.config_path)?;\n    write_flake_and_config(&absolute_output_dir, &flake_nix_content,\n            &config_content)?;\n    let output_flake_nix_path = absolute_output_dir.join(\"flake.nix\");\n    run_statix_check(&absolute_output_dir, &output_flake_nix_path)?;\n    Ok(())\n}\n\nStderr:     Updating crates.io index\n     Locking 43 packages to latest compatible versions\n      Adding toml v0.8.23 (available: v0.9.8)\n   Compiling proc-macro2 v1.0.103\n   Compiling unicode-ident v1.0.22\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling utf8parse v0.2.2\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling equivalent v1.0.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle-parse v0.2.7\n   Compiling anstyle v1.0.13\n   Compiling hashbrown v0.16.0\n   Compiling colorchoice v1.0.4\n   Compiling anstream v0.6.21\n   Compiling strsim v0.11.1\n   Compiling clap_lex v0.7.6\n   Compiling indexmap v2.12.0\n   Compiling winnow v0.7.13\n   Compiling toml_write v0.1.2\n   Compiling heck v0.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling toml_datetime v0.6.11\n   Compiling serde_spanned v0.6.9\n   Compiling toml_edit v0.22.27\n   Compiling toml v0.8.23\n   Compiling flake-template-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmp7i5Vpe)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:2:1\n  |\n2 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `args`\n --> src/main.rs:7:1\n  |\n7 | mod args;\n  | ^^^^^^^^^\n  |\n  = help: to create the module `args`, create file \"src/args.rs\" or \"src/args/mod.rs\"\n  = note: if there is a `mod args` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `config_parser`\n --> src/main.rs:8:1\n  |\n8 | mod config_parser;\n  | ^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `config_parser`, create file \"src/config_parser.rs\" or \"src/config_parser/mod.rs\"\n  = note: if there is a `mod config_parser` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `flake_generator`\n --> src/main.rs:9:1\n  |\n9 | mod flake_generator;\n  | ^^^^^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `flake_generator`, create file \"src/flake_generator.rs\" or \"src/flake_generator/mod.rs\"\n  = note: if there is a `mod flake_generator` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `file_writer`\n  --> src/main.rs:10:1\n   |\n10 | mod file_writer;\n   | ^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `file_writer`, create file \"src/file_writer.rs\" or \"src/file_writer/mod.rs\"\n   = note: if there is a `mod file_writer` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `statix_checker`\n  --> src/main.rs:11:1\n   |\n11 | mod statix_checker;\n   | ^^^^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `statix_checker`, create file \"src/statix_checker.rs\" or \"src/statix_checker/mod.rs\"\n   = note: if there is a `mod statix_checker` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:17:21\n   |\n17 |     let repo_root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n   |                     ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 1 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:22:5\n   |\n22 |     fs::create_dir_all(&absolute_output_dir)?;\n   |     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 1 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:31:26\n   |\n31 |     let config_content = fs::read_to_string(&args.config_path)?;\n   |                          ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 1 + use std::fs;\n   |\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:1:5\n  |\n1 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nSome errors have detailed explanations: E0433, E0583.\nFor more information about an error, try `rustc --explain E0433`.\nwarning: `flake-template-generator` (bin \"flake-template-generator\") generated 1 warning\nerror: could not compile `flake-template-generator` (bin \"flake-template-generator\") due to 9 previous errors; 1 warning emitted\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use crate::prelude::*;\npub mod prelude;\nuse crate::config_parser::parse_config;\nuse crate::file_writer::write_flake_and_config;\nuse crate::statix_checker::run_statix_check;\n//mod prelude;\nmod args;\nmod config_parser;\nmod flake_generator;\nmod file_writer;\nmod statix_checker;\npub use args :: Args ;\npub use serde :: { Deserialize , Serialize } ;\nuse crate::flake_generator::generate_flake_nix_content;\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let args = Args::parse();\n    let repo_root = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"))\n        .parent()\n        .unwrap()\n        .to_path_buf();\n    let absolute_output_dir = repo_root.join(&args.output_dir);\n    fs::create_dir_all(&absolute_output_dir)?;\n    let config = parse_config(&args.config_path)?;\n    let nixpkgs_url = if config.nix.nixpkgs_path.is_empty() {\n        \"github:meta-introspector/nixpkgs?ref=feature/CRQ-016-nixify\".to_string()\n    } else {\n        config.nix.nixpkgs_path\n    };\n    let system_arch = \"aarch64-linux\";\n    let flake_nix_content = generate_flake_nix_content(&nixpkgs_url, &system_arch);\n    let config_content = fs::read_to_string(&args.config_path)?;\n    write_flake_and_config(&absolute_output_dir, &flake_nix_content, &config_content)?;\n    let output_flake_nix_path = absolute_output_dir.join(\"flake.nix\");\n    run_statix_check(&absolute_output_dir, &output_flake_nix_path)?;\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:11:26.732394898Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/prelude-generator/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpX4Tr7z)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpX4Tr7z)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "pub mod args;\npub mod report;\npub mod generate_prelude;\npub mod modify_file;\npub mod modify_crate_root;\npub mod processor;\npub mod test_extractor;\npub mod pipeline;\npub mod use_extractor;\npub mod prelude_category_pipeline;\npub mod code_generator;\npub mod measurement;\npub mod parser;\npub mod decls_visitor;\npub mod bag_of_words_visitor;\npub mod config_parser;\npub mod cli;\npub mod use_statements;\npub mod utils;\npub mod error_handling;\npub mod error_collector;\npub mod declaration;\npub mod gem_parser;\npub mod ast_stats;\npub mod constant_storage;\npub mod declaration_processing;\npub mod command_handlers;\npub mod type_extractor;\n//pub mod global_level0_decls;\npub use args::Args;\n//pub use declaration_processing::{extract_level0_declarations, process_structs};\npub use report::generate_report;\npub use generate_prelude::generate_prelude;\npub use modify_file::modify_file;\npub use modify_crate_root::modify_crate_root;\npub use processor::process_crates;\npub use test_extractor::{collect_all_test_cases, generate_test_report_json, generate_test_verification_script_and_report, TestInfo};\npub use pipeline_traits::{AstStatistics, VariableInfo, FunctionInfo, ImportInfo};\npub use ast_decoder::AstTraversalFunctor;\n\npub use bag_of_words_visitor::{BagOfWordsVisitor, tokenize_ident_to_subwords};\n\n// Re-export necessary types from prelude_collector\npub use prelude_collector::{FileProcessingResult, FileProcessingStatus};\n",
    "timestamp": "2025-10-31T22:11:27.873367554Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/prelude-generator/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpkhR7ED)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `ast-decoder` as a dependency of package `prelude-generator v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpkhR7ED)`\n\nCaused by:\n  failed to load source for dependency `ast-decoder`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/ast-decoder/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use prelude_generator::command_handlers;\nuse std::path::PathBuf;\nuse syn;\nuse tokio;\nuse prelude_generator::use_extractor::get_rustc_info;\n\n#[tokio::main]\nasync fn main() -> anyhow::Result<()> {\n    let (args, config) = prelude_generator::cli::parse_arguments_and_config()?;\n\n    let project_root = if args.path == PathBuf::from(\".\") {\n        std::env::current_dir()?.parent().unwrap().to_path_buf()\n    } else {\n        args.path.clone()\n    };\n\n    let rustc_info = get_rustc_info()?;\n    let cache_dir = project_root.join(\".prelude_cache\");\n    tokio::fs::create_dir_all(&cache_dir).await?;\n\n    let mut all_numerical_constants: Vec<syn::ItemConst> = Vec::new();\n    let mut all_string_constants: Vec<syn::ItemConst> = Vec::new();\n\n    if args.analyze_ast {\n        crate::command_handlers::handle_analyze_ast(&args)?;\n        return Ok(()); // Exit after AST analysis if requested\n    }\n\n    if args.generate_test_report {\n        crate::command_handlers::handle_generate_test_report(&args)?;\n    }\n\n    if args.compile_tests {\n        crate::command_handlers::handle_compile_tests(&args)?;\n    }\n\n    if args.extract_use_statements {\n        crate::command_handlers::handle_extract_use_statements(&args)?;\n    }\n\n    if args.collect_and_process_use_statements {\n        crate::command_handlers::handle_collect_and_process_use_statements();\n    }\n\n    if args.generate_aggregated_test_file {\n        crate::command_handlers::handle_generate_aggregated_test_file();\n    }\n\n    if args.run_pipeline {\n        crate::command_handlers::handle_run_pipeline(&args, config.as_ref().unwrap()).await?;\n    }\n\n    if args.verify_config {\n        crate::command_handlers::handle_verify_config();\n    }\n\n    if args.extract_global_level0_decls {\n        crate::command_handlers::handle_extract_global_level0_decls(\n            &project_root,\n            &args,\n            &mut all_numerical_constants,\n            &mut all_string_constants,\n            &rustc_info,\n            &cache_dir,\n        ).await?;\n    }\n\n    // Process numerical constants\n    if args.extract_numerical_constants {\n        crate::command_handlers::handle_extract_numerical_constants(&project_root, &args, &all_numerical_constants).await?;\n    }\n\n    // Process string constants\n    if args.extract_string_constants {\n        crate::command_handlers::handle_extract_string_constants(&project_root, &args, &all_string_constants).await?;\n    }\n\n    if args.analyze_bag_of_words {\n        crate::command_handlers::handle_analyze_bag_of_words(&project_root, &args)?;\n    }\n\n    if args.calculate_layers {\n        crate::command_handlers::handle_calculate_layers(&project_root, &args).await?;\n    }\n\n    // If no specific command was executed, print help or a default message\n    if !args.analyze_ast && !args.generate_test_report && !args.compile_tests && !args.extract_use_statements && !args.collect_and_process_use_statements && !args.generate_aggregated_test_file && !args.run_pipeline && !args.verify_config && !args.extract_global_level0_decls && !args.analyze_bag_of_words && !args.extract_numerical_constants && !args.extract_string_constants && !args.calculate_layers {\n        println!(r\"No specific command executed. Use --help for options.\");\n    }\n\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:11:28.538709064Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/ast-decoder/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\nerror: failed to get `pipeline-traits` as a dependency of package `ast-decoder v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpiy5Zyc)`\n\nCaused by:\n  failed to load source for dependency `pipeline-traits`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n\nStdout: \nStderr:     Updating crates.io index\nerror: failed to get `pipeline-traits` as a dependency of package `ast-decoder v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpiy5Zyc)`\n\nCaused by:\n  failed to load source for dependency `pipeline-traits`\n\nCaused by:\n  Unable to update /data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits\n\nCaused by:\n  failed to read `/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/pipeline-traits/Cargo.toml`\n\nCaused by:\n  No such file or directory (os error 2)\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use anyhow::{Context, Result};\nuse std::path::PathBuf;\nuse std::pin::Pin;\nuse std::future::Future;\n\nuse syn::{self, visit::{self, Visit}, Item, Visibility};\nuse quote::quote;\n\n// Removed: use crate::measurement; as it's no longer in the same crate\nuse pipeline_traits::{PipelineFunctor, ParsedFile};\nuse pipeline_traits::{AstStatistics, VariableInfo, FunctionInfo};\n\n/// Helper struct to traverse the AST and collect statistics\nstruct AstVisitor {\n    stats: AstStatistics,\n    #[allow(dead_code)]\n    file_path: PathBuf,\n}\n\nimpl AstVisitor {\n    fn new(file_path: PathBuf) -> Self {\n        Self {\n            stats: AstStatistics::default(),\n            file_path,\n        }\n    }\n\n    fn increment_node_type_count(&mut self, node_type: &str) {\n        *self.stats.node_type_counts.entry(node_type.to_string()).or_insert(0) += 1;\n    }\n}\n\nimpl <'ast> Visit<'ast> for AstVisitor {\n    fn visit_item_fn(&mut self, i: &'ast syn::ItemFn) {\n        self.increment_node_type_count(\"function\");\n\n        let mut arg_types = Vec::new();\n        for arg in &i.sig.inputs {\n            if let syn::FnArg::Typed(pat_type) = arg {\n                arg_types.push(quote! { #pat_type.ty }.to_string());\n            }\n        }\n\n        let return_type = if let syn::ReturnType::Type(_, ty) = &i.sig.output {\n            quote! { #ty }.to_string()\n        } else {\n            \"()\".to_string()\n        };\n\n        let visibility_str = match &i.vis {\n            Visibility::Public(_) => \"public\".to_string(),\n            Visibility::Restricted(r) => format!(\"restricted({})\", quote!{#r.path}.to_string()),\n            Visibility::Inherited => \"private\".to_string(),\n            //_ => \"unknown\".to_string(), // Catch-all for any other variants\n        };\n\n        self.stats.function_definitions.push(FunctionInfo {\n            name: i.sig.ident.to_string(),\n            visibility: visibility_str,\n            arg_count: i.sig.inputs.len() as u32,\n            arg_types,\n            return_type,\n            is_async: i.sig.asyncness.is_some(),\n            is_unsafe: i.sig.unsafety.is_some(),\n            is_const: i.sig.constness.is_some(),\n        });\n\n        visit::visit_item_fn(self, i);\n    }\n\n    fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct) {\n        self.increment_node_type_count(\"struct\");\n        visit::visit_item_struct(self, i);\n    }\n\n    fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum) {\n        self.increment_node_type_count(\"enum\");\n        visit::visit_item_enum(self, i);\n    }\n\n    fn visit_item_trait(&mut self, i: &'ast syn::ItemTrait) {\n        self.increment_node_type_count(\"trait\");\n        visit::visit_item_trait(self, i);\n    }\n\n    fn visit_item_impl(&mut self, i: &'ast syn::ItemImpl) {\n        self.increment_node_type_count(\"impl\");\n        visit::visit_item_impl(self, i);\n    }\n\n    fn visit_item_use(&mut self, i: &'ast syn::ItemUse) {\n        self.increment_node_type_count(\"import\");\n        // TODO: Extract detailed ImportInfo\n        visit::visit_item_use(self, i);\n    }\n\n    fn visit_pat_ident(&mut self, i: &'ast syn::PatIdent) {\n        // This captures variable declarations like `let x = ...`\n        // It's tricky to get the type here without more context, but we can get the name.\n        self.increment_node_type_count(\"variable\");\n        // TODO: Extract type and mutability more accurately\n        self.stats.variable_declarations.push(VariableInfo {\n            name: i.ident.to_string(),\n            type_name: \"unknown\".to_string(), // Placeholder\n            is_mutable: i.by_ref.is_some() || i.mutability.is_some(),\n            scope: \"unknown\".to_string(), // Placeholder\n        });\n        visit::visit_pat_ident(self, i);\n    }\n\n    // Catch-all for other items to count them\n    fn visit_item(&mut self, i: &'ast syn::Item) {\n        match i {\n            Item::Const(_) => self.increment_node_type_count(\"const\"),\n            Item::Static(_) => self.increment_node_type_count(\"static\"),\n            Item::Mod(_) => self.increment_node_type_count(\"module\"),\n            Item::ForeignMod(_) => self.increment_node_type_count(\"foreign_module\"),\n            Item::Macro(_) => self.increment_node_type_count(\"macro_definition\"),\n            // Item::Macro2(_) => self.increment_node_type_count(\"macro_definition2\"), // Removed Item::Macro2\n            Item::Type(_) => self.increment_node_type_count(\"type_alias\"),\n            Item::Union(_) => self.increment_node_type_count(\"union\"),\n            _ => self.increment_node_type_count(\"other_item\"), // Fallback for items not explicitly handled\n        }\n        visit::visit_item(self, i);\n    }\n\n    // TODO: Add more specific visitors for expressions, statements, etc.\n}\n\n/// Functor to traverse the AST and collect statistics\npub struct AstTraversalFunctor;\n\nimpl PipelineFunctor<ParsedFile, AstStatistics> for AstTraversalFunctor {\n    fn map<'writer>(\n        &'writer self,\n        _writer: &'writer mut (impl tokio::io::AsyncWriteExt + Unpin + Send),\n        input: ParsedFile,\n    ) -> Pin<Box<dyn Future<Output = Result<AstStatistics>> + Send + 'writer>> {\n        Box::pin(async move {\n            // Removed: measurement::record_function_entry(\"AstTraversalFunctor::map\");\n            let ParsedFile(parsed_code, file_path) = input;\n\n            let stats = tokio::task::spawn_blocking(move || -> anyhow::Result<AstStatistics> {\n                let ast = syn::parse_file(&parsed_code).context(\"Failed to parse code into AST for traversal\")?;\n                let mut visitor = AstVisitor::new(file_path);\n                syn::visit::visit_file(&mut visitor, &ast);\n                Ok(visitor.stats)\n            }).await.context(\"Blocking task for AST parsing failed\")??;\n\n            // Removed: measurement::record_function_exit(\"AstTraversalFunctor::map\");\n            Ok(stats)\n        })\n    }\n}\n",
    "timestamp": "2025-10-31T22:11:29.569184949Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/pipeline-traits/src/lib.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 37 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling parking_lot_core v0.9.12\n   Compiling scopeguard v1.2.0\n   Compiling cfg-if v1.0.4\n   Compiling smallvec v1.15.1\n   Compiling serde_core v1.0.228\n   Compiling lock_api v0.4.14\n   Compiling anyhow v1.0.100\n   Compiling serde v1.0.228\n   Compiling bytes v1.10.1\n   Compiling pin-project-lite v0.2.16\n   Compiling syn v2.0.108\n   Compiling socket2 v0.6.1\n   Compiling signal-hook-registry v1.4.6\n   Compiling mio v1.1.0\n   Compiling parking_lot v0.12.5\n   Compiling serde_derive v1.0.228\n   Compiling tokio-macros v2.6.0\n   Compiling tokio v1.48.0\n   Compiling pipeline-traits v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpCe90PI)\nerror[E0583]: file not found for module `use_statement_types`\n  --> src/lib.rs:10:1\n   |\n10 | pub mod use_statement_types;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `use_statement_types`, create file \"src/use_statement_types.rs\" or \"src/use_statement_types/mod.rs\"\n   = note: if there is a `mod use_statement_types` elsewhere in the crate already, import it with `use crate::...` instead\n\nFor more information about this error, try `rustc --explain E0583`.\nerror: could not compile `pipeline-traits` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\n\nStdout: #![feature(prelude_import)]\n#[macro_use]\nextern crate std;\n#[prelude_import]\nuse std::prelude::rust_2024::*;\nuse anyhow::Result;\nuse std::path::PathBuf;\nuse std::pin::Pin;\nuse std::future::Future;\nuse std::boxed::Box;\nuse std::fmt::Debug;\nuse std::collections::HashMap;\nuse serde::{Deserialize, Serialize};\n\npub mod use_statement_types {}\npub use use_statement_types::{\n    GitDetails, GitInfo, GitInfoTrait, NixDetails, NixInfo, NixInfoTrait,\n    RustDetails, RustDetailsInfo, RustDetailsInfoTrait, CargoDetails,\n    CargoInfo, CargoInfoTrait, SynDetails, SynInfo, SynInfoTrait, LlvmDetails,\n    LlvmInfo, LlvmInfoTrait, LinuxDetails, LinuxInfo, LinuxInfoTrait,\n};\n\npub struct RawFile(pub String, pub String);\n#[automatically_derived]\nimpl ::core::fmt::Debug for RawFile {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_tuple_field2_finish(f, \"RawFile\",\n            &self.0, &&self.1)\n    }\n}\npub struct ParsedFile(pub String, pub PathBuf);\n#[automatically_derived]\nimpl ::core::clone::Clone for ParsedFile {\n    #[inline]\n    fn clone(&self) -> ParsedFile {\n        ParsedFile(::core::clone::Clone::clone(&self.0),\n            ::core::clone::Clone::clone(&self.1))\n    }\n}\npub struct UseStatements(pub Vec<String>);\n#[automatically_derived]\nimpl ::core::fmt::Debug for UseStatements {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_tuple_field1_finish(f, \"UseStatements\",\n            &&self.0)\n    }\n}\npub struct ClassifiedUseStatements(pub Vec<UseStatement>);\n#[automatically_derived]\nimpl ::core::fmt::Debug for ClassifiedUseStatements {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_tuple_field1_finish(f,\n            \"ClassifiedUseStatements\", &&self.0)\n    }\n}\npub struct ValidatedFile(pub String, pub PathBuf);\n#[automatically_derived]\nimpl ::core::fmt::Debug for ValidatedFile {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_tuple_field2_finish(f, \"ValidatedFile\",\n            &self.0, &&self.1)\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for ValidatedFile {\n    #[inline]\n    fn clone(&self) -> ValidatedFile {\n        ValidatedFile(::core::clone::Clone::clone(&self.0),\n            ::core::clone::Clone::clone(&self.1))\n    }\n}\n\n// Functors (as a trait)\npub trait PipelineFunctor<Input: Send + 'static, Output: Send + 'static> {\n    fn map<'writer>(&'writer self,\n    writer: &'writer mut (impl tokio::io::AsyncWriteExt + Unpin + Send),\n    input: Input)\n    -> Pin<Box<dyn Future<Output = Result<Output>> + Send + 'writer>>;\n}\n\npub struct UseStatement {\n    pub statement: String,\n    pub error: Option<String>,\n    // Composed traits\n    pub git_details: Option<GitDetails>,\n    pub nix_details: Option<NixDetails>,\n    pub rust_details: Option<RustDetails>,\n    pub cargo_details: Option<CargoDetails>,\n    pub syn_details: Option<SynDetails>,\n    pub llvm_details: Option<LlvmDetails>,\n    pub linux_details: Option<LinuxDetails>,\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for UseStatement {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        let names: &'static _ =\n            &[\"statement\", \"error\", \"git_details\", \"nix_details\",\n                        \"rust_details\", \"cargo_details\", \"syn_details\",\n                        \"llvm_details\", \"linux_details\"];\n        let values: &[&dyn ::core::fmt::Debug] =\n            &[&self.statement, &self.error, &self.git_details,\n                        &self.nix_details, &self.rust_details, &self.cargo_details,\n                        &self.syn_details, &self.llvm_details,\n                        &&self.linux_details];\n        ::core::fmt::Formatter::debug_struct_fields_finish(f, \"UseStatement\",\n            names, values)\n    }\n}\n\n/// Information about a variable found in the AST\npub struct VariableInfo {\n    pub name: String,\n    pub type_name: String,\n    pub is_mutable: bool,\n    pub scope: String, // e.g., \"function\", \"module\", \"global\"\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for VariableInfo {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_struct_field4_finish(f, \"VariableInfo\",\n            \"name\", &self.name, \"type_name\", &self.type_name, \"is_mutable\",\n            &self.is_mutable, \"scope\", &&self.scope)\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for VariableInfo {\n    #[inline]\n    fn clone(&self) -> VariableInfo {\n        VariableInfo {\n            name: ::core::clone::Clone::clone(&self.name),\n            type_name: ::core::clone::Clone::clone(&self.type_name),\n            is_mutable: ::core::clone::Clone::clone(&self.is_mutable),\n            scope: ::core::clone::Clone::clone(&self.scope),\n        }\n    }\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl _serde::Serialize for VariableInfo {\n            fn serialize<__S>(&self, __serializer: __S)\n                -> _serde::__private228::Result<__S::Ok, __S::Error> where\n                __S: _serde::Serializer {\n                let mut __serde_state =\n                    _serde::Serializer::serialize_struct(__serializer,\n                            \"VariableInfo\", false as usize + 1 + 1 + 1 + 1)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"name\", &self.name)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"type_name\", &self.type_name)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"is_mutable\", &self.is_mutable)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"scope\", &self.scope)?;\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    };\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl<'de> _serde::Deserialize<'de> for VariableInfo {\n            fn deserialize<__D>(__deserializer: __D)\n                -> _serde::__private228::Result<Self, __D::Error> where\n                __D: _serde::Deserializer<'de> {\n                #[allow(non_camel_case_types)]\n                #[doc(hidden)]\n                enum __Field {\n                    __field0,\n                    __field1,\n                    __field2,\n                    __field3,\n                    __ignore,\n                }\n                #[doc(hidden)]\n                struct __FieldVisitor;\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {\n                    type Value = __Field;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"field identifier\")\n                    }\n                    fn visit_u64<__E>(self, __value: u64)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            0u64 => _serde::__private228::Ok(__Field::__field0),\n                            1u64 => _serde::__private228::Ok(__Field::__field1),\n                            2u64 => _serde::__private228::Ok(__Field::__field2),\n                            3u64 => _serde::__private228::Ok(__Field::__field3),\n                            _ => _serde::__private228::Ok(__Field::__ignore),\n                        }\n                    }\n                    fn visit_str<__E>(self, __value: &str)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            \"name\" => _serde::__private228::Ok(__Field::__field0),\n                            \"type_name\" => _serde::__private228::Ok(__Field::__field1),\n                            \"is_mutable\" => _serde::__private228::Ok(__Field::__field2),\n                            \"scope\" => _serde::__private228::Ok(__Field::__field3),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                    fn visit_bytes<__E>(self, __value: &[u8])\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            b\"name\" => _serde::__private228::Ok(__Field::__field0),\n                            b\"type_name\" => _serde::__private228::Ok(__Field::__field1),\n                            b\"is_mutable\" =>\n                                _serde::__private228::Ok(__Field::__field2),\n                            b\"scope\" => _serde::__private228::Ok(__Field::__field3),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                }\n                #[automatically_derived]\n                impl<'de> _serde::Deserialize<'de> for __Field {\n                    #[inline]\n                    fn deserialize<__D>(__deserializer: __D)\n                        -> _serde::__private228::Result<Self, __D::Error> where\n                        __D: _serde::Deserializer<'de> {\n                        _serde::Deserializer::deserialize_identifier(__deserializer,\n                            __FieldVisitor)\n                    }\n                }\n                #[doc(hidden)]\n                struct __Visitor<'de> {\n                    marker: _serde::__private228::PhantomData<VariableInfo>,\n                    lifetime: _serde::__private228::PhantomData<&'de ()>,\n                }\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {\n                    type Value = VariableInfo;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"struct VariableInfo\")\n                    }\n                    #[inline]\n                    fn visit_seq<__A>(self, mut __seq: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::SeqAccess<'de> {\n                        let __field0 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(0usize,\n                                                &\"struct VariableInfo with 4 elements\")),\n                            };\n                        let __field1 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(1usize,\n                                                &\"struct VariableInfo with 4 elements\")),\n                            };\n                        let __field2 =\n                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(2usize,\n                                                &\"struct VariableInfo with 4 elements\")),\n                            };\n                        let __field3 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(3usize,\n                                                &\"struct VariableInfo with 4 elements\")),\n                            };\n                        _serde::__private228::Ok(VariableInfo {\n                                name: __field0,\n                                type_name: __field1,\n                                is_mutable: __field2,\n                                scope: __field3,\n                            })\n                    }\n                    #[inline]\n                    fn visit_map<__A>(self, mut __map: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::MapAccess<'de> {\n                        let mut __field0: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field1: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field2: _serde::__private228::Option<bool> =\n                            _serde::__private228::None;\n                        let mut __field3: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        while let _serde::__private228::Some(__key) =\n                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {\n                            match __key {\n                                __Field::__field0 => {\n                                    if _serde::__private228::Option::is_some(&__field0) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"name\"));\n                                    }\n                                    __field0 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field1 => {\n                                    if _serde::__private228::Option::is_some(&__field1) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"type_name\"));\n                                    }\n                                    __field1 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field2 => {\n                                    if _serde::__private228::Option::is_some(&__field2) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"is_mutable\"));\n                                    }\n                                    __field2 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);\n                                }\n                                __Field::__field3 => {\n                                    if _serde::__private228::Option::is_some(&__field3) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"scope\"));\n                                    }\n                                    __field3 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                _ => {\n                                    let _ =\n                                        _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;\n                                }\n                            }\n                        }\n                        let __field0 =\n                            match __field0 {\n                                _serde::__private228::Some(__field0) => __field0,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"name\")?,\n                            };\n                        let __field1 =\n                            match __field1 {\n                                _serde::__private228::Some(__field1) => __field1,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"type_name\")?,\n                            };\n                        let __field2 =\n                            match __field2 {\n                                _serde::__private228::Some(__field2) => __field2,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"is_mutable\")?,\n                            };\n                        let __field3 =\n                            match __field3 {\n                                _serde::__private228::Some(__field3) => __field3,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"scope\")?,\n                            };\n                        _serde::__private228::Ok(VariableInfo {\n                                name: __field0,\n                                type_name: __field1,\n                                is_mutable: __field2,\n                                scope: __field3,\n                            })\n                    }\n                }\n                #[doc(hidden)]\n                const FIELDS: &'static [&'static str] =\n                    &[\"name\", \"type_name\", \"is_mutable\", \"scope\"];\n                _serde::Deserializer::deserialize_struct(__deserializer,\n                    \"VariableInfo\", FIELDS,\n                    __Visitor {\n                        marker: _serde::__private228::PhantomData::<VariableInfo>,\n                        lifetime: _serde::__private228::PhantomData,\n                    })\n            }\n        }\n    };\n\n/// Information about a function found in the AST\npub struct FunctionInfo {\n    pub name: String,\n    pub visibility: String,\n    // e.g., \"public\", \"private\"\n    pub arg_count: u32,\n    pub arg_types: Vec<String>,\n    pub return_type: String,\n    pub is_async: bool,\n    pub is_unsafe: bool,\n    pub is_const: bool,\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for FunctionInfo {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        let names: &'static _ =\n            &[\"name\", \"visibility\", \"arg_count\", \"arg_types\", \"return_type\",\n                        \"is_async\", \"is_unsafe\", \"is_const\"];\n        let values: &[&dyn ::core::fmt::Debug] =\n            &[&self.name, &self.visibility, &self.arg_count, &self.arg_types,\n                        &self.return_type, &self.is_async, &self.is_unsafe,\n                        &&self.is_const];\n        ::core::fmt::Formatter::debug_struct_fields_finish(f, \"FunctionInfo\",\n            names, values)\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for FunctionInfo {\n    #[inline]\n    fn clone(&self) -> FunctionInfo {\n        FunctionInfo {\n            name: ::core::clone::Clone::clone(&self.name),\n            visibility: ::core::clone::Clone::clone(&self.visibility),\n            arg_count: ::core::clone::Clone::clone(&self.arg_count),\n            arg_types: ::core::clone::Clone::clone(&self.arg_types),\n            return_type: ::core::clone::Clone::clone(&self.return_type),\n            is_async: ::core::clone::Clone::clone(&self.is_async),\n            is_unsafe: ::core::clone::Clone::clone(&self.is_unsafe),\n            is_const: ::core::clone::Clone::clone(&self.is_const),\n        }\n    }\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl _serde::Serialize for FunctionInfo {\n            fn serialize<__S>(&self, __serializer: __S)\n                -> _serde::__private228::Result<__S::Ok, __S::Error> where\n                __S: _serde::Serializer {\n                let mut __serde_state =\n                    _serde::Serializer::serialize_struct(__serializer,\n                            \"FunctionInfo\",\n                            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"name\", &self.name)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"visibility\", &self.visibility)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"arg_count\", &self.arg_count)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"arg_types\", &self.arg_types)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"return_type\", &self.return_type)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"is_async\", &self.is_async)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"is_unsafe\", &self.is_unsafe)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"is_const\", &self.is_const)?;\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    };\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl<'de> _serde::Deserialize<'de> for FunctionInfo {\n            fn deserialize<__D>(__deserializer: __D)\n                -> _serde::__private228::Result<Self, __D::Error> where\n                __D: _serde::Deserializer<'de> {\n                #[allow(non_camel_case_types)]\n                #[doc(hidden)]\n                enum __Field {\n                    __field0,\n                    __field1,\n                    __field2,\n                    __field3,\n                    __field4,\n                    __field5,\n                    __field6,\n                    __field7,\n                    __ignore,\n                }\n                #[doc(hidden)]\n                struct __FieldVisitor;\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {\n                    type Value = __Field;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"field identifier\")\n                    }\n                    fn visit_u64<__E>(self, __value: u64)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            0u64 => _serde::__private228::Ok(__Field::__field0),\n                            1u64 => _serde::__private228::Ok(__Field::__field1),\n                            2u64 => _serde::__private228::Ok(__Field::__field2),\n                            3u64 => _serde::__private228::Ok(__Field::__field3),\n                            4u64 => _serde::__private228::Ok(__Field::__field4),\n                            5u64 => _serde::__private228::Ok(__Field::__field5),\n                            6u64 => _serde::__private228::Ok(__Field::__field6),\n                            7u64 => _serde::__private228::Ok(__Field::__field7),\n                            _ => _serde::__private228::Ok(__Field::__ignore),\n                        }\n                    }\n                    fn visit_str<__E>(self, __value: &str)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            \"name\" => _serde::__private228::Ok(__Field::__field0),\n                            \"visibility\" => _serde::__private228::Ok(__Field::__field1),\n                            \"arg_count\" => _serde::__private228::Ok(__Field::__field2),\n                            \"arg_types\" => _serde::__private228::Ok(__Field::__field3),\n                            \"return_type\" =>\n                                _serde::__private228::Ok(__Field::__field4),\n                            \"is_async\" => _serde::__private228::Ok(__Field::__field5),\n                            \"is_unsafe\" => _serde::__private228::Ok(__Field::__field6),\n                            \"is_const\" => _serde::__private228::Ok(__Field::__field7),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                    fn visit_bytes<__E>(self, __value: &[u8])\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            b\"name\" => _serde::__private228::Ok(__Field::__field0),\n                            b\"visibility\" =>\n                                _serde::__private228::Ok(__Field::__field1),\n                            b\"arg_count\" => _serde::__private228::Ok(__Field::__field2),\n                            b\"arg_types\" => _serde::__private228::Ok(__Field::__field3),\n                            b\"return_type\" =>\n                                _serde::__private228::Ok(__Field::__field4),\n                            b\"is_async\" => _serde::__private228::Ok(__Field::__field5),\n                            b\"is_unsafe\" => _serde::__private228::Ok(__Field::__field6),\n                            b\"is_const\" => _serde::__private228::Ok(__Field::__field7),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                }\n                #[automatically_derived]\n                impl<'de> _serde::Deserialize<'de> for __Field {\n                    #[inline]\n                    fn deserialize<__D>(__deserializer: __D)\n                        -> _serde::__private228::Result<Self, __D::Error> where\n                        __D: _serde::Deserializer<'de> {\n                        _serde::Deserializer::deserialize_identifier(__deserializer,\n                            __FieldVisitor)\n                    }\n                }\n                #[doc(hidden)]\n                struct __Visitor<'de> {\n                    marker: _serde::__private228::PhantomData<FunctionInfo>,\n                    lifetime: _serde::__private228::PhantomData<&'de ()>,\n                }\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {\n                    type Value = FunctionInfo;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"struct FunctionInfo\")\n                    }\n                    #[inline]\n                    fn visit_seq<__A>(self, mut __seq: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::SeqAccess<'de> {\n                        let __field0 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(0usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field1 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(1usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field2 =\n                            match _serde::de::SeqAccess::next_element::<u32>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(2usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field3 =\n                            match _serde::de::SeqAccess::next_element::<Vec<String>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(3usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field4 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(4usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field5 =\n                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(5usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field6 =\n                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(6usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        let __field7 =\n                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(7usize,\n                                                &\"struct FunctionInfo with 8 elements\")),\n                            };\n                        _serde::__private228::Ok(FunctionInfo {\n                                name: __field0,\n                                visibility: __field1,\n                                arg_count: __field2,\n                                arg_types: __field3,\n                                return_type: __field4,\n                                is_async: __field5,\n                                is_unsafe: __field6,\n                                is_const: __field7,\n                            })\n                    }\n                    #[inline]\n                    fn visit_map<__A>(self, mut __map: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::MapAccess<'de> {\n                        let mut __field0: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field1: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field2: _serde::__private228::Option<u32> =\n                            _serde::__private228::None;\n                        let mut __field3:\n                                _serde::__private228::Option<Vec<String>> =\n                            _serde::__private228::None;\n                        let mut __field4: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field5: _serde::__private228::Option<bool> =\n                            _serde::__private228::None;\n                        let mut __field6: _serde::__private228::Option<bool> =\n                            _serde::__private228::None;\n                        let mut __field7: _serde::__private228::Option<bool> =\n                            _serde::__private228::None;\n                        while let _serde::__private228::Some(__key) =\n                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {\n                            match __key {\n                                __Field::__field0 => {\n                                    if _serde::__private228::Option::is_some(&__field0) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"name\"));\n                                    }\n                                    __field0 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field1 => {\n                                    if _serde::__private228::Option::is_some(&__field1) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"visibility\"));\n                                    }\n                                    __field1 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field2 => {\n                                    if _serde::__private228::Option::is_some(&__field2) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"arg_count\"));\n                                    }\n                                    __field2 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<u32>(&mut __map)?);\n                                }\n                                __Field::__field3 => {\n                                    if _serde::__private228::Option::is_some(&__field3) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"arg_types\"));\n                                    }\n                                    __field3 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Vec<String>>(&mut __map)?);\n                                }\n                                __Field::__field4 => {\n                                    if _serde::__private228::Option::is_some(&__field4) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"return_type\"));\n                                    }\n                                    __field4 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field5 => {\n                                    if _serde::__private228::Option::is_some(&__field5) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"is_async\"));\n                                    }\n                                    __field5 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);\n                                }\n                                __Field::__field6 => {\n                                    if _serde::__private228::Option::is_some(&__field6) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"is_unsafe\"));\n                                    }\n                                    __field6 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);\n                                }\n                                __Field::__field7 => {\n                                    if _serde::__private228::Option::is_some(&__field7) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"is_const\"));\n                                    }\n                                    __field7 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);\n                                }\n                                _ => {\n                                    let _ =\n                                        _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;\n                                }\n                            }\n                        }\n                        let __field0 =\n                            match __field0 {\n                                _serde::__private228::Some(__field0) => __field0,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"name\")?,\n                            };\n                        let __field1 =\n                            match __field1 {\n                                _serde::__private228::Some(__field1) => __field1,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"visibility\")?,\n                            };\n                        let __field2 =\n                            match __field2 {\n                                _serde::__private228::Some(__field2) => __field2,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"arg_count\")?,\n                            };\n                        let __field3 =\n                            match __field3 {\n                                _serde::__private228::Some(__field3) => __field3,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"arg_types\")?,\n                            };\n                        let __field4 =\n                            match __field4 {\n                                _serde::__private228::Some(__field4) => __field4,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"return_type\")?,\n                            };\n                        let __field5 =\n                            match __field5 {\n                                _serde::__private228::Some(__field5) => __field5,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"is_async\")?,\n                            };\n                        let __field6 =\n                            match __field6 {\n                                _serde::__private228::Some(__field6) => __field6,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"is_unsafe\")?,\n                            };\n                        let __field7 =\n                            match __field7 {\n                                _serde::__private228::Some(__field7) => __field7,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"is_const\")?,\n                            };\n                        _serde::__private228::Ok(FunctionInfo {\n                                name: __field0,\n                                visibility: __field1,\n                                arg_count: __field2,\n                                arg_types: __field3,\n                                return_type: __field4,\n                                is_async: __field5,\n                                is_unsafe: __field6,\n                                is_const: __field7,\n                            })\n                    }\n                }\n                #[doc(hidden)]\n                const FIELDS: &'static [&'static str] =\n                    &[\"name\", \"visibility\", \"arg_count\", \"arg_types\",\n                                \"return_type\", \"is_async\", \"is_unsafe\", \"is_const\"];\n                _serde::Deserializer::deserialize_struct(__deserializer,\n                    \"FunctionInfo\", FIELDS,\n                    __Visitor {\n                        marker: _serde::__private228::PhantomData::<FunctionInfo>,\n                        lifetime: _serde::__private228::PhantomData,\n                    })\n            }\n        }\n    };\n\n/// Information about an import statement found in the AST\npub struct ImportInfo {\n    pub path: String,\n    // The full path of the import (e.g., \"std::collections::HashMap\")\n    pub alias: Option<String>,\n    pub is_external: bool,\n    pub source_crate: Option<String>,\n    pub git_source_url: Option<String>,\n    pub git_branch: Option<String>,\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for ImportInfo {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        let names: &'static _ =\n            &[\"path\", \"alias\", \"is_external\", \"source_crate\",\n                        \"git_source_url\", \"git_branch\"];\n        let values: &[&dyn ::core::fmt::Debug] =\n            &[&self.path, &self.alias, &self.is_external, &self.source_crate,\n                        &self.git_source_url, &&self.git_branch];\n        ::core::fmt::Formatter::debug_struct_fields_finish(f, \"ImportInfo\",\n            names, values)\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for ImportInfo {\n    #[inline]\n    fn clone(&self) -> ImportInfo {\n        ImportInfo {\n            path: ::core::clone::Clone::clone(&self.path),\n            alias: ::core::clone::Clone::clone(&self.alias),\n            is_external: ::core::clone::Clone::clone(&self.is_external),\n            source_crate: ::core::clone::Clone::clone(&self.source_crate),\n            git_source_url: ::core::clone::Clone::clone(&self.git_source_url),\n            git_branch: ::core::clone::Clone::clone(&self.git_branch),\n        }\n    }\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl _serde::Serialize for ImportInfo {\n            fn serialize<__S>(&self, __serializer: __S)\n                -> _serde::__private228::Result<__S::Ok, __S::Error> where\n                __S: _serde::Serializer {\n                let mut __serde_state =\n                    _serde::Serializer::serialize_struct(__serializer,\n                            \"ImportInfo\", false as usize + 1 + 1 + 1 + 1 + 1 + 1)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"path\", &self.path)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"alias\", &self.alias)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"is_external\", &self.is_external)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"source_crate\", &self.source_crate)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"git_source_url\", &self.git_source_url)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"git_branch\", &self.git_branch)?;\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    };\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl<'de> _serde::Deserialize<'de> for ImportInfo {\n            fn deserialize<__D>(__deserializer: __D)\n                -> _serde::__private228::Result<Self, __D::Error> where\n                __D: _serde::Deserializer<'de> {\n                #[allow(non_camel_case_types)]\n                #[doc(hidden)]\n                enum __Field {\n                    __field0,\n                    __field1,\n                    __field2,\n                    __field3,\n                    __field4,\n                    __field5,\n                    __ignore,\n                }\n                #[doc(hidden)]\n                struct __FieldVisitor;\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {\n                    type Value = __Field;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"field identifier\")\n                    }\n                    fn visit_u64<__E>(self, __value: u64)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            0u64 => _serde::__private228::Ok(__Field::__field0),\n                            1u64 => _serde::__private228::Ok(__Field::__field1),\n                            2u64 => _serde::__private228::Ok(__Field::__field2),\n                            3u64 => _serde::__private228::Ok(__Field::__field3),\n                            4u64 => _serde::__private228::Ok(__Field::__field4),\n                            5u64 => _serde::__private228::Ok(__Field::__field5),\n                            _ => _serde::__private228::Ok(__Field::__ignore),\n                        }\n                    }\n                    fn visit_str<__E>(self, __value: &str)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            \"path\" => _serde::__private228::Ok(__Field::__field0),\n                            \"alias\" => _serde::__private228::Ok(__Field::__field1),\n                            \"is_external\" =>\n                                _serde::__private228::Ok(__Field::__field2),\n                            \"source_crate\" =>\n                                _serde::__private228::Ok(__Field::__field3),\n                            \"git_source_url\" =>\n                                _serde::__private228::Ok(__Field::__field4),\n                            \"git_branch\" => _serde::__private228::Ok(__Field::__field5),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                    fn visit_bytes<__E>(self, __value: &[u8])\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            b\"path\" => _serde::__private228::Ok(__Field::__field0),\n                            b\"alias\" => _serde::__private228::Ok(__Field::__field1),\n                            b\"is_external\" =>\n                                _serde::__private228::Ok(__Field::__field2),\n                            b\"source_crate\" =>\n                                _serde::__private228::Ok(__Field::__field3),\n                            b\"git_source_url\" =>\n                                _serde::__private228::Ok(__Field::__field4),\n                            b\"git_branch\" =>\n                                _serde::__private228::Ok(__Field::__field5),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                }\n                #[automatically_derived]\n                impl<'de> _serde::Deserialize<'de> for __Field {\n                    #[inline]\n                    fn deserialize<__D>(__deserializer: __D)\n                        -> _serde::__private228::Result<Self, __D::Error> where\n                        __D: _serde::Deserializer<'de> {\n                        _serde::Deserializer::deserialize_identifier(__deserializer,\n                            __FieldVisitor)\n                    }\n                }\n                #[doc(hidden)]\n                struct __Visitor<'de> {\n                    marker: _serde::__private228::PhantomData<ImportInfo>,\n                    lifetime: _serde::__private228::PhantomData<&'de ()>,\n                }\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {\n                    type Value = ImportInfo;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"struct ImportInfo\")\n                    }\n                    #[inline]\n                    fn visit_seq<__A>(self, mut __seq: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::SeqAccess<'de> {\n                        let __field0 =\n                            match _serde::de::SeqAccess::next_element::<String>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(0usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        let __field1 =\n                            match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(1usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        let __field2 =\n                            match _serde::de::SeqAccess::next_element::<bool>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(2usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        let __field3 =\n                            match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(3usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        let __field4 =\n                            match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(4usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        let __field5 =\n                            match _serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(5usize,\n                                                &\"struct ImportInfo with 6 elements\")),\n                            };\n                        _serde::__private228::Ok(ImportInfo {\n                                path: __field0,\n                                alias: __field1,\n                                is_external: __field2,\n                                source_crate: __field3,\n                                git_source_url: __field4,\n                                git_branch: __field5,\n                            })\n                    }\n                    #[inline]\n                    fn visit_map<__A>(self, mut __map: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::MapAccess<'de> {\n                        let mut __field0: _serde::__private228::Option<String> =\n                            _serde::__private228::None;\n                        let mut __field1:\n                                _serde::__private228::Option<Option<String>> =\n                            _serde::__private228::None;\n                        let mut __field2: _serde::__private228::Option<bool> =\n                            _serde::__private228::None;\n                        let mut __field3:\n                                _serde::__private228::Option<Option<String>> =\n                            _serde::__private228::None;\n                        let mut __field4:\n                                _serde::__private228::Option<Option<String>> =\n                            _serde::__private228::None;\n                        let mut __field5:\n                                _serde::__private228::Option<Option<String>> =\n                            _serde::__private228::None;\n                        while let _serde::__private228::Some(__key) =\n                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {\n                            match __key {\n                                __Field::__field0 => {\n                                    if _serde::__private228::Option::is_some(&__field0) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"path\"));\n                                    }\n                                    __field0 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<String>(&mut __map)?);\n                                }\n                                __Field::__field1 => {\n                                    if _serde::__private228::Option::is_some(&__field1) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"alias\"));\n                                    }\n                                    __field1 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Option<String>>(&mut __map)?);\n                                }\n                                __Field::__field2 => {\n                                    if _serde::__private228::Option::is_some(&__field2) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"is_external\"));\n                                    }\n                                    __field2 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<bool>(&mut __map)?);\n                                }\n                                __Field::__field3 => {\n                                    if _serde::__private228::Option::is_some(&__field3) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"source_crate\"));\n                                    }\n                                    __field3 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Option<String>>(&mut __map)?);\n                                }\n                                __Field::__field4 => {\n                                    if _serde::__private228::Option::is_some(&__field4) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"git_source_url\"));\n                                    }\n                                    __field4 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Option<String>>(&mut __map)?);\n                                }\n                                __Field::__field5 => {\n                                    if _serde::__private228::Option::is_some(&__field5) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"git_branch\"));\n                                    }\n                                    __field5 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Option<String>>(&mut __map)?);\n                                }\n                                _ => {\n                                    let _ =\n                                        _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;\n                                }\n                            }\n                        }\n                        let __field0 =\n                            match __field0 {\n                                _serde::__private228::Some(__field0) => __field0,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"path\")?,\n                            };\n                        let __field1 =\n                            match __field1 {\n                                _serde::__private228::Some(__field1) => __field1,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"alias\")?,\n                            };\n                        let __field2 =\n                            match __field2 {\n                                _serde::__private228::Some(__field2) => __field2,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"is_external\")?,\n                            };\n                        let __field3 =\n                            match __field3 {\n                                _serde::__private228::Some(__field3) => __field3,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"source_crate\")?,\n                            };\n                        let __field4 =\n                            match __field4 {\n                                _serde::__private228::Some(__field4) => __field4,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"git_source_url\")?,\n                            };\n                        let __field5 =\n                            match __field5 {\n                                _serde::__private228::Some(__field5) => __field5,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"git_branch\")?,\n                            };\n                        _serde::__private228::Ok(ImportInfo {\n                                path: __field0,\n                                alias: __field1,\n                                is_external: __field2,\n                                source_crate: __field3,\n                                git_source_url: __field4,\n                                git_branch: __field5,\n                            })\n                    }\n                }\n                #[doc(hidden)]\n                const FIELDS: &'static [&'static str] =\n                    &[\"path\", \"alias\", \"is_external\", \"source_crate\",\n                                \"git_source_url\", \"git_branch\"];\n                _serde::Deserializer::deserialize_struct(__deserializer,\n                    \"ImportInfo\", FIELDS,\n                    __Visitor {\n                        marker: _serde::__private228::PhantomData::<ImportInfo>,\n                        lifetime: _serde::__private228::PhantomData,\n                    })\n            }\n        }\n    };\n\n/// Comprehensive AST analysis data for a Rust project\npub struct AstStatistics {\n    pub node_type_counts: HashMap<String, u32>,\n    pub variable_declarations: Vec<VariableInfo>,\n    pub function_definitions: Vec<FunctionInfo>,\n    pub import_statements: Vec<ImportInfo>,\n    // Add more fields as needed, e.g., macro invocations, struct definitions\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for AstStatistics {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_struct_field4_finish(f, \"AstStatistics\",\n            \"node_type_counts\", &self.node_type_counts,\n            \"variable_declarations\", &self.variable_declarations,\n            \"function_definitions\", &self.function_definitions,\n            \"import_statements\", &&self.import_statements)\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for AstStatistics {\n    #[inline]\n    fn clone(&self) -> AstStatistics {\n        AstStatistics {\n            node_type_counts: ::core::clone::Clone::clone(&self.node_type_counts),\n            variable_declarations: ::core::clone::Clone::clone(&self.variable_declarations),\n            function_definitions: ::core::clone::Clone::clone(&self.function_definitions),\n            import_statements: ::core::clone::Clone::clone(&self.import_statements),\n        }\n    }\n}\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl _serde::Serialize for AstStatistics {\n            fn serialize<__S>(&self, __serializer: __S)\n                -> _serde::__private228::Result<__S::Ok, __S::Error> where\n                __S: _serde::Serializer {\n                let mut __serde_state =\n                    _serde::Serializer::serialize_struct(__serializer,\n                            \"AstStatistics\", false as usize + 1 + 1 + 1 + 1)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"node_type_counts\", &self.node_type_counts)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"variable_declarations\", &self.variable_declarations)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"function_definitions\", &self.function_definitions)?;\n                _serde::ser::SerializeStruct::serialize_field(&mut __serde_state,\n                        \"import_statements\", &self.import_statements)?;\n                _serde::ser::SerializeStruct::end(__serde_state)\n            }\n        }\n    };\n#[doc(hidden)]\n#[allow(non_upper_case_globals, unused_attributes, unused_qualifications,\nclippy :: absolute_paths,)]\nconst _: () =\n    {\n        #[allow(unused_extern_crates, clippy :: useless_attribute)]\n        extern crate serde as _serde;\n        ;\n        #[automatically_derived]\n        impl<'de> _serde::Deserialize<'de> for AstStatistics {\n            fn deserialize<__D>(__deserializer: __D)\n                -> _serde::__private228::Result<Self, __D::Error> where\n                __D: _serde::Deserializer<'de> {\n                #[allow(non_camel_case_types)]\n                #[doc(hidden)]\n                enum __Field {\n                    __field0,\n                    __field1,\n                    __field2,\n                    __field3,\n                    __ignore,\n                }\n                #[doc(hidden)]\n                struct __FieldVisitor;\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {\n                    type Value = __Field;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"field identifier\")\n                    }\n                    fn visit_u64<__E>(self, __value: u64)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            0u64 => _serde::__private228::Ok(__Field::__field0),\n                            1u64 => _serde::__private228::Ok(__Field::__field1),\n                            2u64 => _serde::__private228::Ok(__Field::__field2),\n                            3u64 => _serde::__private228::Ok(__Field::__field3),\n                            _ => _serde::__private228::Ok(__Field::__ignore),\n                        }\n                    }\n                    fn visit_str<__E>(self, __value: &str)\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            \"node_type_counts\" =>\n                                _serde::__private228::Ok(__Field::__field0),\n                            \"variable_declarations\" =>\n                                _serde::__private228::Ok(__Field::__field1),\n                            \"function_definitions\" =>\n                                _serde::__private228::Ok(__Field::__field2),\n                            \"import_statements\" =>\n                                _serde::__private228::Ok(__Field::__field3),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                    fn visit_bytes<__E>(self, __value: &[u8])\n                        -> _serde::__private228::Result<Self::Value, __E> where\n                        __E: _serde::de::Error {\n                        match __value {\n                            b\"node_type_counts\" =>\n                                _serde::__private228::Ok(__Field::__field0),\n                            b\"variable_declarations\" =>\n                                _serde::__private228::Ok(__Field::__field1),\n                            b\"function_definitions\" =>\n                                _serde::__private228::Ok(__Field::__field2),\n                            b\"import_statements\" =>\n                                _serde::__private228::Ok(__Field::__field3),\n                            _ => { _serde::__private228::Ok(__Field::__ignore) }\n                        }\n                    }\n                }\n                #[automatically_derived]\n                impl<'de> _serde::Deserialize<'de> for __Field {\n                    #[inline]\n                    fn deserialize<__D>(__deserializer: __D)\n                        -> _serde::__private228::Result<Self, __D::Error> where\n                        __D: _serde::Deserializer<'de> {\n                        _serde::Deserializer::deserialize_identifier(__deserializer,\n                            __FieldVisitor)\n                    }\n                }\n                #[doc(hidden)]\n                struct __Visitor<'de> {\n                    marker: _serde::__private228::PhantomData<AstStatistics>,\n                    lifetime: _serde::__private228::PhantomData<&'de ()>,\n                }\n                #[automatically_derived]\n                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {\n                    type Value = AstStatistics;\n                    fn expecting(&self,\n                        __formatter: &mut _serde::__private228::Formatter)\n                        -> _serde::__private228::fmt::Result {\n                        _serde::__private228::Formatter::write_str(__formatter,\n                            \"struct AstStatistics\")\n                    }\n                    #[inline]\n                    fn visit_seq<__A>(self, mut __seq: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::SeqAccess<'de> {\n                        let __field0 =\n                            match _serde::de::SeqAccess::next_element::<HashMap<String,\n                                            u32>>(&mut __seq)? {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(0usize,\n                                                &\"struct AstStatistics with 4 elements\")),\n                            };\n                        let __field1 =\n                            match _serde::de::SeqAccess::next_element::<Vec<VariableInfo>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(1usize,\n                                                &\"struct AstStatistics with 4 elements\")),\n                            };\n                        let __field2 =\n                            match _serde::de::SeqAccess::next_element::<Vec<FunctionInfo>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(2usize,\n                                                &\"struct AstStatistics with 4 elements\")),\n                            };\n                        let __field3 =\n                            match _serde::de::SeqAccess::next_element::<Vec<ImportInfo>>(&mut __seq)?\n                                {\n                                _serde::__private228::Some(__value) => __value,\n                                _serde::__private228::None =>\n                                    return _serde::__private228::Err(_serde::de::Error::invalid_length(3usize,\n                                                &\"struct AstStatistics with 4 elements\")),\n                            };\n                        _serde::__private228::Ok(AstStatistics {\n                                node_type_counts: __field0,\n                                variable_declarations: __field1,\n                                function_definitions: __field2,\n                                import_statements: __field3,\n                            })\n                    }\n                    #[inline]\n                    fn visit_map<__A>(self, mut __map: __A)\n                        -> _serde::__private228::Result<Self::Value, __A::Error>\n                        where __A: _serde::de::MapAccess<'de> {\n                        let mut __field0:\n                                _serde::__private228::Option<HashMap<String, u32>> =\n                            _serde::__private228::None;\n                        let mut __field1:\n                                _serde::__private228::Option<Vec<VariableInfo>> =\n                            _serde::__private228::None;\n                        let mut __field2:\n                                _serde::__private228::Option<Vec<FunctionInfo>> =\n                            _serde::__private228::None;\n                        let mut __field3:\n                                _serde::__private228::Option<Vec<ImportInfo>> =\n                            _serde::__private228::None;\n                        while let _serde::__private228::Some(__key) =\n                                _serde::de::MapAccess::next_key::<__Field>(&mut __map)? {\n                            match __key {\n                                __Field::__field0 => {\n                                    if _serde::__private228::Option::is_some(&__field0) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"node_type_counts\"));\n                                    }\n                                    __field0 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<HashMap<String,\n                                                        u32>>(&mut __map)?);\n                                }\n                                __Field::__field1 => {\n                                    if _serde::__private228::Option::is_some(&__field1) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"variable_declarations\"));\n                                    }\n                                    __field1 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Vec<VariableInfo>>(&mut __map)?);\n                                }\n                                __Field::__field2 => {\n                                    if _serde::__private228::Option::is_some(&__field2) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"function_definitions\"));\n                                    }\n                                    __field2 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Vec<FunctionInfo>>(&mut __map)?);\n                                }\n                                __Field::__field3 => {\n                                    if _serde::__private228::Option::is_some(&__field3) {\n                                        return _serde::__private228::Err(<__A::Error as\n                                                        _serde::de::Error>::duplicate_field(\"import_statements\"));\n                                    }\n                                    __field3 =\n                                        _serde::__private228::Some(_serde::de::MapAccess::next_value::<Vec<ImportInfo>>(&mut __map)?);\n                                }\n                                _ => {\n                                    let _ =\n                                        _serde::de::MapAccess::next_value::<_serde::de::IgnoredAny>(&mut __map)?;\n                                }\n                            }\n                        }\n                        let __field0 =\n                            match __field0 {\n                                _serde::__private228::Some(__field0) => __field0,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"node_type_counts\")?,\n                            };\n                        let __field1 =\n                            match __field1 {\n                                _serde::__private228::Some(__field1) => __field1,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"variable_declarations\")?,\n                            };\n                        let __field2 =\n                            match __field2 {\n                                _serde::__private228::Some(__field2) => __field2,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"function_definitions\")?,\n                            };\n                        let __field3 =\n                            match __field3 {\n                                _serde::__private228::Some(__field3) => __field3,\n                                _serde::__private228::None =>\n                                    _serde::__private228::de::missing_field(\"import_statements\")?,\n                            };\n                        _serde::__private228::Ok(AstStatistics {\n                                node_type_counts: __field0,\n                                variable_declarations: __field1,\n                                function_definitions: __field2,\n                                import_statements: __field3,\n                            })\n                    }\n                }\n                #[doc(hidden)]\n                const FIELDS: &'static [&'static str] =\n                    &[\"node_type_counts\", \"variable_declarations\",\n                                \"function_definitions\", \"import_statements\"];\n                _serde::Deserializer::deserialize_struct(__deserializer,\n                    \"AstStatistics\", FIELDS,\n                    __Visitor {\n                        marker: _serde::__private228::PhantomData::<AstStatistics>,\n                        lifetime: _serde::__private228::PhantomData,\n                    })\n            }\n        }\n    };\n#[automatically_derived]\nimpl ::core::default::Default for AstStatistics {\n    #[inline]\n    fn default() -> AstStatistics {\n        AstStatistics {\n            node_type_counts: ::core::default::Default::default(),\n            variable_declarations: ::core::default::Default::default(),\n            function_definitions: ::core::default::Default::default(),\n            import_statements: ::core::default::Default::default(),\n        }\n    }\n}\n\nStderr:     Updating crates.io index\n     Locking 37 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling libc v0.2.177\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling parking_lot_core v0.9.12\n   Compiling scopeguard v1.2.0\n   Compiling cfg-if v1.0.4\n   Compiling smallvec v1.15.1\n   Compiling serde_core v1.0.228\n   Compiling lock_api v0.4.14\n   Compiling anyhow v1.0.100\n   Compiling serde v1.0.228\n   Compiling bytes v1.10.1\n   Compiling pin-project-lite v0.2.16\n   Compiling syn v2.0.108\n   Compiling socket2 v0.6.1\n   Compiling signal-hook-registry v1.4.6\n   Compiling mio v1.1.0\n   Compiling parking_lot v0.12.5\n   Compiling serde_derive v1.0.228\n   Compiling tokio-macros v2.6.0\n   Compiling tokio v1.48.0\n   Compiling pipeline-traits v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpCe90PI)\nerror[E0583]: file not found for module `use_statement_types`\n  --> src/lib.rs:10:1\n   |\n10 | pub mod use_statement_types;\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = help: to create the module `use_statement_types`, create file \"src/use_statement_types.rs\" or \"src/use_statement_types/mod.rs\"\n   = note: if there is a `mod use_statement_types` elsewhere in the crate already, import it with `use crate::...` instead\n\nFor more information about this error, try `rustc --explain E0583`.\nerror: could not compile `pipeline-traits` (lib) due to 1 previous error\nwarning: build failed, waiting for other jobs to finish...\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "use anyhow::Result;\nuse std::path::PathBuf;\nuse std::pin::Pin;\nuse std::future::Future;\nuse std::boxed::Box;\nuse std::fmt::Debug;\nuse std::collections::HashMap;\nuse serde::{Deserialize, Serialize};\n\npub mod use_statement_types;\npub use use_statement_types::{\n    GitDetails, GitInfo, GitInfoTrait,\n    NixDetails, NixInfo, NixInfoTrait,\n    RustDetails, RustDetailsInfo, RustDetailsInfoTrait,\n    CargoDetails, CargoInfo, CargoInfoTrait,\n    SynDetails, SynInfo, SynInfoTrait,\n    LlvmDetails, LlvmInfo, LlvmInfoTrait,\n    LinuxDetails, LinuxInfo, LinuxInfoTrait,\n};\n\n#[derive(Debug)]\npub struct RawFile(pub String, pub String);\n#[derive(Clone)]\npub struct ParsedFile(pub String, pub PathBuf);\n#[derive(Debug)]\npub struct UseStatements(pub Vec<String>);\n#[derive(Debug)]\npub struct ClassifiedUseStatements(pub Vec<UseStatement>);\n#[derive(Debug, Clone)]\npub struct ValidatedFile(pub String, pub PathBuf);\n\n// Functors (as a trait)\npub trait PipelineFunctor<Input: Send + 'static, Output: Send + 'static> {\n    fn map<'writer>(\n        &'writer self,\n        writer: &'writer mut (impl tokio::io::AsyncWriteExt + Unpin + Send),\n        input: Input,\n    ) -> Pin<Box<dyn Future<Output = Result<Output>> + Send + 'writer>>;\n}\n\n#[derive(Debug)]\npub struct UseStatement {\n    pub statement: String,\n    pub error: Option<String>,\n    // Composed traits\n    pub git_details: Option<GitDetails>,\n    pub nix_details: Option<NixDetails>,\n    pub rust_details: Option<RustDetails>,\n    pub cargo_details: Option<CargoDetails>,\n    pub syn_details: Option<SynDetails>,\n    pub llvm_details: Option<LlvmDetails>,\n    pub linux_details: Option<LinuxDetails>,\n}\n\n/// Information about a variable found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct VariableInfo {\n    pub name: String,\n    pub type_name: String,\n    pub is_mutable: bool,\n    pub scope: String, // e.g., \"function\", \"module\", \"global\"\n}\n\n/// Information about a function found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct FunctionInfo {\n    pub name: String,\n    pub visibility: String, // e.g., \"public\", \"private\"\n    pub arg_count: u32,\n    pub arg_types: Vec<String>,\n    pub return_type: String,\n    pub is_async: bool,\n    pub is_unsafe: bool,\n    pub is_const: bool,\n}\n\n/// Information about an import statement found in the AST\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ImportInfo {\n    pub path: String, // The full path of the import (e.g., \"std::collections::HashMap\")\n    pub alias: Option<String>,\n    pub is_external: bool,\n    pub source_crate: Option<String>,\n    pub git_source_url: Option<String>,\n    pub git_branch: Option<String>,\n}\n\n/// Comprehensive AST analysis data for a Rust project\n#[derive(Debug, Clone, Serialize, Deserialize, Default)]\npub struct AstStatistics {\n    pub node_type_counts: HashMap<String, u32>,\n    pub variable_declarations: Vec<VariableInfo>,\n    pub function_definitions: Vec<FunctionInfo>,\n    pub import_statements: Vec<ImportInfo>,\n    // Add more fields as needed, e.g., macro invocations, struct definitions\n}\n",
    "timestamp": "2025-10-31T22:11:49.429308118Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/rust-decl-splitter/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 17 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling unicode-ident v1.0.22\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling memchr v2.7.6\n   Compiling same-file v1.0.6\n   Compiling lazy_static v1.5.0\n   Compiling walkdir v2.5.0\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling rust-decl-splitter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRhQ54O)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:1:1\n  |\n1 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `measurement`\n --> src/main.rs:2:1\n  |\n2 | mod measurement;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `measurement`, create file \"src/measurement.rs\" or \"src/measurement/mod.rs\"\n  = note: if there is a `mod measurement` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:146:64\n    |\n146 | ...                   .push_str(&format!(\"{}\\n\", quote! { # item }));\n    |                                                  ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:129:49\n    |\n129 | ...                   let impl_code = quote! {\n    |                                       ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:103:41\n    |\n103 | ...                   quote! {\n    |                       ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:93:59\n   |\n93 | ...                   let new_mod_content = quote! {\n   |                                             ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:81:37\n   |\n81 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:73:37\n   |\n73 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:65:37\n   |\n65 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:57:37\n   |\n57 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n --> src/main.rs:5:26\n  |\n5 | fn to_snake_case(ident: &Ident) -> String {\n  |                          ^^^^^ not found in this scope\n  |\nhelp: consider importing one of these structs\n  |\n3 + use proc_macro2::Ident;\n  |\n3 + use syn::Ident;\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `io`\n  --> src/main.rs:15:14\n   |\n15 | fn main() -> io::Result<()> {\n   |              ^^ use of unresolved module or unlinked crate `io`\n   |\n   = help: if you wanted to use a crate named `io`, use `cargo add io` to add it to your `Cargo.toml`\nhelp: a builtin type with a similar name exists\n   |\n15 - fn main() -> io::Result<()> {\n15 + fn main() -> i8::Result<()> {\n   |\nhelp: consider importing this module\n   |\n 3 + use std::io;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`\n  --> src/main.rs:16:29\n   |\n16 |     let args: Vec<String> = env::args().collect();\n   |                             ^^^ use of unresolved module or unlinked crate `env`\n   |\n   = help: if you wanted to use a crate named `env`, use `cargo add env` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::env;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:21:21\n   |\n21 |     let input_dir = PathBuf::from(&args[1]);\n   |                     ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 3 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:22:22\n   |\n22 |     let output_dir = PathBuf::from(&args[2]);\n   |                      ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 3 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:27:5\n   |\n27 |     fs::create_dir_all(&output_dir)?;\n   |     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `WalkDir`\n  --> src/main.rs:28:18\n   |\n28 |     for entry in WalkDir::new(&input_dir) {\n   |                  ^^^^^^^ use of undeclared type `WalkDir`\n   |\nhelp: consider importing this struct\n   |\n 3 + use walkdir::WalkDir;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:33:27\n   |\n33 |             let content = fs::read_to_string(path)?;\n   |                           ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Path`\n  --> src/main.rs:39:64\n   |\n39 |                         .join(relative_path.parent().unwrap_or(Path::new(\"\")));\n   |                                                                ^^^^ use of undeclared type `Path`\n   |\nhelp: consider importing one of these structs\n   |\n 3 + use std::path::Path;\n   |\n 3 + use syn::Path;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:40:21\n   |\n40 |                     fs::create_dir_all(&output_file_dir)?;\n   |                     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:44:29\n   |\n44 | ...                   Item::Fn(mut item_fn) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:62:29\n   |\n62 | ...                   Item::Struct(item_struct) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:70:29\n   |\n70 | ...                   Item::Enum(item_enum) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:78:29\n   |\n78 | ...                   Item::Trait(item_trait) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:86:29\n   |\n86 | ...                   Item::Mod(item_mod) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:96:37\n   |\n96 | ...                   fs::write(&new_mod_file_path, new_mod_content.to_string())?;\n   |                       ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n   --> src/main.rs:109:29\n    |\n109 | ...                   Item::Impl(item_impl) => {\n    |                       ^^^^ use of undeclared type `Item`\n    |\nhelp: consider importing this enum\n    |\n  3 + use syn::Item;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n   --> src/main.rs:117:64\n    |\n117 | ...                   .unwrap_or_else(|| Ident::new(\"unknown\", item_impl.span()))\n    |                                          ^^^^^ use of undeclared type `Ident`\n    |\nhelp: consider importing one of these structs\n    |\n  3 + use proc_macro2::Ident;\n    |\n  3 + use syn::Ident;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n   --> src/main.rs:119:42\n    |\n119 | ...                   _ => Ident::new(\"unknown\", item_impl.span()),\n    |                            ^^^^^ use of undeclared type `Ident`\n    |\nhelp: consider importing one of these structs\n    |\n  3 + use proc_macro2::Ident;\n    |\n  3 + use syn::Ident;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:132:60\n    |\n132 | ...                   let mut existing_content = fs::read_to_string(\n    |                                                  ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:138:33\n    |\n138 | ...                   fs::write(&target_file_path, existing_content)?;\n    |                       ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n   --> src/main.rs:141:29\n    |\n141 | ...                   Item::Use(_item_use) => {\n    |                       ^^^^ use of undeclared type `Item`\n    |\nhelp: consider importing this enum\n    |\n  3 + use syn::Item;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:160:25\n    |\n160 |                         fs::create_dir_all(&function_output_dir)?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:163:25\n    |\n163 |                         fs::create_dir_all(&rollup_data_dir)?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:170:25\n    |\n170 |                         fs::write(&wrapped_code_path, new_file_content)?; // Save as wrapped_code.rs\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:173:25\n    |\n173 |                         fs::write(&new_file_path, format!(\"pub use {}::{};\\n\", snake_case_name, ident))?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:180:21\n    |\n180 |                     fs::write(&original_output_path, original_file_content)?;\n    |                     ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:3:5\n  |\n3 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nSome errors have detailed explanations: E0412, E0433, E0583.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `rust-decl-splitter` (bin \"rust-decl-splitter\") generated 1 warning\nerror: could not compile `rust-decl-splitter` (bin \"rust-decl-splitter\") due to 37 previous errors; 1 warning emitted\n\nStdout: #![feature(prelude_import)]\n#[macro_use]\nextern crate std;\n#[prelude_import]\nuse std::prelude::rust_2024::*;\npub mod prelude {}\nmod measurement {}\nuse crate::prelude::*;\nuse syn::parse_quote;\nfn to_snake_case(ident: &Ident) -> String {\n    let mut s = String::new();\n    for (i, char) in ident.to_string().chars().enumerate() {\n        if char.is_uppercase() && i != 0 { s.push('_'); }\n        s.push(char.to_ascii_lowercase());\n    }\n    s\n}\nfn main() -> io::Result<()> {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n\n        // Directory for this function\n\n        // rollup_data inside function dir\n\n\n        // Save as wrapped_code.rs\n\n        // The original file now just re-exports from the function's directory\n        {\n            ::std::io::_eprint(format_args!(\"Usage: {0} <input_directory> <output_directory>\\n\",\n                    args[0]));\n        };\n        return Ok(());\n    }\n    let input_dir = PathBuf::from(&args[1]);\n    let output_dir = PathBuf::from(&args[2]);\n    if !input_dir.is_dir() {\n        {\n            ::std::io::_eprint(format_args!(\"Error: Input directory does not exist or is not a directory.\\n\"));\n        };\n        return Ok(());\n    }\n    fs::create_dir_all(&output_dir)?;\n    for entry in WalkDir::new(&input_dir) {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() && path.extension().map_or(false, |ext| ext == \"rs\")\n            {\n            {\n                ::std::io::_print(format_args!(\"Processing file: {0}\\n\",\n                        path.display()));\n            };\n            let content = fs::read_to_string(path)?;\n            match syn::parse_file(&content) {\n                Ok(file) => {\n                    {\n                        ::std::io::_print(format_args!(\"Successfully parsed: {0}\\n\",\n                                path.display()));\n                    };\n                    let relative_path = path.strip_prefix(&input_dir).unwrap();\n                    let output_file_dir =\n                        output_dir.join(relative_path.parent().unwrap_or(Path::new(\"\")));\n                    fs::create_dir_all(&output_file_dir)?;\n                    let mut original_file_content = String::new();\n                    for item in file.items {\n                        let (ident, item_code) =\n                            match item {\n                                Item::Fn(mut item_fn) => {\n                                    let original_block = item_fn.block;\n                                    let fn_ident = item_fn.sig.ident.clone();\n                                    item_fn.block =\n                                        ::syn::__private::parse_quote({\n                                                let mut _s = ::quote::__private::TokenStream::new();\n                                                ::quote::__private::push_group(&mut _s,\n                                                    ::quote::__private::Delimiter::Brace,\n                                                    {\n                                                        let mut _s = ::quote::__private::TokenStream::new();\n                                                        ::quote::__private::push_ident(&mut _s, \"measurement\");\n                                                        ::quote::__private::push_colon2(&mut _s);\n                                                        ::quote::__private::push_ident(&mut _s,\n                                                            \"record_function_entry\");\n                                                        ::quote::__private::push_group(&mut _s,\n                                                            ::quote::__private::Delimiter::Parenthesis,\n                                                            {\n                                                                let mut _s = ::quote::__private::TokenStream::new();\n                                                                ::quote::__private::push_ident(&mut _s, \"stringify\");\n                                                                ::quote::__private::push_bang(&mut _s);\n                                                                ::quote::__private::push_group(&mut _s,\n                                                                    ::quote::__private::Delimiter::Parenthesis,\n                                                                    {\n                                                                        let mut _s = ::quote::__private::TokenStream::new();\n                                                                        ::quote::ToTokens::to_tokens(&fn_ident, &mut _s);\n                                                                        _s\n                                                                    });\n                                                                _s\n                                                            });\n                                                        ::quote::__private::push_semi(&mut _s);\n                                                        ::quote::__private::push_ident(&mut _s, \"let\");\n                                                        ::quote::__private::push_ident(&mut _s, \"__result\");\n                                                        ::quote::__private::push_eq(&mut _s);\n                                                        ::quote::ToTokens::to_tokens(&original_block, &mut _s);\n                                                        ::quote::__private::push_semi(&mut _s);\n                                                        ::quote::__private::push_ident(&mut _s, \"measurement\");\n                                                        ::quote::__private::push_colon2(&mut _s);\n                                                        ::quote::__private::push_ident(&mut _s,\n                                                            \"record_function_exit\");\n                                                        ::quote::__private::push_group(&mut _s,\n                                                            ::quote::__private::Delimiter::Parenthesis,\n                                                            {\n                                                                let mut _s = ::quote::__private::TokenStream::new();\n                                                                ::quote::__private::push_ident(&mut _s, \"stringify\");\n                                                                ::quote::__private::push_bang(&mut _s);\n                                                                ::quote::__private::push_group(&mut _s,\n                                                                    ::quote::__private::Delimiter::Parenthesis,\n                                                                    {\n                                                                        let mut _s = ::quote::__private::TokenStream::new();\n                                                                        ::quote::ToTokens::to_tokens(&fn_ident, &mut _s);\n                                                                        _s\n                                                                    });\n                                                                _s\n                                                            });\n                                                        ::quote::__private::push_semi(&mut _s);\n                                                        ::quote::__private::push_ident(&mut _s, \"__result\");\n                                                        _s\n                                                    });\n                                                _s\n                                            });\n                                    (fn_ident, (/*ERROR*/))\n                                }\n                                Item::Struct(item_struct) => {\n                                    (item_struct.ident.clone(), (/*ERROR*/))\n                                }\n                                Item::Enum(item_enum) => {\n                                    (item_enum.ident.clone(), (/*ERROR*/))\n                                }\n                                Item::Trait(item_trait) => {\n                                    (item_trait.ident.clone(), (/*ERROR*/))\n                                }\n                                Item::Mod(item_mod) => {\n                                    let original_item_mod = item_mod.clone();\n                                    if original_item_mod.content.is_some() {\n                                        let mod_ident = original_item_mod.ident.clone();\n                                        let mod_name_snake = to_snake_case(&mod_ident);\n                                        let new_mod_file_path =\n                                            output_file_dir.join(::alloc::__export::must_use({\n                                                        ::alloc::fmt::format(format_args!(\"{0}.rs\", mod_name_snake))\n                                                    }));\n                                        let new_mod_content = (/*ERROR*/);\n                                        fs::write(&new_mod_file_path, new_mod_content.to_string())?;\n                                        original_file_content.push_str(&::alloc::__export::must_use({\n                                                        ::alloc::fmt::format(format_args!(\"pub mod {0};\\n\",\n                                                                mod_name_snake))\n                                                    }));\n                                        continue;\n                                    } else { (original_item_mod.ident.clone(), (/*ERROR*/)) }\n                                }\n                                Item::Impl(item_impl) => {\n                                    let target_ident =\n                                        match &*item_impl.self_ty {\n                                            syn::Type::Path(type_path) => {\n                                                type_path.path.segments.last().map(|segment|\n                                                            segment.ident.clone()).unwrap_or_else(||\n                                                        Ident::new(\"unknown\", item_impl.span()))\n                                            }\n                                            _ => Ident::new(\"unknown\", item_impl.span()),\n                                        };\n                                    let snake_case_name = to_snake_case(&target_ident);\n                                    let target_file_name =\n                                        ::alloc::__export::must_use({\n                                                ::alloc::fmt::format(format_args!(\"{0}.rs\",\n                                                        snake_case_name))\n                                            });\n                                    let target_file_path =\n                                        output_file_dir.join(&target_file_name);\n                                    {\n                                        ::std::io::_print(format_args!(\"  Moving impl block for {0} to {1}\\n\",\n                                                target_ident, target_file_path.display()));\n                                    };\n                                    let impl_code = (/*ERROR*/);\n                                    let mut existing_content =\n                                        fs::read_to_string(&target_file_path).unwrap_or_default();\n                                    existing_content.push_str(&::alloc::__export::must_use({\n                                                    ::alloc::fmt::format(format_args!(\"\\n{0}\\n\",\n                                                            impl_code.to_string()))\n                                                }));\n                                    fs::write(&target_file_path, existing_content)?;\n                                    continue;\n                                }\n                                Item::Use(_item_use) => { continue; }\n                                _ => {\n                                    original_file_content.push_str(&::alloc::__export::must_use({\n                                                    ::alloc::fmt::format(format_args!(\"{0}\\n\", (/*ERROR*/)))\n                                                }));\n                                    continue;\n                                }\n                            };\n                        let snake_case_name = to_snake_case(&ident);\n                        let new_file_name =\n                            ::alloc::__export::must_use({\n                                    ::alloc::fmt::format(format_args!(\"{0}.rs\",\n                                            snake_case_name))\n                                });\n                        let new_file_path = output_file_dir.join(&new_file_name);\n                        {\n                            ::std::io::_print(format_args!(\"  Splitting {0} into {1}\\n\",\n                                    ident, new_file_path.display()));\n                        };\n                        let new_file_name =\n                            ::alloc::__export::must_use({\n                                    ::alloc::fmt::format(format_args!(\"{0}.rs\",\n                                            snake_case_name))\n                                });\n                        let new_file_path = output_file_dir.join(&new_file_name);\n                        let function_output_dir =\n                            output_file_dir.join(&snake_case_name);\n                        fs::create_dir_all(&function_output_dir)?;\n                        let rollup_data_dir =\n                            function_output_dir.join(\"rollup_data\");\n                        fs::create_dir_all(&rollup_data_dir)?;\n                        let wrapped_code_path =\n                            rollup_data_dir.join(\"wrapped_code.rs\");\n                        let mut new_file_content = String::new();\n                        new_file_content.push_str(\"use prelude::*;\\n\");\n                        new_file_content.push_str(&item_code.to_string());\n                        fs::write(&wrapped_code_path, new_file_content)?;\n                        fs::write(&new_file_path,\n                                ::alloc::__export::must_use({\n                                        ::alloc::fmt::format(format_args!(\"pub use {0}::{1};\\n\",\n                                                snake_case_name, ident))\n                                    }))?;\n                        original_file_content.push_str(&::alloc::__export::must_use({\n                                        ::alloc::fmt::format(format_args!(\"pub use {0}::{1};\\n\",\n                                                snake_case_name, ident))\n                                    }));\n                    }\n                    let original_output_path = output_dir.join(relative_path);\n                    fs::write(&original_output_path, original_file_content)?;\n                }\n                Err(e) => {\n                    {\n                        ::std::io::_eprint(format_args!(\"Error parsing {0}: {1}\\n\",\n                                path.display(), e));\n                    };\n                }\n            }\n        }\n    }\n    Ok(())\n}\n\nStderr:     Updating crates.io index\n     Locking 17 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling unicode-ident v1.0.22\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling serde_core v1.0.228\n   Compiling serde v1.0.228\n   Compiling serde_json v1.0.145\n   Compiling itoa v1.0.15\n   Compiling ryu v1.0.20\n   Compiling memchr v2.7.6\n   Compiling same-file v1.0.6\n   Compiling lazy_static v1.5.0\n   Compiling walkdir v2.5.0\n   Compiling syn v2.0.108\n   Compiling serde_derive v1.0.228\n   Compiling rust-decl-splitter v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpRhQ54O)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:1:1\n  |\n1 | pub mod prelude;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `measurement`\n --> src/main.rs:2:1\n  |\n2 | mod measurement;\n  | ^^^^^^^^^^^^^^^^\n  |\n  = help: to create the module `measurement`, create file \"src/measurement.rs\" or \"src/measurement/mod.rs\"\n  = note: if there is a `mod measurement` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:146:64\n    |\n146 | ...                   .push_str(&format!(\"{}\\n\", quote! { # item }));\n    |                                                  ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:129:49\n    |\n129 | ...                   let impl_code = quote! {\n    |                                       ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n   --> src/main.rs:103:41\n    |\n103 | ...                   quote! {\n    |                       ^^^^^\n    |\n    = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n    |\n  3 + use quote::quote;\n    |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:93:59\n   |\n93 | ...                   let new_mod_content = quote! {\n   |                                             ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:81:37\n   |\n81 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:73:37\n   |\n73 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:65:37\n   |\n65 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror: cannot find macro `quote` in this scope\n  --> src/main.rs:57:37\n   |\n57 | ...                   quote! {\n   |                       ^^^^^\n   |\n   = note: `quote` is in scope, but it is a crate, not a macro\nhelp: consider importing this macro\n   |\n 3 + use quote::quote;\n   |\n\nerror[E0412]: cannot find type `Ident` in this scope\n --> src/main.rs:5:26\n  |\n5 | fn to_snake_case(ident: &Ident) -> String {\n  |                          ^^^^^ not found in this scope\n  |\nhelp: consider importing one of these structs\n  |\n3 + use proc_macro2::Ident;\n  |\n3 + use syn::Ident;\n  |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `io`\n  --> src/main.rs:15:14\n   |\n15 | fn main() -> io::Result<()> {\n   |              ^^ use of unresolved module or unlinked crate `io`\n   |\n   = help: if you wanted to use a crate named `io`, use `cargo add io` to add it to your `Cargo.toml`\nhelp: a builtin type with a similar name exists\n   |\n15 - fn main() -> io::Result<()> {\n15 + fn main() -> i8::Result<()> {\n   |\nhelp: consider importing this module\n   |\n 3 + use std::io;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `env`\n  --> src/main.rs:16:29\n   |\n16 |     let args: Vec<String> = env::args().collect();\n   |                             ^^^ use of unresolved module or unlinked crate `env`\n   |\n   = help: if you wanted to use a crate named `env`, use `cargo add env` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::env;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:21:21\n   |\n21 |     let input_dir = PathBuf::from(&args[1]);\n   |                     ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 3 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `PathBuf`\n  --> src/main.rs:22:22\n   |\n22 |     let output_dir = PathBuf::from(&args[2]);\n   |                      ^^^^^^^ use of undeclared type `PathBuf`\n   |\nhelp: consider importing this struct\n   |\n 3 + use std::path::PathBuf;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:27:5\n   |\n27 |     fs::create_dir_all(&output_dir)?;\n   |     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `WalkDir`\n  --> src/main.rs:28:18\n   |\n28 |     for entry in WalkDir::new(&input_dir) {\n   |                  ^^^^^^^ use of undeclared type `WalkDir`\n   |\nhelp: consider importing this struct\n   |\n 3 + use walkdir::WalkDir;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:33:27\n   |\n33 |             let content = fs::read_to_string(path)?;\n   |                           ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Path`\n  --> src/main.rs:39:64\n   |\n39 |                         .join(relative_path.parent().unwrap_or(Path::new(\"\")));\n   |                                                                ^^^^ use of undeclared type `Path`\n   |\nhelp: consider importing one of these structs\n   |\n 3 + use std::path::Path;\n   |\n 3 + use syn::Path;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:40:21\n   |\n40 |                     fs::create_dir_all(&output_file_dir)?;\n   |                     ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:44:29\n   |\n44 | ...                   Item::Fn(mut item_fn) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:62:29\n   |\n62 | ...                   Item::Struct(item_struct) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:70:29\n   |\n70 | ...                   Item::Enum(item_enum) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:78:29\n   |\n78 | ...                   Item::Trait(item_trait) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n  --> src/main.rs:86:29\n   |\n86 | ...                   Item::Mod(item_mod) => {\n   |                       ^^^^ use of undeclared type `Item`\n   |\nhelp: consider importing this enum\n   |\n 3 + use syn::Item;\n   |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n  --> src/main.rs:96:37\n   |\n96 | ...                   fs::write(&new_mod_file_path, new_mod_content.to_string())?;\n   |                       ^^ use of unresolved module or unlinked crate `fs`\n   |\n   = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n   |\n 3 + use std::fs;\n   |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n   --> src/main.rs:109:29\n    |\n109 | ...                   Item::Impl(item_impl) => {\n    |                       ^^^^ use of undeclared type `Item`\n    |\nhelp: consider importing this enum\n    |\n  3 + use syn::Item;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n   --> src/main.rs:117:64\n    |\n117 | ...                   .unwrap_or_else(|| Ident::new(\"unknown\", item_impl.span()))\n    |                                          ^^^^^ use of undeclared type `Ident`\n    |\nhelp: consider importing one of these structs\n    |\n  3 + use proc_macro2::Ident;\n    |\n  3 + use syn::Ident;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Ident`\n   --> src/main.rs:119:42\n    |\n119 | ...                   _ => Ident::new(\"unknown\", item_impl.span()),\n    |                            ^^^^^ use of undeclared type `Ident`\n    |\nhelp: consider importing one of these structs\n    |\n  3 + use proc_macro2::Ident;\n    |\n  3 + use syn::Ident;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:132:60\n    |\n132 | ...                   let mut existing_content = fs::read_to_string(\n    |                                                  ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:138:33\n    |\n138 | ...                   fs::write(&target_file_path, existing_content)?;\n    |                       ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Item`\n   --> src/main.rs:141:29\n    |\n141 | ...                   Item::Use(_item_use) => {\n    |                       ^^^^ use of undeclared type `Item`\n    |\nhelp: consider importing this enum\n    |\n  3 + use syn::Item;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:160:25\n    |\n160 |                         fs::create_dir_all(&function_output_dir)?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:163:25\n    |\n163 |                         fs::create_dir_all(&rollup_data_dir)?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:170:25\n    |\n170 |                         fs::write(&wrapped_code_path, new_file_content)?; // Save as wrapped_code.rs\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:173:25\n    |\n173 |                         fs::write(&new_file_path, format!(\"pub use {}::{};\\n\", snake_case_name, ident))?;\n    |                         ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nerror[E0433]: failed to resolve: use of unresolved module or unlinked crate `fs`\n   --> src/main.rs:180:21\n    |\n180 |                     fs::write(&original_output_path, original_file_content)?;\n    |                     ^^ use of unresolved module or unlinked crate `fs`\n    |\n    = help: if you wanted to use a crate named `fs`, use `cargo add fs` to add it to your `Cargo.toml`\nhelp: consider importing this module\n    |\n  3 + use std::fs;\n    |\n\nwarning: unused import: `crate::prelude::*`\n --> src/main.rs:3:5\n  |\n3 | use crate::prelude::*;\n  |     ^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\nSome errors have detailed explanations: E0412, E0433, E0583.\nFor more information about an error, try `rustc --explain E0412`.\nwarning: `rust-decl-splitter` (bin \"rust-decl-splitter\") generated 1 warning\nerror: could not compile `rust-decl-splitter` (bin \"rust-decl-splitter\") due to 37 previous errors; 1 warning emitted\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "pub mod prelude;\nmod measurement;\nuse crate::prelude::*;\nuse syn::parse_quote;\nfn to_snake_case(ident: &Ident) -> String {\n    let mut s = String::new();\n    for (i, char) in ident.to_string().chars().enumerate() {\n        if char.is_uppercase() && i != 0 {\n            s.push('_');\n        }\n        s.push(char.to_ascii_lowercase());\n    }\n    s\n}\nfn main() -> io::Result<()> {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 3 {\n        eprintln!(\"Usage: {} <input_directory> <output_directory>\", args[0]);\n        return Ok(());\n    }\n    let input_dir = PathBuf::from(&args[1]);\n    let output_dir = PathBuf::from(&args[2]);\n    if !input_dir.is_dir() {\n        eprintln!(\"Error: Input directory does not exist or is not a directory.\");\n        return Ok(());\n    }\n    fs::create_dir_all(&output_dir)?;\n    for entry in WalkDir::new(&input_dir) {\n        let entry = entry?;\n        let path = entry.path();\n        if path.is_file() && path.extension().map_or(false, |ext| ext == \"rs\") {\n            println!(\"Processing file: {}\", path.display());\n            let content = fs::read_to_string(path)?;\n            match syn::parse_file(&content) {\n                Ok(file) => {\n                    println!(\"Successfully parsed: {}\", path.display());\n                    let relative_path = path.strip_prefix(&input_dir).unwrap();\n                    let output_file_dir = output_dir\n                        .join(relative_path.parent().unwrap_or(Path::new(\"\")));\n                    fs::create_dir_all(&output_file_dir)?;\n                    let mut original_file_content = String::new();\n                    for item in file.items {\n                        let (ident, item_code) = match item {\n                            Item::Fn(mut item_fn) => {\n                                let original_block = item_fn.block;\n                                let fn_ident = item_fn.sig.ident.clone();\n                                item_fn.block = parse_quote! {\n                                    {\n                                        measurement::record_function_entry(stringify!(#fn_ident));\n                                        let __result = #original_block;\n                                        measurement::record_function_exit(stringify!(#fn_ident));\n                                        __result\n                                    }\n                                };\n                                (\n                                    fn_ident,\n                                    quote! {\n                                        #item_fn\n                                    },\n                                )\n                            }\n                            Item::Struct(item_struct) => {\n                                (\n                                    item_struct.ident.clone(),\n                                    quote! {\n                                        # item_struct\n                                    },\n                                )\n                            }\n                            Item::Enum(item_enum) => {\n                                (\n                                    item_enum.ident.clone(),\n                                    quote! {\n                                        # item_enum\n                                    },\n                                )\n                            }\n                            Item::Trait(item_trait) => {\n                                (\n                                    item_trait.ident.clone(),\n                                    quote! {\n                                        # item_trait\n                                    },\n                                )\n                            }\n                            Item::Mod(item_mod) => {\n                                let original_item_mod = item_mod.clone();\n                                if original_item_mod.content.is_some() {\n                                    let mod_ident = original_item_mod.ident.clone();\n                                    let mod_name_snake = to_snake_case(&mod_ident);\n                                    let new_mod_file_path = output_file_dir\n                                        .join(format!(\"{}.rs\", mod_name_snake));\n                                    let new_mod_content = quote! {\n                                        # original_item_mod\n                                    };\n                                    fs::write(&new_mod_file_path, new_mod_content.to_string())?;\n                                    original_file_content\n                                        .push_str(&format!(\"pub mod {};\\n\", mod_name_snake));\n                                    continue;\n                                } else {\n                                    (\n                                        original_item_mod.ident.clone(),\n                                        quote! {\n                                            # original_item_mod\n                                        },\n                                    )\n                                }\n                            }\n                            Item::Impl(item_impl) => {\n                                let target_ident = match &*item_impl.self_ty {\n                                    syn::Type::Path(type_path) => {\n                                        type_path\n                                            .path\n                                            .segments\n                                            .last()\n                                            .map(|segment| segment.ident.clone())\n                                            .unwrap_or_else(|| Ident::new(\"unknown\", item_impl.span()))\n                                    }\n                                    _ => Ident::new(\"unknown\", item_impl.span()),\n                                };\n                                let snake_case_name = to_snake_case(&target_ident);\n                                let target_file_name = format!(\"{}.rs\", snake_case_name);\n                                let target_file_path = output_file_dir\n                                    .join(&target_file_name);\n                                println!(\n                                    \"  Moving impl block for {} to {}\", target_ident,\n                                    target_file_path.display()\n                                );\n                                let impl_code = quote! {\n                                    # item_impl\n                                };\n                                let mut existing_content = fs::read_to_string(\n                                        &target_file_path,\n                                    )\n                                    .unwrap_or_default();\n                                existing_content\n                                    .push_str(&format!(\"\\n{}\\n\", impl_code.to_string()));\n                                fs::write(&target_file_path, existing_content)?;\n                                continue;\n                            }\n                            Item::Use(_item_use) => {\n                                continue;\n                            }\n                            _ => {\n                                original_file_content\n                                    .push_str(&format!(\"{}\\n\", quote! { # item }));\n                                continue;\n                            }\n                        };\n                        let snake_case_name = to_snake_case(&ident);\n                        let new_file_name = format!(\"{}.rs\", snake_case_name);\n                        let new_file_path = output_file_dir.join(&new_file_name);\n                        println!(\n                            \"  Splitting {} into {}\", ident, new_file_path.display()\n                        );\n                        let new_file_name = format!(\"{}.rs\", snake_case_name);\n                        let new_file_path = output_file_dir.join(&new_file_name);\n\n                        let function_output_dir = output_file_dir.join(&snake_case_name); // Directory for this function\n                        fs::create_dir_all(&function_output_dir)?;\n\n                        let rollup_data_dir = function_output_dir.join(\"rollup_data\"); // rollup_data inside function dir\n                        fs::create_dir_all(&rollup_data_dir)?;\n\n                        let wrapped_code_path = rollup_data_dir.join(\"wrapped_code.rs\");\n\n                        let mut new_file_content = String::new();\n                        new_file_content.push_str(\"use prelude::*;\\n\");\n                        new_file_content.push_str(&item_code.to_string());\n                        fs::write(&wrapped_code_path, new_file_content)?; // Save as wrapped_code.rs\n\n                        // The original file now just re-exports from the function's directory\n                        fs::write(&new_file_path, format!(\"pub use {}::{};\\n\", snake_case_name, ident))?;\n                        original_file_content\n                            .push_str(\n                                &format!(\"pub use {}::{};\\n\", snake_case_name, ident),\n                            );\n                    }\n                    let original_output_path = output_dir.join(relative_path);\n                    fs::write(&original_output_path, original_file_content)?;\n                }\n                Err(e) => {\n                    eprintln!(\"Error parsing {}: {}\", path.display(), e);\n                }\n            }\n        }\n    }\n    Ok(())\n}\n",
    "timestamp": "2025-10-31T22:12:05.119152175Z",
    "context": null
  },
  {
    "file_path": "/data/data/com.termux.nix/files/home/pick-up-nix2/vendor/rust/platform-tools-agave-rust-solana/vendor/rust-src/vendor/rust/rust-bootstrap-nix/rust-system-composer/src/main.rs",
    "rustc_version": "1.92.0-nightly",
    "rustc_host": "aarch64-unknown-linux-gnu",
    "error_message": "rustc macro expansion failed:     Updating crates.io index\n     Locking 35 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling utf8parse v0.2.2\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling anyhow v1.0.100\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling heck v0.5.0\n   Compiling same-file v1.0.6\n   Compiling walkdir v2.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling rust-system-composer v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpMQs32E)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:1:1\n  |\n1 | mod prelude;\n  | ^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `args`\n --> src/main.rs:2:1\n  |\n2 | mod args;\n  | ^^^^^^^^^\n  |\n  = help: to create the module `args`, create file \"src/args.rs\" or \"src/args/mod.rs\"\n  = note: if there is a `mod args` elsewhere in the crate already, import it with `use crate::...` instead\n\nFor more information about this error, try `rustc --explain E0583`.\nerror: could not compile `rust-system-composer` (bin \"rust-system-composer\") due to 2 previous errors\n\nStdout: #![feature(prelude_import)]\n#[macro_use]\nextern crate std;\n#[prelude_import]\nuse std::prelude::rust_2024::*;\nmod prelude {}\nmod args {}\n\nfn main() {\n    // You can use items from prelude and args here, e.g.:\n    // let args = args::Args::parse();\n    // prelude::some_function();\n    {\n        ::std::io::_print(format_args!(\"Hello from rust-system-composer!\\n\"));\n    };\n}\n\nStderr:     Updating crates.io index\n     Locking 35 packages to latest Rust 1.92.0-nightly compatible versions\n   Compiling proc-macro2 v1.0.103\n   Compiling quote v1.0.41\n   Compiling unicode-ident v1.0.22\n   Compiling utf8parse v0.2.2\n   Compiling is_terminal_polyfill v1.70.2\n   Compiling anstyle-query v1.1.4\n   Compiling anstyle v1.0.13\n   Compiling colorchoice v1.0.4\n   Compiling anstyle-parse v0.2.7\n   Compiling strsim v0.11.1\n   Compiling anyhow v1.0.100\n   Compiling clap_lex v0.7.6\n   Compiling anstream v0.6.21\n   Compiling heck v0.5.0\n   Compiling same-file v1.0.6\n   Compiling walkdir v2.5.0\n   Compiling clap_builder v4.5.51\n   Compiling syn v2.0.108\n   Compiling clap_derive v4.5.49\n   Compiling clap v4.5.51\n   Compiling rust-system-composer v0.1.0 (/data/data/com.termux.nix/files/usr/tmp/nix-shell.nQ2DUL/nix-shell.maqakg/nix-shell.HHQDUs/nix-shell.bDbF0S/nix-shell.c2e2z4/.tmpMQs32E)\nerror[E0583]: file not found for module `prelude`\n --> src/main.rs:1:1\n  |\n1 | mod prelude;\n  | ^^^^^^^^^^^^\n  |\n  = help: to create the module `prelude`, create file \"src/prelude.rs\" or \"src/prelude/mod.rs\"\n  = note: if there is a `mod prelude` elsewhere in the crate already, import it with `use crate::...` instead\n\nerror[E0583]: file not found for module `args`\n --> src/main.rs:2:1\n  |\n2 | mod args;\n  | ^^^^^^^^^\n  |\n  = help: to create the module `args`, create file \"src/args.rs\" or \"src/args/mod.rs\"\n  = note: if there is a `mod args` elsewhere in the crate already, import it with `use crate::...` instead\n\nFor more information about this error, try `rustc --explain E0583`.\nerror: could not compile `rust-system-composer` (bin \"rust-system-composer\") due to 2 previous errors\n",
    "error_type": "MacroExpansionFailed",
    "code_snippet": "mod prelude;\nmod args;\n\nfn main() {\n    println!(\"Hello from rust-system-composer!\");\n    // You can use items from prelude and args here, e.g.:\n    // let args = args::Args::parse();\n    // prelude::some_function();\n}",
    "timestamp": "2025-10-31T22:12:17.779546597Z",
    "context": null
  }
]