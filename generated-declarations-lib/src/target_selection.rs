pub mod target_selection { use std :: fmt ; use build_helper :: prelude :: * ; use crate :: LlvmLibunwind ; use crate :: SplitDebuginfo ; use crate :: StringOrBool ; pub struct TargetSelection { pub triple : String , file : Option < String > , synthetic : bool , } # [automatically_derived] impl :: core :: clone :: Clone for TargetSelection { # [inline] fn clone (& self) -> TargetSelection { TargetSelection { triple : :: core :: clone :: Clone :: clone (& self . triple) , file : :: core :: clone :: Clone :: clone (& self . file) , synthetic : :: core :: clone :: Clone :: clone (& self . synthetic) , } } } # [automatically_derived] impl :: core :: default :: Default for TargetSelection { # [inline] fn default () -> TargetSelection { TargetSelection { triple : :: core :: default :: Default :: default () , file : :: core :: default :: Default :: default () , synthetic : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for TargetSelection { } # [automatically_derived] impl :: core :: cmp :: PartialEq for TargetSelection { # [inline] fn eq (& self , other : & TargetSelection) -> bool { self . synthetic == other . synthetic && self . triple == other . triple && self . file == other . file } } # [automatically_derived] impl :: core :: cmp :: Eq for TargetSelection { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < String > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < String > > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for TargetSelection { # [inline] fn partial_cmp (& self , other : & TargetSelection ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { match :: core :: cmp :: PartialOrd :: partial_cmp (& self . triple , & other . triple) { :: core :: option :: Option :: Some (:: core :: cmp :: Ordering :: Equal) => { match :: core :: cmp :: PartialOrd :: partial_cmp (& self . file , & other . file) { :: core :: option :: Option :: Some (:: core :: cmp :: Ordering :: Equal) => { :: core :: cmp :: PartialOrd :: partial_cmp (& self . synthetic , & other . synthetic ,) } cmp => cmp , } } cmp => cmp , } } } # [automatically_derived] impl :: core :: cmp :: Ord for TargetSelection { # [inline] fn cmp (& self , other : & TargetSelection) -> :: core :: cmp :: Ordering { match :: core :: cmp :: Ord :: cmp (& self . triple , & other . triple) { :: core :: cmp :: Ordering :: Equal => { match :: core :: cmp :: Ord :: cmp (& self . file , & other . file) { :: core :: cmp :: Ordering :: Equal => { :: core :: cmp :: Ord :: cmp (& self . synthetic , & other . synthetic) } cmp => cmp , } } cmp => cmp , } } } # [automatically_derived] impl :: core :: hash :: Hash for TargetSelection { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . triple , state) ; :: core :: hash :: Hash :: hash (& self . file , state) ; :: core :: hash :: Hash :: hash (& self . synthetic , state) } } # [doc = " Newtype over `Vec<TargetSelection>` so we can implement custom parsing logic"] pub struct TargetSelectionList (pub Vec < TargetSelection >) ; # [automatically_derived] impl :: core :: clone :: Clone for TargetSelectionList { # [inline] fn clone (& self) -> TargetSelectionList { TargetSelectionList (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: default :: Default for TargetSelectionList { # [inline] fn default () -> TargetSelectionList { TargetSelectionList (:: core :: default :: Default :: default ()) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for TargetSelectionList { } # [automatically_derived] impl :: core :: cmp :: PartialEq for TargetSelectionList { # [inline] fn eq (& self , other : & TargetSelectionList) -> bool { self . 0 == other . 0 } } # [automatically_derived] impl :: core :: cmp :: Eq for TargetSelectionList { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < Vec < TargetSelection > > ; } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for TargetSelectionList { # [inline] fn partial_cmp (& self , other : & TargetSelectionList ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { :: core :: cmp :: PartialOrd :: partial_cmp (& self . 0 , & other . 0) } } # [automatically_derived] impl :: core :: cmp :: Ord for TargetSelectionList { # [inline] fn cmp (& self , other : & TargetSelectionList) -> :: core :: cmp :: Ordering { :: core :: cmp :: Ord :: cmp (& self . 0 , & other . 0) } } # [automatically_derived] impl :: core :: hash :: Hash for TargetSelectionList { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . 0 , state) } } # [automatically_derived] impl :: core :: fmt :: Debug for TargetSelectionList { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "TargetSelectionList" , & & self . 0 ,) } } pub fn target_selection_list (s : & str) -> Result < TargetSelectionList , String > { Ok (TargetSelectionList (s . split (',') . filter (| s | ! s . is_empty ()) . map (TargetSelection :: from_user) . collect () ,) ,) } impl TargetSelection { pub fn from_user (selection : & str) -> Self { let path = Path :: new (selection) ; let (triple , file) = if path . exists () { let triple = path . file_stem () . expect ("Target specification file has no file stem") . to_str () . expect ("Target specification file stem is not UTF-8") ; (triple , Some (selection)) } else { (selection , None) } ; Self { triple : triple . to_string () , file : file . map (| s | s . to_string ()) , synthetic : false , } } pub fn create_synthetic (triple : & str , file : & str) -> Self { Self { triple : triple . to_string () , file : Some (file . to_string ()) , synthetic : true , } } pub fn rustc_target_arg (& self) -> & str { self . file . as_ref () . unwrap_or (& self . triple) } pub fn contains (& self , needle : & str) -> bool { self . triple . contains (needle) } pub fn starts_with (& self , needle : & str) -> bool { self . triple . starts_with (needle) } pub fn ends_with (& self , needle : & str) -> bool { self . triple . ends_with (needle) } pub fn is_synthetic (& self) -> bool { self . synthetic } pub fn is_msvc (& self) -> bool { self . contains ("msvc") } pub fn is_windows (& self) -> bool { self . contains ("windows") } pub fn is_windows_gnu (& self) -> bool { self . ends_with ("windows-gnu") } # [doc = " Path to the file defining the custom target, if any."] pub fn filepath (& self) -> Option < & Path > { self . file . as_ref () . map (Path :: new) } } impl fmt :: Display for TargetSelection { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . write_fmt (format_args ! ("{0}" , self . triple)) ? ; if let Some (file) = & self . file { f . write_fmt (format_args ! ("({0})" , file)) ? ; } Ok (()) } } impl fmt :: Debug for TargetSelection { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . write_fmt (format_args ! ("{0}" , self)) } } impl PartialEq < & str > for TargetSelection { fn eq (& self , other : & & str) -> bool { self . triple == * other } } impl AsRef < Path > for TargetSelection { fn as_ref (& self) -> & Path { self . triple . as_ref () } } # [doc = " Per-target configuration stored in the global configuration structure."] pub struct Target { # [doc = " Some(path to llvm-config) if using an external LLVM."] pub llvm_config : Option < PathBuf > , pub llvm_has_rust_patches : Option < bool > , # [doc = " Some(path to FileCheck) if one was specified."] pub llvm_filecheck : Option < PathBuf > , pub llvm_libunwind : Option < LlvmLibunwind > , pub cc : Option < PathBuf > , pub cxx : Option < PathBuf > , pub ar : Option < PathBuf > , pub ranlib : Option < PathBuf > , pub default_linker : Option < PathBuf > , pub linker : Option < PathBuf > , pub split_debuginfo : Option < SplitDebuginfo > , pub sanitizers : Option < bool > , pub profiler : Option < StringOrBool > , pub rpath : Option < bool > , pub crt_static : Option < bool > , pub musl_root : Option < PathBuf > , pub musl_libdir : Option < PathBuf > , pub wasi_root : Option < PathBuf > , pub qemu_rootfs : Option < PathBuf > , pub runner : Option < String > , pub no_std : bool , pub codegen_backends : Option < Vec < String > > , } # [automatically_derived] impl :: core :: fmt :: Debug for Target { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { let names : & 'static _ = & ["llvm_config" , "llvm_has_rust_patches" , "llvm_filecheck" , "llvm_libunwind" , "cc" , "cxx" , "ar" , "ranlib" , "default_linker" , "linker" , "split_debuginfo" , "sanitizers" , "profiler" , "rpath" , "crt_static" , "musl_root" , "musl_libdir" , "wasi_root" , "qemu_rootfs" , "runner" , "no_std" , "codegen_backends" ,] ; let values : & [& dyn :: core :: fmt :: Debug] = & [& self . llvm_config , & self . llvm_has_rust_patches , & self . llvm_filecheck , & self . llvm_libunwind , & self . cc , & self . cxx , & self . ar , & self . ranlib , & self . default_linker , & self . linker , & self . split_debuginfo , & self . sanitizers , & self . profiler , & self . rpath , & self . crt_static , & self . musl_root , & self . musl_libdir , & self . wasi_root , & self . qemu_rootfs , & self . runner , & self . no_std , & & self . codegen_backends ,] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , "Target" , names , values ,) } } # [automatically_derived] impl :: core :: default :: Default for Target { # [inline] fn default () -> Target { Target { llvm_config : :: core :: default :: Default :: default () , llvm_has_rust_patches : :: core :: default :: Default :: default () , llvm_filecheck : :: core :: default :: Default :: default () , llvm_libunwind : :: core :: default :: Default :: default () , cc : :: core :: default :: Default :: default () , cxx : :: core :: default :: Default :: default () , ar : :: core :: default :: Default :: default () , ranlib : :: core :: default :: Default :: default () , default_linker : :: core :: default :: Default :: default () , linker : :: core :: default :: Default :: default () , split_debuginfo : :: core :: default :: Default :: default () , sanitizers : :: core :: default :: Default :: default () , profiler : :: core :: default :: Default :: default () , rpath : :: core :: default :: Default :: default () , crt_static : :: core :: default :: Default :: default () , musl_root : :: core :: default :: Default :: default () , musl_libdir : :: core :: default :: Default :: default () , wasi_root : :: core :: default :: Default :: default () , qemu_rootfs : :: core :: default :: Default :: default () , runner : :: core :: default :: Default :: default () , no_std : :: core :: default :: Default :: default () , codegen_backends : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: clone :: Clone for Target { # [inline] fn clone (& self) -> Target { Target { llvm_config : :: core :: clone :: Clone :: clone (& self . llvm_config) , llvm_has_rust_patches : :: core :: clone :: Clone :: clone (& self . llvm_has_rust_patches ,) , llvm_filecheck : :: core :: clone :: Clone :: clone (& self . llvm_filecheck) , llvm_libunwind : :: core :: clone :: Clone :: clone (& self . llvm_libunwind) , cc : :: core :: clone :: Clone :: clone (& self . cc) , cxx : :: core :: clone :: Clone :: clone (& self . cxx) , ar : :: core :: clone :: Clone :: clone (& self . ar) , ranlib : :: core :: clone :: Clone :: clone (& self . ranlib) , default_linker : :: core :: clone :: Clone :: clone (& self . default_linker) , linker : :: core :: clone :: Clone :: clone (& self . linker) , split_debuginfo : :: core :: clone :: Clone :: clone (& self . split_debuginfo) , sanitizers : :: core :: clone :: Clone :: clone (& self . sanitizers) , profiler : :: core :: clone :: Clone :: clone (& self . profiler) , rpath : :: core :: clone :: Clone :: clone (& self . rpath) , crt_static : :: core :: clone :: Clone :: clone (& self . crt_static) , musl_root : :: core :: clone :: Clone :: clone (& self . musl_root) , musl_libdir : :: core :: clone :: Clone :: clone (& self . musl_libdir) , wasi_root : :: core :: clone :: Clone :: clone (& self . wasi_root) , qemu_rootfs : :: core :: clone :: Clone :: clone (& self . qemu_rootfs) , runner : :: core :: clone :: Clone :: clone (& self . runner) , no_std : :: core :: clone :: Clone :: clone (& self . no_std) , codegen_backends : :: core :: clone :: Clone :: clone (& self . codegen_backends) , } } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for Target { } # [automatically_derived] impl :: core :: cmp :: PartialEq for Target { # [inline] fn eq (& self , other : & Target) -> bool { self . no_std == other . no_std && self . llvm_config == other . llvm_config && self . llvm_has_rust_patches == other . llvm_has_rust_patches && self . llvm_filecheck == other . llvm_filecheck && self . llvm_libunwind == other . llvm_libunwind && self . cc == other . cc && self . cxx == other . cxx && self . ar == other . ar && self . ranlib == other . ranlib && self . default_linker == other . default_linker && self . linker == other . linker && self . split_debuginfo == other . split_debuginfo && self . sanitizers == other . sanitizers && self . profiler == other . profiler && self . rpath == other . rpath && self . crt_static == other . crt_static && self . musl_root == other . musl_root && self . musl_libdir == other . musl_libdir && self . wasi_root == other . wasi_root && self . qemu_rootfs == other . qemu_rootfs && self . runner == other . runner && self . codegen_backends == other . codegen_backends } } # [automatically_derived] impl :: core :: cmp :: Eq for Target { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < bool > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < LlvmLibunwind > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < SplitDebuginfo > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < bool > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < StringOrBool > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < bool > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < bool > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < PathBuf > > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < String > > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; let _ : :: core :: cmp :: AssertParamIsEq < Option < Vec < String > > > ; } } }