# [doc = " A type that represents a \"small\" index."] # [doc = ""] # [doc = " The main idea of this type is to provide something that can index memory,"] # [doc = " but uses less memory than `usize` on 64-bit systems. Specifically, its"] # [doc = " representation is always a `u32` and has `repr(transparent)` enabled. (So"] # [doc = " it is safe to transmute between a `u32` and a `SmallIndex`.)"] # [doc = ""] # [doc = " A small index is typically useful in cases where there is no practical way"] # [doc = " that the index will overflow a 32-bit integer. A good example of this is"] # [doc = " an NFA state. If you could somehow build an NFA with `2^30` states, its"] # [doc = " memory usage would be exorbitant and its runtime execution would be so"] # [doc = " slow as to be completely worthless. Therefore, this crate generally deems"] # [doc = " it acceptable to return an error if it would otherwise build an NFA that"] # [doc = " requires a slice longer than what a 32-bit integer can index. In exchange,"] # [doc = " we can use 32-bit indices instead of 64-bit indices in various places."] # [doc = ""] # [doc = " This type ensures this by providing a constructor that will return an error"] # [doc = " if its argument cannot fit into the type. This makes it much easier to"] # [doc = " handle these sorts of boundary cases that are otherwise extremely subtle."] # [doc = ""] # [doc = " On all targets, this type guarantees that its value will fit in a `u32`,"] # [doc = " `i32`, `usize` and an `isize`. This means that on 16-bit targets, for"] # [doc = " example, this type's maximum value will never overflow an `isize`,"] # [doc = " which means it will never overflow a `i16` even though its internal"] # [doc = " representation is still a `u32`."] # [doc = ""] # [doc = " The purpose for making the type fit into even signed integer types like"] # [doc = " `isize` is to guarantee that the difference between any two small indices"] # [doc = " is itself also a small index. This is useful in certain contexts, e.g.,"] # [doc = " for delta encoding."] # [doc = ""] # [doc = " # Other types"] # [doc = ""] # [doc = " The following types wrap `SmallIndex` to provide a more focused use case:"] # [doc = ""] # [doc = " * [`PatternID`] is for representing the identifiers of patterns."] # [doc = " * [`StateID`] is for representing the identifiers of states in finite"] # [doc = " automata. It is used for both NFAs and DFAs."] # [doc = ""] # [doc = " # Representation"] # [doc = ""] # [doc = " This type is always represented internally by a `u32` and is marked as"] # [doc = " `repr(transparent)`. Thus, this type always has the same representation as"] # [doc = " a `u32`. It is thus safe to transmute between a `u32` and a `SmallIndex`."] # [doc = ""] # [doc = " # Indexing"] # [doc = ""] # [doc = " For convenience, callers may use a `SmallIndex` to index slices."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " While a `SmallIndex` is meant to guarantee that its value fits into `usize`"] # [doc = " without using as much space as a `usize` on all targets, callers must"] # [doc = " not rely on this property for safety. Callers may choose to rely on this"] # [doc = " property for correctness however. For example, creating a `SmallIndex` with"] # [doc = " an invalid value can be done in entirely safe code. This may in turn result"] # [doc = " in panics or silent logical errors."] # [repr (transparent)] pub (crate) struct SmallIndex (u32) ;