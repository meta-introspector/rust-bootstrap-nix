pub mod llvm_info { use std :: fmt :: Debug ; pub struct LlvmInfo { pub ir_version : String , pub target_triple : String , } # [automatically_derived] impl :: core :: fmt :: Debug for LlvmInfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "LlvmInfo" , "ir_version" , & self . ir_version , "target_triple" , & & self . target_triple ,) } } # [automatically_derived] impl :: core :: clone :: Clone for LlvmInfo { # [inline] fn clone (& self) -> LlvmInfo { LlvmInfo { ir_version : :: core :: clone :: Clone :: clone (& self . ir_version) , target_triple : :: core :: clone :: Clone :: clone (& self . target_triple) , } } } pub enum LlvmDetails { Info (LlvmInfo) , Error (String) , Unknown , } # [automatically_derived] impl :: core :: fmt :: Debug for LlvmDetails { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { LlvmDetails :: Info (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Info" , & __self_0 ,) } LlvmDetails :: Error (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Error" , & __self_0 ,) } LlvmDetails :: Unknown => { :: core :: fmt :: Formatter :: write_str (f , "Unknown") } } } } # [automatically_derived] impl :: core :: clone :: Clone for LlvmDetails { # [inline] fn clone (& self) -> LlvmDetails { match self { LlvmDetails :: Info (__self_0) => { LlvmDetails :: Info (:: core :: clone :: Clone :: clone (__self_0)) } LlvmDetails :: Error (__self_0) => { LlvmDetails :: Error (:: core :: clone :: Clone :: clone (__self_0)) } LlvmDetails :: Unknown => LlvmDetails :: Unknown , } } } pub trait LlvmInfoTrait : Send + Sync + Debug { fn ir_version (& self) -> Option < & str > ; fn target_triple (& self) -> Option < & str > ; } impl LlvmInfoTrait for LlvmDetails { fn ir_version (& self) -> Option < & str > { match self { LlvmDetails :: Info (info) => Some (& info . ir_version) , _ => None , } } fn target_triple (& self) -> Option < & str > { match self { LlvmDetails :: Info (info) => Some (& info . target_triple) , _ => None , } } } }