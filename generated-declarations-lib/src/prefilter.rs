pub (crate) mod prefilter { use core :: { cmp , fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } , u8 , } ; use alloc :: { sync :: Arc , vec , vec :: Vec } ; use crate :: { packed , util :: { alphabet :: ByteSet , search :: { Match , MatchKind , Span } } } ; # [doc = " A prefilter for accelerating a search."] # [doc = ""] # [doc = " This crate uses prefilters in the core search implementations to accelerate"] # [doc = " common cases. They typically only apply to cases where there are a small"] # [doc = " number of patterns (less than 100 or so), but when they do, thoughput can"] # [doc = " be boosted considerably, perhaps by an order of magnitude. When a prefilter"] # [doc = " is active, it is used whenever a search enters an automaton's start state."] # [doc = ""] # [doc = " Currently, prefilters cannot be constructed by"] # [doc = " callers. A `Prefilter` can only be accessed via the"] # [doc = " [`Automaton::prefilter`](crate::automaton::Automaton::prefilter)"] # [doc = " method and used to execute a search. In other words, a prefilter can be"] # [doc = " used to optimize your own search implementation if necessary, but cannot do"] # [doc = " much else. If you have a use case for more APIs, please submit an issue."] pub struct Prefilter { finder : Arc < dyn PrefilterI > , memory_usage : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Prefilter { # [inline] fn clone (& self) -> Prefilter { Prefilter { finder : :: core :: clone :: Clone :: clone (& self . finder) , memory_usage : :: core :: clone :: Clone :: clone (& self . memory_usage) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Prefilter { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Prefilter" , "finder" , & self . finder , "memory_usage" , & & self . memory_usage ,) } } impl Prefilter { # [doc = " Execute a search in the haystack within the span given. If a match or"] # [doc = " a possible match is returned, then it is guaranteed to occur within"] # [doc = " the bounds of the span."] # [doc = ""] # [doc = " If the span provided is invalid for the given haystack, then behavior"] # [doc = " is unspecified."] # [inline] pub fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { self . finder . find_in (haystack , span) } # [inline] pub (crate) fn memory_usage (& self) -> usize { self . memory_usage } } # [doc = " A candidate is the result of running a prefilter on a haystack at a"] # [doc = " particular position."] # [doc = ""] # [doc = " The result is either no match, a confirmed match or a possible match."] # [doc = ""] # [doc = " When no match is returned, the prefilter is guaranteeing that no possible"] # [doc = " match can be found in the haystack, and the caller may trust this. That is,"] # [doc = " all correct prefilters must never report false negatives."] # [doc = ""] # [doc = " In some cases, a prefilter can confirm a match very quickly, in which case,"] # [doc = " the caller may use this to stop what it's doing and report the match. In"] # [doc = " this case, prefilter implementations must never report a false positive."] # [doc = " In other cases, the prefilter can only report a potential match, in which"] # [doc = " case the callers must attempt to confirm the match. In this case, prefilter"] # [doc = " implementations are permitted to return false positives."] pub enum Candidate { # [doc = " No match was found. Since false negatives are not possible, this means"] # [doc = " the search can quit as it is guaranteed not to find another match."] None , # [doc = " A confirmed match was found. Callers do not need to confirm it."] Match (Match) , # [doc = " The start of a possible match was found. Callers must confirm it before"] # [doc = " reporting it as a match."] PossibleStartOfMatch (usize) , } # [automatically_derived] impl :: core :: clone :: Clone for Candidate { # [inline] fn clone (& self) -> Candidate { match self { Candidate :: None => Candidate :: None , Candidate :: Match (__self_0) => { Candidate :: Match (:: core :: clone :: Clone :: clone (__self_0)) } Candidate :: PossibleStartOfMatch (__self_0) => { Candidate :: PossibleStartOfMatch (:: core :: clone :: Clone :: clone (__self_0) ,) } } } } # [automatically_derived] impl :: core :: fmt :: Debug for Candidate { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { Candidate :: None => :: core :: fmt :: Formatter :: write_str (f , "None") , Candidate :: Match (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Match" , & __self_0 ,) } Candidate :: PossibleStartOfMatch (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "PossibleStartOfMatch" , & __self_0 ,) } } } } impl Candidate { # [doc = " Convert this candidate into an option. This is useful when callers"] # [doc = " do not distinguish between true positives and false positives (i.e.,"] # [doc = " the caller must always confirm the match)."] pub fn into_option (self) -> Option < usize > { match self { Candidate :: None => None , Candidate :: Match (ref m) => Some (m . start ()) , Candidate :: PossibleStartOfMatch (start) => Some (start) , } } } # [doc = " A prefilter describes the behavior of fast literal scanners for quickly"] # [doc = " skipping past bytes in the haystack that we know cannot possibly"] # [doc = " participate in a match."] trait PrefilterI : Send + Sync + RefUnwindSafe + UnwindSafe + Debug + 'static { # [doc = " Returns the next possible match candidate. This may yield false"] # [doc = " positives, so callers must confirm a match starting at the position"] # [doc = " returned. This, however, must never produce false negatives. That is,"] # [doc = " this must, at minimum, return the starting position of the next match"] # [doc = " in the given haystack after or at the given position."] fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate ; } impl < P : PrefilterI + ? Sized > PrefilterI for Arc < P > { # [inline (always)] fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { (* * self) . find_in (haystack , span) } } # [doc = " A builder for constructing the best possible prefilter. When constructed,"] # [doc = " this builder will heuristically select the best prefilter it can build,"] # [doc = " if any, and discard the rest."] pub (crate) struct Builder { count : usize , ascii_case_insensitive : bool , start_bytes : StartBytesBuilder , rare_bytes : RareBytesBuilder , memmem : MemmemBuilder , packed : Option < packed :: Builder > , enabled : bool , } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { let names : & 'static _ = & ["count" , "ascii_case_insensitive" , "start_bytes" , "rare_bytes" , "memmem" , "packed" , "enabled" ,] ; let values : & [& dyn :: core :: fmt :: Debug] = & [& self . count , & self . ascii_case_insensitive , & self . start_bytes , & self . rare_bytes , & self . memmem , & self . packed , & & self . enabled ,] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , "Builder" , names , values ,) } } impl Builder { # [doc = " Create a new builder for constructing the best possible prefilter."] pub (crate) fn new (kind : MatchKind) -> Builder { let pbuilder = kind . as_packed () . map (| kind | packed :: Config :: new () . match_kind (kind) . builder ()) ; Builder { count : 0 , ascii_case_insensitive : false , start_bytes : StartBytesBuilder :: new () , rare_bytes : RareBytesBuilder :: new () , memmem : MemmemBuilder :: default () , packed : pbuilder , enabled : true , } } # [doc = " Enable ASCII case insensitivity. When set, byte strings added to this"] # [doc = " builder will be interpreted without respect to ASCII case."] pub (crate) fn ascii_case_insensitive (mut self , yes : bool) -> Builder { self . ascii_case_insensitive = yes ; self . start_bytes = self . start_bytes . ascii_case_insensitive (yes) ; self . rare_bytes = self . rare_bytes . ascii_case_insensitive (yes) ; self } # [doc = " Return a prefilter suitable for quickly finding potential matches."] # [doc = ""] # [doc = " All patterns added to an Aho-Corasick automaton should be added to this"] # [doc = " builder before attempting to construct the prefilter."] pub (crate) fn build (& self) -> Option < Prefilter > { if ! self . enabled { return None ; } if ! self . ascii_case_insensitive { if let Some (pre) = self . memmem . build () { return Some (pre) ; } } let (packed , patlen , minlen) = if self . ascii_case_insensitive { (None , usize :: MAX , 0) } else { let patlen = self . packed . as_ref () . map_or (usize :: MAX , | p | p . len ()) ; let minlen = self . packed . as_ref () . map_or (0 , | p | p . minimum_len ()) ; let packed = self . packed . as_ref () . and_then (| b | b . build ()) . map (| s | { let memory_usage = s . memory_usage () ; Prefilter { finder : Arc :: new (Packed (s)) , memory_usage , } }) ; (packed , patlen , minlen) } ; match (self . start_bytes . build () , self . rare_bytes . build ()) { (prestart @ Some (_) , prerare @ Some (_)) => { if patlen <= 16 && minlen >= 2 && self . start_bytes . count >= 3 && self . rare_bytes . count >= 3 { return packed ; } let has_fewer_bytes = self . start_bytes . count < self . rare_bytes . count ; let has_rarer_bytes = self . start_bytes . rank_sum <= self . rare_bytes . rank_sum + 50 ; if has_fewer_bytes { prestart } else if has_rarer_bytes { prestart } else { prerare } } (prestart @ Some (_) , None) => { if patlen <= 16 && minlen >= 2 && self . start_bytes . count >= 3 { return packed ; } prestart } (None , prerare @ Some (_)) => { if patlen <= 16 && minlen >= 2 && self . rare_bytes . count >= 3 { return packed ; } prerare } (None , None) if self . ascii_case_insensitive => { None } (None , None) => { if packed . is_some () { } else { } packed } } } # [doc = " Add a literal string to this prefilter builder."] pub (crate) fn add (& mut self , bytes : & [u8]) { if bytes . is_empty () { self . enabled = false ; } if ! self . enabled { return ; } self . count += 1 ; self . start_bytes . add (bytes) ; self . rare_bytes . add (bytes) ; self . memmem . add (bytes) ; if let Some (ref mut pbuilder) = self . packed { pbuilder . add (bytes) ; } } } # [doc = " A type that wraps a packed searcher and implements the `Prefilter`"] # [doc = " interface."] struct Packed (packed :: Searcher) ; # [automatically_derived] impl :: core :: clone :: Clone for Packed { # [inline] fn clone (& self) -> Packed { Packed (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for Packed { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Packed" , & & self . 0) } } impl PrefilterI for Packed { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { self . 0 . find_in (haystack , span) . map_or (Candidate :: None , Candidate :: Match) } } # [doc = " A builder for constructing a prefilter that uses memmem."] struct MemmemBuilder { # [doc = " The number of patterns that have been added."] count : usize , # [doc = " The singular pattern to search for. This is only set when count==1."] one : Option < Vec < u8 > > , } # [automatically_derived] impl :: core :: fmt :: Debug for MemmemBuilder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "MemmemBuilder" , "count" , & self . count , "one" , & & self . one ,) } } # [automatically_derived] impl :: core :: default :: Default for MemmemBuilder { # [inline] fn default () -> MemmemBuilder { MemmemBuilder { count : :: core :: default :: Default :: default () , one : :: core :: default :: Default :: default () , } } } impl MemmemBuilder { fn build (& self) -> Option < Prefilter > { fn imp (builder : & MemmemBuilder) -> Option < Prefilter > { let pattern = builder . one . as_ref () ? ; match (& 1 , & builder . count) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; let finder = Arc :: new (Memmem (memchr :: memmem :: Finder :: new (pattern) . into_owned ()) ,) ; let memory_usage = pattern . len () ; Some (Prefilter { finder , memory_usage }) } imp (self) } fn add (& mut self , bytes : & [u8]) { self . count += 1 ; if self . count == 1 { self . one = Some (bytes . to_vec ()) ; } else { self . one = None ; } } } # [doc = " A type that wraps a SIMD accelerated single substring search from the"] # [doc = " `memchr` crate for use as a prefilter."] # [doc = ""] # [doc = " Currently, this prefilter is only active for Aho-Corasick searchers with"] # [doc = " a single pattern. In theory, this could be extended to support searchers"] # [doc = " that have a common prefix of more than one byte (for one byte, we would use"] # [doc = " memchr), but it's not clear if it's worth it or not."] # [doc = ""] # [doc = " Also, unfortunately, this currently also requires the 'std' feature to"] # [doc = " be enabled. That's because memchr doesn't have a no-std-but-with-alloc"] # [doc = " mode, and so APIs like Finder::into_owned aren't available when 'std' is"] # [doc = " disabled. But there should be an 'alloc' feature that brings in APIs like"] # [doc = " Finder::into_owned but doesn't use std-only features like runtime CPU"] # [doc = " feature detection."] struct Memmem (memchr :: memmem :: Finder < 'static >) ; # [automatically_derived] impl :: core :: clone :: Clone for Memmem { # [inline] fn clone (& self) -> Memmem { Memmem (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for Memmem { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Memmem" , & & self . 0) } } impl PrefilterI for Memmem { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { use crate :: util :: primitives :: PatternID ; self . 0 . find (& haystack [span]) . map_or (Candidate :: None , | i | { let start = span . start + i ; let end = start + self . 0 . needle () . len () ; Candidate :: Match (Match :: new (PatternID :: ZERO , start .. end)) } ,) } } # [doc = " A builder for constructing a rare byte prefilter."] # [doc = ""] # [doc = " A rare byte prefilter attempts to pick out a small set of rare bytes that"] # [doc = " occurr in the patterns, and then quickly scan to matches of those rare"] # [doc = " bytes."] struct RareBytesBuilder { # [doc = " Whether this prefilter should account for ASCII case insensitivity or"] # [doc = " not."] ascii_case_insensitive : bool , # [doc = " A set of rare bytes, indexed by byte value."] rare_set : ByteSet , # [doc = " A set of byte offsets associated with bytes in a pattern. An entry"] # [doc = " corresponds to a particular bytes (its index) and is only non-zero if"] # [doc = " the byte occurred at an offset greater than 0 in at least one pattern."] # [doc = ""] # [doc = " If a byte's offset is not representable in 8 bits, then the rare bytes"] # [doc = " prefilter becomes inert."] byte_offsets : RareByteOffsets , # [doc = " Whether this is available as a prefilter or not. This can be set to"] # [doc = " false during construction if a condition is seen that invalidates the"] # [doc = " use of the rare-byte prefilter."] available : bool , # [doc = " The number of bytes set to an active value in `byte_offsets`."] count : usize , # [doc = " The sum of frequency ranks for the rare bytes detected. This is"] # [doc = " intended to give a heuristic notion of how rare the bytes are."] rank_sum : u16 , } # [automatically_derived] impl :: core :: clone :: Clone for RareBytesBuilder { # [inline] fn clone (& self) -> RareBytesBuilder { RareBytesBuilder { ascii_case_insensitive : :: core :: clone :: Clone :: clone (& self . ascii_case_insensitive ,) , rare_set : :: core :: clone :: Clone :: clone (& self . rare_set) , byte_offsets : :: core :: clone :: Clone :: clone (& self . byte_offsets) , available : :: core :: clone :: Clone :: clone (& self . available) , count : :: core :: clone :: Clone :: clone (& self . count) , rank_sum : :: core :: clone :: Clone :: clone (& self . rank_sum) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RareBytesBuilder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { let names : & 'static _ = & ["ascii_case_insensitive" , "rare_set" , "byte_offsets" , "available" , "count" , "rank_sum" ,] ; let values : & [& dyn :: core :: fmt :: Debug] = & [& self . ascii_case_insensitive , & self . rare_set , & self . byte_offsets , & self . available , & self . count , & & self . rank_sum ,] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , "RareBytesBuilder" , names , values ,) } } # [doc = " A set of byte offsets, keyed by byte."] struct RareByteOffsets { # [doc = " Each entry corresponds to the maximum offset of the corresponding"] # [doc = " byte across all patterns seen."] set : [RareByteOffset ; 256] , } # [automatically_derived] impl :: core :: clone :: Clone for RareByteOffsets { # [inline] fn clone (& self) -> RareByteOffsets { let _ : :: core :: clone :: AssertParamIsClone < [RareByteOffset ; 256] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for RareByteOffsets { } impl RareByteOffsets { # [doc = " Create a new empty set of rare byte offsets."] pub (crate) fn empty () -> RareByteOffsets { RareByteOffsets { set : [RareByteOffset :: default () ; 256] , } } # [doc = " Add the given offset for the given byte to this set. If the offset is"] # [doc = " greater than the existing offset, then it overwrites the previous"] # [doc = " value and returns false. If there is no previous value set, then this"] # [doc = " sets it and returns true."] pub (crate) fn set (& mut self , byte : u8 , off : RareByteOffset) { self . set [byte as usize] . max = cmp :: max (self . set [byte as usize] . max , off . max ,) ; } } impl core :: fmt :: Debug for RareByteOffsets { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let mut offsets = :: alloc :: vec :: Vec :: new () ; for off in self . set . iter () { if off . max > 0 { offsets . push (off) ; } } f . debug_struct ("RareByteOffsets") . field ("set" , & offsets) . finish () } } # [doc = " Offsets associated with an occurrence of a \"rare\" byte in any of the"] # [doc = " patterns used to construct a single Aho-Corasick automaton."] struct RareByteOffset { # [doc = " The maximum offset at which a particular byte occurs from the start"] # [doc = " of any pattern. This is used as a shift amount. That is, when an"] # [doc = " occurrence of this byte is found, the candidate position reported by"] # [doc = " the prefilter is `position_of_byte - max`, such that the automaton"] # [doc = " will begin its search at a position that is guaranteed to observe a"] # [doc = " match."] # [doc = ""] # [doc = " To avoid accidentally quadratic behavior, a prefilter is considered"] # [doc = " ineffective when it is asked to start scanning from a position that it"] # [doc = " has already scanned past."] # [doc = ""] # [doc = " Using a `u8` here means that if we ever see a pattern that's longer"] # [doc = " than 255 bytes, then the entire rare byte prefilter is disabled."] max : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for RareByteOffset { # [inline] fn clone (& self) -> RareByteOffset { let _ : :: core :: clone :: AssertParamIsClone < u8 > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for RareByteOffset { } # [automatically_derived] impl :: core :: fmt :: Debug for RareByteOffset { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "RareByteOffset" , "max" , & & self . max ,) } } impl Default for RareByteOffset { fn default () -> RareByteOffset { RareByteOffset { max : 0 } } } impl RareByteOffset { # [doc = " Create a new rare byte offset. If the given offset is too big, then"] # [doc = " None is returned. In that case, callers should render the rare bytes"] # [doc = " prefilter inert."] fn new (max : usize) -> Option < RareByteOffset > { if max > u8 :: MAX as usize { None } else { Some (RareByteOffset { max : max as u8 }) } } } impl RareBytesBuilder { # [doc = " Create a new builder for constructing a rare byte prefilter."] fn new () -> RareBytesBuilder { RareBytesBuilder { ascii_case_insensitive : false , rare_set : ByteSet :: empty () , byte_offsets : RareByteOffsets :: empty () , available : true , count : 0 , rank_sum : 0 , } } # [doc = " Enable ASCII case insensitivity. When set, byte strings added to this"] # [doc = " builder will be interpreted without respect to ASCII case."] fn ascii_case_insensitive (mut self , yes : bool) -> RareBytesBuilder { self . ascii_case_insensitive = yes ; self } # [doc = " Build the rare bytes prefilter."] # [doc = ""] # [doc = " If there are more than 3 distinct rare bytes found, or if heuristics"] # [doc = " otherwise determine that this prefilter should not be used, then `None`"] # [doc = " is returned."] fn build (& self) -> Option < Prefilter > { fn imp (builder : & RareBytesBuilder) -> Option < Prefilter > { if ! builder . available || builder . count > 3 { return None ; } let (mut bytes , mut len) = ([0 ; 3] , 0) ; for b in 0 ..= 255 { if builder . rare_set . contains (b) { bytes [len] = b ; len += 1 ; } } let finder : Arc < dyn PrefilterI > = match len { 0 => return None , 1 => { Arc :: new (RareBytesOne { byte1 : bytes [0] , offset : builder . byte_offsets . set [bytes [0] as usize] , }) } 2 => { Arc :: new (RareBytesTwo { offsets : builder . byte_offsets , byte1 : bytes [0] , byte2 : bytes [1] , }) } 3 => { Arc :: new (RareBytesThree { offsets : builder . byte_offsets , byte1 : bytes [0] , byte2 : bytes [1] , byte3 : bytes [2] , }) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ; Some (Prefilter { finder , memory_usage : 0 , }) } imp (self) } # [doc = " Add a byte string to this builder."] # [doc = ""] # [doc = " All patterns added to an Aho-Corasick automaton should be added to this"] # [doc = " builder before attempting to construct the prefilter."] fn add (& mut self , bytes : & [u8]) { if ! self . available { return ; } if self . count > 3 { self . available = false ; return ; } if bytes . len () >= 256 { self . available = false ; return ; } let mut rarest = match bytes . first () { None => return , Some (& b) => (b , freq_rank (b)) , } ; let mut found = false ; for (pos , & b) in bytes . iter () . enumerate () { self . set_offset (pos , b) ; if found { continue ; } if self . rare_set . contains (b) { found = true ; continue ; } let rank = freq_rank (b) ; if rank < rarest . 1 { rarest = (b , rank) ; } } if ! found { self . add_rare_byte (rarest . 0) ; } } fn set_offset (& mut self , pos : usize , byte : u8) { let offset = RareByteOffset :: new (pos) . unwrap () ; self . byte_offsets . set (byte , offset) ; if self . ascii_case_insensitive { self . byte_offsets . set (opposite_ascii_case (byte) , offset) ; } } fn add_rare_byte (& mut self , byte : u8) { self . add_one_rare_byte (byte) ; if self . ascii_case_insensitive { self . add_one_rare_byte (opposite_ascii_case (byte)) ; } } fn add_one_rare_byte (& mut self , byte : u8) { if ! self . rare_set . contains (byte) { self . rare_set . add (byte) ; self . count += 1 ; self . rank_sum += freq_rank (byte) as u16 ; } } } # [doc = " A prefilter for scanning for a single \"rare\" byte."] struct RareBytesOne { byte1 : u8 , offset : RareByteOffset , } # [automatically_derived] impl :: core :: clone :: Clone for RareBytesOne { # [inline] fn clone (& self) -> RareBytesOne { RareBytesOne { byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , offset : :: core :: clone :: Clone :: clone (& self . offset) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RareBytesOne { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "RareBytesOne" , "byte1" , & self . byte1 , "offset" , & & self . offset ,) } } impl PrefilterI for RareBytesOne { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr (self . byte1 , & haystack [span]) . map (| i | { let pos = span . start + i ; cmp :: max (span . start , pos . saturating_sub (usize :: from (self . offset . max)) ,) }) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " A prefilter for scanning for two \"rare\" bytes."] struct RareBytesTwo { offsets : RareByteOffsets , byte1 : u8 , byte2 : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for RareBytesTwo { # [inline] fn clone (& self) -> RareBytesTwo { RareBytesTwo { offsets : :: core :: clone :: Clone :: clone (& self . offsets) , byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , byte2 : :: core :: clone :: Clone :: clone (& self . byte2) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RareBytesTwo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "RareBytesTwo" , "offsets" , & self . offsets , "byte1" , & self . byte1 , "byte2" , & & self . byte2 ,) } } impl PrefilterI for RareBytesTwo { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr2 (self . byte1 , self . byte2 , & haystack [span]) . map (| i | { let pos = span . start + i ; let offset = self . offsets . set [usize :: from (haystack [pos])] . max ; cmp :: max (span . start , pos . saturating_sub (usize :: from (offset))) }) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " A prefilter for scanning for three \"rare\" bytes."] struct RareBytesThree { offsets : RareByteOffsets , byte1 : u8 , byte2 : u8 , byte3 : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for RareBytesThree { # [inline] fn clone (& self) -> RareBytesThree { RareBytesThree { offsets : :: core :: clone :: Clone :: clone (& self . offsets) , byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , byte2 : :: core :: clone :: Clone :: clone (& self . byte2) , byte3 : :: core :: clone :: Clone :: clone (& self . byte3) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RareBytesThree { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "RareBytesThree" , "offsets" , & self . offsets , "byte1" , & self . byte1 , "byte2" , & self . byte2 , "byte3" , & & self . byte3 ,) } } impl PrefilterI for RareBytesThree { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr3 (self . byte1 , self . byte2 , self . byte3 , & haystack [span]) . map (| i | { let pos = span . start + i ; let offset = self . offsets . set [usize :: from (haystack [pos])] . max ; cmp :: max (span . start , pos . saturating_sub (usize :: from (offset))) }) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " A builder for constructing a starting byte prefilter."] # [doc = ""] # [doc = " A starting byte prefilter is a simplistic prefilter that looks for possible"] # [doc = " matches by reporting all positions corresponding to a particular byte. This"] # [doc = " generally only takes affect when there are at most 3 distinct possible"] # [doc = " starting bytes. e.g., the patterns `foo`, `bar`, and `baz` have two"] # [doc = " distinct starting bytes (`f` and `b`), and this prefilter returns all"] # [doc = " occurrences of either `f` or `b`."] # [doc = ""] # [doc = " In some cases, a heuristic frequency analysis may determine that it would"] # [doc = " be better not to use this prefilter even when there are 3 or fewer distinct"] # [doc = " starting bytes."] struct StartBytesBuilder { # [doc = " Whether this prefilter should account for ASCII case insensitivity or"] # [doc = " not."] ascii_case_insensitive : bool , # [doc = " The set of starting bytes observed."] byteset : Vec < bool > , # [doc = " The number of bytes set to true in `byteset`."] count : usize , # [doc = " The sum of frequency ranks for the rare bytes detected. This is"] # [doc = " intended to give a heuristic notion of how rare the bytes are."] rank_sum : u16 , } # [automatically_derived] impl :: core :: clone :: Clone for StartBytesBuilder { # [inline] fn clone (& self) -> StartBytesBuilder { StartBytesBuilder { ascii_case_insensitive : :: core :: clone :: Clone :: clone (& self . ascii_case_insensitive ,) , byteset : :: core :: clone :: Clone :: clone (& self . byteset) , count : :: core :: clone :: Clone :: clone (& self . count) , rank_sum : :: core :: clone :: Clone :: clone (& self . rank_sum) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for StartBytesBuilder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "StartBytesBuilder" , "ascii_case_insensitive" , & self . ascii_case_insensitive , "byteset" , & self . byteset , "count" , & self . count , "rank_sum" , & & self . rank_sum ,) } } impl StartBytesBuilder { # [doc = " Create a new builder for constructing a start byte prefilter."] fn new () -> StartBytesBuilder { StartBytesBuilder { ascii_case_insensitive : false , byteset : :: alloc :: vec :: from_elem (false , 256) , count : 0 , rank_sum : 0 , } } # [doc = " Enable ASCII case insensitivity. When set, byte strings added to this"] # [doc = " builder will be interpreted without respect to ASCII case."] fn ascii_case_insensitive (mut self , yes : bool) -> StartBytesBuilder { self . ascii_case_insensitive = yes ; self } # [doc = " Build the starting bytes prefilter."] # [doc = ""] # [doc = " If there are more than 3 distinct starting bytes, or if heuristics"] # [doc = " otherwise determine that this prefilter should not be used, then `None`"] # [doc = " is returned."] fn build (& self) -> Option < Prefilter > { fn imp (builder : & StartBytesBuilder) -> Option < Prefilter > { if builder . count > 3 { return None ; } let (mut bytes , mut len) = ([0 ; 3] , 0) ; for b in 0 .. 256 { if ! builder . byteset [b] { continue ; } if b > 0x7F { return None ; } bytes [len] = b as u8 ; len += 1 ; } let finder : Arc < dyn PrefilterI > = match len { 0 => return None , 1 => Arc :: new (StartBytesOne { byte1 : bytes [0] }) , 2 => { Arc :: new (StartBytesTwo { byte1 : bytes [0] , byte2 : bytes [1] , }) } 3 => { Arc :: new (StartBytesThree { byte1 : bytes [0] , byte2 : bytes [1] , byte3 : bytes [2] , }) } _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ; Some (Prefilter { finder , memory_usage : 0 , }) } imp (self) } # [doc = " Add a byte string to this builder."] # [doc = ""] # [doc = " All patterns added to an Aho-Corasick automaton should be added to this"] # [doc = " builder before attempting to construct the prefilter."] fn add (& mut self , bytes : & [u8]) { if self . count > 3 { return ; } if let Some (& byte) = bytes . first () { self . add_one_byte (byte) ; if self . ascii_case_insensitive { self . add_one_byte (opposite_ascii_case (byte)) ; } } } fn add_one_byte (& mut self , byte : u8) { if ! self . byteset [byte as usize] { self . byteset [byte as usize] = true ; self . count += 1 ; self . rank_sum += freq_rank (byte) as u16 ; } } } # [doc = " A prefilter for scanning for a single starting byte."] struct StartBytesOne { byte1 : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for StartBytesOne { # [inline] fn clone (& self) -> StartBytesOne { StartBytesOne { byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for StartBytesOne { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "StartBytesOne" , "byte1" , & & self . byte1 ,) } } impl PrefilterI for StartBytesOne { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr (self . byte1 , & haystack [span]) . map (| i | span . start + i) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " A prefilter for scanning for two starting bytes."] struct StartBytesTwo { byte1 : u8 , byte2 : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for StartBytesTwo { # [inline] fn clone (& self) -> StartBytesTwo { StartBytesTwo { byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , byte2 : :: core :: clone :: Clone :: clone (& self . byte2) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for StartBytesTwo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "StartBytesTwo" , "byte1" , & self . byte1 , "byte2" , & & self . byte2 ,) } } impl PrefilterI for StartBytesTwo { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr2 (self . byte1 , self . byte2 , & haystack [span]) . map (| i | span . start + i) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " A prefilter for scanning for three starting bytes."] struct StartBytesThree { byte1 : u8 , byte2 : u8 , byte3 : u8 , } # [automatically_derived] impl :: core :: clone :: Clone for StartBytesThree { # [inline] fn clone (& self) -> StartBytesThree { StartBytesThree { byte1 : :: core :: clone :: Clone :: clone (& self . byte1) , byte2 : :: core :: clone :: Clone :: clone (& self . byte2) , byte3 : :: core :: clone :: Clone :: clone (& self . byte3) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for StartBytesThree { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "StartBytesThree" , "byte1" , & self . byte1 , "byte2" , & self . byte2 , "byte3" , & & self . byte3 ,) } } impl PrefilterI for StartBytesThree { fn find_in (& self , haystack : & [u8] , span : Span) -> Candidate { memchr :: memchr3 (self . byte1 , self . byte2 , self . byte3 , & haystack [span]) . map (| i | span . start + i) . map_or (Candidate :: None , Candidate :: PossibleStartOfMatch) } } # [doc = " If the given byte is an ASCII letter, then return it in the opposite case."] # [doc = " e.g., Given `b'A'`, this returns `b'a'`, and given `b'a'`, this returns"] # [doc = " `b'A'`. If a non-ASCII letter is given, then the given byte is returned."] pub (crate) fn opposite_ascii_case (b : u8) -> u8 { if b'A' <= b && b <= b'Z' { b . to_ascii_lowercase () } else if b'a' <= b && b <= b'z' { b . to_ascii_uppercase () } else { b } } # [doc = " Return the frequency rank of the given byte. The higher the rank, the more"] # [doc = " common the byte (heuristically speaking)."] fn freq_rank (b : u8) -> u8 { use crate :: util :: byte_frequencies :: BYTE_FREQUENCIES ; BYTE_FREQUENCIES [b as usize] } }