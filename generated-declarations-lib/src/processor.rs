pub mod processor { use anyhow :: { Context , Result } ; use std :: collections :: HashSet ; use std :: fs ; use std :: time :: { Instant , Duration } ; use prelude_collector :: { collect_prelude_info , FileProcessingResult } ; use serde_json ; use crate :: args :: Args ; use crate :: report :: generate_report ; use crate :: generate_prelude :: generate_prelude ; use crate :: modify_file :: modify_file ; use crate :: modify_crate_root :: modify_crate_root ; pub fn process_crates (args : & Args) -> Result < () > { { :: std :: io :: _print (format_args ! ("--- Prelude Generator Started ---\n")) ; } ; { :: std :: io :: _print (format_args ! ("Parsed arguments: {0:?}\n" , args)) ; } ; let start_time = Instant :: now () ; let timeout_duration = args . timeout . map (Duration :: from_secs) ; if args . cache_report { let cache_dir = args . path . join (".prelude_cache") ; if cache_dir . exists () { let count = fs :: read_dir (& cache_dir) ? . count () ; { :: std :: io :: _print (format_args ! ("Prelude cache at {0} contains {1} items.\n" , cache_dir . display () , count ,) ,) ; } ; } else { { :: std :: io :: _print (format_args ! ("Prelude cache directory not found at {0}.\n" , cache_dir . display () ,) ,) ; } ; } return Ok (()) ; } let mut all_file_processing_results : Vec < FileProcessingResult > = Vec :: new () ; if args . report { if args . results_file . exists () { let json_content = fs :: read_to_string (& args . results_file) . context ("Failed to read results file") ? ; all_file_processing_results = serde_json :: from_str (& json_content) . context ("Failed to deserialize results from JSON") ? ; generate_report (& all_file_processing_results) ? ; } else { { :: std :: io :: _eprint (format_args ! ("Error: Results file not found at {0}. Cannot generate report.\n" , args . results_file . display () ,) ,) ; } ; } } else { let mut excluded_crates : HashSet < String > = args . exclude_crates . clone () . into_iter () . collect () ; excluded_crates . insert ("prelude-generator" . to_string ()) ; excluded_crates . insert ("rust-decl-splitter" . to_string ()) ; excluded_crates . insert ("dependency-analyzer" . to_string ()) ; excluded_crates . insert ("prelude-collector" . to_string ()) ; { :: std :: io :: _print (format_args ! ("Excluded crates: {0:?}\n" , excluded_crates) ,) ; } ; { :: std :: io :: _print (format_args ! ("Calling collect_prelude_info with path: {0} and excluded crates: {1:?}\n" , args . path . display () , excluded_crates ,) ,) ; } ; let collected_info_vec = collect_prelude_info (& args . path , & excluded_crates) ? ; { :: std :: io :: _print (format_args ! ("Finished collect_prelude_info. Collected {0} crates.\n" , collected_info_vec . len () ,) ,) ; } ; for info in collected_info_vec { if let Some (duration) = timeout_duration { if start_time . elapsed () > duration { { :: std :: io :: _print (format_args ! ("Timeout of {0} seconds reached. Stopping prelude generation.\n" , duration . as_secs () ,) ,) ; } ; break ; } } { :: std :: io :: _print (format_args ! ("\nProcessing collected info for crate: {0} ({1})\n" , info . crate_name , info . crate_root . display () ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("  Prelude content for this crate:\n---\n{0}\n---\n" , info . prelude_content ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("  Files to be modified in this crate: {0:?}\n" , info . modified_files ,) ,) ; } ; all_file_processing_results . extend (info . file_processing_results) ; let src_dir = info . crate_root . join ("src") ; generate_prelude (& src_dir , & info . prelude_content , args . dry_run , args . force ,) ? ; for path in & info . modified_files { modify_file (path , args . dry_run , args . force) ? ; } if info . crate_root_modified { modify_crate_root (& src_dir , args . dry_run , args . force) ? ; } } { :: std :: io :: _print (format_args ! ("\nPrelude generation complete.\n")) ; } ; { :: std :: io :: _print (format_args ! ("  -> Contents of all_file_processing_results: {0:?}\n" , all_file_processing_results ,) ,) ; } ; let json_content = serde_json :: to_string_pretty (& all_file_processing_results) . context ("Failed to serialize results to JSON") ? ; { :: std :: io :: _print (format_args ! ("  -> Attempting to save processing results to: {0}\n" , args . results_file . display () ,) ,) ; } ; fs :: write (& args . results_file , json_content) . context ("Failed to write results to file") ? ; { :: std :: io :: _print (format_args ! ("Processing results saved to {0}.\n" , args . results_file . display () ,) ,) ; } ; if args . report { generate_report (& all_file_processing_results) ? ; } } Ok (()) } }