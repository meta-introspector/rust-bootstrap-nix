# [doc = " Represents the current state of an overlapping search."] # [doc = ""] # [doc = " This is used for overlapping searches since they need to know something"] # [doc = " about the previous search. For example, when multiple patterns match at the"] # [doc = " same position, this state tracks the last reported pattern so that the next"] # [doc = " search knows whether to report another matching pattern or continue with"] # [doc = " the search at the next position. Additionally, it also tracks which state"] # [doc = " the last search call terminated in and the current offset of the search"] # [doc = " in the haystack."] # [doc = ""] # [doc = " This type provides limited introspection capabilities. The only thing a"] # [doc = " caller can do is construct it and pass it around to permit search routines"] # [doc = " to use it to track state, and to ask whether a match has been found."] # [doc = ""] # [doc = " Callers should always provide a fresh state constructed via"] # [doc = " [`OverlappingState::start`] when starting a new search. That same state"] # [doc = " should be reused for subsequent searches on the same `Input`. The state"] # [doc = " given will advance through the haystack itself. Callers can detect the end"] # [doc = " of a search when neither an error nor a match is returned."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to manually iterate over all overlapping matches. If"] # [doc = " you need this, you might consider using"] # [doc = " [`AhoCorasick::find_overlapping_iter`](crate::AhoCorasick::find_overlapping_iter)"] # [doc = " instead, but this shows how to correctly use an `OverlappingState`."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut state = OverlappingState::start();"] # [doc = " let mut matches = vec![];"] # [doc = ""] # [doc = " loop {"] # [doc = "     ac.find_overlapping(haystack, &mut state);"] # [doc = "     let mat = match state.get_match() {"] # [doc = "         None => break,"] # [doc = "         Some(mat) => mat,"] # [doc = "     };"] # [doc = "     matches.push(mat);"] # [doc = " }"] # [doc = " let expected = vec!["] # [doc = "     Match::must(2, 0..3),"] # [doc = "     Match::must(0, 0..6),"] # [doc = "     Match::must(2, 11..14),"] # [doc = "     Match::must(2, 22..25),"] # [doc = "     Match::must(0, 22..28),"] # [doc = "     Match::must(1, 22..31),"] # [doc = " ];"] # [doc = " assert_eq!(expected, matches);"] # [doc = " ```"] pub struct OverlappingState { # [doc = " The match reported by the most recent overlapping search to use this"] # [doc = " state."] # [doc = ""] # [doc = " If a search does not find any matches, then it is expected to clear"] # [doc = " this value."] mat : Option < Match > , # [doc = " The state ID of the state at which the search was in when the call"] # [doc = " terminated. When this is a match state, `last_match` must be set to a"] # [doc = " non-None value."] # [doc = ""] # [doc = " A `None` value indicates the start state of the corresponding"] # [doc = " automaton. We cannot use the actual ID, since any one automaton may"] # [doc = " have many start states, and which one is in use depends on search-time"] # [doc = " factors (such as whether the search is anchored or not)."] id : Option < StateID > , # [doc = " The position of the search."] # [doc = ""] # [doc = " When `id` is None (i.e., we are starting a search), this is set to"] # [doc = " the beginning of the search as given by the caller regardless of its"] # [doc = " current value. Subsequent calls to an overlapping search pick up at"] # [doc = " this offset."] at : usize , # [doc = " The index into the matching patterns of the next match to report if the"] # [doc = " current state is a match state. Note that this may be 1 greater than"] # [doc = " the total number of matches to report for the current match state. (In"] # [doc = " which case, no more matches should be reported at the current position"] # [doc = " and the search should advance to the next position.)"] next_match_index : Option < usize > , }