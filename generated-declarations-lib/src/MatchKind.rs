# [doc = " A knob for controlling the match semantics of an Aho-Corasick automaton."] # [doc = ""] # [doc = " There are two generally different ways that Aho-Corasick automatons can"] # [doc = " report matches. The first way is the \"standard\" approach that results from"] # [doc = " implementing most textbook explanations of Aho-Corasick. The second way is"] # [doc = " to report only the leftmost non-overlapping matches. The leftmost approach"] # [doc = " is in turn split into two different ways of resolving ambiguous matches:"] # [doc = " leftmost-first and leftmost-longest."] # [doc = ""] # [doc = " The `Standard` match kind is the default and is the only one that supports"] # [doc = " overlapping matches and stream searching. (Trying to find overlapping or"] # [doc = " streaming matches using leftmost match semantics will result in an error in"] # [doc = " fallible APIs and a panic when using infallibe APIs.) The `Standard` match"] # [doc = " kind will report matches as they are seen. When searching for overlapping"] # [doc = " matches, then all possible matches are reported. When searching for"] # [doc = " non-overlapping matches, the first match seen is reported. For example, for"] # [doc = " non-overlapping matches, given the patterns `abcd` and `b` and the haystack"] # [doc = " `abcdef`, only a match for `b` is reported since it is detected first. The"] # [doc = " `abcd` match is never reported since it overlaps with the `b` match."] # [doc = ""] # [doc = " In contrast, the leftmost match kind always prefers the leftmost match"] # [doc = " among all possible matches. Given the same example as above with `abcd` and"] # [doc = " `b` as patterns and `abcdef` as the haystack, the leftmost match is `abcd`"] # [doc = " since it begins before the `b` match, even though the `b` match is detected"] # [doc = " before the `abcd` match. In this case, the `b` match is not reported at all"] # [doc = " since it overlaps with the `abcd` match."] # [doc = ""] # [doc = " The difference between leftmost-first and leftmost-longest is in how they"] # [doc = " resolve ambiguous matches when there are multiple leftmost matches to"] # [doc = " choose from. Leftmost-first always chooses the pattern that was provided"] # [doc = " earliest, where as leftmost-longest always chooses the longest matching"] # [doc = " pattern. For example, given the patterns `a` and `ab` and the subject"] # [doc = " string `ab`, the leftmost-first match is `a` but the leftmost-longest match"] # [doc = " is `ab`. Conversely, if the patterns were given in reverse order, i.e.,"] # [doc = " `ab` and `a`, then both the leftmost-first and leftmost-longest matches"] # [doc = " would be `ab`. Stated differently, the leftmost-first match depends on the"] # [doc = " order in which the patterns were given to the Aho-Corasick automaton."] # [doc = " Because of that, when leftmost-first matching is used, if a pattern `A`"] # [doc = " that appears before a pattern `B` is a prefix of `B`, then it is impossible"] # [doc = " to ever observe a match of `B`."] # [doc = ""] # [doc = " If you're not sure which match kind to pick, then stick with the standard"] # [doc = " kind, which is the default. In particular, if you need overlapping or"] # [doc = " streaming matches, then you _must_ use the standard kind. The leftmost"] # [doc = " kinds are useful in specific circumstances. For example, leftmost-first can"] # [doc = " be very useful as a way to implement match priority based on the order of"] # [doc = " patterns given and leftmost-longest can be useful for dictionary searching"] # [doc = " such that only the longest matching words are reported."] # [doc = ""] # [doc = " # Relationship with regular expression alternations"] # [doc = ""] # [doc = " Understanding match semantics can be a little tricky, and one easy way"] # [doc = " to conceptualize non-overlapping matches from an Aho-Corasick automaton"] # [doc = " is to think about them as a simple alternation of literals in a regular"] # [doc = " expression. For example, let's say we wanted to match the strings"] # [doc = " `Sam` and `Samwise`, which would turn into the regex `Sam|Samwise`. It"] # [doc = " turns out that regular expression engines have two different ways of"] # [doc = " matching this alternation. The first way, leftmost-longest, is commonly"] # [doc = " found in POSIX compatible implementations of regular expressions (such as"] # [doc = " `grep`). The second way, leftmost-first, is commonly found in backtracking"] # [doc = " implementations such as Perl. (Some regex engines, such as RE2 and Rust's"] # [doc = " regex engine do not use backtracking, but still implement leftmost-first"] # [doc = " semantics in an effort to match the behavior of dominant backtracking"] # [doc = " regex engines such as those found in Perl, Ruby, Python, Javascript and"] # [doc = " PHP.)"] # [doc = ""] # [doc = " That is, when matching `Sam|Samwise` against `Samwise`, a POSIX regex"] # [doc = " will match `Samwise` because it is the longest possible match, but a"] # [doc = " Perl-like regex will match `Sam` since it appears earlier in the"] # [doc = " alternation. Indeed, the regex `Sam|Samwise` in a Perl-like regex engine"] # [doc = " will never match `Samwise` since `Sam` will always have higher priority."] # [doc = " Conversely, matching the regex `Samwise|Sam` against `Samwise` will lead to"] # [doc = " a match of `Samwise` in both POSIX and Perl-like regexes since `Samwise` is"] # [doc = " still longest match, but it also appears earlier than `Sam`."] # [doc = ""] # [doc = " The \"standard\" match semantics of Aho-Corasick generally don't correspond"] # [doc = " to the match semantics of any large group of regex implementations, so"] # [doc = " there's no direct analogy that can be made here. Standard match semantics"] # [doc = " are generally useful for overlapping matches, or if you just want to see"] # [doc = " matches as they are detected."] # [doc = ""] # [doc = " The main conclusion to draw from this section is that the match semantics"] # [doc = " can be tweaked to precisely match either Perl-like regex alternations or"] # [doc = " POSIX regex alternations."] # [non_exhaustive] pub enum MatchKind { # [doc = " Use standard match semantics, which support overlapping matches. When"] # [doc = " used with non-overlapping matches, matches are reported as they are"] # [doc = " seen."] Standard , # [doc = " Use leftmost-first match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the match"] # [doc = " corresponding to the pattern that appeared earlier when constructing"] # [doc = " the automaton is reported."] # [doc = ""] # [doc = " This does **not** support overlapping matches or stream searching. If"] # [doc = " this match kind is used, attempting to find overlapping matches or"] # [doc = " stream matches will fail."] LeftmostFirst , # [doc = " Use leftmost-longest match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the longest match"] # [doc = " is chosen."] # [doc = ""] # [doc = " This does **not** support overlapping matches or stream searching. If"] # [doc = " this match kind is used, attempting to find overlapping matches or"] # [doc = " stream matches will fail."] LeftmostLongest , }