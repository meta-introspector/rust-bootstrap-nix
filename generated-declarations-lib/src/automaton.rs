pub mod automaton { # ! [doc = "\nProvides [`Automaton`] trait for abstracting over Aho-Corasick automata.\n\nThe `Automaton` trait provides a way to write generic code over any\nAho-Corasick automaton. It also provides access to lower level APIs that\npermit walking the state transitions of an Aho-Corasick automaton manually.\n"] use alloc :: { string :: String , vec :: Vec } ; use crate :: util :: { error :: MatchError , primitives :: PatternID , search :: { Anchored , Input , Match , MatchKind , Span } , } ; pub use crate :: util :: { prefilter :: { Candidate , Prefilter } , primitives :: { StateID , StateIDError } , } ; # [doc = " We seal the `Automaton` trait for now. It's a big trait, and it's"] # [doc = " conceivable that I might want to add new required methods, and sealing the"] # [doc = " trait permits doing that in a backwards compatible fashion. On other the"] # [doc = " hand, if you have a solid use case for implementing the trait yourself,"] # [doc = " please file an issue and we can discuss it. This was *mostly* done as a"] # [doc = " conservative step."] pub (crate) mod private { pub trait Sealed { } } impl private :: Sealed for crate :: nfa :: noncontiguous :: NFA { } impl private :: Sealed for crate :: nfa :: contiguous :: NFA { } impl private :: Sealed for crate :: dfa :: DFA { } impl < 'a , T : private :: Sealed + ? Sized > private :: Sealed for & 'a T { } # [doc = " A trait that abstracts over Aho-Corasick automata."] # [doc = ""] # [doc = " This trait primarily exists for niche use cases such as:"] # [doc = ""] # [doc = " * Using an NFA or DFA directly, bypassing the top-level"] # [doc = " [`AhoCorasick`](crate::AhoCorasick) searcher. Currently, these include"] # [doc = " [`noncontiguous::NFA`](crate::nfa::noncontiguous::NFA),"] # [doc = " [`contiguous::NFA`](crate::nfa::contiguous::NFA) and"] # [doc = " [`dfa::DFA`](crate::dfa::DFA)."] # [doc = " * Implementing your own custom search routine by walking the automaton"] # [doc = " yourself. This might be useful for implementing search on non-contiguous"] # [doc = " strings or streams."] # [doc = ""] # [doc = " For most use cases, it is not expected that users will need"] # [doc = " to use or even know about this trait. Indeed, the top level"] # [doc = " [`AhoCorasick`](crate::AhoCorasick) searcher does not expose any details"] # [doc = " about this trait, nor does it implement it itself."] # [doc = ""] # [doc = " Note that this trait defines a number of default methods, such as"] # [doc = " [`Automaton::try_find`] and [`Automaton::try_find_iter`], which implement"] # [doc = " higher level search routines in terms of the lower level automata API."] # [doc = ""] # [doc = " # Sealed"] # [doc = ""] # [doc = " Currently, this trait is sealed. That means users of this crate can write"] # [doc = " generic routines over this trait but cannot implement it themselves. This"] # [doc = " restriction may be lifted in the future, but sealing the trait permits"] # [doc = " adding new required methods in a backwards compatible fashion."] # [doc = ""] # [doc = " # Special states"] # [doc = ""] # [doc = " This trait encodes a notion of \"special\" states in an automaton. Namely,"] # [doc = " a state is treated as special if it is a dead, match or start state:"] # [doc = ""] # [doc = " * A dead state is a state that cannot be left once entered. All transitions"] # [doc = " on a dead state lead back to itself. The dead state is meant to be treated"] # [doc = " as a sentinel indicating that the search should stop and return a match if"] # [doc = " one has been found, and nothing otherwise."] # [doc = " * A match state is a state that indicates one or more patterns have"] # [doc = " matched. Depending on the [`MatchKind`] of the automaton, a search may"] # [doc = " stop once a match is seen, or it may continue looking for matches until"] # [doc = " it enters a dead state or sees the end of the haystack."] # [doc = " * A start state is a state that a search begins in. It is useful to know"] # [doc = " when a search enters a start state because it may mean that a prefilter can"] # [doc = " be used to skip ahead and quickly look for candidate matches. Unlike dead"] # [doc = " and match states, it is never necessary to explicitly handle start states"] # [doc = " for correctness. Indeed, in this crate, implementations of `Automaton`"] # [doc = " will only treat start states as \"special\" when a prefilter is enabled and"] # [doc = " active. Otherwise, treating it as special has no purpose and winds up"] # [doc = " slowing down the overall search because it results in ping-ponging between"] # [doc = " the main state transition and the \"special\" state logic."] # [doc = ""] # [doc = " Since checking whether a state is special by doing three different"] # [doc = " checks would be too expensive inside a fast search loop, the"] # [doc = " [`Automaton::is_special`] method is provided for quickly checking whether"] # [doc = " the state is special. The `Automaton::is_dead`, `Automaton::is_match` and"] # [doc = " `Automaton::is_start` predicates can then be used to determine which kind"] # [doc = " of special state it is."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " Most of the APIs on this trait should panic or give incorrect results"] # [doc = " if invalid inputs are given to it. For example, `Automaton::next_state`"] # [doc = " has unspecified behavior if the state ID given to it is not a valid"] # [doc = " state ID for the underlying automaton. Valid state IDs can only be"] # [doc = " retrieved in one of two ways: calling `Automaton::start_state` or calling"] # [doc = " `Automaton::next_state` with a valid state ID."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " This trait is not safe to implement so that code may rely on the"] # [doc = " correctness of implementations of this trait to avoid undefined behavior."] # [doc = " The primary correctness guarantees are:"] # [doc = ""] # [doc = " * `Automaton::start_state` always returns a valid state ID or an error or"] # [doc = " panics."] # [doc = " * `Automaton::next_state`, when given a valid state ID, always returns"] # [doc = " a valid state ID for all values of `anchored` and `byte`, or otherwise"] # [doc = " panics."] # [doc = ""] # [doc = " In general, the rest of the methods on `Automaton` need to uphold their"] # [doc = " contracts as well. For example, `Automaton::is_dead` should only returns"] # [doc = " true if the given state ID is actually a dead state."] # [doc = ""] # [doc = " Note that currently this crate does not rely on the safety property defined"] # [doc = " here to avoid undefined behavior. Instead, this was done to make it"] # [doc = " _possible_ to do in the future."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how one might implement a basic but correct search"] # [doc = " routine. We keep things simple by not using prefilters or worrying about"] # [doc = " anchored searches, but do make sure our search is correct for all possible"] # [doc = " [`MatchKind`] semantics. (The comments in the code below note the parts"] # [doc = " that are needed to support certain `MatchKind` semantics.)"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::Automaton,"] # [doc = "     nfa::noncontiguous::NFA,"] # [doc = "     Anchored, Match, MatchError, MatchKind,"] # [doc = " };"] # [doc = ""] # [doc = " // Run an unanchored search for 'aut' in 'haystack'. Return the first match"] # [doc = " // seen according to the automaton's match semantics. This returns an error"] # [doc = " // if the given automaton does not support unanchored searches."] # [doc = " fn find<A: Automaton>("] # [doc = "     aut: A,"] # [doc = "     haystack: &[u8],"] # [doc = " ) -> Result<Option<Match>, MatchError> {"] # [doc = "     let mut sid = aut.start_state(Anchored::No)?;"] # [doc = "     let mut at = 0;"] # [doc = "     let mut mat = None;"] # [doc = "     let get_match = |sid, at| {"] # [doc = "         let pid = aut.match_pattern(sid, 0);"] # [doc = "         let len = aut.pattern_len(pid);"] # [doc = "         Match::new(pid, (at - len)..at)"] # [doc = "     };"] # [doc = "     // Start states can be match states!"] # [doc = "     if aut.is_match(sid) {"] # [doc = "         mat = Some(get_match(sid, at));"] # [doc = "         // Standard semantics require matches to be reported as soon as"] # [doc = "         // they're seen. Otherwise, we continue until we see a dead state"] # [doc = "         // or the end of the haystack."] # [doc = "         if matches!(aut.match_kind(), MatchKind::Standard) {"] # [doc = "             return Ok(mat);"] # [doc = "         }"] # [doc = "     }"] # [doc = "     while at < haystack.len() {"] # [doc = "         sid = aut.next_state(Anchored::No, sid, haystack[at]);"] # [doc = "         if aut.is_special(sid) {"] # [doc = "             if aut.is_dead(sid) {"] # [doc = "                 return Ok(mat);"] # [doc = "             } else if aut.is_match(sid) {"] # [doc = "                 mat = Some(get_match(sid, at + 1));"] # [doc = "                 // As above, standard semantics require that we return"] # [doc = "                 // immediately once a match is found."] # [doc = "                 if matches!(aut.match_kind(), MatchKind::Standard) {"] # [doc = "                     return Ok(mat);"] # [doc = "                 }"] # [doc = "             }"] # [doc = "         }"] # [doc = "         at += 1;"] # [doc = "     }"] # [doc = "     Ok(mat)"] # [doc = " }"] # [doc = ""] # [doc = " // Show that it works for standard searches."] # [doc = " let nfa = NFA::new(&[\"samwise\", \"sam\"]).unwrap();"] # [doc = " assert_eq!(Some(Match::must(1, 0..3)), find(&nfa, b\"samwise\")?);"] # [doc = ""] # [doc = " // But also works when using leftmost-first. Notice how the match result"] # [doc = " // has changed!"] # [doc = " let nfa = NFA::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(&[\"samwise\", \"sam\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(Some(Match::must(0, 0..7)), find(&nfa, b\"samwise\")?);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub unsafe trait Automaton : private :: Sealed { # [doc = " Returns the starting state for the given anchor mode."] # [doc = ""] # [doc = " Upon success, the state ID returned is guaranteed to be valid for"] # [doc = " this automaton."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when the given search configuration is not"] # [doc = " supported by the underlying automaton. For example, if the underlying"] # [doc = " automaton only supports unanchored searches but the given configuration"] # [doc = " was set to an anchored search, then this must return an error."] fn start_state (& self , anchored : Anchored) -> Result < StateID , MatchError > ; # [doc = " Performs a state transition from `sid` for `byte` and returns the next"] # [doc = " state."] # [doc = ""] # [doc = " `anchored` should be [`Anchored::Yes`] when executing an anchored"] # [doc = " search and [`Anchored::No`] otherwise. For some implementations of"] # [doc = " `Automaton`, it is required to know whether the search is anchored"] # [doc = " or not in order to avoid following failure transitions. Other"] # [doc = " implementations may ignore `anchored` altogether and depend on"] # [doc = " `Automaton::start_state` returning a state that walks a different path"] # [doc = " through the automaton depending on whether the search is anchored or"] # [doc = " not."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This routine may panic or return incorrect results when the given state"] # [doc = " ID is invalid. A state ID is valid if and only if:"] # [doc = ""] # [doc = " 1. It came from a call to `Automaton::start_state`, or"] # [doc = " 2. It came from a previous call to `Automaton::next_state` with a"] # [doc = " valid state ID."] # [doc = ""] # [doc = " Implementations must treat all possible values of `byte` as valid."] # [doc = ""] # [doc = " Implementations may panic on unsupported values of `anchored`, but are"] # [doc = " not required to do so."] fn next_state (& self , anchored : Anchored , sid : StateID , byte : u8) -> StateID ; # [doc = " Returns true if the given ID represents a \"special\" state. A special"] # [doc = " state is a dead, match or start state."] # [doc = ""] # [doc = " Note that implementations may choose to return false when the given ID"] # [doc = " corresponds to a start state. Namely, it always correct to treat start"] # [doc = " states as non-special. Implementations must return true for states that"] # [doc = " are dead or contain matches."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_special (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a dead state."] # [doc = ""] # [doc = " A dead state is a type of \"sink\" in a finite state machine. It"] # [doc = " corresponds to a state whose transitions all loop back to itself. That"] # [doc = " is, once entered, it can never be left. In practice, it serves as a"] # [doc = " sentinel indicating that the search should terminate."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_dead (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a match state."] # [doc = ""] # [doc = " A match state is always associated with one or more pattern IDs that"] # [doc = " matched at the position in the haystack when the match state was"] # [doc = " entered. When a match state is entered, the match semantics dictate"] # [doc = " whether it should be returned immediately (for `MatchKind::Standard`)"] # [doc = " or if the search should continue (for `MatchKind::LeftmostFirst` and"] # [doc = " `MatchKind::LeftmostLongest`) until a dead state is seen or the end of"] # [doc = " the haystack has been reached."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_match (& self , sid : StateID) -> bool ; # [doc = " Returns true if the given ID represents a start state."] # [doc = ""] # [doc = " While it is never incorrect to ignore start states during a search"] # [doc = " (except for the start of the search of course), knowing whether one has"] # [doc = " entered a start state can be useful for certain classes of performance"] # [doc = " optimizations. For example, if one is in a start state, it may be legal"] # [doc = " to try to skip ahead and look for match candidates more quickly than"] # [doc = " would otherwise be accomplished by walking the automaton."] # [doc = ""] # [doc = " Implementations of `Automaton` in this crate \"unspecialize\" start"] # [doc = " states when a prefilter is not active or enabled. In this case, it"] # [doc = " is possible for `Automaton::is_special(sid)` to return false while"] # [doc = " `Automaton::is_start(sid)` returns true."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid state ID."] fn is_start (& self , sid : StateID) -> bool ; # [doc = " Returns the match semantics that this automaton was built with."] fn match_kind (& self) -> MatchKind ; # [doc = " Returns the total number of matches for the given state ID."] # [doc = ""] # [doc = " This has unspecified behavior if the given ID does not refer to a match"] # [doc = " state."] fn match_len (& self , sid : StateID) -> usize ; # [doc = " Returns the pattern ID for the match state given by `sid` at the"] # [doc = " `index` given."] # [doc = ""] # [doc = " Typically, `index` is only ever greater than `0` when implementing an"] # [doc = " overlapping search. Otherwise, it's likely that your search only cares"] # [doc = " about reporting the first pattern ID in a match state."] # [doc = ""] # [doc = " This has unspecified behavior if the given ID does not refer to a match"] # [doc = " state, or if the index is greater than or equal to the total number of"] # [doc = " matches in this match state."] fn match_pattern (& self , sid : StateID , index : usize) -> PatternID ; # [doc = " Returns the total number of patterns compiled into this automaton."] fn patterns_len (& self) -> usize ; # [doc = " Returns the length of the pattern for the given ID."] # [doc = ""] # [doc = " This has unspecified behavior when given an invalid pattern"] # [doc = " ID. A pattern ID is valid if and only if it is less than"] # [doc = " `Automaton::patterns_len`."] fn pattern_len (& self , pid : PatternID) -> usize ; # [doc = " Returns the length, in bytes, of the shortest pattern in this"] # [doc = " automaton."] fn min_pattern_len (& self) -> usize ; # [doc = " Returns the length, in bytes, of the longest pattern in this automaton."] fn max_pattern_len (& self) -> usize ; # [doc = " Returns the heap memory usage, in bytes, used by this automaton."] fn memory_usage (& self) -> usize ; # [doc = " Returns a prefilter, if available, that can be used to accelerate"] # [doc = " searches for this automaton."] # [doc = ""] # [doc = " The typical way this is used is when the start state is entered during"] # [doc = " a search. When that happens, one can use a prefilter to skip ahead and"] # [doc = " look for candidate matches without having to walk the automaton on the"] # [doc = " bytes between candidates."] # [doc = ""] # [doc = " Typically a prefilter is only available when there are a small (<100)"] # [doc = " number of patterns built into the automaton."] fn prefilter (& self) -> Option < & Prefilter > ; # [doc = " Executes a non-overlapping search with this automaton using the given"] # [doc = " configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find`](crate::AhoCorasick::try_find)"] # [doc = " for more documentation and examples."] fn try_find (& self , input : & Input < '_ >) -> Result < Option < Match > , MatchError > { try_find_fwd (& self , input) } # [doc = " Executes a overlapping search with this automaton using the given"] # [doc = " configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_overlapping`](crate::AhoCorasick::try_find_overlapping)"] # [doc = " for more documentation and examples."] fn try_find_overlapping (& self , input : & Input < '_ > , state : & mut OverlappingState ,) -> Result < () , MatchError > { try_find_overlapping_fwd (& self , input , state) } # [doc = " Returns an iterator of non-overlapping matches with this automaton"] # [doc = " using the given configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_iter`](crate::AhoCorasick::try_find_iter)"] # [doc = " for more documentation and examples."] fn try_find_iter < 'a , 'h > (& 'a self , input : Input < 'h > ,) -> Result < FindIter < 'a , 'h , Self > , MatchError > where Self : Sized , { FindIter :: new (self , input) } # [doc = " Returns an iterator of overlapping matches with this automaton"] # [doc = " using the given configuration."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_find_overlapping_iter`](crate::AhoCorasick::try_find_overlapping_iter)"] # [doc = " for more documentation and examples."] fn try_find_overlapping_iter < 'a , 'h > (& 'a self , input : Input < 'h > ,) -> Result < FindOverlappingIter < 'a , 'h , Self > , MatchError > where Self : Sized , { if ! self . match_kind () . is_standard () { return Err (MatchError :: unsupported_overlapping (self . match_kind ())) ; } if input . get_anchored () . is_anchored () { return Err (MatchError :: invalid_input_anchored ()) ; } let _ = self . start_state (input . get_anchored ()) ? ; let state = OverlappingState :: start () ; Ok (FindOverlappingIter { aut : self , input , state , }) } # [doc = " Replaces all non-overlapping matches in `haystack` with"] # [doc = " strings from `replace_with` depending on the pattern that"] # [doc = " matched. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all`](crate::AhoCorasick::try_replace_all)"] # [doc = " for more documentation and examples."] fn try_replace_all < B > (& self , haystack : & str , replace_with : & [B] ,) -> Result < String , MatchError > where Self : Sized , B : AsRef < str > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; let mut dst = String :: with_capacity (haystack . len ()) ; self . try_replace_all_with (haystack , & mut dst , | mat , _ , dst | { dst . push_str (replace_with [mat . pattern ()] . as_ref ()) ; true } ,) ? ; Ok (dst) } # [doc = " Replaces all non-overlapping matches in `haystack` with"] # [doc = " strings from `replace_with` depending on the pattern that"] # [doc = " matched. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_bytes`](crate::AhoCorasick::try_replace_all_bytes)"] # [doc = " for more documentation and examples."] fn try_replace_all_bytes < B > (& self , haystack : & [u8] , replace_with : & [B] ,) -> Result < Vec < u8 > , MatchError > where Self : Sized , B : AsRef < [u8] > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; let mut dst = Vec :: with_capacity (haystack . len ()) ; self . try_replace_all_with_bytes (haystack , & mut dst , | mat , _ , dst | { dst . extend (replace_with [mat . pattern ()] . as_ref ()) ; true } ,) ? ; Ok (dst) } # [doc = " Replaces all non-overlapping matches in `haystack` by calling the"] # [doc = " `replace_with` closure given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_with`](crate::AhoCorasick::try_replace_all_with)"] # [doc = " for more documentation and examples."] fn try_replace_all_with < F > (& self , haystack : & str , dst : & mut String , mut replace_with : F ,) -> Result < () , MatchError > where Self : Sized , F : FnMut (& Match , & str , & mut String) -> bool , { let mut last_match = 0 ; for m in self . try_find_iter (Input :: new (haystack)) ? { if ! haystack . is_char_boundary (m . start ()) || ! haystack . is_char_boundary (m . end ()) { continue ; } dst . push_str (& haystack [last_match .. m . start ()]) ; last_match = m . end () ; if ! replace_with (& m , & haystack [m . start () .. m . end ()] , dst) { break ; } } dst . push_str (& haystack [last_match ..]) ; Ok (()) } # [doc = " Replaces all non-overlapping matches in `haystack` by calling the"] # [doc = " `replace_with` closure given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_replace_all_with_bytes`](crate::AhoCorasick::try_replace_all_with_bytes)"] # [doc = " for more documentation and examples."] fn try_replace_all_with_bytes < F > (& self , haystack : & [u8] , dst : & mut Vec < u8 > , mut replace_with : F ,) -> Result < () , MatchError > where Self : Sized , F : FnMut (& Match , & [u8] , & mut Vec < u8 >) -> bool , { let mut last_match = 0 ; for m in self . try_find_iter (Input :: new (haystack)) ? { dst . extend (& haystack [last_match .. m . start ()]) ; last_match = m . end () ; if ! replace_with (& m , & haystack [m . start () .. m . end ()] , dst) { break ; } } dst . extend (& haystack [last_match ..]) ; Ok (()) } # [doc = " Returns an iterator of non-overlapping matches with this automaton"] # [doc = " from the stream given."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_find_iter`](crate::AhoCorasick::try_stream_find_iter)"] # [doc = " for more documentation and examples."] fn try_stream_find_iter < 'a , R : std :: io :: Read > (& 'a self , rdr : R ,) -> Result < StreamFindIter < 'a , Self , R > , MatchError > where Self : Sized , { Ok (StreamFindIter { it : StreamChunkIter :: new (self , rdr) ? , }) } # [doc = " Replaces all non-overlapping matches in `rdr` with strings from"] # [doc = " `replace_with` depending on the pattern that matched, and writes the"] # [doc = " result to `wtr`. The `replace_with` slice must have length equal to"] # [doc = " `Automaton::patterns_len`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_replace_all`](crate::AhoCorasick::try_stream_replace_all)"] # [doc = " for more documentation and examples."] fn try_stream_replace_all < R , W , B > (& self , rdr : R , wtr : W , replace_with : & [B] ,) -> std :: io :: Result < () > where Self : Sized , R : std :: io :: Read , W : std :: io :: Write , B : AsRef < [u8] > , { match (& replace_with . len () , & self . patterns_len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("streaming replace_all requires a replacement for every pattern in the automaton" ,) ,) ,) ; } } } ; self . try_stream_replace_all_with (rdr , wtr , | mat , _ , wtr | { wtr . write_all (replace_with [mat . pattern ()] . as_ref ()) } ,) } # [doc = " Replaces all non-overlapping matches in `rdr` by calling the"] # [doc = " `replace_with` closure given and writing the result to `wtr`."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasick::try_stream_replace_all_with`](crate::AhoCorasick::try_stream_replace_all_with)"] # [doc = " for more documentation and examples."] fn try_stream_replace_all_with < R , W , F > (& self , rdr : R , mut wtr : W , mut replace_with : F ,) -> std :: io :: Result < () > where Self : Sized , R : std :: io :: Read , W : std :: io :: Write , F : FnMut (& Match , & [u8] , & mut W) -> std :: io :: Result < () > , { let mut it = StreamChunkIter :: new (self , rdr) . map_err (| e | { let kind = std :: io :: ErrorKind :: Other ; std :: io :: Error :: new (kind , e) }) ? ; while let Some (result) = it . next () { let chunk = result ? ; match chunk { StreamChunk :: NonMatch { bytes , .. } => { wtr . write_all (bytes) ? ; } StreamChunk :: Match { bytes , mat } => { replace_with (& mat , bytes , & mut wtr) ? ; } } } Ok (()) } } unsafe impl < 'a , A : Automaton + ? Sized > Automaton for & 'a A { # [inline (always)] fn start_state (& self , anchored : Anchored) -> Result < StateID , MatchError > { (* * self) . start_state (anchored) } # [inline (always)] fn next_state (& self , anchored : Anchored , sid : StateID , byte : u8) -> StateID { (* * self) . next_state (anchored , sid , byte) } # [inline (always)] fn is_special (& self , sid : StateID) -> bool { (* * self) . is_special (sid) } # [inline (always)] fn is_dead (& self , sid : StateID) -> bool { (* * self) . is_dead (sid) } # [inline (always)] fn is_match (& self , sid : StateID) -> bool { (* * self) . is_match (sid) } # [inline (always)] fn is_start (& self , sid : StateID) -> bool { (* * self) . is_start (sid) } # [inline (always)] fn match_kind (& self) -> MatchKind { (* * self) . match_kind () } # [inline (always)] fn match_len (& self , sid : StateID) -> usize { (* * self) . match_len (sid) } # [inline (always)] fn match_pattern (& self , sid : StateID , index : usize) -> PatternID { (* * self) . match_pattern (sid , index) } # [inline (always)] fn patterns_len (& self) -> usize { (* * self) . patterns_len () } # [inline (always)] fn pattern_len (& self , pid : PatternID) -> usize { (* * self) . pattern_len (pid) } # [inline (always)] fn min_pattern_len (& self) -> usize { (* * self) . min_pattern_len () } # [inline (always)] fn max_pattern_len (& self) -> usize { (* * self) . max_pattern_len () } # [inline (always)] fn memory_usage (& self) -> usize { (* * self) . memory_usage () } # [inline (always)] fn prefilter (& self) -> Option < & Prefilter > { (* * self) . prefilter () } } # [doc = " Represents the current state of an overlapping search."] # [doc = ""] # [doc = " This is used for overlapping searches since they need to know something"] # [doc = " about the previous search. For example, when multiple patterns match at the"] # [doc = " same position, this state tracks the last reported pattern so that the next"] # [doc = " search knows whether to report another matching pattern or continue with"] # [doc = " the search at the next position. Additionally, it also tracks which state"] # [doc = " the last search call terminated in and the current offset of the search"] # [doc = " in the haystack."] # [doc = ""] # [doc = " This type provides limited introspection capabilities. The only thing a"] # [doc = " caller can do is construct it and pass it around to permit search routines"] # [doc = " to use it to track state, and to ask whether a match has been found."] # [doc = ""] # [doc = " Callers should always provide a fresh state constructed via"] # [doc = " [`OverlappingState::start`] when starting a new search. That same state"] # [doc = " should be reused for subsequent searches on the same `Input`. The state"] # [doc = " given will advance through the haystack itself. Callers can detect the end"] # [doc = " of a search when neither an error nor a match is returned."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to manually iterate over all overlapping matches. If"] # [doc = " you need this, you might consider using"] # [doc = " [`AhoCorasick::find_overlapping_iter`](crate::AhoCorasick::find_overlapping_iter)"] # [doc = " instead, but this shows how to correctly use an `OverlappingState`."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut state = OverlappingState::start();"] # [doc = " let mut matches = vec![];"] # [doc = ""] # [doc = " loop {"] # [doc = "     ac.find_overlapping(haystack, &mut state);"] # [doc = "     let mat = match state.get_match() {"] # [doc = "         None => break,"] # [doc = "         Some(mat) => mat,"] # [doc = "     };"] # [doc = "     matches.push(mat);"] # [doc = " }"] # [doc = " let expected = vec!["] # [doc = "     Match::must(2, 0..3),"] # [doc = "     Match::must(0, 0..6),"] # [doc = "     Match::must(2, 11..14),"] # [doc = "     Match::must(2, 22..25),"] # [doc = "     Match::must(0, 22..28),"] # [doc = "     Match::must(1, 22..31),"] # [doc = " ];"] # [doc = " assert_eq!(expected, matches);"] # [doc = " ```"] pub struct OverlappingState { # [doc = " The match reported by the most recent overlapping search to use this"] # [doc = " state."] # [doc = ""] # [doc = " If a search does not find any matches, then it is expected to clear"] # [doc = " this value."] mat : Option < Match > , # [doc = " The state ID of the state at which the search was in when the call"] # [doc = " terminated. When this is a match state, `last_match` must be set to a"] # [doc = " non-None value."] # [doc = ""] # [doc = " A `None` value indicates the start state of the corresponding"] # [doc = " automaton. We cannot use the actual ID, since any one automaton may"] # [doc = " have many start states, and which one is in use depends on search-time"] # [doc = " factors (such as whether the search is anchored or not)."] id : Option < StateID > , # [doc = " The position of the search."] # [doc = ""] # [doc = " When `id` is None (i.e., we are starting a search), this is set to"] # [doc = " the beginning of the search as given by the caller regardless of its"] # [doc = " current value. Subsequent calls to an overlapping search pick up at"] # [doc = " this offset."] at : usize , # [doc = " The index into the matching patterns of the next match to report if the"] # [doc = " current state is a match state. Note that this may be 1 greater than"] # [doc = " the total number of matches to report for the current match state. (In"] # [doc = " which case, no more matches should be reported at the current position"] # [doc = " and the search should advance to the next position.)"] next_match_index : Option < usize > , } # [automatically_derived] impl :: core :: clone :: Clone for OverlappingState { # [inline] fn clone (& self) -> OverlappingState { OverlappingState { mat : :: core :: clone :: Clone :: clone (& self . mat) , id : :: core :: clone :: Clone :: clone (& self . id) , at : :: core :: clone :: Clone :: clone (& self . at) , next_match_index : :: core :: clone :: Clone :: clone (& self . next_match_index) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for OverlappingState { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "OverlappingState" , "mat" , & self . mat , "id" , & self . id , "at" , & self . at , "next_match_index" , & & self . next_match_index ,) } } impl OverlappingState { # [doc = " Create a new overlapping state that begins at the start state."] pub fn start () -> OverlappingState { OverlappingState { mat : None , id : None , at : 0 , next_match_index : None , } } # [doc = " Return the match result of the most recent search to execute with this"] # [doc = " state."] # [doc = ""] # [doc = " Every search will clear this result automatically, such that if no"] # [doc = " match is found, this will always correctly report `None`."] pub fn get_match (& self) -> Option < Match > { self . mat } } # [doc = " An iterator of non-overlapping matches in a particular haystack."] # [doc = ""] # [doc = " This iterator yields matches according to the [`MatchKind`] used by this"] # [doc = " automaton."] # [doc = ""] # [doc = " This iterator is constructed via the [`Automaton::try_find_iter`] method."] # [doc = ""] # [doc = " The type variable `A` refers to the implementation of the [`Automaton`]"] # [doc = " trait used to execute the search."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the [`Automaton`]"] # [doc = " implementation."] # [doc = ""] # [doc = " The lifetime `'h` refers to the lifetime of the haystack being searched."] pub struct FindIter < 'a , 'h , A > { # [doc = " The automaton used to drive the search."] aut : & 'a A , # [doc = " The input parameters to give to each search call."] # [doc = ""] # [doc = " The start position of the search is mutated during iteration."] input : Input < 'h > , # [doc = " Records the end offset of the most recent match. This is necessary to"] # [doc = " handle a corner case for preventing empty matches from overlapping with"] # [doc = " the ending bounds of a prior match."] last_match_end : Option < usize > , } # [automatically_derived] impl < 'a , 'h , A : :: core :: fmt :: Debug > :: core :: fmt :: Debug for FindIter < 'a , 'h , A > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "FindIter" , "aut" , & self . aut , "input" , & self . input , "last_match_end" , & & self . last_match_end ,) } } impl < 'a , 'h , A : Automaton > FindIter < 'a , 'h , A > { # [doc = " Creates a new non-overlapping iterator. If the given automaton would"] # [doc = " return an error on a search with the given input configuration, then"] # [doc = " that error is returned here."] fn new (aut : & 'a A , input : Input < 'h >) -> Result < FindIter < 'a , 'h , A > , MatchError > { let _ = aut . start_state (input . get_anchored ()) ? ; Ok (FindIter { aut , input , last_match_end : None , }) } # [doc = " Executes a search and returns a match if one is found."] # [doc = ""] # [doc = " This does not advance the input forward. It just executes a search"] # [doc = " based on the current configuration/offsets."] fn search (& self) -> Option < Match > { self . aut . try_find (& self . input) . expect ("already checked that no match error can occur") } # [doc = " Handles the special case of an empty match by ensuring that 1) the"] # [doc = " iterator always advances and 2) empty matches never overlap with other"] # [doc = " matches."] # [doc = ""] # [doc = " (1) is necessary because we principally make progress by setting the"] # [doc = " starting location of the next search to the ending location of the last"] # [doc = " match. But if a match is empty, then this results in a search that does"] # [doc = " not advance and thus does not terminate."] # [doc = ""] # [doc = " (2) is not strictly necessary, but makes intuitive sense and matches"] # [doc = " the presiding behavior of most general purpose regex engines."] # [doc = " (Obviously this crate isn't a regex engine, but we choose to match"] # [doc = " their semantics.) The \"intuitive sense\" here is that we want to report"] # [doc = " NON-overlapping matches. So for example, given the patterns 'a' and"] # [doc = " '' (an empty string) against the haystack 'a', without the special"] # [doc = " handling, you'd get the matches [0, 1) and [1, 1), where the latter"] # [doc = " overlaps with the end bounds of the former."] # [doc = ""] # [doc = " Note that we mark this cold and forcefully prevent inlining because"] # [doc = " handling empty matches like this is extremely rare and does require"] # [doc = " quite a bit of code, comparatively. Keeping this code out of the main"] # [doc = " iterator function keeps it smaller and more amenable to inlining"] # [doc = " itself."] # [cold] # [inline (never)] fn handle_overlapping_empty_match (& mut self , mut m : Match) -> Option < Match > { if ! m . is_empty () { :: core :: panicking :: panic ("assertion failed: m.is_empty()") } if Some (m . end ()) == self . last_match_end { self . input . set_start (self . input . start () . checked_add (1) . unwrap ()) ; m = self . search () ? ; } Some (m) } } impl < 'a , 'h , A : Automaton > Iterator for FindIter < 'a , 'h , A > { type Item = Match ; # [inline (always)] fn next (& mut self) -> Option < Match > { let mut m = self . search () ? ; if m . is_empty () { m = self . handle_overlapping_empty_match (m) ? ; } self . input . set_start (m . end ()) ; self . last_match_end = Some (m . end ()) ; Some (m) } } # [doc = " An iterator of overlapping matches in a particular haystack."] # [doc = ""] # [doc = " This iterator will report all possible matches in a particular haystack,"] # [doc = " even when the matches overlap."] # [doc = ""] # [doc = " This iterator is constructed via the"] # [doc = " [`Automaton::try_find_overlapping_iter`] method."] # [doc = ""] # [doc = " The type variable `A` refers to the implementation of the [`Automaton`]"] # [doc = " trait used to execute the search."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the [`Automaton`]"] # [doc = " implementation."] # [doc = ""] # [doc = " The lifetime `'h` refers to the lifetime of the haystack being searched."] pub struct FindOverlappingIter < 'a , 'h , A > { aut : & 'a A , input : Input < 'h > , state : OverlappingState , } # [automatically_derived] impl < 'a , 'h , A : :: core :: fmt :: Debug > :: core :: fmt :: Debug for FindOverlappingIter < 'a , 'h , A > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "FindOverlappingIter" , "aut" , & self . aut , "input" , & self . input , "state" , & & self . state ,) } } impl < 'a , 'h , A : Automaton > Iterator for FindOverlappingIter < 'a , 'h , A > { type Item = Match ; # [inline (always)] fn next (& mut self) -> Option < Match > { self . aut . try_find_overlapping (& self . input , & mut self . state) . expect ("already checked that no match error can occur here") ; self . state . get_match () } } # [doc = " An iterator that reports matches in a stream."] # [doc = ""] # [doc = " This iterator yields elements of type `io::Result<Match>`, where an error"] # [doc = " is reported if there was a problem reading from the underlying stream."] # [doc = " The iterator terminates only when the underlying stream reaches `EOF`."] # [doc = ""] # [doc = " This iterator is constructed via the [`Automaton::try_stream_find_iter`]"] # [doc = " method."] # [doc = ""] # [doc = " The type variable `A` refers to the implementation of the [`Automaton`]"] # [doc = " trait used to execute the search."] # [doc = ""] # [doc = " The type variable `R` refers to the `io::Read` stream that is being read"] # [doc = " from."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the [`Automaton`]"] # [doc = " implementation."] pub struct StreamFindIter < 'a , A , R > { it : StreamChunkIter < 'a , A , R > , } # [automatically_derived] impl < 'a , A : :: core :: fmt :: Debug , R : :: core :: fmt :: Debug > :: core :: fmt :: Debug for StreamFindIter < 'a , A , R > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "StreamFindIter" , "it" , & & self . it ,) } } impl < 'a , A : Automaton , R : std :: io :: Read > Iterator for StreamFindIter < 'a , A , R > { type Item = std :: io :: Result < Match > ; fn next (& mut self) -> Option < std :: io :: Result < Match > > { loop { match self . it . next () { None => return None , Some (Err (err)) => return Some (Err (err)) , Some (Ok (StreamChunk :: NonMatch { .. })) => { } Some (Ok (StreamChunk :: Match { mat , .. })) => { return Some (Ok (mat)) ; } } } } } # [doc = " An iterator that reports matches in a stream."] # [doc = ""] # [doc = " (This doesn't actually implement the `Iterator` trait because it returns"] # [doc = " something with a lifetime attached to a buffer it owns, but that's OK. It"] # [doc = " still has a `next` method and is iterator-like enough to be fine.)"] # [doc = ""] # [doc = " This iterator yields elements of type `io::Result<StreamChunk>`, where"] # [doc = " an error is reported if there was a problem reading from the underlying"] # [doc = " stream. The iterator terminates only when the underlying stream reaches"] # [doc = " `EOF`."] # [doc = ""] # [doc = " The idea here is that each chunk represents either a match or a non-match,"] # [doc = " and if you concatenated all of the chunks together, you'd reproduce the"] # [doc = " entire contents of the stream, byte-for-byte."] # [doc = ""] # [doc = " This chunk machinery is a bit complicated and it isn't strictly required"] # [doc = " for a stream searcher that just reports matches. But we do need something"] # [doc = " like this to deal with the \"replacement\" API, which needs to know which"] # [doc = " chunks it can copy and which it needs to replace."] struct StreamChunkIter < 'a , A , R > { # [doc = " The underlying automaton to do the search."] aut : & 'a A , # [doc = " The source of bytes we read from."] rdr : R , # [doc = " A roll buffer for managing bytes from `rdr`. Basically, this is used"] # [doc = " to handle the case of a match that is split by two different"] # [doc = " calls to `rdr.read()`. This isn't strictly needed if all we needed to"] # [doc = " do was report matches, but here we are reporting chunks of non-matches"] # [doc = " and matches and in order to do that, we really just cannot treat our"] # [doc = " stream as non-overlapping blocks of bytes. We need to permit some"] # [doc = " overlap while we retain bytes from a previous `read` call in memory."] buf : crate :: util :: buffer :: Buffer , # [doc = " The unanchored starting state of this automaton."] start : StateID , # [doc = " The state of the automaton."] sid : StateID , # [doc = " The absolute position over the entire stream."] absolute_pos : usize , # [doc = " The position we're currently at within `buf`."] buffer_pos : usize , # [doc = " The buffer position of the end of the bytes that we last returned"] # [doc = " to the caller. Basically, whenever we find a match, we look to see if"] # [doc = " there is a difference between where the match started and the position"] # [doc = " of the last byte we returned to the caller. If there's a difference,"] # [doc = " then we need to return a 'NonMatch' chunk."] buffer_reported_pos : usize , } # [automatically_derived] impl < 'a , A : :: core :: fmt :: Debug , R : :: core :: fmt :: Debug > :: core :: fmt :: Debug for StreamChunkIter < 'a , A , R > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { let names : & 'static _ = & ["aut" , "rdr" , "buf" , "start" , "sid" , "absolute_pos" , "buffer_pos" , "buffer_reported_pos" ,] ; let values : & [& dyn :: core :: fmt :: Debug] = & [& self . aut , & self . rdr , & self . buf , & self . start , & self . sid , & self . absolute_pos , & self . buffer_pos , & & self . buffer_reported_pos ,] ; :: core :: fmt :: Formatter :: debug_struct_fields_finish (f , "StreamChunkIter" , names , values ,) } } impl < 'a , A : Automaton , R : std :: io :: Read > StreamChunkIter < 'a , A , R > { fn new (aut : & 'a A , rdr : R) -> Result < StreamChunkIter < 'a , A , R > , MatchError > { if ! aut . match_kind () . is_standard () { return Err (MatchError :: unsupported_stream (aut . match_kind ())) ; } if aut . min_pattern_len () == 0 { return Err (MatchError :: unsupported_empty ()) ; } let start = aut . start_state (Anchored :: No) ? ; Ok (StreamChunkIter { aut , rdr , buf : crate :: util :: buffer :: Buffer :: new (aut . max_pattern_len ()) , start , sid : start , absolute_pos : 0 , buffer_pos : 0 , buffer_reported_pos : 0 , }) } fn next (& mut self) -> Option < std :: io :: Result < StreamChunk > > { loop { if self . aut . is_match (self . sid) { let mat = self . get_match () ; if let Some (r) = self . get_non_match_chunk (mat) { self . buffer_reported_pos += r . len () ; let bytes = & self . buf . buffer () [r] ; return Some (Ok (StreamChunk :: NonMatch { bytes })) ; } self . sid = self . start ; let r = self . get_match_chunk (mat) ; self . buffer_reported_pos += r . len () ; let bytes = & self . buf . buffer () [r] ; return Some (Ok (StreamChunk :: Match { bytes , mat })) ; } if self . buffer_pos >= self . buf . buffer () . len () { if let Some (r) = self . get_pre_roll_non_match_chunk () { self . buffer_reported_pos += r . len () ; let bytes = & self . buf . buffer () [r] ; return Some (Ok (StreamChunk :: NonMatch { bytes })) ; } if self . buf . buffer () . len () >= self . buf . min_buffer_len () { self . buffer_pos = self . buf . min_buffer_len () ; self . buffer_reported_pos -= self . buf . buffer () . len () - self . buf . min_buffer_len () ; self . buf . roll () ; } match self . buf . fill (& mut self . rdr) { Err (err) => return Some (Err (err)) , Ok (true) => { } Ok (false) => { if let Some (r) = self . get_eof_non_match_chunk () { self . buffer_reported_pos += r . len () ; let bytes = & self . buf . buffer () [r] ; return Some (Ok (StreamChunk :: NonMatch { bytes })) ; } return None ; } } } let start = self . absolute_pos ; for & byte in self . buf . buffer () [self . buffer_pos ..] . iter () { self . sid = self . aut . next_state (Anchored :: No , self . sid , byte) ; self . absolute_pos += 1 ; if self . aut . is_match (self . sid) { break ; } } self . buffer_pos += self . absolute_pos - start ; } } # [doc = " Return a match chunk for the given match. It is assumed that the match"] # [doc = " ends at the current `buffer_pos`."] fn get_match_chunk (& self , mat : Match) -> core :: ops :: Range < usize > { let start = self . buffer_pos - mat . len () ; let end = self . buffer_pos ; start .. end } # [doc = " Return a non-match chunk, if necessary, just before reporting a match."] # [doc = " This returns `None` if there is nothing to report. Otherwise, this"] # [doc = " assumes that the given match ends at the current `buffer_pos`."] fn get_non_match_chunk (& self , mat : Match) -> Option < core :: ops :: Range < usize > > { let buffer_mat_start = self . buffer_pos - mat . len () ; if buffer_mat_start > self . buffer_reported_pos { let start = self . buffer_reported_pos ; let end = buffer_mat_start ; return Some (start .. end) ; } None } # [doc = " Look for any bytes that should be reported as a non-match just before"] # [doc = " rolling the buffer."] # [doc = ""] # [doc = " Note that this only reports bytes up to `buffer.len() -"] # [doc = " min_buffer_len`, as it's not possible to know whether the bytes"] # [doc = " following that will participate in a match or not."] fn get_pre_roll_non_match_chunk (& self) -> Option < core :: ops :: Range < usize > > { let end = self . buf . buffer () . len () . saturating_sub (self . buf . min_buffer_len ()) ; if self . buffer_reported_pos < end { return Some (self . buffer_reported_pos .. end) ; } None } # [doc = " Return any unreported bytes as a non-match up to the end of the buffer."] # [doc = ""] # [doc = " This should only be called when the entire contents of the buffer have"] # [doc = " been searched and EOF has been hit when trying to fill the buffer."] fn get_eof_non_match_chunk (& self) -> Option < core :: ops :: Range < usize > > { if self . buffer_reported_pos < self . buf . buffer () . len () { return Some (self . buffer_reported_pos .. self . buf . buffer () . len ()) ; } None } # [doc = " Return the match at the current position for the current state."] # [doc = ""] # [doc = " This panics if `self.aut.is_match(self.sid)` isn't true."] fn get_match (& self) -> Match { get_match (self . aut , self . sid , 0 , self . absolute_pos) } } # [doc = " A single chunk yielded by the stream chunk iterator."] # [doc = ""] # [doc = " The `'r` lifetime refers to the lifetime of the stream chunk iterator."] enum StreamChunk < 'r > { # [doc = " A chunk that does not contain any matches."] NonMatch { bytes : & 'r [u8] } , # [doc = " A chunk that precisely contains a match."] Match { bytes : & 'r [u8] , mat : Match } , } # [automatically_derived] impl < 'r > :: core :: fmt :: Debug for StreamChunk < 'r > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { StreamChunk :: NonMatch { bytes : __self_0 } => { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "NonMatch" , "bytes" , & __self_0 ,) } StreamChunk :: Match { bytes : __self_0 , mat : __self_1 } => { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Match" , "bytes" , __self_0 , "mat" , & __self_1 ,) } } } } # [inline (never)] pub (crate) fn try_find_fwd < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > ,) -> Result < Option < Match > , MatchError > { if input . is_done () { return Ok (None) ; } let earliest = aut . match_kind () . is_standard () || input . get_earliest () ; if input . get_anchored () . is_anchored () { try_find_fwd_imp (aut , input , None , Anchored :: Yes , earliest) } else if let Some (pre) = aut . prefilter () { if earliest { try_find_fwd_imp (aut , input , Some (pre) , Anchored :: No , true) } else { try_find_fwd_imp (aut , input , Some (pre) , Anchored :: No , false) } } else { if earliest { try_find_fwd_imp (aut , input , None , Anchored :: No , true) } else { try_find_fwd_imp (aut , input , None , Anchored :: No , false) } } } # [inline (always)] fn try_find_fwd_imp < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > , pre : Option < & Prefilter > , anchored : Anchored , earliest : bool ,) -> Result < Option < Match > , MatchError > { let mut sid = aut . start_state (input . get_anchored ()) ? ; let mut at = input . start () ; let mut mat = None ; if aut . is_match (sid) { mat = Some (get_match (aut , sid , 0 , at)) ; if earliest { return Ok (mat) ; } } if let Some (pre) = pre { match pre . find_in (input . haystack () , input . get_span ()) { Candidate :: None => return Ok (None) , Candidate :: Match (m) => return Ok (Some (m)) , Candidate :: PossibleStartOfMatch (i) => { at = i ; } } } while at < input . end () { sid = aut . next_state (anchored , sid , input . haystack () [at]) ; if aut . is_special (sid) { if aut . is_dead (sid) { return Ok (mat) ; } else if aut . is_match (sid) { let m = get_match (aut , sid , 0 , at + 1) ; if ! (anchored . is_anchored () && m . start () > input . start ()) { mat = Some (m) ; if earliest { return Ok (mat) ; } } } else if let Some (pre) = pre { if true { if ! aut . is_start (sid) { :: core :: panicking :: panic ("assertion failed: aut.is_start(sid)" ,) } } let span = Span :: from (at .. input . end ()) ; match pre . find_in (input . haystack () , span) . into_option () { None => return Ok (None) , Some (i) => { if i > at { at = i ; continue ; } } } } else { if true { if ! false { { :: core :: panicking :: panic_fmt (format_args ! ("unreachable")) ; } } } } } at += 1 ; } Ok (mat) } # [inline (never)] fn try_find_overlapping_fwd < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > , state : & mut OverlappingState ,) -> Result < () , MatchError > { state . mat = None ; if input . is_done () { return Ok (()) ; } if aut . prefilter () . is_some () && ! input . get_anchored () . is_anchored () { let pre = aut . prefilter () . unwrap () ; try_find_overlapping_fwd_imp (aut , input , Some (pre) , state) } else { try_find_overlapping_fwd_imp (aut , input , None , state) } } # [inline (always)] fn try_find_overlapping_fwd_imp < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > , pre : Option < & Prefilter > , state : & mut OverlappingState ,) -> Result < () , MatchError > { let mut sid = match state . id { None => { let sid = aut . start_state (input . get_anchored ()) ? ; if aut . is_match (sid) { let i = state . next_match_index . unwrap_or (0) ; let len = aut . match_len (sid) ; if i < len { state . next_match_index = Some (i + 1) ; state . mat = Some (get_match (aut , sid , i , input . start ())) ; return Ok (()) ; } } state . at = input . start () ; state . id = Some (sid) ; state . next_match_index = None ; state . mat = None ; sid } Some (sid) => { if let Some (i) = state . next_match_index { let len = aut . match_len (sid) ; if i < len { state . next_match_index = Some (i + 1) ; state . mat = Some (get_match (aut , sid , i , state . at + 1)) ; return Ok (()) ; } state . at += 1 ; state . next_match_index = None ; state . mat = None ; } sid } } ; while state . at < input . end () { sid = aut . next_state (input . get_anchored () , sid , input . haystack () [state . at]) ; if aut . is_special (sid) { state . id = Some (sid) ; if aut . is_dead (sid) { return Ok (()) ; } else if aut . is_match (sid) { state . next_match_index = Some (1) ; state . mat = Some (get_match (aut , sid , 0 , state . at + 1)) ; return Ok (()) ; } else if let Some (pre) = pre { if true { if ! aut . is_start (sid) { :: core :: panicking :: panic ("assertion failed: aut.is_start(sid)" ,) } } let span = Span :: from (state . at .. input . end ()) ; match pre . find_in (input . haystack () , span) . into_option () { None => return Ok (()) , Some (i) => { if i > state . at { state . at = i ; continue ; } } } } else { } } state . at += 1 ; } state . id = Some (sid) ; Ok (()) } # [inline (always)] fn get_match < A : Automaton + ? Sized > (aut : & A , sid : StateID , index : usize , at : usize ,) -> Match { let pid = aut . match_pattern (sid , index) ; let len = aut . pattern_len (pid) ; Match :: new (pid , (at - len) .. at) } # [doc = " Write a prefix \"state\" indicator for fmt::Debug impls. It always writes"] # [doc = " exactly two printable bytes to the given formatter."] # [doc = ""] # [doc = " Specifically, this tries to succinctly distinguish the different types of"] # [doc = " states: dead states, start states and match states. It even accounts for"] # [doc = " the possible overlappings of different state types. (The only possible"] # [doc = " overlapping is that of match and start states.)"] pub (crate) fn fmt_state_indicator < A : Automaton > (f : & mut core :: fmt :: Formatter < '_ > , aut : A , id : StateID ,) -> core :: fmt :: Result { if aut . is_dead (id) { f . write_fmt (format_args ! ("D ")) ? ; } else if aut . is_match (id) { if aut . is_start (id) { f . write_fmt (format_args ! ("*>")) ? ; } else { f . write_fmt (format_args ! ("* ")) ? ; } } else if aut . is_start (id) { f . write_fmt (format_args ! (" >")) ? ; } else { f . write_fmt (format_args ! ("  ")) ? ; } Ok (()) } # [doc = " Return an iterator of transitions in a sparse format given an iterator"] # [doc = " of all explicitly defined transitions. The iterator yields ranges of"] # [doc = " transitions, such that any adjacent transitions mapped to the same"] # [doc = " state are combined into a single range."] pub (crate) fn sparse_transitions < 'a > (mut it : impl Iterator < Item = (u8 , StateID) > + 'a ,) -> impl Iterator < Item = (u8 , u8 , StateID) > + 'a { let mut cur : Option < (u8 , u8 , StateID) > = None ; core :: iter :: from_fn (move | | { while let Some ((class , next)) = it . next () { let (prev_start , prev_end , prev_next) = match cur { Some (x) => x , None => { cur = Some ((class , class , next)) ; continue ; } } ; if prev_next == next { cur = Some ((prev_start , class , prev_next)) ; } else { cur = Some ((class , class , next)) ; return Some ((prev_start , prev_end , prev_next)) ; } } if let Some ((start , end , next)) = cur . take () { return Some ((start , end , next)) ; } None }) } }