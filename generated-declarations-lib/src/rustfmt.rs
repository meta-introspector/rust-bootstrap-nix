pub mod rustfmt { use build_helper :: prelude :: * ; pub enum RustfmtState { SystemToolchain (PathBuf) , Downloaded (PathBuf) , Unavailable , # [default] LazyEvaluated , } # [automatically_derived] impl :: core :: clone :: Clone for RustfmtState { # [inline] fn clone (& self) -> RustfmtState { match self { RustfmtState :: SystemToolchain (__self_0) => { RustfmtState :: SystemToolchain (:: core :: clone :: Clone :: clone (__self_0)) } RustfmtState :: Downloaded (__self_0) => { RustfmtState :: Downloaded (:: core :: clone :: Clone :: clone (__self_0)) } RustfmtState :: Unavailable => RustfmtState :: Unavailable , RustfmtState :: LazyEvaluated => RustfmtState :: LazyEvaluated , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RustfmtState { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { RustfmtState :: SystemToolchain (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "SystemToolchain" , & __self_0 ,) } RustfmtState :: Downloaded (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Downloaded" , & __self_0 ,) } RustfmtState :: Unavailable => { :: core :: fmt :: Formatter :: write_str (f , "Unavailable") } RustfmtState :: LazyEvaluated => { :: core :: fmt :: Formatter :: write_str (f , "LazyEvaluated") } } } } # [automatically_derived] impl :: core :: default :: Default for RustfmtState { # [inline] fn default () -> RustfmtState { Self :: LazyEvaluated } } }