mod aarch64_neon { use core :: arch :: aarch64 :: * ; use super :: Vector ; impl Vector for uint8x16_t { const BITS : usize = 128 ; const BYTES : usize = 16 ; # [inline (always)] unsafe fn splat (byte : u8) -> uint8x16_t { vdupq_n_u8 (byte) } # [inline (always)] unsafe fn load_unaligned (data : * const u8) -> uint8x16_t { vld1q_u8 (data) } # [inline (always)] unsafe fn is_zero (self) -> bool { let maxes = vreinterpretq_u64_u8 (vpmaxq_u8 (self , self)) ; vgetq_lane_u64 (maxes , 0) == 0 } # [inline (always)] unsafe fn cmpeq (self , vector2 : Self) -> uint8x16_t { vceqq_u8 (self , vector2) } # [inline (always)] unsafe fn and (self , vector2 : Self) -> uint8x16_t { vandq_u8 (self , vector2) } # [inline (always)] unsafe fn or (self , vector2 : Self) -> uint8x16_t { vorrq_u8 (self , vector2) } # [inline (always)] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self { if true { if ! (BITS <= 7) { :: core :: panicking :: panic ("assertion failed: BITS <= 7") } } vshrq_n_u8 (self , BITS) } # [inline (always)] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 15) } # [inline (always)] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 14) } # [inline (always)] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 13) } # [inline (always)] unsafe fn shuffle_bytes (self , indices : Self) -> Self { vqtbl1q_u8 (self , indices) } # [inline (always)] unsafe fn for_each_64bit_lane < T > (self , mut f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > { let this = vreinterpretq_u64_u8 (self) ; let lane = vgetq_lane_u64 (this , 0) ; if let Some (t) = f (0 , lane) { return Some (t) ; } let lane = vgetq_lane_u64 (this , 1) ; if let Some (t) = f (1 , lane) { return Some (t) ; } None } } }