pub mod use_extractor { pub mod rustc_info { use anyhow :: Result ; use std :: process :: Command ; pub struct RustcInfo { pub version : String , pub host : String , } # [automatically_derived] impl :: core :: fmt :: Debug for RustcInfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "RustcInfo" , "version" , & self . version , "host" , & & self . host ,) } } # [automatically_derived] impl :: core :: clone :: Clone for RustcInfo { # [inline] fn clone (& self) -> RustcInfo { RustcInfo { version : :: core :: clone :: Clone :: clone (& self . version) , host : :: core :: clone :: Clone :: clone (& self . host) , } } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for RustcInfo { } # [automatically_derived] impl :: core :: cmp :: PartialEq for RustcInfo { # [inline] fn eq (& self , other : & RustcInfo) -> bool { self . version == other . version && self . host == other . host } } # [automatically_derived] impl :: core :: cmp :: Eq for RustcInfo { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < String > ; } } # [automatically_derived] impl :: core :: hash :: Hash for RustcInfo { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . version , state) ; :: core :: hash :: Hash :: hash (& self . host , state) } } pub fn get_rustc_info () -> Result < RustcInfo > { let output = Command :: new ("rustc") . arg ("--version") . arg ("--verbose") . output () ? ; if ! output . status . success () { return :: anyhow :: __private :: Err (:: anyhow :: Error :: msg (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("rustc --version --verbose failed: {0}" , String :: from_utf8_lossy (& output . stderr) ,) ,) }) ,) ,) ; } let stdout = String :: from_utf8_lossy (& output . stdout) ; let version_line = stdout . lines () . find (| line | line . starts_with ("rustc ")) ; let host_line = stdout . lines () . find (| line | line . starts_with ("host: ")) ; let version = version_line . and_then (| line | line . split_whitespace () . nth (1)) . unwrap_or ("unknown") . to_string () ; let host = host_line . and_then (| line | line . split_whitespace () . nth (1)) . unwrap_or ("unknown") . to_string () ; Ok (RustcInfo { version , host }) } } pub mod collect_and_process_use_statements { use anyhow :: Result ; use std :: path :: Path ; pub fn collect_and_process_use_statements (_repo_root : & Path , _stop_after : usize , _step_timeout : u64 , _verbose : u8 , _dry_run : bool ,) -> Result < () > { Ok (()) } } pub mod generate_aggregated_use_test_file { use anyhow :: Result ; use std :: path :: Path ; pub fn generate_aggregated_use_test_file (_repo_root : & Path) -> Result < () > { Ok (()) } } pub mod flatten_use_tree { use syn :: UseTree ; use pipeline_traits :: UseStatement ; pub fn flatten_use_tree (base_path : & mut Vec < String > , use_tree : & UseTree , flat_uses : & mut Vec < UseStatement > ,) { match use_tree { UseTree :: Path (path) => { base_path . push (path . ident . to_string ()) ; flatten_use_tree (base_path , & path . tree , flat_uses) ; base_path . pop () ; } UseTree :: Name (_name) => { let full_path = base_path . join ("::") ; flat_uses . push (UseStatement { statement : :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("use {0};" , full_path)) }) , error : None , git_details : None , nix_details : None , rust_details : None , cargo_details : None , syn_details : None , llvm_details : None , linux_details : None , }) ; } UseTree :: Rename (rename) => { let mut full_path = base_path . join ("::") ; if ! full_path . is_empty () { full_path . push_str ("::") ; } flat_uses . push (UseStatement { statement : :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("use {0} as {1};" , full_path , rename . rename . to_string () ,) ,) }) , error : None , git_details : None , nix_details : None , rust_details : None , cargo_details : None , syn_details : None , llvm_details : None , linux_details : None , }) ; } UseTree :: Glob (_glob) => { let mut full_path = base_path . join ("::") ; if ! full_path . is_empty () { full_path . push_str ("::") ; } full_path . push_str ("* ") ; flat_uses . push (UseStatement { statement : :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("use {0};" , full_path)) }) , error : None , git_details : None , nix_details : None , rust_details : None , cargo_details : None , syn_details : None , llvm_details : None , linux_details : None , }) ; } UseTree :: Group (group) => { for tree in group . items . iter () { flatten_use_tree (base_path , tree , flat_uses) ; } } } } } pub mod expand_macros_and_parse { use anyhow :: { Context , Result } ; use std :: path :: Path ; use sha2 :: { Sha256 , Digest } ; use crate :: use_extractor :: rustc_info :: RustcInfo ; use crate :: error_collector :: ErrorSample ; use chrono :: Utc ; use tokio :: fs ; use tempfile ; pub async fn expand_macros_and_parse (writer : & mut (impl tokio :: io :: AsyncWriteExt + Unpin) , file_path : & Path , crate_root : & Path , manifest_path : & Path , rustc_info : & RustcInfo , cache_dir : & Path ,) -> Result < (syn :: File , Option < ErrorSample >) > { let mut hasher = Sha256 :: new () ; hasher . update (file_path . to_string_lossy () . as_bytes ()) ; hasher . update (crate_root . to_string_lossy () . as_bytes ()) ; let content = tokio :: fs :: read_to_string (file_path) . await . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read file content for hashing: {0}" , file_path . display () ,) ,) })) ? ; hasher . update (content . as_bytes ()) ; let content_hash = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:x}" , hasher . finalize ())) }) ; let cache_key = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("expanded_{0}_{1}_{2}_{3}_{4}" , content_hash , rustc_info . version , rustc_info . host , "cargo_expand" , "2021" ,) ,) }) ; let cached_file_path = cache_dir . join (cache_key) ; if cached_file_path . exists () { writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("      -> Using cached expanded code for: {0}\n" , file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; let expanded_code = fs :: read_to_string (& cached_file_path) . await . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read cached expanded code for {0}" , file_path . display () ,) ,) })) ? ; return Ok ((syn :: parse_file (& expanded_code) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse cached expanded code for {0}" , file_path . display () ,) ,) })) ? , None ,)) ; } let cache_key = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("expanded_{0}_{1}_{2}_{3}" , content_hash , rustc_info . version , rustc_info . host , "2021" ,) ,) }) ; let cached_file_path = cache_dir . join (cache_key) ; if cached_file_path . exists () { writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("      -> Using cached expanded code for: {0}\n" , file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; let expanded_code = fs :: read_to_string (& cached_file_path) . await . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read cached expanded code for {0}" , file_path . display () ,) ,) })) ? ; return Ok ((syn :: parse_file (& expanded_code) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse cached expanded code for {0}" , file_path . display () ,) ,) })) ? , None ,)) ; } let temp_crate_dir = tempfile :: tempdir () . context ("Failed to create temporary directory") ? ; let temp_crate_path = temp_crate_dir . path () ; let original_cargo_toml_path = manifest_path ; let temp_cargo_toml_path = temp_crate_path . join ("Cargo.toml") ; fs :: copy (& original_cargo_toml_path , & temp_cargo_toml_path) . await . context ("Failed to copy Cargo.toml to temporary directory") ? ; let temp_src_dir = temp_crate_path . join ("src") ; fs :: create_dir (& temp_src_dir) . await . context ("Failed to create temporary src directory") ? ; let temp_lib_rs_path = temp_src_dir . join ("lib.rs") ; fs :: copy (file_path , & temp_lib_rs_path) . await . context ("Failed to copy source file to temporary lib.rs") ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> PATH environment variable: {0:?}\n" , std :: env :: var ("PATH") ,) ,) }) . as_bytes () ,) . await ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> Running cargo rustc -Zunpretty=expanded --lib for: {0}\n" , file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; let output = tokio :: process :: Command :: new ("cargo") . arg ("rustc") . arg ("--manifest-path") . arg (& temp_cargo_toml_path) . arg ("--lib") . arg ("--") . arg ("-Zunpretty=expanded") . output () . await ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> rustc status for {0}: {1}\n" , file_path . display () , output . status ,) ,) }) . as_bytes () ,) . await ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> rustc stdout for {0}: {1}\n" , file_path . display () , String :: from_utf8_lossy (& output . stdout) ,) ,) }) . as_bytes () ,) . await ? ; if ! output . status . success () { let error_message = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("rustc macro expansion failed: {0}\nStdout: {1}\nStderr: {2}" , String :: from_utf8_lossy (& output . stderr) , String :: from_utf8_lossy (& output . stdout) , String :: from_utf8_lossy (& output . stderr) ,) ,) }) ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> {0}\n" , error_message) ,) }) . as_bytes () ,) . await . context ("Failed to write rustc error to writer") ? ; let error_sample = ErrorSample { file_path : file_path . to_path_buf () , rustc_version : rustc_info . version . clone () , rustc_host : rustc_info . host . clone () , error_message : error_message . clone () , error_type : "MacroExpansionFailed" . to_string () , code_snippet : Some (content . to_string ()) , timestamp : Utc :: now () , context : None , } ; return Ok ((syn :: parse_file ("") . unwrap () , Some (error_sample))) ; } let expanded_code = String :: from_utf8_lossy (& output . stdout) . to_string () ; let relevant_expanded_code = expanded_code . to_string () ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> Writing expanded code to cache for: {0}\n" , file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; tokio :: fs :: write (& cached_file_path , & relevant_expanded_code) . await . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write expanded code to cache for {0}" , file_path . display () ,) ,) })) ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("      -> Wrote expanded code to cache: {0}\n" , cached_file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> Parsing expanded code for: {0}\n" , file_path . display () ,) ,) }) . as_bytes () ,) . await ? ; match syn :: parse_file (& relevant_expanded_code) { Ok (file) => Ok ((file , None)) , Err (e) => { let error_message = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse expanded code for {0}: {1}" , file_path . display () , e ,) ,) }) ; writer . write_all (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("        -> {0}\n" , error_message) ,) }) . as_bytes () ,) . await . context ("Failed to write parsing error to writer") ? ; let error_sample = ErrorSample { file_path : file_path . to_path_buf () , rustc_version : rustc_info . version . clone () , rustc_host : rustc_info . host . clone () , error_message : error_message . clone () , error_type : "SynParsingFailed" . to_string () , code_snippet : Some (relevant_expanded_code . to_string ()) , timestamp : Utc :: now () , context : None , } ; Ok ((syn :: parse_file ("") . unwrap () , Some (error_sample))) } } } } pub use rustc_info :: RustcInfo ; pub use rustc_info :: get_rustc_info ; pub use collect_and_process_use_statements :: collect_and_process_use_statements ; pub use generate_aggregated_use_test_file :: generate_aggregated_use_test_file ; pub use flatten_use_tree :: flatten_use_tree ; pub use expand_macros_and_parse :: expand_macros_and_parse ; }