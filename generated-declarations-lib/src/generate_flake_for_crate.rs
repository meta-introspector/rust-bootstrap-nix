# [doc = " Generates a Nix flake for a given Cargo project."] # [doc = ""] # [doc = " This function takes the path to a Cargo project and generates a `flake.nix`"] # [doc = " and potentially a `flake.lock` file in the project's root directory."] # [doc = ""] # [doc = " # Arguments"] # [doc = " * `project_root` - The absolute path to the root of the Cargo project."] # [doc = " * `config` - Configuration for flake generation, including Nixpkgs and rust-overlay URLs."] # [doc = ""] # [doc = " # Returns"] # [doc = " `Ok(())` if the flake generation is successful, otherwise an `anyhow::Error`."] pub fn generate_flake_for_crate (project_root : & Path , config : & FlakeGeneratorConfig ,) -> Result < () > { { :: std :: io :: _print (format_args ! ("Generating flake for crate: {0}\n" , project_root . display ()) ,) ; } ; let metadata = MetadataCommand :: new () . manifest_path (project_root . join ("Cargo.toml")) . exec () . context ("Failed to execute cargo metadata") ? ; if metadata . workspace_root == project_root { { :: std :: io :: _print (format_args ! ("Skipping flake generation for workspace root: {0}\n" , project_root . display () ,) ,) ; } ; return Ok (()) ; } let flake_nix_content = construct_flake_nix_content (project_root , & metadata , config ,) ? ; let flake_nix_path = project_root . join ("flake.nix") ; std :: fs :: write (& flake_nix_path , flake_nix_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write flake.nix to {0}" , flake_nix_path . display () ,) ,) })) ? ; Ok (()) }