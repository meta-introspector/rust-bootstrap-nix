pub mod packed { # ! [doc = "\nProvides packed multiple substring search, principally for a small number of\npatterns.\n\nThis sub-module provides vectorized routines for quickly finding\nmatches of a small number of patterns. In general, users of this crate\nshouldn't need to interface with this module directly, as the primary\n[`AhoCorasick`](crate::AhoCorasick) searcher will use these routines\nautomatically as a prefilter when applicable. However, in some cases, callers\nmay want to bypass the Aho-Corasick machinery entirely and use this vectorized\nsearcher directly.\n\n# Overview\n\nThe primary types in this sub-module are:\n\n* [`Searcher`] executes the actual search algorithm to report matches in a\nhaystack.\n* [`Builder`] accumulates patterns incrementally and can construct a\n`Searcher`.\n* [`Config`] permits tuning the searcher, and itself will produce a `Builder`\n(which can then be used to build a `Searcher`). Currently, the only tuneable\nknob are the match semantics, but this may be expanded in the future.\n\n# Examples\n\nThis example shows how to create a searcher from an iterator of patterns.\nBy default, leftmost-first match semantics are used. (See the top-level\n[`MatchKind`] type for more details about match semantics, which apply\nsimilarly to packed substring search.)\n\n```\nuse aho_corasick::{packed::{MatchKind, Searcher}, PatternID};\n\n# fn example() -> Option<()> {\nlet searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;\nlet matches: Vec<PatternID> = searcher\n    .find_iter(\"foobar\")\n    .map(|mat| mat.pattern())\n    .collect();\nassert_eq!(vec![PatternID::ZERO], matches);\n# Some(()) }\n# if cfg!(all(feature = \"std\", any(\n#     target_arch = \"x86_64\", target_arch = \"aarch64\",\n# ))) {\n#     example().unwrap()\n# } else {\n#     assert!(example().is_none());\n# }\n```\n\nThis example shows how to use [`Config`] to change the match semantics to\nleftmost-longest:\n\n```\nuse aho_corasick::{packed::{Config, MatchKind}, PatternID};\n\n# fn example() -> Option<()> {\nlet searcher = Config::new()\n    .match_kind(MatchKind::LeftmostLongest)\n    .builder()\n    .add(\"foo\")\n    .add(\"foobar\")\n    .build()?;\nlet matches: Vec<PatternID> = searcher\n    .find_iter(\"foobar\")\n    .map(|mat| mat.pattern())\n    .collect();\nassert_eq!(vec![PatternID::must(1)], matches);\n# Some(()) }\n# if cfg!(all(feature = \"std\", any(\n#     target_arch = \"x86_64\", target_arch = \"aarch64\",\n# ))) {\n#     example().unwrap()\n# } else {\n#     assert!(example().is_none());\n# }\n```\n\n# Packed substring searching\n\nPacked substring searching refers to the use of SIMD (Single Instruction,\nMultiple Data) to accelerate the detection of matches in a haystack. Unlike\nconventional algorithms, such as Aho-Corasick, SIMD algorithms for substring\nsearch tend to do better with a small number of patterns, where as Aho-Corasick\ngenerally maintains reasonably consistent performance regardless of the number\nof patterns you give it. Because of this, the vectorized searcher in this\nsub-module cannot be used as a general purpose searcher, since building the\nsearcher may fail even when given a small number of patterns. However, in\nexchange, when searching for a small number of patterns, searching can be quite\na bit faster than Aho-Corasick (sometimes by an order of magnitude).\n\nThe key take away here is that constructing a searcher from a list of patterns\nis a fallible operation with no clear rules for when it will fail. While the\nprecise conditions under which building a searcher can fail is specifically an\nimplementation detail, here are some common reasons:\n\n* Too many patterns were given. Typically, the limit is on the order of 100 or\n  so, but this limit may fluctuate based on available CPU features.\n* The available packed algorithms require CPU features that aren't available.\n  For example, currently, this crate only provides packed algorithms for\n  `x86_64` and `aarch64`. Therefore, constructing a packed searcher on any\n  other target will always fail.\n* Zero patterns were given, or one of the patterns given was empty. Packed\n  searchers require at least one pattern and that all patterns are non-empty.\n* Something else about the nature of the patterns (typically based on\n  heuristics) suggests that a packed searcher would perform very poorly, so\n  no searcher is built.\n"] pub use crate :: packed :: api :: { Builder , Config , FindIter , MatchKind , Searcher } ; mod api { use alloc :: sync :: Arc ; use crate :: { packed :: { pattern :: Patterns , rabinkarp :: RabinKarp , teddy } , util :: search :: { Match , Span } , } ; # [doc = " This is a limit placed on the total number of patterns we're willing to try"] # [doc = " and match at once. As more sophisticated algorithms are added, this number"] # [doc = " may be increased."] const PATTERN_LIMIT : usize = 128 ; # [doc = " A knob for controlling the match semantics of a packed multiple string"] # [doc = " searcher."] # [doc = ""] # [doc = " This differs from the [`MatchKind`](crate::MatchKind) type in the top-level"] # [doc = " crate module in that it doesn't support \"standard\" match semantics,"] # [doc = " and instead only supports leftmost-first or leftmost-longest. Namely,"] # [doc = " \"standard\" semantics cannot be easily supported by packed searchers."] # [doc = ""] # [doc = " For more information on the distinction between leftmost-first and"] # [doc = " leftmost-longest, see the docs on the top-level `MatchKind` type."] # [doc = ""] # [doc = " Unlike the top-level `MatchKind` type, the default match semantics for this"] # [doc = " type are leftmost-first."] # [non_exhaustive] pub enum MatchKind { # [doc = " Use leftmost-first match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the match"] # [doc = " corresponding to the pattern that appeared earlier when constructing"] # [doc = " the automaton is reported."] # [doc = ""] # [doc = " This is the default."] LeftmostFirst , # [doc = " Use leftmost-longest match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the longest match"] # [doc = " is chosen."] LeftmostLongest , } # [automatically_derived] impl :: core :: clone :: Clone for MatchKind { # [inline] fn clone (& self) -> MatchKind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for MatchKind { } # [automatically_derived] impl :: core :: fmt :: Debug for MatchKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { MatchKind :: LeftmostFirst => "LeftmostFirst" , MatchKind :: LeftmostLongest => "LeftmostLongest" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for MatchKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for MatchKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for MatchKind { # [inline] fn eq (& self , other : & MatchKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl Default for MatchKind { fn default () -> MatchKind { MatchKind :: LeftmostFirst } } # [doc = " The configuration for a packed multiple pattern searcher."] # [doc = ""] # [doc = " The configuration is currently limited only to being able to select the"] # [doc = " match semantics (leftmost-first or leftmost-longest) of a searcher. In the"] # [doc = " future, more knobs may be made available."] # [doc = ""] # [doc = " A configuration produces a [`packed::Builder`](Builder), which in turn can"] # [doc = " be used to construct a [`packed::Searcher`](Searcher) for searching."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to use leftmost-longest semantics instead of the"] # [doc = " default (leftmost-first)."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{Config, MatchKind}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Config::new()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .builder()"] # [doc = "     .add(\"foo\")"] # [doc = "     .add(\"foobar\")"] # [doc = "     .build()?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::must(1)], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Config { kind : MatchKind , force : Option < ForceAlgorithm > , only_teddy_fat : Option < bool > , only_teddy_256bit : Option < bool > , heuristic_pattern_limits : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Config { # [inline] fn clone (& self) -> Config { Config { kind : :: core :: clone :: Clone :: clone (& self . kind) , force : :: core :: clone :: Clone :: clone (& self . force) , only_teddy_fat : :: core :: clone :: Clone :: clone (& self . only_teddy_fat) , only_teddy_256bit : :: core :: clone :: Clone :: clone (& self . only_teddy_256bit ,) , heuristic_pattern_limits : :: core :: clone :: Clone :: clone (& self . heuristic_pattern_limits ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Config { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field5_finish (f , "Config" , "kind" , & self . kind , "force" , & self . force , "only_teddy_fat" , & self . only_teddy_fat , "only_teddy_256bit" , & self . only_teddy_256bit , "heuristic_pattern_limits" , & & self . heuristic_pattern_limits ,) } } # [doc = " An internal option for forcing the use of a particular packed algorithm."] # [doc = ""] # [doc = " When an algorithm is forced, if a searcher could not be constructed for it,"] # [doc = " then no searcher will be returned even if an alternative algorithm would"] # [doc = " work."] enum ForceAlgorithm { Teddy , RabinKarp , } # [automatically_derived] impl :: core :: clone :: Clone for ForceAlgorithm { # [inline] fn clone (& self) -> ForceAlgorithm { match self { ForceAlgorithm :: Teddy => ForceAlgorithm :: Teddy , ForceAlgorithm :: RabinKarp => ForceAlgorithm :: RabinKarp , } } } # [automatically_derived] impl :: core :: fmt :: Debug for ForceAlgorithm { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { ForceAlgorithm :: Teddy => "Teddy" , ForceAlgorithm :: RabinKarp => "RabinKarp" , } ,) } } impl Default for Config { fn default () -> Config { Config :: new () } } impl Config { # [doc = " Create a new default configuration. A default configuration uses"] # [doc = " leftmost-first match semantics."] pub fn new () -> Config { Config { kind : MatchKind :: LeftmostFirst , force : None , only_teddy_fat : None , only_teddy_256bit : None , heuristic_pattern_limits : true , } } # [doc = " Create a packed builder from this configuration. The builder can be"] # [doc = " used to accumulate patterns and create a [`Searcher`] from them."] pub fn builder (& self) -> Builder { Builder :: from_config (self . clone ()) } # [doc = " Set the match semantics for this configuration."] pub fn match_kind (& mut self , kind : MatchKind) -> & mut Config { self . kind = kind ; self } # [doc = " An undocumented method for forcing the use of the Teddy algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy (& mut self , yes : bool) -> & mut Config { if yes { self . force = Some (ForceAlgorithm :: Teddy) ; } else { self . force = None ; } self } # [doc = " An undocumented method for forcing the use of the Fat Teddy algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy_fat (& mut self , yes : Option < bool >) -> & mut Config { self . only_teddy_fat = yes ; self } # [doc = " An undocumented method for forcing the use of SSE (`Some(false)`) or"] # [doc = " AVX (`Some(true)`) algorithms."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy_256bit (& mut self , yes : Option < bool >) -> & mut Config { self . only_teddy_256bit = yes ; self } # [doc = " An undocumented method for forcing the use of the Rabin-Karp algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_rabin_karp (& mut self , yes : bool) -> & mut Config { if yes { self . force = Some (ForceAlgorithm :: RabinKarp) ; } else { self . force = None ; } self } # [doc = " Request that heuristic limitations on the number of patterns be"] # [doc = " employed. This useful to disable for benchmarking where one wants to"] # [doc = " explore how Teddy performs on large number of patterns even if the"] # [doc = " heuristics would otherwise refuse construction."] # [doc = ""] # [doc = " This is enabled by default."] pub fn heuristic_pattern_limits (& mut self , yes : bool) -> & mut Config { self . heuristic_pattern_limits = yes ; self } } # [doc = " A builder for constructing a packed searcher from a collection of patterns."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to use a builder to construct a searcher. By"] # [doc = " default, leftmost-first match semantics are used."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{Builder, MatchKind}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Builder::new()"] # [doc = "     .add(\"foobar\")"] # [doc = "     .add(\"foo\")"] # [doc = "     .build()?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Builder { # [doc = " The configuration of this builder and subsequent matcher."] config : Config , # [doc = " Set to true if the builder detects that a matcher cannot be built."] inert : bool , # [doc = " The patterns provided by the caller."] patterns : Patterns , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { config : :: core :: clone :: Clone :: clone (& self . config) , inert : :: core :: clone :: Clone :: clone (& self . inert) , patterns : :: core :: clone :: Clone :: clone (& self . patterns) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "config" , & self . config , "inert" , & self . inert , "patterns" , & & self . patterns ,) } } impl Builder { # [doc = " Create a new builder for constructing a multi-pattern searcher. This"] # [doc = " constructor uses the default configuration."] pub fn new () -> Builder { Builder :: from_config (Config :: new ()) } fn from_config (config : Config) -> Builder { Builder { config , inert : false , patterns : Patterns :: new () , } } # [doc = " Build a searcher from the patterns added to this builder so far."] pub fn build (& self) -> Option < Searcher > { if self . inert || self . patterns . is_empty () { return None ; } let mut patterns = self . patterns . clone () ; patterns . set_match_kind (self . config . kind) ; let patterns = Arc :: new (patterns) ; let rabinkarp = RabinKarp :: new (& patterns) ; let (search_kind , minimum_len) = match self . config . force { None | Some (ForceAlgorithm :: Teddy) => { let teddy = match self . build_teddy (Arc :: clone (& patterns)) { None => return None , Some (teddy) => teddy , } ; let minimum_len = teddy . minimum_len () ; (SearchKind :: Teddy (teddy) , minimum_len) } Some (ForceAlgorithm :: RabinKarp) => { (SearchKind :: RabinKarp , 0) } } ; Some (Searcher { patterns , rabinkarp , search_kind , minimum_len , }) } fn build_teddy (& self , patterns : Arc < Patterns >) -> Option < teddy :: Searcher > { teddy :: Builder :: new () . only_256bit (self . config . only_teddy_256bit) . only_fat (self . config . only_teddy_fat) . heuristic_pattern_limits (self . config . heuristic_pattern_limits) . build (patterns) } # [doc = " Add the given pattern to this set to match."] # [doc = ""] # [doc = " The order in which patterns are added is significant. Namely, when"] # [doc = " using leftmost-first match semantics, then when multiple patterns can"] # [doc = " match at a particular location, the pattern that was added first is"] # [doc = " used as the match."] # [doc = ""] # [doc = " If the number of patterns added exceeds the amount supported by packed"] # [doc = " searchers, then the builder will stop accumulating patterns and render"] # [doc = " itself inert. At this point, constructing a searcher will always return"] # [doc = " `None`."] pub fn add < P : AsRef < [u8] > > (& mut self , pattern : P) -> & mut Builder { if self . inert { return self ; } else if self . patterns . len () >= PATTERN_LIMIT { self . inert = true ; self . patterns . reset () ; return self ; } if ! (self . patterns . len () <= core :: u16 :: MAX as usize) { :: core :: panicking :: panic ("assertion failed: self.patterns.len() <= core::u16::MAX as usize" ,) } let pattern = pattern . as_ref () ; if pattern . is_empty () { self . inert = true ; self . patterns . reset () ; return self ; } self . patterns . add (pattern) ; self } # [doc = " Add the given iterator of patterns to this set to match."] # [doc = ""] # [doc = " The iterator must yield elements that can be converted into a `&[u8]`."] # [doc = ""] # [doc = " The order in which patterns are added is significant. Namely, when"] # [doc = " using leftmost-first match semantics, then when multiple patterns can"] # [doc = " match at a particular location, the pattern that was added first is"] # [doc = " used as the match."] # [doc = ""] # [doc = " If the number of patterns added exceeds the amount supported by packed"] # [doc = " searchers, then the builder will stop accumulating patterns and render"] # [doc = " itself inert. At this point, constructing a searcher will always return"] # [doc = " `None`."] pub fn extend < I , P > (& mut self , patterns : I) -> & mut Builder where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { for p in patterns { self . add (p) ; } self } # [doc = " Returns the number of patterns added to this builder."] pub fn len (& self) -> usize { self . patterns . len () } # [doc = " Returns the length, in bytes, of the shortest pattern added."] pub fn minimum_len (& self) -> usize { self . patterns . minimum_len () } } impl Default for Builder { fn default () -> Builder { Builder :: new () } } # [doc = " A packed searcher for quickly finding occurrences of multiple patterns."] # [doc = ""] # [doc = " If callers need more flexible construction, or if one wants to change the"] # [doc = " match semantics (either leftmost-first or leftmost-longest), then one can"] # [doc = " use the [`Config`] and/or [`Builder`] types for more fine grained control."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to create a searcher from an iterator of patterns."] # [doc = " By default, leftmost-first match semantics are used."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Searcher { patterns : Arc < Patterns > , rabinkarp : RabinKarp , search_kind : SearchKind , minimum_len : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Searcher { # [inline] fn clone (& self) -> Searcher { Searcher { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , rabinkarp : :: core :: clone :: Clone :: clone (& self . rabinkarp) , search_kind : :: core :: clone :: Clone :: clone (& self . search_kind) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Searcher { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "Searcher" , "patterns" , & self . patterns , "rabinkarp" , & self . rabinkarp , "search_kind" , & self . search_kind , "minimum_len" , & & self . minimum_len ,) } } enum SearchKind { Teddy (teddy :: Searcher) , RabinKarp , } # [automatically_derived] impl :: core :: clone :: Clone for SearchKind { # [inline] fn clone (& self) -> SearchKind { match self { SearchKind :: Teddy (__self_0) => { SearchKind :: Teddy (:: core :: clone :: Clone :: clone (__self_0)) } SearchKind :: RabinKarp => SearchKind :: RabinKarp , } } } # [automatically_derived] impl :: core :: fmt :: Debug for SearchKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { SearchKind :: Teddy (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Teddy" , & __self_0 ,) } SearchKind :: RabinKarp => { :: core :: fmt :: Formatter :: write_str (f , "RabinKarp") } } } } impl Searcher { # [doc = " A convenience function for constructing a searcher from an iterator"] # [doc = " of things that can be converted to a `&[u8]`."] # [doc = ""] # [doc = " If a searcher could not be constructed (either because of an"] # [doc = " unsupported CPU or because there are too many patterns), then `None`"] # [doc = " is returned."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub fn new < I , P > (patterns : I) -> Option < Searcher > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { Builder :: new () . extend (patterns) . build () } # [doc = " A convenience function for calling `Config::new()`."] # [doc = ""] # [doc = " This is useful for avoiding an additional import."] pub fn config () -> Config { Config :: new () } # [doc = " A convenience function for calling `Builder::new()`."] # [doc = ""] # [doc = " This is useful for avoiding an additional import."] pub fn builder () -> Builder { Builder :: new () } # [doc = " Return the first occurrence of any of the patterns in this searcher,"] # [doc = " according to its match semantics, in the given haystack. The `Match`"] # [doc = " returned will include the identifier of the pattern that matched, which"] # [doc = " corresponds to the index of the pattern (starting from `0`) in which it"] # [doc = " was added."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let mat = searcher.find(\"foobar\")?;"] # [doc = " assert_eq!(PatternID::ZERO, mat.pattern());"] # [doc = " assert_eq!(0, mat.start());"] # [doc = " assert_eq!(6, mat.end());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find < B : AsRef < [u8] > > (& self , haystack : B) -> Option < Match > { let haystack = haystack . as_ref () ; self . find_in (haystack , Span :: from (0 .. haystack . len ())) } # [doc = " Return the first occurrence of any of the patterns in this searcher,"] # [doc = " according to its match semantics, in the given haystack starting from"] # [doc = " the given position."] # [doc = ""] # [doc = " The `Match` returned will include the identifier of the pattern that"] # [doc = " matched, which corresponds to the index of the pattern (starting from"] # [doc = " `0`) in which it was added. The offsets in the `Match` will be relative"] # [doc = " to the start of `haystack` (and not `at`)."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID, Span};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let haystack = \"foofoobar\";"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let mat = searcher.find_in(haystack, Span::from(3..haystack.len()))?;"] # [doc = " assert_eq!(PatternID::ZERO, mat.pattern());"] # [doc = " assert_eq!(3, mat.start());"] # [doc = " assert_eq!(9, mat.end());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find_in < B : AsRef < [u8] > > (& self , haystack : B , span : Span ,) -> Option < Match > { let haystack = haystack . as_ref () ; match self . search_kind { SearchKind :: Teddy (ref teddy) => { if haystack [span] . len () < teddy . minimum_len () { return self . find_in_slow (haystack , span) ; } teddy . find (& haystack [.. span . end] , span . start) } SearchKind :: RabinKarp => { self . rabinkarp . find_at (& haystack [.. span . end] , span . start) } } } # [doc = " Return an iterator of non-overlapping occurrences of the patterns in"] # [doc = " this searcher, according to its match semantics, in the given haystack."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar fooba foofoo\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(1),"] # [doc = "     PatternID::must(1),"] # [doc = "     PatternID::must(1),"] # [doc = " ], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find_iter < 'a , 'b , B : ? Sized + AsRef < [u8] > > (& 'a self , haystack : & 'b B ,) -> FindIter < 'a , 'b > { let haystack = haystack . as_ref () ; let span = Span :: from (0 .. haystack . len ()) ; FindIter { searcher : self , haystack , span , } } # [doc = " Returns the match kind used by this packed searcher."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::packed::{MatchKind, Searcher};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " // leftmost-first is the default."] # [doc = " assert_eq!(&MatchKind::LeftmostFirst, searcher.match_kind());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn match_kind (& self) -> & MatchKind { self . patterns . match_kind () } # [doc = " Returns the minimum length of a haystack that is required in order for"] # [doc = " packed searching to be effective."] # [doc = ""] # [doc = " In some cases, the underlying packed searcher may not be able to search"] # [doc = " very short haystacks. When that occurs, the implementation will defer"] # [doc = " to a slower non-packed searcher (which is still generally faster than"] # [doc = " Aho-Corasick for a small number of patterns). However, callers may"] # [doc = " want to avoid ever using the slower variant, which one can do by"] # [doc = " never passing a haystack shorter than the minimum length returned by"] # [doc = " this method."] # [inline] pub fn minimum_len (& self) -> usize { self . minimum_len } # [doc = " Returns the approximate total amount of heap used by this searcher, in"] # [doc = " units of bytes."] # [inline] pub fn memory_usage (& self) -> usize { self . patterns . memory_usage () + self . rabinkarp . memory_usage () + self . search_kind . memory_usage () } # [doc = " Use a slow (non-packed) searcher."] # [doc = ""] # [doc = " This is useful when a packed searcher could be constructed, but could"] # [doc = " not be used to search a specific haystack. For example, if Teddy was"] # [doc = " built but the haystack is smaller than ~34 bytes, then Teddy might not"] # [doc = " be able to run."] fn find_in_slow (& self , haystack : & [u8] , span : Span) -> Option < Match > { self . rabinkarp . find_at (& haystack [.. span . end] , span . start) } } impl SearchKind { fn memory_usage (& self) -> usize { match * self { SearchKind :: Teddy (ref ted) => ted . memory_usage () , SearchKind :: RabinKarp => 0 , } } } # [doc = " An iterator over non-overlapping matches from a packed searcher."] # [doc = ""] # [doc = " The lifetime `'s` refers to the lifetime of the underlying [`Searcher`],"] # [doc = " while the lifetime `'h` refers to the lifetime of the haystack being"] # [doc = " searched."] pub struct FindIter < 's , 'h > { searcher : & 's Searcher , haystack : & 'h [u8] , span : Span , } # [automatically_derived] impl < 's , 'h > :: core :: fmt :: Debug for FindIter < 's , 'h > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "FindIter" , "searcher" , & self . searcher , "haystack" , & self . haystack , "span" , & & self . span ,) } } impl < 's , 'h > Iterator for FindIter < 's , 'h > { type Item = Match ; fn next (& mut self) -> Option < Match > { if self . span . start > self . span . end { return None ; } match self . searcher . find_in (self . haystack , self . span) { None => None , Some (m) => { self . span . start = m . end () ; Some (m) } } } } } mod ext { # [doc = " A trait for adding some helper routines to pointers."] pub (crate) trait Pointer { # [doc = " Returns the distance, in units of `T`, between `self` and `origin`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Same as `ptr::offset_from` in addition to `self >= origin`."] unsafe fn distance (self , origin : Self) -> usize ; # [doc = " Casts this pointer to `usize`."] # [doc = ""] # [doc = " Callers should not convert the `usize` back to a pointer if at all"] # [doc = " possible. (And if you believe it's necessary, open an issue to discuss"] # [doc = " why. Otherwise, it has the potential to violate pointer provenance.)"] # [doc = " The purpose of this function is just to be able to do arithmetic, i.e.,"] # [doc = " computing offsets or alignments."] fn as_usize (self) -> usize ; } impl < T > Pointer for * const T { unsafe fn distance (self , origin : * const T) -> usize { usize :: try_from (self . offset_from (origin)) . unwrap_unchecked () } fn as_usize (self) -> usize { self as usize } } impl < T > Pointer for * mut T { unsafe fn distance (self , origin : * mut T) -> usize { (self as * const T) . distance (origin as * const T) } fn as_usize (self) -> usize { (self as * const T) . as_usize () } } } mod pattern { use core :: { cmp , fmt , mem , u16 , usize } ; use alloc :: { boxed :: Box , string :: String , vec , vec :: Vec } ; use crate :: { packed :: { api :: MatchKind , ext :: Pointer } , PatternID , } ; # [doc = " A non-empty collection of non-empty patterns to search for."] # [doc = ""] # [doc = " This collection of patterns is what is passed around to both execute"] # [doc = " searches and to construct the searchers themselves. Namely, this permits"] # [doc = " searches to avoid copying all of the patterns, and allows us to keep only"] # [doc = " one copy throughout all packed searchers."] # [doc = ""] # [doc = " Note that this collection is not a set. The same pattern can appear more"] # [doc = " than once."] pub (crate) struct Patterns { # [doc = " The match semantics supported by this collection of patterns."] # [doc = ""] # [doc = " The match semantics determines the order of the iterator over patterns."] # [doc = " For leftmost-first, patterns are provided in the same order as were"] # [doc = " provided by the caller. For leftmost-longest, patterns are provided in"] # [doc = " descending order of length, with ties broken by the order in which they"] # [doc = " were provided by the caller."] kind : MatchKind , # [doc = " The collection of patterns, indexed by their identifier."] by_id : Vec < Vec < u8 > > , # [doc = " The order of patterns defined for iteration, given by pattern"] # [doc = " identifiers. The order of `by_id` and `order` is always the same for"] # [doc = " leftmost-first semantics, but may be different for leftmost-longest"] # [doc = " semantics."] order : Vec < PatternID > , # [doc = " The length of the smallest pattern, in bytes."] minimum_len : usize , # [doc = " The total number of pattern bytes across the entire collection. This"] # [doc = " is used for reporting total heap usage in constant time."] total_pattern_bytes : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Patterns { # [inline] fn clone (& self) -> Patterns { Patterns { kind : :: core :: clone :: Clone :: clone (& self . kind) , by_id : :: core :: clone :: Clone :: clone (& self . by_id) , order : :: core :: clone :: Clone :: clone (& self . order) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , total_pattern_bytes : :: core :: clone :: Clone :: clone (& self . total_pattern_bytes ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Patterns { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field5_finish (f , "Patterns" , "kind" , & self . kind , "by_id" , & self . by_id , "order" , & self . order , "minimum_len" , & self . minimum_len , "total_pattern_bytes" , & & self . total_pattern_bytes ,) } } impl Patterns { # [doc = " Create a new collection of patterns for the given match semantics. The"] # [doc = " ID of each pattern is the index of the pattern at which it occurs in"] # [doc = " the `by_id` slice."] # [doc = ""] # [doc = " If any of the patterns in the slice given are empty, then this panics."] # [doc = " Similarly, if the number of patterns given is zero, then this also"] # [doc = " panics."] pub (crate) fn new () -> Patterns { Patterns { kind : MatchKind :: default () , by_id : :: alloc :: vec :: Vec :: new () , order : :: alloc :: vec :: Vec :: new () , minimum_len : usize :: MAX , total_pattern_bytes : 0 , } } # [doc = " Add a pattern to this collection."] # [doc = ""] # [doc = " This panics if the pattern given is empty."] pub (crate) fn add (& mut self , bytes : & [u8]) { if ! ! bytes . is_empty () { :: core :: panicking :: panic ("assertion failed: !bytes.is_empty()") } if ! (self . by_id . len () <= u16 :: MAX as usize) { :: core :: panicking :: panic ("assertion failed: self.by_id.len() <= u16::MAX as usize" ,) } let id = PatternID :: new (self . by_id . len ()) . unwrap () ; self . order . push (id) ; self . by_id . push (bytes . to_vec ()) ; self . minimum_len = cmp :: min (self . minimum_len , bytes . len ()) ; self . total_pattern_bytes += bytes . len () ; } # [doc = " Set the match kind semantics for this collection of patterns."] # [doc = ""] # [doc = " If the kind is not set, then the default is leftmost-first."] pub (crate) fn set_match_kind (& mut self , kind : MatchKind) { self . kind = kind ; match self . kind { MatchKind :: LeftmostFirst => { self . order . sort () ; } MatchKind :: LeftmostLongest => { let (order , by_id) = (& mut self . order , & mut self . by_id) ; order . sort_by (| & id1 , & id2 | { by_id [id1] . len () . cmp (& by_id [id2] . len ()) . reverse () }) ; } } } # [doc = " Return the number of patterns in this collection."] # [doc = ""] # [doc = " This is guaranteed to be greater than zero."] pub (crate) fn len (& self) -> usize { self . by_id . len () } # [doc = " Returns true if and only if this collection of patterns is empty."] pub (crate) fn is_empty (& self) -> bool { self . len () == 0 } # [doc = " Returns the approximate total amount of heap used by these patterns, in"] # [doc = " units of bytes."] pub (crate) fn memory_usage (& self) -> usize { self . order . len () * mem :: size_of :: < PatternID > () + self . by_id . len () * mem :: size_of :: < Vec < u8 > > () + self . total_pattern_bytes } # [doc = " Clears all heap memory associated with this collection of patterns and"] # [doc = " resets all state such that it is a valid empty collection."] pub (crate) fn reset (& mut self) { self . kind = MatchKind :: default () ; self . by_id . clear () ; self . order . clear () ; self . minimum_len = usize :: MAX ; } # [doc = " Returns the length, in bytes, of the smallest pattern."] # [doc = ""] # [doc = " This is guaranteed to be at least one."] pub (crate) fn minimum_len (& self) -> usize { self . minimum_len } # [doc = " Returns the match semantics used by these patterns."] pub (crate) fn match_kind (& self) -> & MatchKind { & self . kind } # [doc = " Return the pattern with the given identifier. If such a pattern does"] # [doc = " not exist, then this panics."] pub (crate) fn get (& self , id : PatternID) -> Pattern < '_ > { Pattern (& self . by_id [id]) } # [doc = " Return the pattern with the given identifier without performing bounds"] # [doc = " checks."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that a pattern with the given identifier exists"] # [doc = " before using this method."] pub (crate) unsafe fn get_unchecked (& self , id : PatternID) -> Pattern < '_ > { Pattern (self . by_id . get_unchecked (id . as_usize ())) } # [doc = " Return an iterator over all the patterns in this collection, in the"] # [doc = " order in which they should be matched."] # [doc = ""] # [doc = " Specifically, in a naive multi-pattern matcher, the following is"] # [doc = " guaranteed to satisfy the match semantics of this collection of"] # [doc = " patterns:"] # [doc = ""] # [doc = " ```ignore"] # [doc = " for i in 0..haystack.len():"] # [doc = "   for p in patterns.iter():"] # [doc = "     if haystack[i..].starts_with(p.bytes()):"] # [doc = "       return Match(p.id(), i, i + p.bytes().len())"] # [doc = " ```"] # [doc = ""] # [doc = " Namely, among the patterns in a collection, if they are matched in"] # [doc = " the order provided by this iterator, then the result is guaranteed"] # [doc = " to satisfy the correct match semantics. (Either leftmost-first or"] # [doc = " leftmost-longest.)"] pub (crate) fn iter (& self) -> PatternIter < '_ > { PatternIter { patterns : self , i : 0 , } } } # [doc = " An iterator over the patterns in the `Patterns` collection."] # [doc = ""] # [doc = " The order of the patterns provided by this iterator is consistent with the"] # [doc = " match semantics of the originating collection of patterns."] # [doc = ""] # [doc = " The lifetime `'p` corresponds to the lifetime of the collection of patterns"] # [doc = " this is iterating over."] pub (crate) struct PatternIter < 'p > { patterns : & 'p Patterns , i : usize , } # [automatically_derived] impl < 'p > :: core :: fmt :: Debug for PatternIter < 'p > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "PatternIter" , "patterns" , & self . patterns , "i" , & & self . i ,) } } impl < 'p > Iterator for PatternIter < 'p > { type Item = (PatternID , Pattern < 'p >) ; fn next (& mut self) -> Option < (PatternID , Pattern < 'p >) > { if self . i >= self . patterns . len () { return None ; } let id = self . patterns . order [self . i] ; let p = self . patterns . get (id) ; self . i += 1 ; Some ((id , p)) } } # [doc = " A pattern that is used in packed searching."] pub (crate) struct Pattern < 'a > (& 'a [u8]) ; # [automatically_derived] impl < 'a > :: core :: clone :: Clone for Pattern < 'a > { # [inline] fn clone (& self) -> Pattern < 'a > { Pattern (:: core :: clone :: Clone :: clone (& self . 0)) } } impl < 'a > fmt :: Debug for Pattern < 'a > { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . debug_struct ("Pattern") . field ("lit" , & String :: from_utf8_lossy (self . 0)) . finish () } } impl < 'p > Pattern < 'p > { # [doc = " Returns the length of this pattern, in bytes."] pub (crate) fn len (& self) -> usize { self . 0 . len () } # [doc = " Returns the bytes of this pattern."] pub (crate) fn bytes (& self) -> & [u8] { self . 0 } # [doc = " Returns the first `len` low nybbles from this pattern. If this pattern"] # [doc = " is shorter than `len`, then this panics."] pub (crate) fn low_nybbles (& self , len : usize) -> Box < [u8] > { let mut nybs = :: alloc :: vec :: from_elem (0 , len) . into_boxed_slice () ; for (i , byte) in self . bytes () . iter () . take (len) . enumerate () { nybs [i] = byte & 0xF ; } nybs } # [doc = " Returns true if this pattern is a prefix of the given bytes."] # [inline (always)] pub (crate) fn is_prefix (& self , bytes : & [u8]) -> bool { is_prefix (bytes , self . bytes ()) } # [doc = " Returns true if this pattern is a prefix of the haystack given by the"] # [doc = " raw `start` and `end` pointers."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " * It must be the case that `start < end` and that the distance between"] # [doc = " them is at least equal to `V::BYTES`. That is, it must always be valid"] # [doc = " to do at least an unaligned load of `V` at `start`."] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [inline (always)] pub (crate) unsafe fn is_prefix_raw (& self , start : * const u8 , end : * const u8 ,) -> bool { let patlen = self . bytes () . len () ; let haylen = end . distance (start) ; if patlen > haylen { return false ; } is_equal_raw (start , self . bytes () . as_ptr () , patlen) } } # [doc = " Returns true if and only if `needle` is a prefix of `haystack`."] # [doc = ""] # [doc = " This uses a latency optimized variant of `memcmp` internally which *might*"] # [doc = " make this faster for very short strings."] # [doc = ""] # [doc = " # Inlining"] # [doc = ""] # [doc = " This routine is marked `inline(always)`. If you want to call this function"] # [doc = " in a way that is not always inlined, you'll need to wrap a call to it in"] # [doc = " another function that is marked as `inline(never)` or just `inline`."] # [inline (always)] fn is_prefix (haystack : & [u8] , needle : & [u8]) -> bool { if needle . len () > haystack . len () { return false ; } unsafe { is_equal_raw (haystack . as_ptr () , needle . as_ptr () , needle . len ()) } } # [doc = " Compare `n` bytes at the given pointers for equality."] # [doc = ""] # [doc = " This returns true if and only if `*x.add(i) == *y.add(i)` for all"] # [doc = " `0 <= i < n`."] # [doc = ""] # [doc = " # Inlining"] # [doc = ""] # [doc = " This routine is marked `inline(always)`. If you want to call this function"] # [doc = " in a way that is not always inlined, you'll need to wrap a call to it in"] # [doc = " another function that is marked as `inline(never)` or just `inline`."] # [doc = ""] # [doc = " # Motivation"] # [doc = ""] # [doc = " Why not use slice equality instead? Well, slice equality usually results in"] # [doc = " a call out to the current platform's `libc` which might not be inlineable"] # [doc = " or have other overhead. This routine isn't guaranteed to be a win, but it"] # [doc = " might be in some cases."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " * Both `x` and `y` must be valid for reads of up to `n` bytes."] # [doc = " * Both `x` and `y` must point to an initialized value."] # [doc = " * Both `x` and `y` must each point to an allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object. `x` and `y` do not need to point to the same allocated"] # [doc = " object, but they may."] # [doc = " * Both `x` and `y` must be _derived from_ a pointer to their respective"] # [doc = " allocated objects."] # [doc = " * The distance between `x` and `x+n` must not overflow `isize`. Similarly"] # [doc = " for `y` and `y+n`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [inline (always)] unsafe fn is_equal_raw (mut x : * const u8 , mut y : * const u8 , n : usize) -> bool { if n < 4 { return match n { 0 => true , 1 => x . read () == y . read () , 2 => { x . cast :: < u16 > () . read_unaligned () == y . cast :: < u16 > () . read_unaligned () } 3 => x . cast :: < [u8 ; 3] > () . read () == y . cast :: < [u8 ; 3] > () . read () , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ; } let xend = x . add (n . wrapping_sub (4)) ; let yend = y . add (n . wrapping_sub (4)) ; while x < xend { let vx = x . cast :: < u32 > () . read_unaligned () ; let vy = y . cast :: < u32 > () . read_unaligned () ; if vx != vy { return false ; } x = x . add (4) ; y = y . add (4) ; } let vx = xend . cast :: < u32 > () . read_unaligned () ; let vy = yend . cast :: < u32 > () . read_unaligned () ; vx == vy } } mod rabinkarp { use alloc :: { sync :: Arc , vec , vec :: Vec } ; use crate :: { packed :: pattern :: Patterns , util :: search :: Match , PatternID } ; # [doc = " The type of the rolling hash used in the Rabin-Karp algorithm."] type Hash = usize ; # [doc = " The number of buckets to store our patterns in. We don't want this to be"] # [doc = " too big in order to avoid wasting memory, but we don't want it to be too"] # [doc = " small either to avoid spending too much time confirming literals."] # [doc = ""] # [doc = " The number of buckets MUST be a power of two. Otherwise, determining the"] # [doc = " bucket from a hash will slow down the code considerably. Using a power"] # [doc = " of two means `hash % NUM_BUCKETS` can compile down to a simple `and`"] # [doc = " instruction."] const NUM_BUCKETS : usize = 64 ; # [doc = " An implementation of the Rabin-Karp algorithm. The main idea of this"] # [doc = " algorithm is to maintain a rolling hash as it moves through the input, and"] # [doc = " then check whether that hash corresponds to the same hash for any of the"] # [doc = " patterns we're looking for."] # [doc = ""] # [doc = " A draw back of naively scaling Rabin-Karp to multiple patterns is that"] # [doc = " it requires all of the patterns to be the same length, which in turn"] # [doc = " corresponds to the number of bytes to hash. We adapt this to work for"] # [doc = " multiple patterns of varying size by fixing the number of bytes to hash"] # [doc = " to be the length of the smallest pattern. We also split the patterns into"] # [doc = " several buckets to hopefully make the confirmation step faster."] # [doc = ""] # [doc = " Wikipedia has a decent explanation, if a bit heavy on the theory:"] # [doc = " https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm"] # [doc = ""] # [doc = " But ESMAJ provides something a bit more concrete:"] # [doc = " https://www-igm.univ-mlv.fr/~lecroq/string/node5.html"] pub (crate) struct RabinKarp { # [doc = " The patterns we're searching for."] patterns : Arc < Patterns > , # [doc = " The order of patterns in each bucket is significant. Namely, they are"] # [doc = " arranged such that the first one to match is the correct match. This"] # [doc = " may not necessarily correspond to the order provided by the caller."] # [doc = " For example, if leftmost-longest semantics are used, then the patterns"] # [doc = " are sorted by their length in descending order. If leftmost-first"] # [doc = " semantics are used, then the patterns are sorted by their pattern ID"] # [doc = " in ascending order (which corresponds to the caller's order)."] buckets : Vec < Vec < (Hash , PatternID) > > , # [doc = " The length of the hashing window. Generally, this corresponds to the"] # [doc = " length of the smallest pattern."] hash_len : usize , # [doc = " The factor to subtract out of a hash before updating it with a new"] # [doc = " byte."] hash_2pow : usize , } # [automatically_derived] impl :: core :: clone :: Clone for RabinKarp { # [inline] fn clone (& self) -> RabinKarp { RabinKarp { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , buckets : :: core :: clone :: Clone :: clone (& self . buckets) , hash_len : :: core :: clone :: Clone :: clone (& self . hash_len) , hash_2pow : :: core :: clone :: Clone :: clone (& self . hash_2pow) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for RabinKarp { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "RabinKarp" , "patterns" , & self . patterns , "buckets" , & self . buckets , "hash_len" , & self . hash_len , "hash_2pow" , & & self . hash_2pow ,) } } impl RabinKarp { # [doc = " Compile a new Rabin-Karp matcher from the patterns given."] # [doc = ""] # [doc = " This panics if any of the patterns in the collection are empty, or if"] # [doc = " the collection is itself empty."] pub (crate) fn new (patterns : & Arc < Patterns >) -> RabinKarp { if ! (patterns . len () >= 1) { :: core :: panicking :: panic ("assertion failed: patterns.len() >= 1") } let hash_len = patterns . minimum_len () ; if ! (hash_len >= 1) { :: core :: panicking :: panic ("assertion failed: hash_len >= 1") } let mut hash_2pow = 1usize ; for _ in 1 .. hash_len { hash_2pow = hash_2pow . wrapping_shl (1) ; } let mut rk = RabinKarp { patterns : Arc :: clone (patterns) , buckets : :: alloc :: vec :: from_elem (:: alloc :: vec :: Vec :: new () , NUM_BUCKETS ,) , hash_len , hash_2pow , } ; for (id , pat) in patterns . iter () { let hash = rk . hash (& pat . bytes () [.. rk . hash_len]) ; let bucket = hash % NUM_BUCKETS ; rk . buckets [bucket] . push ((hash , id)) ; } rk } # [doc = " Return the first matching pattern in the given haystack, begining the"] # [doc = " search at `at`."] pub (crate) fn find_at (& self , haystack : & [u8] , mut at : usize ,) -> Option < Match > { match (& NUM_BUCKETS , & self . buckets . len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if at + self . hash_len > haystack . len () { return None ; } let mut hash = self . hash (& haystack [at .. at + self . hash_len]) ; loop { let bucket = & self . buckets [hash % NUM_BUCKETS] ; for & (phash , pid) in bucket { if phash == hash { if let Some (c) = self . verify (pid , haystack , at) { return Some (c) ; } } } if at + self . hash_len >= haystack . len () { return None ; } hash = self . update_hash (hash , haystack [at] , haystack [at + self . hash_len]) ; at += 1 ; } } # [doc = " Returns the approximate total amount of heap used by this searcher, in"] # [doc = " units of bytes."] pub (crate) fn memory_usage (& self) -> usize { self . buckets . len () * core :: mem :: size_of :: < Vec < (Hash , PatternID) > > () + self . patterns . len () * core :: mem :: size_of :: < (Hash , PatternID) > () } # [doc = " Verify whether the pattern with the given id matches at"] # [doc = " `haystack[at..]`."] # [doc = ""] # [doc = " We tag this function as `cold` because it helps improve codegen."] # [doc = " Intuitively, it would seem like inlining it would be better. However,"] # [doc = " the only time this is called and a match is not found is when there"] # [doc = " there is a hash collision, or when a prefix of a pattern matches but"] # [doc = " the entire pattern doesn't match. This is hopefully fairly rare, and"] # [doc = " if it does occur a lot, it's going to be slow no matter what we do."] # [cold] fn verify (& self , id : PatternID , haystack : & [u8] , at : usize ,) -> Option < Match > { let pat = self . patterns . get (id) ; if pat . is_prefix (& haystack [at ..]) { Some (Match :: new (id , at .. at + pat . len ())) } else { None } } # [doc = " Hash the given bytes."] fn hash (& self , bytes : & [u8]) -> Hash { match (& self . hash_len , & bytes . len ()) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; let mut hash = 0usize ; for & b in bytes { hash = hash . wrapping_shl (1) . wrapping_add (b as usize) ; } hash } # [doc = " Update the hash given based on removing `old_byte` at the beginning"] # [doc = " of some byte string, and appending `new_byte` to the end of that same"] # [doc = " byte string."] fn update_hash (& self , prev : Hash , old_byte : u8 , new_byte : u8) -> Hash { prev . wrapping_sub ((old_byte as usize) . wrapping_mul (self . hash_2pow)) . wrapping_shl (1) . wrapping_add (new_byte as usize) } } } mod teddy { # ! [allow (dead_code)] pub (crate) use self :: builder :: { Builder , Searcher } ; mod builder { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; use alloc :: sync :: Arc ; use crate :: packed :: { ext :: Pointer , pattern :: Patterns , teddy :: generic :: Match } ; # [doc = " A builder for constructing a Teddy matcher."] # [doc = ""] # [doc = " The builder primarily permits fine grained configuration of the Teddy"] # [doc = " matcher. Most options are made only available for testing/benchmarking"] # [doc = " purposes. In reality, options are automatically determined by the nature"] # [doc = " and number of patterns given to the builder."] pub (crate) struct Builder { # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " slim Teddy is used (8 buckets) and `true` means fat Teddy is used"] # [doc = " (16 buckets). Fat Teddy requires AVX2, so if that CPU feature isn't"] # [doc = " available and Fat Teddy was requested, no matcher will be built."] only_fat : Option < bool > , # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " that 128-bit vectors will be used (up to SSSE3 instructions) where as"] # [doc = " `true` means that 256-bit vectors will be used. As with `fat`, if"] # [doc = " 256-bit vectors are requested and they aren't available, then a"] # [doc = " searcher will not be built."] only_256bit : Option < bool > , # [doc = " When true (the default), the number of patterns will be used as a"] # [doc = " heuristic for refusing construction of a Teddy searcher. The point here"] # [doc = " is that too many patterns can overwhelm Teddy. But this can be disabled"] # [doc = " in cases where the caller knows better."] heuristic_pattern_limits : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { only_fat : :: core :: clone :: Clone :: clone (& self . only_fat) , only_256bit : :: core :: clone :: Clone :: clone (& self . only_256bit) , heuristic_pattern_limits : :: core :: clone :: Clone :: clone (& self . heuristic_pattern_limits ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "only_fat" , & self . only_fat , "only_256bit" , & self . only_256bit , "heuristic_pattern_limits" , & & self . heuristic_pattern_limits ,) } } impl Default for Builder { fn default () -> Builder { Builder :: new () } } impl Builder { # [doc = " Create a new builder for configuring a Teddy matcher."] pub (crate) fn new () -> Builder { Builder { only_fat : None , only_256bit : None , heuristic_pattern_limits : true , } } # [doc = " Build a matcher for the set of patterns given. If a matcher could not"] # [doc = " be built, then `None` is returned."] # [doc = ""] # [doc = " Generally, a matcher isn't built if the necessary CPU features aren't"] # [doc = " available, an unsupported target or if the searcher is believed to be"] # [doc = " slower than standard techniques (i.e., if there are too many literals)."] pub (crate) fn build (& self , patterns : Arc < Patterns >) -> Option < Searcher > { self . build_imp (patterns) } # [doc = " Require the use of Fat (true) or Slim (false) Teddy. Fat Teddy uses"] # [doc = " 16 buckets where as Slim Teddy uses 8 buckets. More buckets are useful"] # [doc = " for a larger set of literals."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based"] # [doc = " on the number of literals and available CPU features."] pub (crate) fn only_fat (& mut self , yes : Option < bool >) -> & mut Builder { self . only_fat = yes ; self } # [doc = " Request the use of 256-bit vectors (true) or 128-bit vectors (false)."] # [doc = " Generally, a larger vector size is better since it either permits"] # [doc = " matching more patterns or matching more bytes in the haystack at once."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based on"] # [doc = " the number of literals and available CPU features."] pub (crate) fn only_256bit (& mut self , yes : Option < bool >) -> & mut Builder { self . only_256bit = yes ; self } # [doc = " Request that heuristic limitations on the number of patterns be"] # [doc = " employed. This useful to disable for benchmarking where one wants to"] # [doc = " explore how Teddy performs on large number of patterns even if the"] # [doc = " heuristics would otherwise refuse construction."] # [doc = ""] # [doc = " This is enabled by default."] pub (crate) fn heuristic_pattern_limits (& mut self , yes : bool ,) -> & mut Builder { self . heuristic_pattern_limits = yes ; self } fn build_imp (& self , patterns : Arc < Patterns >) -> Option < Searcher > { let patlimit = self . heuristic_pattern_limits ; if ! true { return None ; } if patlimit && patterns . len () > 64 { return None ; } { use self :: aarch64 :: SlimNeon ; let mask_len = core :: cmp :: min (4 , patterns . minimum_len ()) ; if self . only_256bit == Some (true) { return None ; } if self . only_fat == Some (true) { } match mask_len { 1 => { if patlimit && patterns . len () > 16 { } SlimNeon :: < 1 > :: new (& patterns) } 2 => { if patlimit && patterns . len () > 32 { } SlimNeon :: < 2 > :: new (& patterns) } 3 => { if patlimit && patterns . len () > 48 { } SlimNeon :: < 3 > :: new (& patterns) } 4 => { SlimNeon :: < 4 > :: new (& patterns) } _ => { None } } } } } # [doc = " A searcher that dispatches to one of several possible Teddy variants."] pub (crate) struct Searcher { # [doc = " The Teddy variant we use. We use dynamic dispatch under the theory that"] # [doc = " it results in better codegen then a enum, although this is a specious"] # [doc = " claim."] # [doc = ""] # [doc = " This `Searcher` is essentially a wrapper for a `SearcherT` trait"] # [doc = " object. We just make `memory_usage` and `minimum_len` available without"] # [doc = " going through dynamic dispatch."] imp : Arc < dyn SearcherT > , # [doc = " Total heap memory used by the Teddy variant."] memory_usage : usize , # [doc = " The minimum haystack length this searcher can handle. It is intended"] # [doc = " for callers to use some other search routine (such as Rabin-Karp) in"] # [doc = " cases where the haystack (or remainer of the haystack) is too short."] minimum_len : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Searcher { # [inline] fn clone (& self) -> Searcher { Searcher { imp : :: core :: clone :: Clone :: clone (& self . imp) , memory_usage : :: core :: clone :: Clone :: clone (& self . memory_usage) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Searcher { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Searcher" , "imp" , & self . imp , "memory_usage" , & self . memory_usage , "minimum_len" , & & self . minimum_len ,) } } impl Searcher { # [doc = " Look for the leftmost occurrence of any pattern in this search in the"] # [doc = " given haystack starting at the given position."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `haystack[at..].len()` is less than the minimum length"] # [doc = " for this haystack."] # [inline (always)] pub (crate) fn find (& self , haystack : & [u8] , at : usize ,) -> Option < crate :: Match > { if ! (haystack [at ..] . len () >= self . minimum_len) { :: core :: panicking :: panic ("assertion failed: haystack[at..].len() >= self.minimum_len" ,) } let hayptr = haystack . as_ptr () ; let teddym = unsafe { self . imp . find (hayptr . add (at) , hayptr . add (haystack . len ())) ? } ; let start = teddym . start () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let end = teddym . end () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let span = crate :: Span { start , end } ; let pid = crate :: PatternID :: new_unchecked (teddym . pattern () . as_usize () ,) ; let m = crate :: Match :: new (pid , span) ; Some (m) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . memory_usage } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { self . minimum_len } } # [doc = " A trait that provides dynamic dispatch over the different possible Teddy"] # [doc = " variants on the same algorithm."] # [doc = ""] # [doc = " On `x86_64` for example, it isn't known until runtime which of 12 possible"] # [doc = " variants will be used. One might use one of the four slim 128-bit vector"] # [doc = " variants, or one of the four 256-bit vector variants or even one of the"] # [doc = " four fat 256-bit vector variants."] # [doc = ""] # [doc = " Since this choice is generally made when the Teddy searcher is constructed"] # [doc = " and this choice is based on the patterns given and what the current CPU"] # [doc = " supports, it follows that there must be some kind of indirection at search"] # [doc = " time that \"selects\" the variant chosen at build time."] # [doc = ""] # [doc = " There are a few different ways to go about this. One approach is to use an"] # [doc = " enum. It works fine, but in my experiments, this generally results in worse"] # [doc = " codegen. Another approach, which is what we use here, is dynamic dispatch"] # [doc = " via a trait object. We basically implement this trait for each possible"] # [doc = " variant, select the variant we want at build time and convert it to a"] # [doc = " trait object for use at search time."] # [doc = ""] # [doc = " Another approach is to use function pointers and stick each of the possible"] # [doc = " variants into a union. This is essentially isomorphic to the dynamic"] # [doc = " dispatch approach, but doesn't require any allocations. Since this crate"] # [doc = " requires `alloc`, there's no real reason (AFAIK) to go down this path. (The"] # [doc = " `memchr` crate does this.)"] trait SearcherT : Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static { # [doc = " Execute a search on the given haystack (identified by `start` and `end`"] # [doc = " raw pointers)."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Essentially, the `start` and `end` pointers must be valid and point"] # [doc = " to a haystack one can read. As long as you derive them from, for"] # [doc = " example, a `&[u8]`, they should automatically satisfy all of the safety"] # [doc = " obligations:"] # [doc = ""] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [doc = " * It must be the case that `start <= end`."] # [doc = " * `end - start` must be greater than the minimum length for this"] # [doc = " searcher."] # [doc = ""] # [doc = " Also, it is expected that implementations of this trait will tag this"] # [doc = " method with a `target_feature` attribute. Callers must ensure that"] # [doc = " they are executing this method in an environment where that attribute"] # [doc = " is valid."] unsafe fn find (& self , start : * const u8 , end : * const u8) -> Option < Match > ; } mod aarch64 { use core :: arch :: aarch64 :: uint8x16_t ; use alloc :: sync :: Arc ; use crate :: packed :: { pattern :: Patterns , teddy :: generic :: { self , Match } } ; use super :: { Searcher , SearcherT } ; pub (super) struct SlimNeon < const BYTES : usize > { slim128 : generic :: Slim < uint8x16_t , BYTES > , } # [automatically_derived] impl < const BYTES : usize > :: core :: clone :: Clone for SlimNeon < BYTES > { # [inline] fn clone (& self) -> SlimNeon < BYTES > { SlimNeon { slim128 : :: core :: clone :: Clone :: clone (& self . slim128) , } } } # [automatically_derived] impl < const BYTES : usize > :: core :: fmt :: Debug for SlimNeon < BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter ,) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SlimNeon" , "slim128" , & & self . slim128 ,) } } impl SlimNeon < 1 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 1 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 1 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 1 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 2 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 2 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 2 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 2 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 3 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 3 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 3 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 3 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 4 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 4 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 4 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 4 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } } } mod generic { use core :: fmt :: Debug ; use alloc :: { boxed :: Box , collections :: BTreeMap , format , sync :: Arc , vec , vec :: Vec , } ; use crate :: { packed :: { ext :: Pointer , pattern :: Patterns , vector :: { FatVector , Vector } } , util :: int :: U32 , PatternID , } ; # [doc = " A match type specialized to the Teddy implementations below."] # [doc = ""] # [doc = " Essentially, instead of representing a match at byte offsets, we use"] # [doc = " raw pointers. This is because the implementations below operate on raw"] # [doc = " pointers, and so this is a more natural return type based on how the"] # [doc = " implementation works."] # [doc = ""] # [doc = " Also, the `PatternID` used here is a `u16`."] pub (crate) struct Match { pid : PatternID , start : * const u8 , end : * const u8 , } # [automatically_derived] impl :: core :: clone :: Clone for Match { # [inline] fn clone (& self) -> Match { let _ : :: core :: clone :: AssertParamIsClone < PatternID > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for Match { } # [automatically_derived] impl :: core :: fmt :: Debug for Match { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Match" , "pid" , & self . pid , "start" , & self . start , "end" , & & self . end ,) } } impl Match { # [doc = " Returns the ID of the pattern that matched."] pub (crate) fn pattern (& self) -> PatternID { self . pid } # [doc = " Returns a pointer into the haystack at which the match starts."] pub (crate) fn start (& self) -> * const u8 { self . start } # [doc = " Returns a pointer into the haystack at which the match ends."] pub (crate) fn end (& self) -> * const u8 { self . end } } # [doc = " A \"slim\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Slim < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"slim\" Teddy verification."] teddy : Teddy < 8 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Slim < V , BYTES > { # [inline] fn clone (& self) -> Slim < V , BYTES > { Slim { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Slim < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Slim" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : Vector , const BYTES : usize > Slim < V , BYTES > { # [doc = " Create a new \"slim\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Slim < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = SlimMaskBuilder :: from_teddy (& teddy) ; Slim { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: BYTES + (BYTES - 1) } } impl < V : Vector > Slim < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : Vector > Slim < V , 2 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : Vector > Slim < V , 3 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : Vector > Slim < V , 4 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " A \"fat\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Fat < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"fat\" Teddy verification."] teddy : Teddy < 16 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Fat < V , BYTES > { # [inline] fn clone (& self) -> Fat < V , BYTES > { Fat { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Fat < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Fat" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : FatVector , const BYTES : usize > Fat < V , BYTES > { # [doc = " Create a new \"fat\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Fat < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = FatMaskBuilder :: from_teddy (& teddy) ; Fat { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: Half :: BYTES + (BYTES - 1) } } impl < V : FatVector > Fat < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_half_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : FatVector > Fat < V , 2 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : FatVector > Fat < V , 3 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : FatVector > Fat < V , 4 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . half_shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " The common elements of all \"slim\" and \"fat\" Teddy search implementations."] # [doc = ""] # [doc = " Essentially, this contains the patterns and the buckets. Namely, it"] # [doc = " contains enough to implement the verification step after candidates are"] # [doc = " identified via the shuffle masks."] # [doc = ""] # [doc = " It is generic over the number of buckets used. In general, the number of"] # [doc = " buckets is either 8 (for \"slim\" Teddy) or 16 (for \"fat\" Teddy). The generic"] # [doc = " parameter isn't really meant to be instantiated for any value other than"] # [doc = " 8 or 16, although it is technically possible. The main hiccup is that there"] # [doc = " is some bit-shifting done in the critical part of verification that could"] # [doc = " be quite expensive if `N` is not a multiple of 2."] struct Teddy < const BUCKETS : usize > { # [doc = " The patterns we are searching for."] # [doc = ""] # [doc = " A pattern string can be found by its `PatternID`."] patterns : Arc < Patterns > , # [doc = " The allocation of patterns in buckets. This only contains the IDs of"] # [doc = " patterns. In order to do full verification, callers must provide the"] # [doc = " actual patterns when using Teddy."] buckets : [Vec < PatternID > ; BUCKETS] , } # [automatically_derived] impl < const BUCKETS : usize > :: core :: clone :: Clone for Teddy < BUCKETS > { # [inline] fn clone (& self) -> Teddy < BUCKETS > { Teddy { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , buckets : :: core :: clone :: Clone :: clone (& self . buckets) , } } } # [automatically_derived] impl < const BUCKETS : usize > :: core :: fmt :: Debug for Teddy < BUCKETS > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Teddy" , "patterns" , & self . patterns , "buckets" , & & self . buckets ,) } } impl < const BUCKETS : usize > Teddy < BUCKETS > { # [doc = " Create a new generic data structure for Teddy verification."] fn new (patterns : Arc < Patterns >) -> Teddy < BUCKETS > { match (& (0) , & (patterns . len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy requires at least one pattern") ,) ,) ; } } } ; match (& (0) , & (patterns . minimum_len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy does not support zero-length patterns") ,) ,) ; } } } ; if ! (BUCKETS == 8 || BUCKETS == 16) { { :: core :: panicking :: panic_fmt (format_args ! ("Teddy only supports 8 or 16 buckets") ,) ; } } let buckets = < [Vec < PatternID , > ; BUCKETS] > :: try_from (:: alloc :: vec :: from_elem (:: alloc :: vec :: Vec :: new () , BUCKETS) ,) . unwrap () ; let mut t = Teddy { patterns , buckets } ; let mut map : BTreeMap < Box < [u8] > , usize > = BTreeMap :: new () ; for (id , pattern) in t . patterns . iter () { let lonybs = pattern . low_nybbles (t . mask_len ()) ; if let Some (& bucket) = map . get (& lonybs) { t . buckets [bucket] . push (id) ; } else { let bucket = (BUCKETS - 1) - (id . as_usize () % BUCKETS) ; t . buckets [bucket] . push (id) ; map . insert (lonybs , bucket) ; } } t } # [doc = " Verify whether there are any matches starting at or after `cur` in the"] # [doc = " haystack. The candidate chunk given should correspond to 8-bit bitsets"] # [doc = " for N buckets."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [inline (always)] unsafe fn verify64 (& self , cur : * const u8 , end : * const u8 , mut candidate_chunk : u64 ,) -> Option < Match > { while candidate_chunk != 0 { let bit = candidate_chunk . trailing_zeros () . as_usize () ; candidate_chunk &= ! (1 << bit) ; let cur = cur . add (bit / BUCKETS) ; let bucket = bit % BUCKETS ; if let Some (m) = self . verify_bucket (cur , end , bucket) { return Some (m) ; } } None } # [doc = " Verify whether there are any matches starting at `at` in the given"] # [doc = " `haystack` corresponding only to patterns in the given bucket."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " The bucket index must be less than or equal to `self.buckets.len()`."] # [inline (always)] unsafe fn verify_bucket (& self , cur : * const u8 , end : * const u8 , bucket : usize ,) -> Option < Match > { if true { if ! (bucket < self . buckets . len ()) { :: core :: panicking :: panic ("assertion failed: bucket < self.buckets.len()" ,) } } for pid in self . buckets . get_unchecked (bucket) . iter () . copied () { if true { if ! (pid . as_usize () < self . patterns . len ()) { :: core :: panicking :: panic ("assertion failed: pid.as_usize() < self.patterns.len()" ,) } } let pat = self . patterns . get_unchecked (pid) ; if pat . is_prefix_raw (cur , end) { let start = cur ; let end = start . add (pat . len ()) ; return Some (Match { pid , start , end }) ; } } None } # [doc = " Returns the total number of masks required by the patterns in this"] # [doc = " Teddy searcher."] # [doc = ""] # [doc = " Basically, the mask length corresponds to the type of Teddy searcher"] # [doc = " to use: a 1-byte, 2-byte, 3-byte or 4-byte searcher. The bigger the"] # [doc = " better, typically, since searching for longer substrings usually"] # [doc = " decreases the rate of false positives. Therefore, the number of masks"] # [doc = " needed is the length of the shortest pattern in this searcher. If the"] # [doc = " length of the shortest pattern (in bytes) is bigger than 4, then the"] # [doc = " mask length is 4 since there are no Teddy searchers for more than 4"] # [doc = " bytes."] fn mask_len (& self) -> usize { core :: cmp :: min (4 , self . patterns . minimum_len ()) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] fn memory_usage (& self) -> usize { self . patterns . len () * core :: mem :: size_of :: < PatternID > () } } impl Teddy < 8 > { # [doc = " Runs the verification routine for \"slim\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + j` in `cur` is in the bucket `i`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : Vector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } candidate . for_each_64bit_lane (# [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (8) ; result } ,) } } impl Teddy < 16 > { # [doc = " Runs the verification routine for \"fat\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + (j < 16 ? j : j - 16)` in `cur` is in the"] # [doc = " bucket `j < 16 ? i : i + 8`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : FatVector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } let swapped = candidate . swap_halves () ; let r1 = candidate . interleave_low_8bit_lanes (swapped) ; let r2 = candidate . interleave_high_8bit_lanes (swapped) ; r1 . for_each_low_64bit_lane (r2 , # [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (4) ; result } ,) } } # [doc = " A vector generic mask for the low and high nybbles in a set of patterns."] # [doc = " Each 8-bit lane `j` in a vector corresponds to a bitset where the `i`th bit"] # [doc = " is set if and only if the nybble `j` is in the bucket `i` at a particular"] # [doc = " position."] # [doc = ""] # [doc = " This is slightly tweaked dependending on whether Slim or Fat Teddy is being"] # [doc = " used. For Slim Teddy, the bitsets in the lower half are the same as the"] # [doc = " bitsets in the higher half, so that we can search `V::BYTES` bytes at a"] # [doc = " time. (Remember, the nybbles in the haystack are used as indices into these"] # [doc = " masks, and 256-bit shuffles only operate on 128-bit lanes.)"] # [doc = ""] # [doc = " For Fat Teddy, the bitsets are not repeated, but instead, the high half"] # [doc = " bits correspond to an addition 8 buckets. So that a bitset `00100010` has"] # [doc = " buckets 1 and 5 set if it's in the lower half, but has buckets 9 and 13 set"] # [doc = " if it's in the higher half."] struct Mask < V > { lo : V , hi : V , } # [automatically_derived] impl < V : :: core :: clone :: Clone > :: core :: clone :: Clone for Mask < V > { # [inline] fn clone (& self) -> Mask < V > { Mask { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl < V : :: core :: marker :: Copy > :: core :: marker :: Copy for Mask < V > { } # [automatically_derived] impl < V : :: core :: fmt :: Debug > :: core :: fmt :: Debug for Mask < V > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Mask" , "lo" , & self . lo , "hi" , & & self . hi ,) } } impl < V : Vector > Mask < V > { # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 1-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If a candidate is returned, it will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. If no candidate is found, then the vector returned will have all"] # [doc = " lanes set to zero."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " `mask1` should correspond to a low/high mask for the first byte of all"] # [doc = " patterns that are being searched."] # [inline (always)] unsafe fn members1 (chunk : V , masks : [Mask < V > ; 1]) -> V { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand = masks [0] . lo . shuffle_bytes (hlo) ; let hicand = masks [0] . hi . shuffle_bytes (hhi) ; locand . and (hicand) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 2-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first and second bytes"] # [doc = " of the patterns being searched. If no candidate is found, then all of"] # [doc = " the lanes will be set to zero in at least one of the vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first and"] # [doc = " second bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members2 (chunk : V , masks : [Mask < V > ; 2]) -> (V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; (cand1 , cand2) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 3-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second and third"] # [doc = " bytes of the patterns being searched. If no candidate is found, then"] # [doc = " all of the lanes will be set to zero in at least one of the vectors"] # [doc = " returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first, second"] # [doc = " and third bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members3 (chunk : V , masks : [Mask < V > ; 3]) -> (V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; (cand1 , cand2 , cand3) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 4-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second, third"] # [doc = " and fourth bytes of the patterns being searched. If no candidate is"] # [doc = " found, then all of the lanes will be set to zero in at least one of the"] # [doc = " vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first,"] # [doc = " second, third and fourth bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members4 (chunk : V , masks : [Mask < V > ; 4]) -> (V , V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; let locand4 = masks [3] . lo . shuffle_bytes (hlo) ; let hicand4 = masks [3] . hi . shuffle_bytes (hhi) ; let cand4 = locand4 . and (hicand4) ; (cand1 , cand2 , cand3 , cand4) } } # [doc = " Represents the low and high nybble masks that will be used during"] # [doc = " search. Each mask is 32 bytes wide, although only the first 16 bytes are"] # [doc = " used for 128-bit vectors."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] # [doc = ""] # [doc = " Each mask is used as the target of a shuffle, where the indices for the"] # [doc = " shuffle are taken from the haystack. AND'ing the shuffles for both the"] # [doc = " low and high masks together also results in 8-bit bitsets, but where bit"] # [doc = " `i` is set if and only if the correspond *byte* is in the ith bucket."] struct SlimMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for SlimMaskBuilder { # [inline] fn clone (& self) -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl :: core :: default :: Default for SlimMaskBuilder { # [inline] fn default () -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl SlimMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-7."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 8`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 8) { :: core :: panicking :: panic ("assertion failed: bucket < 8") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; self . lo [byte_lo] |= 1 << bucket ; self . lo [byte_lo + 16] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; self . hi [byte_hi + 16] |= 1 << bucket ; } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a slim"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 8 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (SlimMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [SlimMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for SlimMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("SlimMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } # [doc = " Represents the low and high nybble masks that will be used during \"fat\""] # [doc = " Teddy search."] # [doc = ""] # [doc = " Each mask is 32 bytes wide, and at the time of writing, only 256-bit vectors"] # [doc = " support fat Teddy."] # [doc = ""] # [doc = " A fat Teddy mask is like a slim Teddy mask, except that instead of"] # [doc = " repeating the bitsets in the high and low 128-bits in 256-bit vectors, the"] # [doc = " high and low 128-bit halves each represent distinct buckets. (Bringing the"] # [doc = " total to 16 instead of 8.) This permits spreading the patterns out a bit"] # [doc = " more and thus putting less pressure on verification to be fast."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] struct FatMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for FatMaskBuilder { # [inline] fn clone (& self) -> FatMaskBuilder { let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for FatMaskBuilder { } # [automatically_derived] impl :: core :: default :: Default for FatMaskBuilder { # [inline] fn default () -> FatMaskBuilder { FatMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl FatMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-15."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 16`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 16) { :: core :: panicking :: panic ("assertion failed: bucket < 16") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; if bucket < 8 { self . lo [byte_lo] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; } else { self . lo [byte_lo + 16] |= 1 << (bucket % 8) ; self . hi [byte_hi + 16] |= 1 << (bucket % 8) ; } } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a fat"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 16 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (FatMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [FatMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for FatMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("FatMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } } } mod vector { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; # [doc = " A trait for describing vector operations used by vectorized searchers."] # [doc = ""] # [doc = " The trait is highly constrained to low level vector operations needed for"] # [doc = " the specific algorithms used in this crate. In general, it was invented"] # [doc = " mostly to be generic over x86's __m128i and __m256i types. At time of"] # [doc = " writing, it also supports wasm and aarch64 128-bit vector types as well."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " All methods are not safe since they are intended to be implemented using"] # [doc = " vendor intrinsics, which are also not safe. Callers must ensure that"] # [doc = " the appropriate target features are enabled in the calling function,"] # [doc = " and that the current CPU supports them. All implementations should"] # [doc = " avoid marking the routines with `#[target_feature]` and instead mark"] # [doc = " them as `#[inline(always)]` to ensure they get appropriately inlined."] # [doc = " (`inline(always)` cannot be used with target_feature.)"] pub (crate) trait Vector : Copy + Debug + Send + Sync + UnwindSafe + RefUnwindSafe { # [doc = " The number of bits in the vector."] const BITS : usize ; # [doc = " The number of bytes in the vector. That is, this is the size of the"] # [doc = " vector in memory."] const BYTES : usize ; # [doc = " Create a vector with 8-bit lanes with the given byte repeated into each"] # [doc = " lane."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn splat (byte : u8) -> Self ; # [doc = " Read a vector-size number of bytes from the given pointer. The pointer"] # [doc = " does not need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `BYTES` bytes are readable from"] # [doc = " `data`."] unsafe fn load_unaligned (data : * const u8) -> Self ; # [doc = " Returns true if and only if this vector has zero in all of its lanes."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn is_zero (self) -> bool ; # [doc = " Do an 8-bit pairwise equality check. If lane `i` is equal in this"] # [doc = " vector and the one given, then lane `i` in the resulting vector is set"] # [doc = " to `0xFF`. Otherwise, it is set to `0x00`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn cmpeq (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'and' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn and (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'or' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [allow (dead_code)] unsafe fn or (self , vector2 : Self) -> Self ; # [doc = " Shift each 8-bit lane in this vector to the right by the number of"] # [doc = " bits indictated by the `BITS` type parameter."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self ; # [doc = " Shift this vector to the left by one byte and shift the most"] # [doc = " significant byte of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 1` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 1`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by two bytes and shift the two most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 2` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 2`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by three bytes and shift the three most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 3` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last three bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 3`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Shuffles the bytes in this vector according to the indices in each of"] # [doc = " the corresponding lanes in `indices`."] # [doc = ""] # [doc = " If `i` is the index of corresponding lanes, `A` is this vector, `B` is"] # [doc = " indices and `C` is the resulting vector, then `C = A[B[i]]`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shuffle_bytes (self , indices : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in this vector. The"] # [doc = " given function is provided the lane index and lane value as a `u64`."] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Notes"] # [doc = ""] # [doc = " Conceptually it would be nice if we could have a"] # [doc = " `unpack64(self) -> [u64; BITS / 64]` method, but defining that is"] # [doc = " tricky given Rust's [current support for const generics][support]."] # [doc = " And even if we could, it would be tricky to write generic code over"] # [doc = " it. (Not impossible. We could introduce another layer that requires"] # [doc = " `AsRef<[u64]>` or something.)"] # [doc = ""] # [doc = " [support]: https://github.com/rust-lang/rust/issues/60551"] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_64bit_lane < T > (self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; } # [doc = " This trait extends the `Vector` trait with additional operations to support"] # [doc = " Fat Teddy."] # [doc = ""] # [doc = " Fat Teddy uses 16 buckets instead of 8, but reads half as many bytes (as"] # [doc = " the vector size) instead of the full size of a vector per iteration. For"] # [doc = " example, when using a 256-bit vector, Slim Teddy reads 32 bytes at a timr"] # [doc = " but Fat Teddy reads 16 bytes at a time."] # [doc = ""] # [doc = " Fat Teddy is useful when searching for a large number of literals."] # [doc = " The extra number of buckets spreads the literals out more and reduces"] # [doc = " verification time."] # [doc = ""] # [doc = " Currently we only implement this for AVX on x86_64. It would be nice to"] # [doc = " implement this for SSE on x86_64 and NEON on aarch64, with the latter two"] # [doc = " only reading 8 bytes at a time. It's not clear how well it would work, but"] # [doc = " there are some tricky things to figure out in terms of implementation. The"] # [doc = " `half_shift_in_{one,two,three}_bytes` methods in particular are probably"] # [doc = " the trickiest of the bunch. For AVX2, these are implemented by taking"] # [doc = " advantage of the fact that `_mm256_alignr_epi8` operates on each 128-bit"] # [doc = " half instead of the full 256-bit vector. (Where as `_mm_alignr_epi8`"] # [doc = " operates on the full 128-bit vector and not on each 64-bit half.) I didn't"] # [doc = " do a careful survey of NEON to see if it could easily support these"] # [doc = " operations."] pub (crate) trait FatVector : Vector { type Half : Vector ; # [doc = " Read a half-vector-size number of bytes from the given pointer, and"] # [doc = " broadcast it across both halfs of a full vector. The pointer does not"] # [doc = " need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `Self::HALF::BYTES` bytes are"] # [doc = " readable from `data`."] unsafe fn load_half_unaligned (data : * const u8) -> Self ; # [doc = " Like `Vector::shift_in_one_byte`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Swap the 128-bit lanes in this vector."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn swap_halves (self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the low 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_low_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the high 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_high_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in the lower half"] # [doc = " of this vector and then in the other vector. The given function is"] # [doc = " provided the lane index and lane value as a `u64`. (The high 128-bits"] # [doc = " of each vector are ignored.)"] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_low_64bit_lane < T > (self , vector2 : Self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; } mod aarch64_neon { use core :: arch :: aarch64 :: * ; use super :: Vector ; impl Vector for uint8x16_t { const BITS : usize = 128 ; const BYTES : usize = 16 ; # [inline (always)] unsafe fn splat (byte : u8) -> uint8x16_t { vdupq_n_u8 (byte) } # [inline (always)] unsafe fn load_unaligned (data : * const u8) -> uint8x16_t { vld1q_u8 (data) } # [inline (always)] unsafe fn is_zero (self) -> bool { let maxes = vreinterpretq_u64_u8 (vpmaxq_u8 (self , self)) ; vgetq_lane_u64 (maxes , 0) == 0 } # [inline (always)] unsafe fn cmpeq (self , vector2 : Self) -> uint8x16_t { vceqq_u8 (self , vector2) } # [inline (always)] unsafe fn and (self , vector2 : Self) -> uint8x16_t { vandq_u8 (self , vector2) } # [inline (always)] unsafe fn or (self , vector2 : Self) -> uint8x16_t { vorrq_u8 (self , vector2) } # [inline (always)] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self { if true { if ! (BITS <= 7) { :: core :: panicking :: panic ("assertion failed: BITS <= 7") } } vshrq_n_u8 (self , BITS) } # [inline (always)] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 15) } # [inline (always)] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 14) } # [inline (always)] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 13) } # [inline (always)] unsafe fn shuffle_bytes (self , indices : Self) -> Self { vqtbl1q_u8 (self , indices) } # [inline (always)] unsafe fn for_each_64bit_lane < T > (self , mut f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > { let this = vreinterpretq_u64_u8 (self) ; let lane = vgetq_lane_u64 (this , 0) ; if let Some (t) = f (0 , lane) { return Some (t) ; } let lane = vgetq_lane_u64 (this , 1) ; if let Some (t) = f (1 , lane) { return Some (t) ; } None } } } } }