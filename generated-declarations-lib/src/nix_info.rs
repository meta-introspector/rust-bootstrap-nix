pub mod nix_info { use std :: fmt :: Debug ; pub struct NixInfo { pub flake_path : String , pub output_type : String , } # [automatically_derived] impl :: core :: fmt :: Debug for NixInfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "NixInfo" , "flake_path" , & self . flake_path , "output_type" , & & self . output_type ,) } } # [automatically_derived] impl :: core :: clone :: Clone for NixInfo { # [inline] fn clone (& self) -> NixInfo { NixInfo { flake_path : :: core :: clone :: Clone :: clone (& self . flake_path) , output_type : :: core :: clone :: Clone :: clone (& self . output_type) , } } } pub enum NixDetails { Info (NixInfo) , Error (String) , Unknown , } # [automatically_derived] impl :: core :: fmt :: Debug for NixDetails { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { NixDetails :: Info (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Info" , & __self_0 ,) } NixDetails :: Error (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Error" , & __self_0 ,) } NixDetails :: Unknown => { :: core :: fmt :: Formatter :: write_str (f , "Unknown") } } } } # [automatically_derived] impl :: core :: clone :: Clone for NixDetails { # [inline] fn clone (& self) -> NixDetails { match self { NixDetails :: Info (__self_0) => { NixDetails :: Info (:: core :: clone :: Clone :: clone (__self_0)) } NixDetails :: Error (__self_0) => { NixDetails :: Error (:: core :: clone :: Clone :: clone (__self_0)) } NixDetails :: Unknown => NixDetails :: Unknown , } } } pub trait NixInfoTrait : Send + Sync + Debug { fn nix_flake_path (& self) -> Option < & str > ; fn nix_output_type (& self) -> Option < & str > ; } impl NixInfoTrait for NixDetails { fn nix_flake_path (& self) -> Option < & str > { match self { NixDetails :: Info (info) => Some (& info . flake_path) , _ => None , } } fn nix_output_type (& self) -> Option < & str > { match self { NixDetails :: Info (info) => Some (& info . output_type) , _ => None , } } } }