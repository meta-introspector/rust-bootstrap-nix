pub mod public_tests { use super :: args :: Args ; use std :: path :: PathBuf ; use anyhow :: Result ; use std :: fs ; use prelude_collector :: { FileProcessingResult , FileProcessingStatus } ; use tempfile :: tempdir ; use std :: env ; use super :: generate_prelude ; use clap :: Parser ; pub fn test_args_default_values () { let args = Args :: parse_from (& ["prelude-generator"]) ; if ! ! args . dry_run { :: core :: panicking :: panic ("assertion failed: !args.dry_run") } match (& args . path , & PathBuf :: from (".")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . exclude_crates . is_empty () { :: core :: panicking :: panic ("assertion failed: args.exclude_crates.is_empty()") } if ! ! args . report { :: core :: panicking :: panic ("assertion failed: !args.report") } match (& args . results_file , & PathBuf :: from ("prelude_processing_results.json")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! ! args . cache_report { :: core :: panicking :: panic ("assertion failed: !args.cache_report") } if ! args . timeout . is_none () { :: core :: panicking :: panic ("assertion failed: args.timeout.is_none()") } if ! ! args . force { :: core :: panicking :: panic ("assertion failed: !args.force") } } pub fn test_args_custom_values () { let args = Args :: parse_from (& ["prelude-generator" , "--dry-run" , "--path" , "/tmp/my_project" , "--exclude-crates" , "crate1,crate2" , "--report" , "--results-file" , "custom_results.json" , "--cache-report" , "--timeout" , "60" , "--force" ,] ,) ; if ! args . dry_run { :: core :: panicking :: panic ("assertion failed: args.dry_run") } match (& args . path , & PathBuf :: from ("/tmp/my_project")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; match (& args . exclude_crates , & < [_] > :: into_vec (:: alloc :: boxed :: box_new (["crate1" . to_string () , "crate2" . to_string ()]) ,) ,) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . report { :: core :: panicking :: panic ("assertion failed: args.report") } match (& args . results_file , & PathBuf :: from ("custom_results.json")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . cache_report { :: core :: panicking :: panic ("assertion failed: args.cache_report") } match (& args . timeout , & Some (60)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . force { :: core :: panicking :: panic ("assertion failed: args.force") } } pub fn test_generate_report_empty_results () -> Result < () > { let dir = tempdir () ? ; let original_dir = std :: env :: current_dir () ? ; std :: env :: set_current_dir (& dir) ? ; super :: report :: generate_report (& []) ? ; let report_path = dir . path () . join ("prelude_generator_summary.md") ; if ! report_path . exists () { :: core :: panicking :: panic ("assertion failed: report_path.exists()") } let content = fs :: read_to_string (& report_path) ? ; if ! content . contains ("# Prelude Generation Summary Report") { :: core :: panicking :: panic ("assertion failed: content.contains(\"# Prelude Generation Summary Report\")" ,) } if ! content . contains ("- Total files processed: 0") { :: core :: panicking :: panic ("assertion failed: content.contains(\"- Total files processed: 0\")" ,) } if ! ! content . contains ("## Detailed Results") { :: core :: panicking :: panic ("assertion failed: !content.contains(\"## Detailed Results\")" ,) } std :: env :: set_current_dir (& original_dir) ? ; Ok (()) } pub fn test_generate_report_with_results () -> Result < () > { let dir = tempdir () ? ; let original_dir = std :: env :: current_dir () ? ; std :: env :: set_current_dir (& dir) ? ; let results = < [_] > :: into_vec (:: alloc :: boxed :: box_new ([FileProcessingResult { path : PathBuf :: from ("src/file1.rs") , status : FileProcessingStatus :: Success , } , FileProcessingResult { path : PathBuf :: from ("src/file2.rs") , status : FileProcessingStatus :: Skipped { reason : "already processed" . to_string () , } , } , FileProcessingResult { path : PathBuf :: from ("src/file3.rs") , status : FileProcessingStatus :: Failed { error : "syntax error" . to_string () , } , } ,]) ,) ; super :: report :: generate_report (& results) ? ; let report_path = dir . path () . join ("prelude_generator_summary.md") ; if ! report_path . exists () { :: core :: panicking :: panic ("assertion failed: report_path.exists()") } let content = fs :: read_to_string (& report_path) ? ; if ! content . contains ("# Prelude Generation Summary Report") { :: core :: panicking :: panic ("assertion failed: content.contains(\"# Prelude Generation Summary Report\")" ,) } if ! content . contains ("- Total files processed: 3") { :: core :: panicking :: panic ("assertion failed: content.contains(\"- Total files processed: 3\")" ,) } if ! content . contains ("- Successfully processed: 1") { :: core :: panicking :: panic ("assertion failed: content.contains(\"- Successfully processed: 1\")" ,) } if ! content . contains ("- Skipped: 1") { :: core :: panicking :: panic ("assertion failed: content.contains(\"- Skipped: 1\")" ,) } if ! content . contains ("- Failed: 1") { :: core :: panicking :: panic ("assertion failed: content.contains(\"- Failed: 1\")" ,) } if ! content . contains ("### src/file1.rs\n- Status: ✅ Successfully Processed") { :: core :: panicking :: panic ("assertion failed: content.contains(\"### src/file1.rs\\n- Status: \u{2705} Successfully Processed\")" ,) } if ! content . contains ("### src/file2.rs\n- Status: ⏭️ Skipped (Reason: already processed" ,) { :: core :: panicking :: panic ("assertion failed: content.contains(\"### src/file2.rs\\n- Status: \u{23ed}\u{fe0f} Skipped (Reason: already processed\")" ,) } if ! content . contains ("### src/file3.rs\n- Status: ❌ Failed (Error: syntax error") { :: core :: panicking :: panic ("assertion failed: content.contains(\"### src/file3.rs\\n- Status: \u{274c} Failed (Error: syntax error\")" ,) } std :: env :: set_current_dir (& original_dir) ? ; Ok (()) } pub fn test_generate_prelude_creates_file () -> Result < () > { let dir = tempdir () ? ; let src_dir = dir . path () . join ("src") ; fs :: create_dir (& src_dir) ? ; let prelude_content = "// Test prelude content" ; generate_prelude :: generate_prelude (& src_dir , prelude_content , false , false) ? ; let prelude_path = src_dir . join ("prelude.rs") ; if ! prelude_path . exists () { :: core :: panicking :: panic ("assertion failed: prelude_path.exists()") } match (& fs :: read_to_string (& prelude_path) ? , & prelude_content) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; Ok (()) } pub fn test_generate_prelude_dry_run () -> Result < () > { let dir = tempdir () ? ; let src_dir = dir . path () . join ("src") ; fs :: create_dir (& src_dir) ? ; let prelude_content = "// Test prelude content" ; generate_prelude :: generate_prelude (& src_dir , prelude_content , true , false) ? ; let prelude_path = src_dir . join ("prelude.rs") ; if ! ! prelude_path . exists () { :: core :: panicking :: panic ("assertion failed: !prelude_path.exists()") } Ok (()) } pub fn test_generate_prelude_force_overwrite () -> Result < () > { let dir = tempdir () ? ; let src_dir = dir . path () . join ("src") ; fs :: create_dir (& src_dir) ? ; let prelude_path = src_dir . join ("prelude.rs") ; fs :: write (& prelude_path , "// Original content") ? ; let new_prelude_content = "// New prelude content" ; generate_prelude :: generate_prelude (& src_dir , new_prelude_content , false , true) ? ; if ! prelude_path . exists () { :: core :: panicking :: panic ("assertion failed: prelude_path.exists()") } match (& fs :: read_to_string (& prelude_path) ? , & new_prelude_content) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; Ok (()) } pub fn test_generate_prelude_no_force_no_overwrite () -> Result < () > { let dir = tempdir () ? ; let src_dir = dir . path () . join ("src") ; fs :: create_dir (& src_dir) ? ; let prelude_path = src_dir . join ("prelude.rs") ; let original_content = "// Original content" ; fs :: write (& prelude_path , original_content) ? ; let new_prelude_content = "// New prelude content" ; generate_prelude :: generate_prelude (& src_dir , new_prelude_content , false , false) ? ; if ! prelude_path . exists () { :: core :: panicking :: panic ("assertion failed: prelude_path.exists()") } match (& fs :: read_to_string (& prelude_path) ? , & original_content) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; Ok (()) } }