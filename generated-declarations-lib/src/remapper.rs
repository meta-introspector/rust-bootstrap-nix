pub (crate) mod remapper { use alloc :: vec :: Vec ; use crate :: { nfa :: noncontiguous , util :: primitives :: StateID } ; # [doc = " Remappable is a tightly coupled abstraction that facilitates remapping"] # [doc = " state identifiers in DFAs."] # [doc = ""] # [doc = " The main idea behind remapping state IDs is that DFAs often need to check"] # [doc = " if a certain state is a \"special\" state of some kind (like a match state)"] # [doc = " during a search. Since this is extremely perf critical code, we want this"] # [doc = " check to be as fast as possible. Partitioning state IDs into, for example,"] # [doc = " into \"non-match\" and \"match\" states means one can tell if a state is a"] # [doc = " match state via a simple comparison of the state ID."] # [doc = ""] # [doc = " The issue is that during the DFA construction process, it's not"] # [doc = " particularly easy to partition the states. Instead, the simplest thing is"] # [doc = " to often just do a pass over all of the states and shuffle them into their"] # [doc = " desired partitionings. To do that, we need a mechanism for swapping states."] # [doc = " Hence, this abstraction."] # [doc = ""] # [doc = " Normally, for such little code, I would just duplicate it. But this is a"] # [doc = " key optimization and the implementation is a bit subtle. So the abstraction"] # [doc = " is basically a ham-fisted attempt at DRY. The only place we use this is in"] # [doc = " the dense and one-pass DFAs."] # [doc = ""] # [doc = " See also src/dfa/special.rs for a more detailed explanation of how dense"] # [doc = " DFAs are partitioned."] pub (crate) trait Remappable : core :: fmt :: Debug { # [doc = " Return the total number of states."] fn state_len (& self) -> usize ; # [doc = " Swap the states pointed to by the given IDs. The underlying finite"] # [doc = " state machine should be mutated such that all of the transitions in"] # [doc = " `id1` are now in the memory region where the transitions for `id2`"] # [doc = " were, and all of the transitions in `id2` are now in the memory region"] # [doc = " where the transitions for `id1` were."] # [doc = ""] # [doc = " Essentially, this \"moves\" `id1` to `id2` and `id2` to `id1`."] # [doc = ""] # [doc = " It is expected that, after calling this, the underlying state machine"] # [doc = " will be left in an inconsistent state, since any other transitions"] # [doc = " pointing to, e.g., `id1` need to be updated to point to `id2`, since"] # [doc = " that's where `id1` moved to."] # [doc = ""] # [doc = " In order to \"fix\" the underlying inconsistent state, a `Remapper`"] # [doc = " should be used to guarantee that `remap` is called at the appropriate"] # [doc = " time."] fn swap_states (& mut self , id1 : StateID , id2 : StateID) ; # [doc = " This must remap every single state ID in the underlying value according"] # [doc = " to the function given. For example, in a DFA, this should remap every"] # [doc = " transition and every starting state ID."] fn remap (& mut self , map : impl Fn (StateID) -> StateID) ; } # [doc = " Remapper is an abstraction the manages the remapping of state IDs in a"] # [doc = " finite state machine. This is useful when one wants to shuffle states into"] # [doc = " different positions in the machine."] # [doc = ""] # [doc = " One of the key complexities this manages is the ability to correctly move"] # [doc = " one state multiple times."] # [doc = ""] # [doc = " Once shuffling is complete, `remap` must be called, which will rewrite"] # [doc = " all pertinent transitions to updated state IDs. Neglecting to call `remap`"] # [doc = " will almost certainly result in a corrupt machine."] pub (crate) struct Remapper { # [doc = " A map from the index of a state to its pre-multiplied identifier."] # [doc = ""] # [doc = " When a state is swapped with another, then their corresponding"] # [doc = " locations in this map are also swapped. Thus, its new position will"] # [doc = " still point to its old pre-multiplied StateID."] # [doc = ""] # [doc = " While there is a bit more to it, this then allows us to rewrite the"] # [doc = " state IDs in a DFA's transition table in a single pass. This is done"] # [doc = " by iterating over every ID in this map, then iterating over each"] # [doc = " transition for the state at that ID and re-mapping the transition from"] # [doc = " `old_id` to `map[dfa.to_index(old_id)]`. That is, we find the position"] # [doc = " in this map where `old_id` *started*, and set it to where it ended up"] # [doc = " after all swaps have been completed."] map : Vec < StateID > , # [doc = " A way to map indices to state IDs (and back)."] idx : IndexMapper , } # [automatically_derived] impl :: core :: fmt :: Debug for Remapper { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Remapper" , "map" , & self . map , "idx" , & & self . idx ,) } } impl Remapper { # [doc = " Create a new remapper from the given remappable implementation. The"] # [doc = " remapper can then be used to swap states. The remappable value given"] # [doc = " here must the same one given to `swap` and `remap`."] # [doc = ""] # [doc = " The given stride should be the stride of the transition table expressed"] # [doc = " as a power of 2. This stride is used to map between state IDs and state"] # [doc = " indices. If state IDs and state indices are equivalent, then provide"] # [doc = " a `stride2` of `0`, which acts as an identity."] pub (crate) fn new (r : & impl Remappable , stride2 : usize) -> Remapper { let idx = IndexMapper { stride2 } ; let map = (0 .. r . state_len ()) . map (| i | idx . to_state_id (i)) . collect () ; Remapper { map , idx } } # [doc = " Swap two states. Once this is called, callers must follow through to"] # [doc = " call `remap`, or else it's possible for the underlying remappable"] # [doc = " value to be in a corrupt state."] pub (crate) fn swap (& mut self , r : & mut impl Remappable , id1 : StateID , id2 : StateID ,) { if id1 == id2 { return ; } r . swap_states (id1 , id2) ; self . map . swap (self . idx . to_index (id1) , self . idx . to_index (id2)) ; } # [doc = " Complete the remapping process by rewriting all state IDs in the"] # [doc = " remappable value according to the swaps performed."] pub (crate) fn remap (mut self , r : & mut impl Remappable) { let oldmap = self . map . clone () ; for i in 0 .. r . state_len () { let cur_id = self . idx . to_state_id (i) ; let mut new_id = oldmap [i] ; if cur_id == new_id { continue ; } loop { let id = oldmap [self . idx . to_index (new_id)] ; if cur_id == id { self . map [i] = new_id ; break ; } new_id = id ; } } r . remap (| sid | self . map [self . idx . to_index (sid)]) ; } } # [doc = " A simple type for mapping between state indices and state IDs."] # [doc = ""] # [doc = " The reason why this exists is because state IDs are \"premultiplied\" in a"] # [doc = " DFA. That is, in order to get to the transitions for a particular state,"] # [doc = " one need only use the state ID as-is, instead of having to multiply it by"] # [doc = " transition table's stride."] # [doc = ""] # [doc = " The downside of this is that it's inconvenient to map between state IDs"] # [doc = " using a dense map, e.g., Vec<StateID>. That's because state IDs look like"] # [doc = " `0`, `stride`, `2*stride`, `3*stride`, etc., instead of `0`, `1`, `2`, `3`,"] # [doc = " etc."] # [doc = ""] # [doc = " Since our state IDs are premultiplied, we can convert back-and-forth"] # [doc = " between IDs and indices by simply unmultiplying the IDs and multiplying the"] # [doc = " indices."] # [doc = ""] # [doc = " Note that for a sparse NFA, state IDs and indices are equivalent. In this"] # [doc = " case, we set the stride of the index mapped to be `0`, which acts as an"] # [doc = " identity."] struct IndexMapper { # [doc = " The power of 2 corresponding to the stride of the corresponding"] # [doc = " transition table. 'id >> stride2' de-multiplies an ID while 'index <<"] # [doc = " stride2' pre-multiplies an index to an ID."] stride2 : usize , } # [automatically_derived] impl :: core :: fmt :: Debug for IndexMapper { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "IndexMapper" , "stride2" , & & self . stride2 ,) } } impl IndexMapper { # [doc = " Convert a state ID to a state index."] fn to_index (& self , id : StateID) -> usize { id . as_usize () >> self . stride2 } # [doc = " Convert a state index to a state ID."] fn to_state_id (& self , index : usize) -> StateID { StateID :: new_unchecked (index << self . stride2) } } impl Remappable for noncontiguous :: NFA { fn state_len (& self) -> usize { noncontiguous :: NFA :: states (self) . len () } fn swap_states (& mut self , id1 : StateID , id2 : StateID) { noncontiguous :: NFA :: swap_states (self , id1 , id2) } fn remap (& mut self , map : impl Fn (StateID) -> StateID) { noncontiguous :: NFA :: remap (self , map) } } }