# [doc = " Return an iterator of transitions in a sparse format given an iterator"] # [doc = " of all explicitly defined transitions. The iterator yields ranges of"] # [doc = " transitions, such that any adjacent transitions mapped to the same"] # [doc = " state are combined into a single range."] pub (crate) fn sparse_transitions < 'a > (mut it : impl Iterator < Item = (u8 , StateID) > + 'a ,) -> impl Iterator < Item = (u8 , u8 , StateID) > + 'a { let mut cur : Option < (u8 , u8 , StateID) > = None ; core :: iter :: from_fn (move | | { while let Some ((class , next)) = it . next () { let (prev_start , prev_end , prev_next) = match cur { Some (x) => x , None => { cur = Some ((class , class , next)) ; continue ; } } ; if prev_next == next { cur = Some ((prev_start , class , prev_next)) ; } else { cur = Some ((class , class , next)) ; return Some ((prev_start , prev_end , prev_next)) ; } } if let Some ((start , end , next)) = cur . take () { return Some ((start , end , next)) ; } None }) }