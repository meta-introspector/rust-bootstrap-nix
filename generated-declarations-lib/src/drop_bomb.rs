pub mod drop_bomb { use crate :: prelude :: * ; use std :: ffi :: OsString ; use std :: ffi :: OsStr ; pub struct DropBomb { command : OsString , defused : bool , armed_location : panic :: Location < 'static > , } # [automatically_derived] impl :: core :: fmt :: Debug for DropBomb { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "DropBomb" , "command" , & self . command , "defused" , & self . defused , "armed_location" , & & self . armed_location ,) } } impl DropBomb { # [doc = " Arm a [`DropBomb`]. If the value is dropped without being [`defused`][Self::defused], then"] # [doc = " it will panic. It is expected that the command wrapper uses `#[track_caller]` to help"] # [doc = " propagate the caller location."] # [track_caller] pub fn arm < S : AsRef < OsStr > > (command : S) -> DropBomb { DropBomb { command : command . as_ref () . into () , defused : false , armed_location : * panic :: Location :: caller () , } } pub fn get_created_location (& self) -> panic :: Location < 'static > { self . armed_location } # [doc = " Defuse the [`DropBomb`]. This will prevent the drop bomb from panicking when dropped."] pub fn defuse (& mut self) { self . defused = true ; } } impl Drop for DropBomb { fn drop (& mut self) { if ! self . defused && ! std :: thread :: panicking () { { :: core :: panicking :: panic_fmt (format_args ! ("command constructed at `{0}` was dropped without being executed: `{1}`" , self . armed_location , self . command . to_string_lossy () ,) ,) ; } } } } }