pub mod command_handlers { use anyhow :: Context ; use std :: path :: PathBuf ; use syn :: { self , visit :: Visit } ; use crate :: { declaration_processing , constant_storage , BagOfWordsVisitor , config_parser , pipeline , type_extractor , error_collector :: ErrorCollection , } ; use std :: collections :: HashMap ; pub fn handle_analyze_ast (_args : & crate :: Args) -> anyhow :: Result < () > { let path = _args . ast_analysis_path . clone () . ok_or_else (| | :: anyhow :: __private :: must_use ({ let error = :: anyhow :: __private :: format_err (format_args ! ("ast_analysis_path is required when analyze_ast is true" ,) ,) ; error })) ? ; { :: std :: io :: _print (format_args ! ("Analyzing AST for project: {0}\n" , path . display ()) ,) ; } ; Ok (()) } pub fn handle_generate_test_report (_args : & crate :: Args) -> anyhow :: Result < () > { let _output_file = _args . test_report_output_file . clone () . unwrap_or_else (| | PathBuf :: from ("test_report.json")) ; Ok (()) } pub fn handle_compile_tests (_args : & crate :: Args) -> anyhow :: Result < () > { let _input_file = _args . test_report_input_file . clone () . ok_or_else (| | :: anyhow :: __private :: must_use ({ let error = :: anyhow :: __private :: format_err (format_args ! ("test_report_input_file is required when compile_tests is true" ,) ,) ; error })) ? ; let _output_dir = _args . test_verification_output_dir . clone () . ok_or_else (| | :: anyhow :: __private :: must_use ({ let error = :: anyhow :: __private :: format_err (format_args ! ("test_verification_output_dir is required when compile_tests is true" ,) ,) ; error })) ? ; Ok (()) } pub fn handle_extract_use_statements (_args : & crate :: Args) -> anyhow :: Result < () > { let output_dir = _args . use_statements_output_dir . clone () . ok_or_else (| | :: anyhow :: __private :: must_use ({ let error = :: anyhow :: __private :: format_err (format_args ! ("use_statements_output_dir is required when extract_use_statements is true" ,) ,) ; error })) ? ; { :: std :: io :: _print (format_args ! ("Extracting use statements to: {0}\n" , output_dir . display ()) ,) ; } ; Ok (()) } pub fn handle_collect_and_process_use_statements () { { :: std :: io :: _print (format_args ! ("Collecting and processing use statements...\n") ,) ; } ; } pub fn handle_generate_aggregated_test_file () { { :: std :: io :: _print (format_args ! ("Generating aggregated test file...\n")) ; } ; } pub async fn handle_run_pipeline (args : & crate :: Args , config : & config_parser :: Config ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Running main pipeline...\n")) ; } ; let mut stdout = tokio :: io :: stdout () ; let dummy_content = "fn main() { println!(\"Hello, world!\"); }" . to_string () ; let dummy_path = "dummy_file.rs" . to_string () ; pipeline :: run_category_pipeline (& mut stdout , & dummy_content , & dummy_path , & args , & Some (config . clone ()) ,) . await ? ; Ok (()) } pub fn handle_verify_config () { { :: std :: io :: _print (format_args ! ("Verifying configuration...\n")) ; } ; } use crate :: gem_parser :: GemConfig ; use cargo_metadata :: { MetadataCommand , Package } ; pub async fn handle_extract_global_level0_decls (project_root : & PathBuf , args : & crate :: Args , all_numerical_constants : & mut Vec < syn :: ItemConst > , all_string_constants : & mut Vec < syn :: ItemConst > , rustc_info : & crate :: use_extractor :: rustc_info :: RustcInfo , cache_dir : & std :: path :: Path ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Extracting global Level 0 declarations...\n") ,) ; } ; { :: std :: io :: _print (format_args ! ("Project root: {0}\n" , project_root . display ()) ,) ; } ; let generated_decls_output_dir = args . generated_decls_output_dir . clone () . unwrap_or_else (| | { project_root . join ("generated/level0_decls") }) ; { :: std :: io :: _print (format_args ! ("Generated decls output dir: {0}\n" , generated_decls_output_dir . display () ,) ,) ; } ; let gem_config_path = project_root . join ("gems.toml") ; let gem_config = GemConfig :: load_from_file (& gem_config_path) . context (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to load gem config from {0}" , gem_config_path . display () ,) ,) }) ,) ? ; let type_map = type_extractor :: extract_bag_of_types (project_root , & args . filter_names ,) . await ? ; let metadata = MetadataCommand :: new () . manifest_path (project_root . join ("Cargo.toml")) . exec () . context ("Failed to execute cargo metadata") ? ; let mut all_declarations : Vec < crate :: declaration :: Declaration > = Vec :: new () ; let mut total_files_processed = 0 ; let mut collected_errors = Vec :: new () ; let mut total_fns = 0 ; let mut total_structs = 0 ; let mut total_enums = 0 ; let mut total_statics = 0 ; let mut total_other_items = 0 ; let total_structs_per_layer : HashMap < usize , usize > = HashMap :: new () ; let mut packages_to_process : Vec < & Package > = Vec :: new () ; for member_id in & metadata . workspace_members { if let Some (pkg) = metadata . packages . iter () . find (| p | & p . id == member_id) { packages_to_process . push (pkg) ; } } for pkg in & metadata . packages { if pkg . manifest_path . starts_with (project_root) && ! metadata . workspace_members . contains (& pkg . id) { packages_to_process . push (pkg) ; } } for pkg in packages_to_process { let manifest_path = pkg . manifest_path . to_path_buf () ; { :: std :: io :: _print (format_args ! ("Processing crate: {0} at {1}\n" , pkg . name , manifest_path ,) ,) ; } ; let (decls , files_processed , fns , structs , enums , statics , other_items , _structs_per_layer , errors ,) = declaration_processing :: extract_all_declarations_from_crate (manifest_path . as_ref () , & args , & type_map , & args . filter_names , rustc_info , cache_dir , & gem_config ,) . await ? ; all_declarations . extend (decls) ; collected_errors . extend (errors) ; total_files_processed += files_processed ; total_fns += fns ; total_structs += structs ; total_enums += enums ; total_statics += statics ; total_other_items += other_items ; } let mut error_collection = ErrorCollection :: default () ; for err_sample in collected_errors { error_collection . add_error (err_sample) ; } let layered_declarations = declaration_processing :: layer_declarations (all_declarations ,) ; { :: std :: io :: _print (format_args ! ("\n--- Layered Declaration Analysis ---\n")) ; } ; for layer_num in 0 ..= 8 { if let Some (decls_in_layer) = layered_declarations . get (& layer_num) { { :: std :: io :: _print (format_args ! ("Layer {0}: {1} declarations\n" , layer_num , decls_in_layer . len () ,) ,) ; } ; } else if layer_num == 0 && layered_declarations . get (& 0) . is_none () { { :: std :: io :: _print (format_args ! ("Layer 0: No declarations found.\n")) ; } ; } else if layered_declarations . get (& layer_num) . is_none () && layer_num > 0 { { :: std :: io :: _print (format_args ! ("Layer {0}: No declarations found.\n" , layer_num) ,) ; } ; if layered_declarations . keys () . all (| & k | k < layer_num) { break ; } } } { :: std :: io :: _print (format_args ! ("-------------------------------------\n")) ; } ; let mut constants : Vec < syn :: ItemConst > = Vec :: new () ; let mut structs : HashMap < usize , Vec < syn :: ItemStruct > > = HashMap :: new () ; for (_layer_num , decls_in_layer) in layered_declarations . iter () { for decl in decls_in_layer { match & decl . item { crate :: declaration :: DeclarationItem :: Const (c) => { constants . push (c . clone ()) } crate :: declaration :: DeclarationItem :: Struct (s) => { let struct_name = s . ident . to_string () ; let layer = type_map . get (& struct_name) . and_then (| info | info . layer) . unwrap_or (0) ; structs . entry (layer) . or_insert_with (Vec :: new) . push (s . clone ()) ; } _ => { } } } } if let Err (e) = declaration_processing :: process_constants (constants . clone () , & args , & project_root , all_numerical_constants , all_string_constants , & type_map ,) . await { { :: std :: io :: _eprint (format_args ! ("Error processing constants: {0:?}\n" , e) ,) ; } ; } { :: std :: io :: _print (format_args ! ("Total files processed: {0}\n" , total_files_processed) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total constants extracted: {0}\n" , constants . len ()) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total functions found: {0}\n" , total_fns)) ; } ; { :: std :: io :: _print (format_args ! ("Total structs found: {0}\n" , total_structs)) ; } ; { :: std :: io :: _print (format_args ! ("Total structs extracted per layer: {0:?}\n" , total_structs_per_layer ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total enums found: {0}\n" , total_enums)) ; } ; { :: std :: io :: _print (format_args ! ("Total statics found: {0}\n" , total_statics)) ; } ; { :: std :: io :: _print (format_args ! ("Total other items found: {0}\n" , total_other_items) ,) ; } ; { :: std :: io :: _print (format_args ! ("---------------------------------------------\n") ,) ; } ; if ! error_collection . errors . is_empty () { { :: std :: io :: _eprint (format_args ! ("\\n--- Summary of Errors Encountered During Macro Expansion/Parsing ---\n" ,) ,) ; } ; for error in & error_collection . errors { { :: std :: io :: _eprint (format_args ! ("File: {0}, Type: {1}, Message: {2}\n" , error . file_path . display () , error . error_type , error . error_message ,) ,) ; } ; } { :: std :: io :: _eprint (format_args ! ("---------------------------------------------------------------------\n" ,) ,) ; } ; let error_output_path = project_root . join ("collected_errors.json") ; error_collection . write_to_file (& error_output_path) . await ? ; { :: std :: io :: _eprint (format_args ! ("Collected errors written to: {0}\n" , error_output_path . display () ,) ,) ; } ; } Ok (()) } pub async fn handle_extract_numerical_constants (_project_root : & PathBuf , _args : & crate :: Args , all_numerical_constants : & Vec < syn :: ItemConst > ,) -> anyhow :: Result < () > { let numerical_output_dir = _project_root . join (r"generated/numerical_constants") ; tokio :: fs :: create_dir_all (& numerical_output_dir) . await . context (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to create output directory {0:?}" , numerical_output_dir ,) ,) }) ,) ? ; constant_storage :: numerical_constants :: write_numerical_constants_to_hierarchical_structure (& all_numerical_constants , & numerical_output_dir ,) . await ? ; { :: std :: io :: _print (format_args ! ("  -> Numerical constants will be written to: {0:?}\n" , numerical_output_dir ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("  -> Total numerical constants extracted: {0}\n" , all_numerical_constants . len () ,) ,) ; } ; Ok (()) } pub async fn handle_extract_string_constants (_project_root : & PathBuf , _args : & crate :: Args , all_string_constants : & Vec < syn :: ItemConst > ,) -> anyhow :: Result < () > { let string_output_dir = _project_root . join (r"generated/string_constants") ; tokio :: fs :: create_dir_all (& string_output_dir) . await . context (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to create output directory {0:?}" , string_output_dir ,) ,) }) ,) ? ; constant_storage :: string_constants :: write_string_constants_to_hierarchical_structure (& all_string_constants , & string_output_dir ,) . await ? ; { :: std :: io :: _print (format_args ! ("  -> String constants will be written to: {0:?}\n" , string_output_dir ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("  -> Total string constants extracted: {0}\n" , all_string_constants . len () ,) ,) ; } ; Ok (()) } pub fn handle_analyze_bag_of_words (_project_root : & PathBuf , args : & crate :: Args ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Analyzing bag of words...\n")) ; } ; let project_root = if args . path == PathBuf :: from (".") { std :: env :: current_dir () ? . parent () . unwrap () . to_path_buf () } else { args . path . clone () } ; let mut bag_of_words_visitor = BagOfWordsVisitor :: new () ; let mut files_processed_for_bow = 0 ; for entry in walkdir :: WalkDir :: new (& project_root) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . file_type () . is_file () && e . path () . extension () . map_or (false , | ext | ext == r"rs") }) { let path = entry . path () ; if let Ok (content) = std :: fs :: read_to_string (& path) { if let Ok (file) = syn :: parse_file (& content) { bag_of_words_visitor . visit_file (& file) ; files_processed_for_bow += 1 ; } else { { :: std :: io :: _eprint (format_args ! ("Warning: Could not parse file for bag of words analysis: {0}\n" , path . display () ,) ,) ; } ; } } else { { :: std :: io :: _eprint (format_args ! ("Warning: Could not read file for bag of words analysis: {0}\n" , path . display () ,) ,) ; } ; } } { :: std :: io :: _print (format_args ! ("Processed {0} files for bag of words analysis.\n" , files_processed_for_bow ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("Top 20 most common terms:\n")) ; } ; let mut sorted_terms : Vec < (& String , & usize) > = bag_of_words_visitor . bag_of_words . iter () . collect () ; sorted_terms . sort_by (| a , b | b . 1 . cmp (a . 1)) ; for (term , count) in sorted_terms . iter () . take (20) { { :: std :: io :: _print (format_args ! ("  - {0}: {1}\n" , term , count)) ; } ; } Ok (()) } pub async fn handle_calculate_layers (project_root : & PathBuf , args : & crate :: Args ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Calculating type layers...\n")) ; } ; let type_map = type_extractor :: extract_bag_of_types (project_root , & args . filter_names ,) . await ? ; { :: std :: io :: _print (format_args ! ("\n--- Type Layer Analysis ---\n")) ; } ; { :: std :: io :: _print (format_args ! ("{0:<30} {1:<10} {2:<10}\n" , "Type" , "Count" , "Layer") ,) ; } ; { :: std :: io :: _print (format_args ! ("---------------------------------------------------\n") ,) ; } ; let mut sorted_types : Vec < (& String , & type_extractor :: TypeInfo) > = type_map . iter () . collect () ; sorted_types . sort_by (| a , b | b . 1 . count . cmp (& a . 1 . count)) ; for (type_name , info) in sorted_types . iter () { { :: std :: io :: _print (format_args ! ("{0:<30} {1:<10} {2:<10?}\n" , type_name , info . count , info . layer ,) ,) ; } ; } { :: std :: io :: _print (format_args ! ("---------------------------------------------------\n") ,) ; } ; Ok (()) } }