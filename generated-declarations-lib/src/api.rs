mod api { use alloc :: sync :: Arc ; use crate :: { packed :: { pattern :: Patterns , rabinkarp :: RabinKarp , teddy } , util :: search :: { Match , Span } , } ; # [doc = " This is a limit placed on the total number of patterns we're willing to try"] # [doc = " and match at once. As more sophisticated algorithms are added, this number"] # [doc = " may be increased."] const PATTERN_LIMIT : usize = 128 ; # [doc = " A knob for controlling the match semantics of a packed multiple string"] # [doc = " searcher."] # [doc = ""] # [doc = " This differs from the [`MatchKind`](crate::MatchKind) type in the top-level"] # [doc = " crate module in that it doesn't support \"standard\" match semantics,"] # [doc = " and instead only supports leftmost-first or leftmost-longest. Namely,"] # [doc = " \"standard\" semantics cannot be easily supported by packed searchers."] # [doc = ""] # [doc = " For more information on the distinction between leftmost-first and"] # [doc = " leftmost-longest, see the docs on the top-level `MatchKind` type."] # [doc = ""] # [doc = " Unlike the top-level `MatchKind` type, the default match semantics for this"] # [doc = " type are leftmost-first."] # [non_exhaustive] pub enum MatchKind { # [doc = " Use leftmost-first match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the match"] # [doc = " corresponding to the pattern that appeared earlier when constructing"] # [doc = " the automaton is reported."] # [doc = ""] # [doc = " This is the default."] LeftmostFirst , # [doc = " Use leftmost-longest match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the longest match"] # [doc = " is chosen."] LeftmostLongest , } # [automatically_derived] impl :: core :: clone :: Clone for MatchKind { # [inline] fn clone (& self) -> MatchKind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for MatchKind { } # [automatically_derived] impl :: core :: fmt :: Debug for MatchKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { MatchKind :: LeftmostFirst => "LeftmostFirst" , MatchKind :: LeftmostLongest => "LeftmostLongest" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for MatchKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for MatchKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for MatchKind { # [inline] fn eq (& self , other : & MatchKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl Default for MatchKind { fn default () -> MatchKind { MatchKind :: LeftmostFirst } } # [doc = " The configuration for a packed multiple pattern searcher."] # [doc = ""] # [doc = " The configuration is currently limited only to being able to select the"] # [doc = " match semantics (leftmost-first or leftmost-longest) of a searcher. In the"] # [doc = " future, more knobs may be made available."] # [doc = ""] # [doc = " A configuration produces a [`packed::Builder`](Builder), which in turn can"] # [doc = " be used to construct a [`packed::Searcher`](Searcher) for searching."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to use leftmost-longest semantics instead of the"] # [doc = " default (leftmost-first)."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{Config, MatchKind}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Config::new()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .builder()"] # [doc = "     .add(\"foo\")"] # [doc = "     .add(\"foobar\")"] # [doc = "     .build()?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::must(1)], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Config { kind : MatchKind , force : Option < ForceAlgorithm > , only_teddy_fat : Option < bool > , only_teddy_256bit : Option < bool > , heuristic_pattern_limits : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Config { # [inline] fn clone (& self) -> Config { Config { kind : :: core :: clone :: Clone :: clone (& self . kind) , force : :: core :: clone :: Clone :: clone (& self . force) , only_teddy_fat : :: core :: clone :: Clone :: clone (& self . only_teddy_fat) , only_teddy_256bit : :: core :: clone :: Clone :: clone (& self . only_teddy_256bit ,) , heuristic_pattern_limits : :: core :: clone :: Clone :: clone (& self . heuristic_pattern_limits ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Config { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field5_finish (f , "Config" , "kind" , & self . kind , "force" , & self . force , "only_teddy_fat" , & self . only_teddy_fat , "only_teddy_256bit" , & self . only_teddy_256bit , "heuristic_pattern_limits" , & & self . heuristic_pattern_limits ,) } } # [doc = " An internal option for forcing the use of a particular packed algorithm."] # [doc = ""] # [doc = " When an algorithm is forced, if a searcher could not be constructed for it,"] # [doc = " then no searcher will be returned even if an alternative algorithm would"] # [doc = " work."] enum ForceAlgorithm { Teddy , RabinKarp , } # [automatically_derived] impl :: core :: clone :: Clone for ForceAlgorithm { # [inline] fn clone (& self) -> ForceAlgorithm { match self { ForceAlgorithm :: Teddy => ForceAlgorithm :: Teddy , ForceAlgorithm :: RabinKarp => ForceAlgorithm :: RabinKarp , } } } # [automatically_derived] impl :: core :: fmt :: Debug for ForceAlgorithm { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { ForceAlgorithm :: Teddy => "Teddy" , ForceAlgorithm :: RabinKarp => "RabinKarp" , } ,) } } impl Default for Config { fn default () -> Config { Config :: new () } } impl Config { # [doc = " Create a new default configuration. A default configuration uses"] # [doc = " leftmost-first match semantics."] pub fn new () -> Config { Config { kind : MatchKind :: LeftmostFirst , force : None , only_teddy_fat : None , only_teddy_256bit : None , heuristic_pattern_limits : true , } } # [doc = " Create a packed builder from this configuration. The builder can be"] # [doc = " used to accumulate patterns and create a [`Searcher`] from them."] pub fn builder (& self) -> Builder { Builder :: from_config (self . clone ()) } # [doc = " Set the match semantics for this configuration."] pub fn match_kind (& mut self , kind : MatchKind) -> & mut Config { self . kind = kind ; self } # [doc = " An undocumented method for forcing the use of the Teddy algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy (& mut self , yes : bool) -> & mut Config { if yes { self . force = Some (ForceAlgorithm :: Teddy) ; } else { self . force = None ; } self } # [doc = " An undocumented method for forcing the use of the Fat Teddy algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy_fat (& mut self , yes : Option < bool >) -> & mut Config { self . only_teddy_fat = yes ; self } # [doc = " An undocumented method for forcing the use of SSE (`Some(false)`) or"] # [doc = " AVX (`Some(true)`) algorithms."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_teddy_256bit (& mut self , yes : Option < bool >) -> & mut Config { self . only_teddy_256bit = yes ; self } # [doc = " An undocumented method for forcing the use of the Rabin-Karp algorithm."] # [doc = ""] # [doc = " This is only exposed for more precise testing and benchmarks. Callers"] # [doc = " should not use it as it is not part of the API stability guarantees of"] # [doc = " this crate."] # [doc (hidden)] pub fn only_rabin_karp (& mut self , yes : bool) -> & mut Config { if yes { self . force = Some (ForceAlgorithm :: RabinKarp) ; } else { self . force = None ; } self } # [doc = " Request that heuristic limitations on the number of patterns be"] # [doc = " employed. This useful to disable for benchmarking where one wants to"] # [doc = " explore how Teddy performs on large number of patterns even if the"] # [doc = " heuristics would otherwise refuse construction."] # [doc = ""] # [doc = " This is enabled by default."] pub fn heuristic_pattern_limits (& mut self , yes : bool) -> & mut Config { self . heuristic_pattern_limits = yes ; self } } # [doc = " A builder for constructing a packed searcher from a collection of patterns."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to use a builder to construct a searcher. By"] # [doc = " default, leftmost-first match semantics are used."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{Builder, MatchKind}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Builder::new()"] # [doc = "     .add(\"foobar\")"] # [doc = "     .add(\"foo\")"] # [doc = "     .build()?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Builder { # [doc = " The configuration of this builder and subsequent matcher."] config : Config , # [doc = " Set to true if the builder detects that a matcher cannot be built."] inert : bool , # [doc = " The patterns provided by the caller."] patterns : Patterns , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { config : :: core :: clone :: Clone :: clone (& self . config) , inert : :: core :: clone :: Clone :: clone (& self . inert) , patterns : :: core :: clone :: Clone :: clone (& self . patterns) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "config" , & self . config , "inert" , & self . inert , "patterns" , & & self . patterns ,) } } impl Builder { # [doc = " Create a new builder for constructing a multi-pattern searcher. This"] # [doc = " constructor uses the default configuration."] pub fn new () -> Builder { Builder :: from_config (Config :: new ()) } fn from_config (config : Config) -> Builder { Builder { config , inert : false , patterns : Patterns :: new () , } } # [doc = " Build a searcher from the patterns added to this builder so far."] pub fn build (& self) -> Option < Searcher > { if self . inert || self . patterns . is_empty () { return None ; } let mut patterns = self . patterns . clone () ; patterns . set_match_kind (self . config . kind) ; let patterns = Arc :: new (patterns) ; let rabinkarp = RabinKarp :: new (& patterns) ; let (search_kind , minimum_len) = match self . config . force { None | Some (ForceAlgorithm :: Teddy) => { let teddy = match self . build_teddy (Arc :: clone (& patterns)) { None => return None , Some (teddy) => teddy , } ; let minimum_len = teddy . minimum_len () ; (SearchKind :: Teddy (teddy) , minimum_len) } Some (ForceAlgorithm :: RabinKarp) => { (SearchKind :: RabinKarp , 0) } } ; Some (Searcher { patterns , rabinkarp , search_kind , minimum_len , }) } fn build_teddy (& self , patterns : Arc < Patterns >) -> Option < teddy :: Searcher > { teddy :: Builder :: new () . only_256bit (self . config . only_teddy_256bit) . only_fat (self . config . only_teddy_fat) . heuristic_pattern_limits (self . config . heuristic_pattern_limits) . build (patterns) } # [doc = " Add the given pattern to this set to match."] # [doc = ""] # [doc = " The order in which patterns are added is significant. Namely, when"] # [doc = " using leftmost-first match semantics, then when multiple patterns can"] # [doc = " match at a particular location, the pattern that was added first is"] # [doc = " used as the match."] # [doc = ""] # [doc = " If the number of patterns added exceeds the amount supported by packed"] # [doc = " searchers, then the builder will stop accumulating patterns and render"] # [doc = " itself inert. At this point, constructing a searcher will always return"] # [doc = " `None`."] pub fn add < P : AsRef < [u8] > > (& mut self , pattern : P) -> & mut Builder { if self . inert { return self ; } else if self . patterns . len () >= PATTERN_LIMIT { self . inert = true ; self . patterns . reset () ; return self ; } if ! (self . patterns . len () <= core :: u16 :: MAX as usize) { :: core :: panicking :: panic ("assertion failed: self.patterns.len() <= core::u16::MAX as usize" ,) } let pattern = pattern . as_ref () ; if pattern . is_empty () { self . inert = true ; self . patterns . reset () ; return self ; } self . patterns . add (pattern) ; self } # [doc = " Add the given iterator of patterns to this set to match."] # [doc = ""] # [doc = " The iterator must yield elements that can be converted into a `&[u8]`."] # [doc = ""] # [doc = " The order in which patterns are added is significant. Namely, when"] # [doc = " using leftmost-first match semantics, then when multiple patterns can"] # [doc = " match at a particular location, the pattern that was added first is"] # [doc = " used as the match."] # [doc = ""] # [doc = " If the number of patterns added exceeds the amount supported by packed"] # [doc = " searchers, then the builder will stop accumulating patterns and render"] # [doc = " itself inert. At this point, constructing a searcher will always return"] # [doc = " `None`."] pub fn extend < I , P > (& mut self , patterns : I) -> & mut Builder where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { for p in patterns { self . add (p) ; } self } # [doc = " Returns the number of patterns added to this builder."] pub fn len (& self) -> usize { self . patterns . len () } # [doc = " Returns the length, in bytes, of the shortest pattern added."] pub fn minimum_len (& self) -> usize { self . patterns . minimum_len () } } impl Default for Builder { fn default () -> Builder { Builder :: new () } } # [doc = " A packed searcher for quickly finding occurrences of multiple patterns."] # [doc = ""] # [doc = " If callers need more flexible construction, or if one wants to change the"] # [doc = " match semantics (either leftmost-first or leftmost-longest), then one can"] # [doc = " use the [`Config`] and/or [`Builder`] types for more fine grained control."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to create a searcher from an iterator of patterns."] # [doc = " By default, leftmost-first match semantics are used."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub struct Searcher { patterns : Arc < Patterns > , rabinkarp : RabinKarp , search_kind : SearchKind , minimum_len : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Searcher { # [inline] fn clone (& self) -> Searcher { Searcher { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , rabinkarp : :: core :: clone :: Clone :: clone (& self . rabinkarp) , search_kind : :: core :: clone :: Clone :: clone (& self . search_kind) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Searcher { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "Searcher" , "patterns" , & self . patterns , "rabinkarp" , & self . rabinkarp , "search_kind" , & self . search_kind , "minimum_len" , & & self . minimum_len ,) } } enum SearchKind { Teddy (teddy :: Searcher) , RabinKarp , } # [automatically_derived] impl :: core :: clone :: Clone for SearchKind { # [inline] fn clone (& self) -> SearchKind { match self { SearchKind :: Teddy (__self_0) => { SearchKind :: Teddy (:: core :: clone :: Clone :: clone (__self_0)) } SearchKind :: RabinKarp => SearchKind :: RabinKarp , } } } # [automatically_derived] impl :: core :: fmt :: Debug for SearchKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { SearchKind :: Teddy (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Teddy" , & __self_0 ,) } SearchKind :: RabinKarp => { :: core :: fmt :: Formatter :: write_str (f , "RabinKarp") } } } } impl Searcher { # [doc = " A convenience function for constructing a searcher from an iterator"] # [doc = " of things that can be converted to a `&[u8]`."] # [doc = ""] # [doc = " If a searcher could not be constructed (either because of an"] # [doc = " unsupported CPU or because there are too many patterns), then `None`"] # [doc = " is returned."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec![PatternID::ZERO], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] pub fn new < I , P > (patterns : I) -> Option < Searcher > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { Builder :: new () . extend (patterns) . build () } # [doc = " A convenience function for calling `Config::new()`."] # [doc = ""] # [doc = " This is useful for avoiding an additional import."] pub fn config () -> Config { Config :: new () } # [doc = " A convenience function for calling `Builder::new()`."] # [doc = ""] # [doc = " This is useful for avoiding an additional import."] pub fn builder () -> Builder { Builder :: new () } # [doc = " Return the first occurrence of any of the patterns in this searcher,"] # [doc = " according to its match semantics, in the given haystack. The `Match`"] # [doc = " returned will include the identifier of the pattern that matched, which"] # [doc = " corresponds to the index of the pattern (starting from `0`) in which it"] # [doc = " was added."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let mat = searcher.find(\"foobar\")?;"] # [doc = " assert_eq!(PatternID::ZERO, mat.pattern());"] # [doc = " assert_eq!(0, mat.start());"] # [doc = " assert_eq!(6, mat.end());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find < B : AsRef < [u8] > > (& self , haystack : B) -> Option < Match > { let haystack = haystack . as_ref () ; self . find_in (haystack , Span :: from (0 .. haystack . len ())) } # [doc = " Return the first occurrence of any of the patterns in this searcher,"] # [doc = " according to its match semantics, in the given haystack starting from"] # [doc = " the given position."] # [doc = ""] # [doc = " The `Match` returned will include the identifier of the pattern that"] # [doc = " matched, which corresponds to the index of the pattern (starting from"] # [doc = " `0`) in which it was added. The offsets in the `Match` will be relative"] # [doc = " to the start of `haystack` (and not `at`)."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID, Span};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let haystack = \"foofoobar\";"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let mat = searcher.find_in(haystack, Span::from(3..haystack.len()))?;"] # [doc = " assert_eq!(PatternID::ZERO, mat.pattern());"] # [doc = " assert_eq!(3, mat.start());"] # [doc = " assert_eq!(9, mat.end());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find_in < B : AsRef < [u8] > > (& self , haystack : B , span : Span ,) -> Option < Match > { let haystack = haystack . as_ref () ; match self . search_kind { SearchKind :: Teddy (ref teddy) => { if haystack [span] . len () < teddy . minimum_len () { return self . find_in_slow (haystack , span) ; } teddy . find (& haystack [.. span . end] , span . start) } SearchKind :: RabinKarp => { self . rabinkarp . find_at (& haystack [.. span . end] , span . start) } } } # [doc = " Return an iterator of non-overlapping occurrences of the patterns in"] # [doc = " this searcher, according to its match semantics, in the given haystack."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{packed::{MatchKind, Searcher}, PatternID};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " let matches: Vec<PatternID> = searcher"] # [doc = "     .find_iter(\"foobar fooba foofoo\")"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(1),"] # [doc = "     PatternID::must(1),"] # [doc = "     PatternID::must(1),"] # [doc = " ], matches);"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn find_iter < 'a , 'b , B : ? Sized + AsRef < [u8] > > (& 'a self , haystack : & 'b B ,) -> FindIter < 'a , 'b > { let haystack = haystack . as_ref () ; let span = Span :: from (0 .. haystack . len ()) ; FindIter { searcher : self , haystack , span , } } # [doc = " Returns the match kind used by this packed searcher."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::packed::{MatchKind, Searcher};"] # [doc = ""] # [doc = " # fn example() -> Option<()> {"] # [doc = " let searcher = Searcher::new([\"foobar\", \"foo\"].iter().cloned())?;"] # [doc = " // leftmost-first is the default."] # [doc = " assert_eq!(&MatchKind::LeftmostFirst, searcher.match_kind());"] # [doc = " # Some(()) }"] # [doc = " # if cfg!(all(feature = \"std\", any("] # [doc = " #     target_arch = \"x86_64\", target_arch = \"aarch64\","] # [doc = " # ))) {"] # [doc = " #     example().unwrap()"] # [doc = " # } else {"] # [doc = " #     assert!(example().is_none());"] # [doc = " # }"] # [doc = " ```"] # [inline] pub fn match_kind (& self) -> & MatchKind { self . patterns . match_kind () } # [doc = " Returns the minimum length of a haystack that is required in order for"] # [doc = " packed searching to be effective."] # [doc = ""] # [doc = " In some cases, the underlying packed searcher may not be able to search"] # [doc = " very short haystacks. When that occurs, the implementation will defer"] # [doc = " to a slower non-packed searcher (which is still generally faster than"] # [doc = " Aho-Corasick for a small number of patterns). However, callers may"] # [doc = " want to avoid ever using the slower variant, which one can do by"] # [doc = " never passing a haystack shorter than the minimum length returned by"] # [doc = " this method."] # [inline] pub fn minimum_len (& self) -> usize { self . minimum_len } # [doc = " Returns the approximate total amount of heap used by this searcher, in"] # [doc = " units of bytes."] # [inline] pub fn memory_usage (& self) -> usize { self . patterns . memory_usage () + self . rabinkarp . memory_usage () + self . search_kind . memory_usage () } # [doc = " Use a slow (non-packed) searcher."] # [doc = ""] # [doc = " This is useful when a packed searcher could be constructed, but could"] # [doc = " not be used to search a specific haystack. For example, if Teddy was"] # [doc = " built but the haystack is smaller than ~34 bytes, then Teddy might not"] # [doc = " be able to run."] fn find_in_slow (& self , haystack : & [u8] , span : Span) -> Option < Match > { self . rabinkarp . find_at (& haystack [.. span . end] , span . start) } } impl SearchKind { fn memory_usage (& self) -> usize { match * self { SearchKind :: Teddy (ref ted) => ted . memory_usage () , SearchKind :: RabinKarp => 0 , } } } # [doc = " An iterator over non-overlapping matches from a packed searcher."] # [doc = ""] # [doc = " The lifetime `'s` refers to the lifetime of the underlying [`Searcher`],"] # [doc = " while the lifetime `'h` refers to the lifetime of the haystack being"] # [doc = " searched."] pub struct FindIter < 's , 'h > { searcher : & 's Searcher , haystack : & 'h [u8] , span : Span , } # [automatically_derived] impl < 's , 'h > :: core :: fmt :: Debug for FindIter < 's , 'h > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "FindIter" , "searcher" , & self . searcher , "haystack" , & self . haystack , "span" , & & self . span ,) } } impl < 's , 'h > Iterator for FindIter < 's , 'h > { type Item = Match ; fn next (& mut self) -> Option < Match > { if self . span . start > self . span . end { return None ; } match self . searcher . find_in (self . haystack , self . span) { None => None , Some (m) => { self . span . start = m . end () ; Some (m) } } } } }