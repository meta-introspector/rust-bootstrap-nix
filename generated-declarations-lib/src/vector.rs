mod vector { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; # [doc = " A trait for describing vector operations used by vectorized searchers."] # [doc = ""] # [doc = " The trait is highly constrained to low level vector operations needed for"] # [doc = " the specific algorithms used in this crate. In general, it was invented"] # [doc = " mostly to be generic over x86's __m128i and __m256i types. At time of"] # [doc = " writing, it also supports wasm and aarch64 128-bit vector types as well."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " All methods are not safe since they are intended to be implemented using"] # [doc = " vendor intrinsics, which are also not safe. Callers must ensure that"] # [doc = " the appropriate target features are enabled in the calling function,"] # [doc = " and that the current CPU supports them. All implementations should"] # [doc = " avoid marking the routines with `#[target_feature]` and instead mark"] # [doc = " them as `#[inline(always)]` to ensure they get appropriately inlined."] # [doc = " (`inline(always)` cannot be used with target_feature.)"] pub (crate) trait Vector : Copy + Debug + Send + Sync + UnwindSafe + RefUnwindSafe { # [doc = " The number of bits in the vector."] const BITS : usize ; # [doc = " The number of bytes in the vector. That is, this is the size of the"] # [doc = " vector in memory."] const BYTES : usize ; # [doc = " Create a vector with 8-bit lanes with the given byte repeated into each"] # [doc = " lane."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn splat (byte : u8) -> Self ; # [doc = " Read a vector-size number of bytes from the given pointer. The pointer"] # [doc = " does not need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `BYTES` bytes are readable from"] # [doc = " `data`."] unsafe fn load_unaligned (data : * const u8) -> Self ; # [doc = " Returns true if and only if this vector has zero in all of its lanes."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn is_zero (self) -> bool ; # [doc = " Do an 8-bit pairwise equality check. If lane `i` is equal in this"] # [doc = " vector and the one given, then lane `i` in the resulting vector is set"] # [doc = " to `0xFF`. Otherwise, it is set to `0x00`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn cmpeq (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'and' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn and (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'or' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [allow (dead_code)] unsafe fn or (self , vector2 : Self) -> Self ; # [doc = " Shift each 8-bit lane in this vector to the right by the number of"] # [doc = " bits indictated by the `BITS` type parameter."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self ; # [doc = " Shift this vector to the left by one byte and shift the most"] # [doc = " significant byte of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 1` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 1`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by two bytes and shift the two most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 2` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 2`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by three bytes and shift the three most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 3` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last three bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 3`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Shuffles the bytes in this vector according to the indices in each of"] # [doc = " the corresponding lanes in `indices`."] # [doc = ""] # [doc = " If `i` is the index of corresponding lanes, `A` is this vector, `B` is"] # [doc = " indices and `C` is the resulting vector, then `C = A[B[i]]`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shuffle_bytes (self , indices : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in this vector. The"] # [doc = " given function is provided the lane index and lane value as a `u64`."] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Notes"] # [doc = ""] # [doc = " Conceptually it would be nice if we could have a"] # [doc = " `unpack64(self) -> [u64; BITS / 64]` method, but defining that is"] # [doc = " tricky given Rust's [current support for const generics][support]."] # [doc = " And even if we could, it would be tricky to write generic code over"] # [doc = " it. (Not impossible. We could introduce another layer that requires"] # [doc = " `AsRef<[u64]>` or something.)"] # [doc = ""] # [doc = " [support]: https://github.com/rust-lang/rust/issues/60551"] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_64bit_lane < T > (self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; } # [doc = " This trait extends the `Vector` trait with additional operations to support"] # [doc = " Fat Teddy."] # [doc = ""] # [doc = " Fat Teddy uses 16 buckets instead of 8, but reads half as many bytes (as"] # [doc = " the vector size) instead of the full size of a vector per iteration. For"] # [doc = " example, when using a 256-bit vector, Slim Teddy reads 32 bytes at a timr"] # [doc = " but Fat Teddy reads 16 bytes at a time."] # [doc = ""] # [doc = " Fat Teddy is useful when searching for a large number of literals."] # [doc = " The extra number of buckets spreads the literals out more and reduces"] # [doc = " verification time."] # [doc = ""] # [doc = " Currently we only implement this for AVX on x86_64. It would be nice to"] # [doc = " implement this for SSE on x86_64 and NEON on aarch64, with the latter two"] # [doc = " only reading 8 bytes at a time. It's not clear how well it would work, but"] # [doc = " there are some tricky things to figure out in terms of implementation. The"] # [doc = " `half_shift_in_{one,two,three}_bytes` methods in particular are probably"] # [doc = " the trickiest of the bunch. For AVX2, these are implemented by taking"] # [doc = " advantage of the fact that `_mm256_alignr_epi8` operates on each 128-bit"] # [doc = " half instead of the full 256-bit vector. (Where as `_mm_alignr_epi8`"] # [doc = " operates on the full 128-bit vector and not on each 64-bit half.) I didn't"] # [doc = " do a careful survey of NEON to see if it could easily support these"] # [doc = " operations."] pub (crate) trait FatVector : Vector { type Half : Vector ; # [doc = " Read a half-vector-size number of bytes from the given pointer, and"] # [doc = " broadcast it across both halfs of a full vector. The pointer does not"] # [doc = " need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `Self::HALF::BYTES` bytes are"] # [doc = " readable from `data`."] unsafe fn load_half_unaligned (data : * const u8) -> Self ; # [doc = " Like `Vector::shift_in_one_byte`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Swap the 128-bit lanes in this vector."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn swap_halves (self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the low 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_low_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the high 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_high_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in the lower half"] # [doc = " of this vector and then in the other vector. The given function is"] # [doc = " provided the lane index and lane value as a `u64`. (The high 128-bits"] # [doc = " of each vector are ignored.)"] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_low_64bit_lane < T > (self , vector2 : Self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; } mod aarch64_neon { use core :: arch :: aarch64 :: * ; use super :: Vector ; impl Vector for uint8x16_t { const BITS : usize = 128 ; const BYTES : usize = 16 ; # [inline (always)] unsafe fn splat (byte : u8) -> uint8x16_t { vdupq_n_u8 (byte) } # [inline (always)] unsafe fn load_unaligned (data : * const u8) -> uint8x16_t { vld1q_u8 (data) } # [inline (always)] unsafe fn is_zero (self) -> bool { let maxes = vreinterpretq_u64_u8 (vpmaxq_u8 (self , self)) ; vgetq_lane_u64 (maxes , 0) == 0 } # [inline (always)] unsafe fn cmpeq (self , vector2 : Self) -> uint8x16_t { vceqq_u8 (self , vector2) } # [inline (always)] unsafe fn and (self , vector2 : Self) -> uint8x16_t { vandq_u8 (self , vector2) } # [inline (always)] unsafe fn or (self , vector2 : Self) -> uint8x16_t { vorrq_u8 (self , vector2) } # [inline (always)] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self { if true { if ! (BITS <= 7) { :: core :: panicking :: panic ("assertion failed: BITS <= 7") } } vshrq_n_u8 (self , BITS) } # [inline (always)] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 15) } # [inline (always)] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 14) } # [inline (always)] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self { vextq_u8 (vector2 , self , 13) } # [inline (always)] unsafe fn shuffle_bytes (self , indices : Self) -> Self { vqtbl1q_u8 (self , indices) } # [inline (always)] unsafe fn for_each_64bit_lane < T > (self , mut f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > { let this = vreinterpretq_u64_u8 (self) ; let lane = vgetq_lane_u64 (this , 0) ; if let Some (t) = f (0 , lane) { return Some (t) ; } let lane = vgetq_lane_u64 (this , 1) ; if let Some (t) = f (1 , lane) { return Some (t) ; } None } } } }