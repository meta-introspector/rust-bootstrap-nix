pub fn handle_analyze_bag_of_words (_project_root : & PathBuf , args : & crate :: Args ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Analyzing bag of words...\n")) ; } ; let project_root = if args . path == PathBuf :: from (".") { std :: env :: current_dir () ? . parent () . unwrap () . to_path_buf () } else { args . path . clone () } ; let mut bag_of_words_visitor = BagOfWordsVisitor :: new () ; let mut files_processed_for_bow = 0 ; for entry in walkdir :: WalkDir :: new (& project_root) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . file_type () . is_file () && e . path () . extension () . map_or (false , | ext | ext == r"rs") }) { let path = entry . path () ; if let Ok (content) = std :: fs :: read_to_string (& path) { if let Ok (file) = syn :: parse_file (& content) { bag_of_words_visitor . visit_file (& file) ; files_processed_for_bow += 1 ; } else { { :: std :: io :: _eprint (format_args ! ("Warning: Could not parse file for bag of words analysis: {0}\n" , path . display () ,) ,) ; } ; } } else { { :: std :: io :: _eprint (format_args ! ("Warning: Could not read file for bag of words analysis: {0}\n" , path . display () ,) ,) ; } ; } } { :: std :: io :: _print (format_args ! ("Processed {0} files for bag of words analysis.\n" , files_processed_for_bow ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("Top 20 most common terms:\n")) ; } ; let mut sorted_terms : Vec < (& String , & usize) > = bag_of_words_visitor . bag_of_words . iter () . collect () ; sorted_terms . sort_by (| a , b | b . 1 . cmp (a . 1)) ; for (term , count) in sorted_terms . iter () . take (20) { { :: std :: io :: _print (format_args ! ("  - {0}: {1}\n" , term , count)) ; } ; } Ok (()) }