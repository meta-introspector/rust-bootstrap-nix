use anyhow::{Context, Result};
use clap::Parser;
use std::path::{ PathBuf};
use tokio::fs;
use tokio::process::Command;
use walkdir::WalkDir;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Path to the project root to search for Cargo.toml files.
    #[arg(long, default_value = ".")]
    project_root: PathBuf,
    /// Path to the rustc wrapper script.
    #[arg(long)]
    rustc_wrapper_path: PathBuf,
    /// Output directory for generated flakes.
    #[arg(long, default_value = "generated_flakes")]
    output_dir: PathBuf,
}

#[tokio::main]
async fn main() -> Result<()> {
    let args = Args::parse();

    let project_root = args.project_root.canonicalize()?;
    let rustc_wrapper_path = args.rustc_wrapper_path.canonicalize()?;
    let generated_flakes_output_root = args.output_dir;

    println!("Searching for Cargo.toml files in: {}", project_root.display());

    for entry in WalkDir::new(&project_root)
        .into_iter()
        .filter_map(|e| e.ok())
    {
        if entry.file_name() == "Cargo.toml" {
            let cargo_toml_path = entry.path();
            let crate_dir = cargo_toml_path.parent().context("Cargo.toml has no parent directory")?;
            let crate_name = crate_dir
                .file_name()
                .context("Crate directory has no name")?
                .to_string_lossy()
                .to_string();

            println!("\nFound Cargo.toml for crate: {} at {}", crate_name, cargo_toml_path.display());

            let flake_output_dir = generated_flakes_output_root.join(&crate_name);
            fs::create_dir_all(&flake_output_dir).await?;

            // Copy Cargo.toml and Cargo.lock to the flake output directory
            fs::copy(cargo_toml_path, flake_output_dir.join("Cargo.toml")).await?;
            let cargo_lock_path = crate_dir.join("Cargo.lock");
            if cargo_lock_path.exists() {
                fs::copy(&cargo_lock_path, flake_output_dir.join("Cargo.lock")).await?;
            }

            // Generate flake.nix content
            let nixpkgs_url = "github:NixOS/nixpkgs/nixos-23.11"; // Hardcoded for now
            let system_arch = "aarch64-linux"; // Hardcoded for now
            let flake_nix_content = flake_template_generator::generate_flake_nix_content(
                nixpkgs_url,
                system_arch,
                true, // use_rustc_wrapper
                //&rustc_wrapper_path,
            );
            fs::write(flake_output_dir.join("flake.nix"), flake_nix_content).await?;

            // For now, copy the template Cargo.nix. In a real scenario, this would be generated by cargo2nix for the specific crate.
            fs::copy(
                project_root.join("standalonex/src/Cargo.nix"), // Assuming this is the template
                flake_output_dir.join("Cargo.nix"),
            ).await?;


            println!("Generated flake for {} in {}", crate_name, flake_output_dir.display());

            // Run nix build --dry-run
            println!("Running nix build --dry-run for {}...", crate_name);
            let output = Command::new("nix")
                .arg("build")
                .arg("--experimental-features")
                .arg("nix-command flakes")
                .arg("--dry-run")
                .arg("--no-link")
                .arg(format!("{}#default", flake_output_dir.display()))
                .output()
                .await?;

            println!("nix build --dry-run status for {}: {}", crate_name, output.status);
            println!("nix build --dry-run stdout for {}:\n{}", crate_name, String::from_utf8_lossy(&output.stdout));
            eprintln!("nix build --dry-run stderr for {}:\n{}", crate_name, String::from_utf8_lossy(&output.stderr));

            if !output.status.success() {
                eprintln!("Error: nix build --dry-run failed for crate {}", crate_name);
            } else {
                // In a dry-run, rustc_calls.log won't be generated in the Nix store.
                // We would need to run a full build to get that.
                // For now, we're just inspecting the dry-run output.
                println!("Successfully ran nix build --dry-run for {}. Check stderr for build plan.", crate_name);
            }
        }
    }

    Ok(())
}
