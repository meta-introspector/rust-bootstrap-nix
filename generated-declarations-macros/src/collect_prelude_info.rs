pub fn collect_prelude_info (workspace_path : & Path , exclude_crates : & HashSet < String > ,) -> Result < Vec < CollectedPreludeInfo > > { let rustc_info = get_rustc_info () ? ; let cache_dir = workspace_path . join (".prelude_cache") ; fs :: create_dir_all (& cache_dir) . context ("Failed to create prelude cache directory") ? ; let output = Command :: new ("cargo") . arg ("metadata") . arg ("--no-deps") . arg ("--format-version=1") . current_dir (workspace_path) . output () ? ; if ! output . status . success () { return :: anyhow :: __private :: Err (:: anyhow :: Error :: msg (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("cargo metadata failed: {0}" , String :: from_utf8_lossy (& output . stderr) ,) ,) }) ,) ,) ; } let metadata : Metadata = serde_json :: from_slice (& output . stdout) ? ; let mut collected_info = Vec :: new () ; for package in metadata . packages { if exclude_crates . contains (& package . name) { { :: std :: io :: _print (format_args ! ("Skipping explicitly excluded crate: {0} ({1})\n" , package . name , package . manifest_path . display () ,) ,) ; } ; continue ; } let crate_root = package . manifest_path . parent () . unwrap () . to_path_buf () ; if is_proc_macro_crate (& crate_root) ? { { :: std :: io :: _print (format_args ! ("Skipping procedural macro crate: {0} ({1})\n" , package . name , crate_root . display () ,) ,) ; } ; continue ; } { :: std :: io :: _print (format_args ! ("\nCollecting prelude info for crate: {0} ({1})\n" , package . name , crate_root . display () ,) ,) ; } ; let src_dir = crate_root . join ("src") ; if ! src_dir . is_dir () { { :: std :: io :: _print (format_args ! ("  -> No src directory found, skipping.\n") ,) ; } ; continue ; } let mut use_statements = HashSet :: new () ; let mut rust_files = Vec :: new () ; let mut file_processing_results = Vec :: new () ; { :: std :: io :: _print (format_args ! ("  -> Starting file walk for crate: {0}\n" , package . name) ,) ; } ; for entry in WalkDir :: new (& src_dir) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { let path = e . path () ; path . extension () . map_or (false , | ext | ext == "rs") && path . file_name () . map_or (false , | name | name != "prelude.rs") }) { let path = entry . path () ; rust_files . push (path . to_path_buf ()) ; let content = match fs :: read_to_string (path) { Ok (c) => c , Err (e) => { file_processing_results . push (FileProcessingResult { path : path . to_path_buf () , status : FileProcessingStatus :: Failed { error : :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read file: {0}" , e) ,) }) , } , }) ; continue ; } } ; { :: std :: io :: _print (format_args ! ("    -> Expanding macros and parsing file: {0}\n" , path . display () ,) ,) ; } ; let ast = match expand_macros_and_parse (path , & content , & rustc_info , & cache_dir ,) { Ok (ast) => ast , Err (e) => { file_processing_results . push (FileProcessingResult { path : path . to_path_buf () , status : FileProcessingStatus :: Failed { error : :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to expand macros and parse: {0}" , e) ,) }) , } , }) ; continue ; } } ; { :: std :: io :: _print (format_args ! ("    -> Successfully expanded macros and parsed file: {0}\n" , path . display () ,) ,) ; } ; for item in & ast . items { if let Item :: Use (use_item) = item { let mut base_path = Vec :: new () ; flatten_use_tree (& mut base_path , & use_item . tree , & mut use_statements ,) ; } } file_processing_results . push (FileProcessingResult { path : path . to_path_buf () , status : FileProcessingStatus :: Success , }) ; } { :: std :: io :: _print (format_args ! ("  -> Finished file walk for crate: {0}\n" , package . name) ,) ; } ; if use_statements . is_empty () { file_processing_results . push (FileProcessingResult { path : src_dir . to_path_buf () , status : FileProcessingStatus :: Skipped { reason : "No use statements found in crate" . to_string () , } , }) ; continue ; } let mut prelude_content = String :: from ("// This file is auto-generated by prelude-generator. Do not edit.\n\n" ,) ; let mut sorted_uses : Vec < _ > = use_statements . iter () . collect () ; sorted_uses . sort () ; for use_stmt in sorted_uses { prelude_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("pub {0}" , use_stmt)) }) ,) ; prelude_content . push_str ("\n") ; } let mut crate_root_modified = false ; let lib_rs = src_dir . join ("lib.rs") ; let main_rs = src_dir . join ("main.rs") ; let crate_root_path = if lib_rs . exists () { Some (lib_rs) } else if main_rs . exists () { Some (main_rs) } else { None } ; if let Some (path) = crate_root_path { let content = fs :: read_to_string (& path) ? ; let ast = expand_macros_and_parse (& path , & content , & rustc_info , & cache_dir) ? ; let mut has_prelude_mod = false ; for item in & ast . items { if let Item :: Mod (mod_item) = item { if mod_item . ident == "prelude" { has_prelude_mod = true ; break ; } } } if ! has_prelude_mod { crate_root_modified = true ; } } collected_info . push (CollectedPreludeInfo { crate_name : package . name , crate_root , prelude_content , modified_files : rust_files , crate_root_modified , file_processing_results , }) ; } Ok (collected_info) }