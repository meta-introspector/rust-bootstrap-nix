# [proc_macro] pub fn define_config (input : TokenStream) -> TokenStream { let ConfigInput { attrs , ident , fields , .. } = match :: syn :: parse :: < ConfigInput , > (input) { :: syn :: __private :: Ok (data) => data , :: syn :: __private :: Err (err) => { return :: syn :: __private :: TokenStream :: from (err . to_compile_error ()) ; } } ; let field_names : Vec < _ > = fields . iter () . map (| f | & f . ident) . collect () ; let field_types : Vec < _ > = fields . iter () . map (| f | & f . ty) . collect () ; let field_keys : Vec < _ > = fields . iter () . map (| f | { if let Some (key_lit) = & f . key { { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: ToTokens :: to_tokens (& key_lit , & mut _s) ; _s } } else { let ident_str = LitStr :: new (& f . ident . to_string () , f . ident . span ()) ; { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: ToTokens :: to_tokens (& ident_str , & mut _s) ; _s } } }) . collect () ; let expanded = { let mut _s = :: quote :: __private :: TokenStream :: new () ; { use :: quote :: __private :: ext :: * ; let has_iter = :: quote :: __private :: HasIterator :: < false > ; # [allow (unused_mut)] let (mut attrs , i) = attrs . quote_into_iter () ; let has_iter = has_iter | i ; < _ as :: quote :: __private :: CheckHasIterator < true > > :: check (has_iter) ; while true { let attrs = match attrs . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; :: quote :: ToTokens :: to_tokens (& attrs , & mut _s) ; } } :: quote :: __private :: push_ident (& mut _s , "pub") ; :: quote :: __private :: push_ident (& mut _s , "struct") ; :: quote :: ToTokens :: to_tokens (& ident , & mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; { use :: quote :: __private :: ext :: * ; let has_iter = :: quote :: __private :: HasIterator :: < false > ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_types , i) = field_types . quote_into_iter () ; let has_iter = has_iter | i ; < _ as :: quote :: __private :: CheckHasIterator < true > > :: check (has_iter) ; while true { let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_types = match field_types . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; :: quote :: __private :: push_ident (& mut _s , "pub") ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_colon (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_types , & mut _s) ; :: quote :: __private :: push_comma (& mut _s) ; } } _s } ,) ; :: quote :: __private :: push_ident (& mut _s , "impl") ; :: quote :: __private :: push_ident (& mut _s , "config_core") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "Merge") ; :: quote :: __private :: push_ident (& mut _s , "for") ; :: quote :: ToTokens :: to_tokens (& ident , & mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "fn") ; :: quote :: __private :: push_ident (& mut _s , "merge") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_and (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "mut") ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_comma (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_colon (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "Self") ; :: quote :: __private :: push_comma (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "replace") ; :: quote :: __private :: push_colon (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "config_core") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "ReplaceOpt") ; _s } ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; { use :: quote :: __private :: ext :: * ; let has_iter = :: quote :: __private :: HasIterator :: < false > ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_keys , i) = field_keys . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; # [allow (unused_mut)] let (mut field_names , i) = field_names . quote_into_iter () ; let has_iter = has_iter | i ; < _ as :: quote :: __private :: CheckHasIterator < true , > > :: check (has_iter) ; while true { let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_keys = match field_keys . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; let field_names = match field_names . next () { Some (_x) => :: quote :: __private :: RepInterp (_x) , None => break , } ; :: quote :: __private :: push_ident (& mut _s , "match") ; :: quote :: __private :: push_ident (& mut _s , "replace") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "config_core") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "ReplaceOpt") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "IgnoreDuplicate") ; :: quote :: __private :: push_fat_arrow (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "if") ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "is_none") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , :: quote :: __private :: TokenStream :: new () ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_eq (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_semi (& mut _s) ; _s } ,) ; _s } ,) ; :: quote :: __private :: push_comma (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "config_core") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "ReplaceOpt") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "Override") ; :: quote :: __private :: push_fat_arrow (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "if") ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "is_some") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , :: quote :: __private :: TokenStream :: new () ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_eq (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_semi (& mut _s) ; _s } ,) ; _s } ,) ; :: quote :: __private :: push_ident (& mut _s , "config_core") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "ReplaceOpt") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "ErrorOnDuplicate") ; :: quote :: __private :: push_fat_arrow (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "if") ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "is_some") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , :: quote :: __private :: TokenStream :: new () ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "if") ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "is_some") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , :: quote :: __private :: TokenStream :: new () ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "if") ; :: quote :: __private :: push_ident (& mut _s , "cfg") ; :: quote :: __private :: push_bang (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "test") ; _s } ,) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "panic") ; :: quote :: __private :: push_bang (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: parse (& mut _s , "\"overriding existing option\"" ,) ; _s } ,) ; _s } ,) ; :: quote :: __private :: push_ident (& mut _s , "else") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "eprintln") ; :: quote :: __private :: push_bang (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: parse (& mut _s , "\"overriding existing option: `{}`\"" ,) ; :: quote :: __private :: push_comma (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_keys , & mut _s) ; _s } ,) ; :: quote :: __private :: push_semi (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "panic") ; :: quote :: __private :: push_bang (& mut _s) ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Parenthesis , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: parse (& mut _s , "\"overriding existing option\"" ,) ; _s } ,) ; :: quote :: __private :: push_semi (& mut _s) ; _s } ,) ; _s } ,) ; _s } ,) ; :: quote :: __private :: push_ident (& mut _s , "else") ; :: quote :: __private :: push_group (& mut _s , :: quote :: __private :: Delimiter :: Brace , { let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "self") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_eq (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "other") ; :: quote :: __private :: push_dot (& mut _s) ; :: quote :: ToTokens :: to_tokens (& field_names , & mut _s) ; :: quote :: __private :: push_semi (& mut _s) ; _s } ,) ; _s } ,) ; _s } ,) ; } } _s } ,) ; _s } ,) ; _s } ; expanded . into () }