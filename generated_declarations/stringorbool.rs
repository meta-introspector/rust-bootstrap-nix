pub mod stringorbool { use serde :: Deserialize ; # [serde (untagged)] pub enum StringOrBool { String (String) , Bool (bool) , } # [automatically_derived] impl :: core :: clone :: Clone for StringOrBool { # [inline] fn clone (& self) -> StringOrBool { match self { StringOrBool :: String (__self_0) => { StringOrBool :: String (:: core :: clone :: Clone :: clone (__self_0)) } StringOrBool :: Bool (__self_0) => { StringOrBool :: Bool (:: core :: clone :: Clone :: clone (__self_0)) } } } } # [automatically_derived] impl :: core :: fmt :: Debug for StringOrBool { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { StringOrBool :: String (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "String" , & __self_0 ,) } StringOrBool :: Bool (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Bool" , & __self_0 ,) } } } } # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for StringOrBool { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { let __content = _serde :: de :: DeserializeSeed :: deserialize (_serde :: __private228 :: de :: ContentVisitor :: new () , __deserializer ,) ? ; let __deserializer = _serde :: __private228 :: de :: ContentRefDeserializer :: < __D :: Error , > :: new (& __content) ; if let _serde :: __private228 :: Ok (__ok) = _serde :: __private228 :: Result :: map (< String as _serde :: Deserialize > :: deserialize (__deserializer) , StringOrBool :: String ,) { return _serde :: __private228 :: Ok (__ok) ; } if let _serde :: __private228 :: Ok (__ok) = _serde :: __private228 :: Result :: map (< bool as _serde :: Deserialize > :: deserialize (__deserializer) , StringOrBool :: Bool ,) { return _serde :: __private228 :: Ok (__ok) ; } _serde :: __private228 :: Err (_serde :: de :: Error :: custom ("data did not match any variant of untagged enum StringOrBool" ,) ,) } } } ; # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for StringOrBool { } # [automatically_derived] impl :: core :: cmp :: PartialEq for StringOrBool { # [inline] fn eq (& self , other : & StringOrBool) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr && match (self , other) { (StringOrBool :: String (__self_0) , StringOrBool :: String (__arg1_0)) => { __self_0 == __arg1_0 } (StringOrBool :: Bool (__self_0) , StringOrBool :: Bool (__arg1_0)) => { __self_0 == __arg1_0 } _ => unsafe { :: core :: intrinsics :: unreachable () } } } } # [automatically_derived] impl :: core :: cmp :: Eq for StringOrBool { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < String > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; } } impl Default for StringOrBool { fn default () -> StringOrBool { StringOrBool :: Bool (false) } } impl StringOrBool { pub fn is_string_or_true (& self) -> bool { # [allow (non_exhaustive_omitted_patterns)] match self { Self :: String (_) | Self :: Bool (true) => true , _ => false , } } } }