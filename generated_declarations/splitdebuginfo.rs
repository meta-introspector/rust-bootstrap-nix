pub mod splitdebuginfo { use crate :: TargetSelection ; pub enum SplitDebuginfo { Packed , Unpacked , # [default] Off , } # [automatically_derived] impl :: core :: fmt :: Debug for SplitDebuginfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { SplitDebuginfo :: Packed => "Packed" , SplitDebuginfo :: Unpacked => "Unpacked" , SplitDebuginfo :: Off => "Off" , } ,) } } # [automatically_derived] impl :: core :: default :: Default for SplitDebuginfo { # [inline] fn default () -> SplitDebuginfo { Self :: Off } } # [automatically_derived] impl :: core :: marker :: Copy for SplitDebuginfo { } # [automatically_derived] impl :: core :: clone :: Clone for SplitDebuginfo { # [inline] fn clone (& self) -> SplitDebuginfo { * self } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for SplitDebuginfo { } # [automatically_derived] impl :: core :: cmp :: PartialEq for SplitDebuginfo { # [inline] fn eq (& self , other : & SplitDebuginfo) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } # [automatically_derived] impl :: core :: cmp :: Eq for SplitDebuginfo { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for SplitDebuginfo { # [inline] fn partial_cmp (& self , other : & SplitDebuginfo ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; :: core :: cmp :: PartialOrd :: partial_cmp (& __self_discr , & __arg1_discr) } } # [automatically_derived] impl :: core :: cmp :: Ord for SplitDebuginfo { # [inline] fn cmp (& self , other : & SplitDebuginfo) -> :: core :: cmp :: Ordering { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; :: core :: cmp :: Ord :: cmp (& __self_discr , & __arg1_discr) } } # [automatically_derived] impl :: core :: hash :: Hash for SplitDebuginfo { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; :: core :: hash :: Hash :: hash (& __self_discr , state) } } impl std :: str :: FromStr for SplitDebuginfo { type Err = () ; fn from_str (s : & str) -> Result < Self , Self :: Err > { match s { "packed" => Ok (SplitDebuginfo :: Packed) , "unpacked" => Ok (SplitDebuginfo :: Unpacked) , "off" => Ok (SplitDebuginfo :: Off) , _ => Err (()) , } } } impl SplitDebuginfo { # [doc = " Returns the default `-Csplit-debuginfo` value for the current target. See the comment for"] # [doc = " `rust.split-debuginfo` in `config.example.toml`."] pub fn default_for_platform (target : TargetSelection) -> Self { if target . contains ("apple") { SplitDebuginfo :: Unpacked } else if target . is_windows () { SplitDebuginfo :: Packed } else { SplitDebuginfo :: Off } } } }