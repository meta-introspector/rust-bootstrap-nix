pub mod contiguous { # ! [doc = "\nProvides a contiguous NFA implementation of Aho-Corasick.\n\nThis is a low-level API that generally only needs to be used in niche\ncircumstances. When possible, prefer using [`AhoCorasick`](crate::AhoCorasick)\ninstead of a contiguous NFA directly. Using an `NFA` directly is typically only\nnecessary when one needs access to the [`Automaton`] trait implementation.\n"] use alloc :: { vec , vec :: Vec } ; use crate :: { automaton :: Automaton , nfa :: noncontiguous , util :: { alphabet :: ByteClasses , error :: { BuildError , MatchError } , int :: { Usize , U16 , U32 } , prefilter :: Prefilter , primitives :: { IteratorIndexExt , PatternID , SmallIndex , StateID } , search :: { Anchored , MatchKind } , special :: Special , } , } ; # [doc = " A contiguous NFA implementation of Aho-Corasick."] # [doc = ""] # [doc = " When possible, prefer using [`AhoCorasick`](crate::AhoCorasick) instead of"] # [doc = " this type directly. Using an `NFA` directly is typically only necessary"] # [doc = " when one needs access to the [`Automaton`] trait implementation."] # [doc = ""] # [doc = " This NFA can only be built by first constructing a [`noncontiguous::NFA`]."] # [doc = " Both [`NFA::new`] and [`Builder::build`] do this for you automatically, but"] # [doc = " [`Builder::build_from_noncontiguous`] permits doing it explicitly."] # [doc = ""] # [doc = " The main difference between a noncontiguous NFA and a contiguous NFA is"] # [doc = " that the latter represents all of its states and transitions in a single"] # [doc = " allocation, where as the former uses a separate allocation for each state."] # [doc = " Doing this at construction time while keeping a low memory footprint isn't"] # [doc = " feasible, which is primarily why there are two different NFA types: one"] # [doc = " that does the least amount of work possible to build itself, and another"] # [doc = " that does a little extra work to compact itself and make state transitions"] # [doc = " faster by making some states use a dense representation."] # [doc = ""] # [doc = " Because a contiguous NFA uses a single allocation, there is a lot more"] # [doc = " opportunity for compression tricks to reduce the heap memory used. Indeed,"] # [doc = " it is not uncommon for a contiguous NFA to use an order of magnitude less"] # [doc = " heap memory than a noncontiguous NFA. Since building a contiguous NFA"] # [doc = " usually only takes a fraction of the time it takes to build a noncontiguous"] # [doc = " NFA, the overall build time is not much slower. Thus, in most cases, a"] # [doc = " contiguous NFA is the best choice."] # [doc = ""] # [doc = " Since a contiguous NFA uses various tricks for compression and to achieve"] # [doc = " faster state transitions, currently, its limit on the number of states"] # [doc = " is somewhat smaller than what a noncontiguous NFA can achieve. Generally"] # [doc = " speaking, you shouldn't expect to run into this limit if the number of"] # [doc = " patterns is under 1 million. It is plausible that this limit will be"] # [doc = " increased in the future. If the limit is reached, building a contiguous NFA"] # [doc = " will return an error. Often, since building a contiguous NFA is relatively"] # [doc = " cheap, it can make sense to always try it even if you aren't sure if it"] # [doc = " will fail or not. If it does, you can always fall back to a noncontiguous"] # [doc = " NFA. (Indeed, the main [`AhoCorasick`](crate::AhoCorasick) type employs a"] # [doc = " strategy similar to this at construction time.)"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to build an `NFA` directly and use it to execute"] # [doc = " [`Automaton::try_find`]:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::Automaton,"] # [doc = "     nfa::contiguous::NFA,"] # [doc = "     Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let nfa = NFA::new(patterns).unwrap();"] # [doc = " assert_eq!("] # [doc = "     Some(Match::must(0, 1..2)),"] # [doc = "     nfa.try_find(&Input::new(haystack))?,"] # [doc = " );"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " It is also possible to implement your own version of `try_find`. See the"] # [doc = " [`Automaton`] documentation for an example."] pub struct NFA { # [doc = " The raw NFA representation. Each state is packed with a header"] # [doc = " (containing the format of the state, the failure transition and, for"] # [doc = " a sparse state, the number of transitions), its transitions and any"] # [doc = " matching pattern IDs for match states."] repr : Vec < u32 > , # [doc = " The length of each pattern. This is used to compute the start offset"] # [doc = " of a match."] pattern_lens : Vec < SmallIndex > , # [doc = " The total number of states in this NFA."] state_len : usize , # [doc = " A prefilter for accelerating searches, if one exists."] prefilter : Option < Prefilter > , # [doc = " The match semantics built into this NFA."] match_kind : MatchKind , # [doc = " The alphabet size, or total number of equivalence classes, for this"] # [doc = " NFA. Dense states always have this many transitions."] alphabet_len : usize , # [doc = " The equivalence classes for this NFA. All transitions, dense and"] # [doc = " sparse, are defined on equivalence classes and not on the 256 distinct"] # [doc = " byte values."] byte_classes : ByteClasses , # [doc = " The length of the shortest pattern in this automaton."] min_pattern_len : usize , # [doc = " The length of the longest pattern in this automaton."] max_pattern_len : usize , # [doc = " The information required to deduce which states are \"special\" in this"] # [doc = " NFA."] special : Special , } # [automatically_derived] impl :: core :: clone :: Clone for NFA { # [inline] fn clone (& self) -> NFA { NFA { repr : :: core :: clone :: Clone :: clone (& self . repr) , pattern_lens : :: core :: clone :: Clone :: clone (& self . pattern_lens) , state_len : :: core :: clone :: Clone :: clone (& self . state_len) , prefilter : :: core :: clone :: Clone :: clone (& self . prefilter) , match_kind : :: core :: clone :: Clone :: clone (& self . match_kind) , alphabet_len : :: core :: clone :: Clone :: clone (& self . alphabet_len) , byte_classes : :: core :: clone :: Clone :: clone (& self . byte_classes) , min_pattern_len : :: core :: clone :: Clone :: clone (& self . min_pattern_len) , max_pattern_len : :: core :: clone :: Clone :: clone (& self . max_pattern_len) , special : :: core :: clone :: Clone :: clone (& self . special) , } } } impl NFA { # [doc = " Create a new Aho-Corasick contiguous NFA using the default"] # [doc = " configuration."] # [doc = ""] # [doc = " Use a [`Builder`] if you want to change the configuration."] pub fn new < I , P > (patterns : I) -> Result < NFA , BuildError > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { NFA :: builder () . build (patterns) } # [doc = " A convenience method for returning a new Aho-Corasick contiguous NFA"] # [doc = " builder."] # [doc = ""] # [doc = " This usually permits one to just import the `NFA` type."] pub fn builder () -> Builder { Builder :: new () } } impl NFA { # [doc = " A sentinel state ID indicating that a search should stop once it has"] # [doc = " entered this state. When a search stops, it returns a match if one"] # [doc = " has been found, otherwise no match. A contiguous NFA always has an"] # [doc = " actual dead state at this ID."] const DEAD : StateID = StateID :: new_unchecked (0) ; # [doc = " Another sentinel state ID indicating that a search should move through"] # [doc = " current state's failure transition."] # [doc = ""] # [doc = " Note that unlike DEAD, this does not actually point to a valid state"] # [doc = " in a contiguous NFA. (noncontiguous::NFA::FAIL does point to a valid"] # [doc = " state.) Instead, this points to the position that is guaranteed to"] # [doc = " never be a valid state ID (by making sure it points to a place in the"] # [doc = " middle of the encoding of the DEAD state). Since we never need to"] # [doc = " actually look at the FAIL state itself, this works out."] # [doc = ""] # [doc = " By why do it this way? So that FAIL is a constant. I don't have any"] # [doc = " concrete evidence that this materially helps matters, but it's easy to"] # [doc = " do. The alternative would be making the FAIL ID point to the second"] # [doc = " state, which could be made a constant but is a little trickier to do."] # [doc = " The easiest path is to just make the FAIL state a runtime value, but"] # [doc = " since comparisons with FAIL occur in perf critical parts of the search,"] # [doc = " we want it to be as tight as possible and not waste any registers."] # [doc = ""] # [doc = " Very hand wavy... But the code complexity that results from this is"] # [doc = " very mild."] const FAIL : StateID = StateID :: new_unchecked (1) ; } unsafe impl Automaton for NFA { # [inline (always)] fn start_state (& self , anchored : Anchored) -> Result < StateID , MatchError > { match anchored { Anchored :: No => Ok (self . special . start_unanchored_id) , Anchored :: Yes => Ok (self . special . start_anchored_id) , } } # [inline (always)] fn next_state (& self , anchored : Anchored , mut sid : StateID , byte : u8 ,) -> StateID { let repr = & self . repr ; let class = self . byte_classes . get (byte) ; let u32tosid = StateID :: from_u32_unchecked ; loop { let o = sid . as_usize () ; let kind = repr [o] & 0xFF ; if kind == State :: KIND_DENSE { let next = u32tosid (repr [o + 2 + usize :: from (class)]) ; if next != NFA :: FAIL { return next ; } } else if kind == State :: KIND_ONE { if class == repr [o] . low_u16 () . high_u8 () { return u32tosid (repr [o + 2]) ; } } else { let trans_len = kind . as_usize () ; let classes_len = u32_len (trans_len) ; let trans_offset = o + 2 + classes_len ; for (i , & chunk) in repr [o + 2 ..] [.. classes_len] . iter () . enumerate () { let classes = chunk . to_ne_bytes () ; if classes [0] == class { return u32tosid (repr [trans_offset + i * 4]) ; } if classes [1] == class { return u32tosid (repr [trans_offset + i * 4 + 1]) ; } if classes [2] == class { return u32tosid (repr [trans_offset + i * 4 + 2]) ; } if classes [3] == class { return u32tosid (repr [trans_offset + i * 4 + 3]) ; } } } if anchored . is_anchored () { return NFA :: DEAD ; } sid = u32tosid (repr [o + 1]) ; } } # [inline (always)] fn is_special (& self , sid : StateID) -> bool { sid <= self . special . max_special_id } # [inline (always)] fn is_dead (& self , sid : StateID) -> bool { sid == NFA :: DEAD } # [inline (always)] fn is_match (& self , sid : StateID) -> bool { ! self . is_dead (sid) && sid <= self . special . max_match_id } # [inline (always)] fn is_start (& self , sid : StateID) -> bool { sid == self . special . start_unanchored_id || sid == self . special . start_anchored_id } # [inline (always)] fn match_kind (& self) -> MatchKind { self . match_kind } # [inline (always)] fn patterns_len (& self) -> usize { self . pattern_lens . len () } # [inline (always)] fn pattern_len (& self , pid : PatternID) -> usize { self . pattern_lens [pid] . as_usize () } # [inline (always)] fn min_pattern_len (& self) -> usize { self . min_pattern_len } # [inline (always)] fn max_pattern_len (& self) -> usize { self . max_pattern_len } # [inline (always)] fn match_len (& self , sid : StateID) -> usize { State :: match_len (self . alphabet_len , & self . repr [sid . as_usize () ..]) } # [inline (always)] fn match_pattern (& self , sid : StateID , index : usize) -> PatternID { State :: match_pattern (self . alphabet_len , & self . repr [sid . as_usize () ..] , index ,) } # [inline (always)] fn memory_usage (& self) -> usize { use core :: mem :: size_of ; (self . repr . len () * size_of :: < u32 > ()) + (self . pattern_lens . len () * size_of :: < SmallIndex > ()) + self . prefilter . as_ref () . map_or (0 , | p | p . memory_usage ()) } # [inline (always)] fn prefilter (& self) -> Option < & Prefilter > { self . prefilter . as_ref () } } impl core :: fmt :: Debug for NFA { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { use crate :: automaton :: fmt_state_indicator ; f . write_fmt (format_args ! ("contiguous::NFA(\n")) ? ; let mut sid = NFA :: DEAD ; loop { let raw = & self . repr [sid . as_usize () ..] ; if raw . is_empty () { break ; } let is_match = self . is_match (sid) ; let state = State :: read (self . alphabet_len , is_match , raw) ; fmt_state_indicator (f , self , sid) ? ; f . write_fmt (format_args ! ("{0:06}({1:06}): " , sid . as_usize () , state . fail . as_usize () ,) ,) ? ; state . fmt (f) ? ; f . write_fmt (format_args ! ("\n")) ? ; if self . is_match (sid) { f . write_fmt (format_args ! ("         matches: ")) ? ; for i in 0 .. state . match_len { let pid = State :: match_pattern (self . alphabet_len , raw , i) ; if i > 0 { f . write_fmt (format_args ! (", ")) ? ; } f . write_fmt (format_args ! ("{0}" , pid . as_usize ())) ? ; } f . write_fmt (format_args ! ("\n")) ? ; } if sid == NFA :: DEAD { f . write_fmt (format_args ! ("F {0:06}:\n" , NFA :: FAIL . as_usize ())) ? ; } let len = State :: len (self . alphabet_len , is_match , raw) ; sid = StateID :: new (sid . as_usize () . checked_add (len) . unwrap ()) . unwrap () ; } f . write_fmt (format_args ! ("match kind: {0:?}\n" , self . match_kind)) ? ; f . write_fmt (format_args ! ("prefilter: {0:?}\n" , self . prefilter . is_some ()) ,) ? ; f . write_fmt (format_args ! ("state length: {0:?}\n" , self . state_len)) ? ; f . write_fmt (format_args ! ("pattern length: {0:?}\n" , self . patterns_len ()) ,) ? ; f . write_fmt (format_args ! ("shortest pattern length: {0:?}\n" , self . min_pattern_len ,) ,) ? ; f . write_fmt (format_args ! ("longest pattern length: {0:?}\n" , self . max_pattern_len) ,) ? ; f . write_fmt (format_args ! ("alphabet length: {0:?}\n" , self . alphabet_len) ,) ? ; f . write_fmt (format_args ! ("byte classes: {0:?}\n" , self . byte_classes)) ? ; f . write_fmt (format_args ! ("memory usage: {0:?}\n" , self . memory_usage ())) ? ; f . write_fmt (format_args ! (")\n")) ? ; Ok (()) } } # [doc = " The \"in memory\" representation a single dense or sparse state."] # [doc = ""] # [doc = " A `State`'s in memory representation is not ever actually materialized"] # [doc = " during a search with a contiguous NFA. Doing so would be too slow. (Indeed,"] # [doc = " the only time a `State` is actually constructed is in `Debug` impls.)"] # [doc = " Instead, a `State` exposes a number of static methods for reading certain"] # [doc = " things from the raw binary encoding of the state."] struct State < 'a > { # [doc = " The state to transition to when 'class_to_next' yields a transition"] # [doc = " to the FAIL state."] fail : StateID , # [doc = " The number of pattern IDs in this state. For a non-match state, this is"] # [doc = " always zero. Otherwise it is always bigger than zero."] match_len : usize , # [doc = " The sparse or dense representation of the transitions for this state."] trans : StateTrans < 'a > , } # [automatically_derived] impl < 'a > :: core :: clone :: Clone for State < 'a > { # [inline] fn clone (& self) -> State < 'a > { State { fail : :: core :: clone :: Clone :: clone (& self . fail) , match_len : :: core :: clone :: Clone :: clone (& self . match_len) , trans : :: core :: clone :: Clone :: clone (& self . trans) , } } } # [doc = " The underlying representation of sparse or dense transitions for a state."] # [doc = ""] # [doc = " Note that like `State`, we don't typically construct values of this type"] # [doc = " during a search since we don't always need all values and thus would"] # [doc = " represent a lot of wasteful work."] enum StateTrans < 'a > { # [doc = " A sparse representation of transitions for a state, where only non-FAIL"] # [doc = " transitions are explicitly represented."] Sparse { classes : & 'a [u32] , # [doc = " The transitions for this state, where each transition is packed"] # [doc = " into a u32. The low 8 bits correspond to the byte class for the"] # [doc = " transition, and the high 24 bits correspond to the next state ID."] # [doc = ""] # [doc = " This packing is why the max state ID allowed for a contiguous"] # [doc = " NFA is 2^24-1."] nexts : & 'a [u32] , } , # [doc = " A \"one transition\" state that is never a match state."] # [doc = ""] # [doc = " These are by far the most common state, so we use a specialized and"] # [doc = " very compact representation for them."] One { # [doc = " The element of this NFA's alphabet that this transition is"] # [doc = " defined for."] class : u8 , # [doc = " The state this should transition to if the current symbol is"] # [doc = " equal to 'class'."] next : u32 , } , # [doc = " A dense representation of transitions for a state, where all"] # [doc = " transitions are explicitly represented, including transitions to the"] # [doc = " FAIL state."] Dense { # [doc = " A dense set of transitions to other states. The transitions may"] # [doc = " point to a FAIL state, in which case, the search should try the"] # [doc = " same transition lookup at 'fail'."] # [doc = ""] # [doc = " Note that this is indexed by byte equivalence classes and not"] # [doc = " byte values. That means 'class_to_next[byte]' is wrong and"] # [doc = " 'class_to_next[classes.get(byte)]' is correct. The number of"] # [doc = " transitions is always equivalent to 'classes.alphabet_len()'."] class_to_next : & 'a [u32] , } , } # [automatically_derived] impl < 'a > :: core :: clone :: Clone for StateTrans < 'a > { # [inline] fn clone (& self) -> StateTrans < 'a > { match self { StateTrans :: Sparse { classes : __self_0 , nexts : __self_1 } => { StateTrans :: Sparse { classes : :: core :: clone :: Clone :: clone (__self_0) , nexts : :: core :: clone :: Clone :: clone (__self_1) , } } StateTrans :: One { class : __self_0 , next : __self_1 } => { StateTrans :: One { class : :: core :: clone :: Clone :: clone (__self_0) , next : :: core :: clone :: Clone :: clone (__self_1) , } } StateTrans :: Dense { class_to_next : __self_0 } => { StateTrans :: Dense { class_to_next : :: core :: clone :: Clone :: clone (__self_0) , } } } } } impl < 'a > State < 'a > { # [doc = " The offset of where the \"kind\" of a state is stored. If it isn't one"] # [doc = " of the sentinel values below, then it's a sparse state and the kind"] # [doc = " corresponds to the number of transitions in the state."] const KIND : usize = 0 ; # [doc = " A sentinel value indicating that the state uses a dense representation."] const KIND_DENSE : u32 = 0xFF ; # [doc = " A sentinel value indicating that the state uses a special \"one"] # [doc = " transition\" encoding. In practice, non-match states with one transition"] # [doc = " make up the overwhelming majority of all states in any given"] # [doc = " Aho-Corasick automaton, so we can specialize them using a very compact"] # [doc = " representation."] const KIND_ONE : u32 = 0xFE ; # [doc = " The maximum number of transitions to encode as a sparse state. Usually"] # [doc = " states with a lot of transitions are either very rare, or occur near"] # [doc = " the start state. In the latter case, they are probably dense already"] # [doc = " anyway. In the former case, making them dense is fine because they're"] # [doc = " rare."] # [doc = ""] # [doc = " This needs to be small enough to permit each of the sentinel values for"] # [doc = " 'KIND' above. Namely, a sparse state embeds the number of transitions"] # [doc = " into the 'KIND'. Basically, \"sparse\" is a state kind too, but it's the"] # [doc = " \"else\" branch."] # [doc = ""] # [doc = " N.B. There isn't anything particularly magical about 127 here. I"] # [doc = " just picked it because I figured any sparse state with this many"] # [doc = " transitions is going to be exceptionally rare, and if it did have this"] # [doc = " many transitions, then it would be quite slow to do a linear scan on"] # [doc = " the transitions during a search anyway."] const MAX_SPARSE_TRANSITIONS : usize = 127 ; # [doc = " Remap state IDs in-place."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a state. (The start"] # [doc = " of the slice must correspond to the start of the state, but the slice"] # [doc = " may extend past the end of the encoding of the state.)"] fn remap (alphabet_len : usize , old_to_new : & [StateID] , state : & mut [u32] ,) -> Result < () , BuildError > { let kind = State :: kind (state) ; if kind == State :: KIND_DENSE { state [1] = old_to_new [state [1] . as_usize ()] . as_u32 () ; for next in state [2 ..] [.. alphabet_len] . iter_mut () { * next = old_to_new [next . as_usize ()] . as_u32 () ; } } else if kind == State :: KIND_ONE { state [1] = old_to_new [state [1] . as_usize ()] . as_u32 () ; state [2] = old_to_new [state [2] . as_usize ()] . as_u32 () ; } else { let trans_len = State :: sparse_trans_len (state) ; let classes_len = u32_len (trans_len) ; state [1] = old_to_new [state [1] . as_usize ()] . as_u32 () ; for next in state [2 + classes_len ..] [.. trans_len] . iter_mut () { * next = old_to_new [next . as_usize ()] . as_u32 () ; } } Ok (()) } # [doc = " Returns the length, in number of u32s, of this state."] # [doc = ""] # [doc = " This is useful for reading states consecutively, e.g., in the Debug"] # [doc = " impl without needing to store a separate map from state index to state"] # [doc = " identifier."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a state. (The start"] # [doc = " of the slice must correspond to the start of the state, but the slice"] # [doc = " may extend past the end of the encoding of the state.)"] fn len (alphabet_len : usize , is_match : bool , state : & [u32]) -> usize { let kind_len = 1 ; let fail_len = 1 ; let kind = State :: kind (state) ; let (classes_len , trans_len) = if kind == State :: KIND_DENSE { (0 , alphabet_len) } else if kind == State :: KIND_ONE { (0 , 1) } else { let trans_len = State :: sparse_trans_len (state) ; let classes_len = u32_len (trans_len) ; (classes_len , trans_len) } ; let match_len = if ! is_match { 0 } else if State :: match_len (alphabet_len , state) == 1 { 1 } else { 1 + State :: match_len (alphabet_len , state) } ; kind_len + fail_len + classes_len + trans_len + match_len } # [doc = " Returns the kind of this state."] # [doc = ""] # [doc = " This only includes the low byte."] # [inline (always)] fn kind (state : & [u32]) -> u32 { state [State :: KIND] & 0xFF } # [doc = " Get the number of sparse transitions in this state. This can never"] # [doc = " be more than State::MAX_SPARSE_TRANSITIONS, as all states with more"] # [doc = " transitions are encoded as dense states."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a sparse state. (The"] # [doc = " start of the slice must correspond to the start of the state, but the"] # [doc = " slice may extend past the end of the encoding of the state.) If this"] # [doc = " isn't a sparse state, then the return value is unspecified."] # [doc = ""] # [doc = " Do note that this is only legal to call on a sparse state. So for"] # [doc = " example, \"one transition\" state is not a sparse state, so it would not"] # [doc = " be legal to call this method on such a state."] # [inline (always)] fn sparse_trans_len (state : & [u32]) -> usize { (state [State :: KIND] & 0xFF) . as_usize () } # [doc = " Returns the total number of matching pattern IDs in this state. Calling"] # [doc = " this on a state that isn't a match results in unspecified behavior."] # [doc = " Thus, the returned number is never 0 for all correct calls."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a state. (The start"] # [doc = " of the slice must correspond to the start of the state, but the slice"] # [doc = " may extend past the end of the encoding of the state.)"] # [inline (always)] fn match_len (alphabet_len : usize , state : & [u32]) -> usize { let packed = if State :: kind (state) == State :: KIND_DENSE { let start = 2 + alphabet_len ; state [start] . as_usize () } else { let trans_len = State :: sparse_trans_len (state) ; let classes_len = u32_len (trans_len) ; let start = 2 + classes_len + trans_len ; state [start] . as_usize () } ; if packed & (1 << 31) == 0 { packed } else { 1 } } # [doc = " Returns the pattern ID corresponding to the given index for the state"] # [doc = " given. The `index` provided must be less than the number of pattern IDs"] # [doc = " in this state."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a state. (The start of"] # [doc = " the slice must correspond to the start of the state, but the slice may"] # [doc = " extend past the end of the encoding of the state.)"] # [doc = ""] # [doc = " If the given state is not a match state or if the index is out of"] # [doc = " bounds, then this has unspecified behavior."] # [inline (always)] fn match_pattern (alphabet_len : usize , state : & [u32] , index : usize ,) -> PatternID { let start = if State :: kind (state) == State :: KIND_DENSE { 2 + alphabet_len } else { let trans_len = State :: sparse_trans_len (state) ; let classes_len = u32_len (trans_len) ; 2 + classes_len + trans_len } ; let packed = state [start] ; let pid = if packed & (1 << 31) == 0 { state [start + 1 + index] } else { match (& 0 , & index) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; packed & ! (1 << 31) } ; PatternID :: from_u32_unchecked (pid) } # [doc = " Read a state's binary encoding to its in-memory representation."] # [doc = ""] # [doc = " `alphabet_len` should be the total number of transitions defined for"] # [doc = " dense states."] # [doc = ""] # [doc = " `is_match` should be true if this state is a match state and false"] # [doc = " otherwise."] # [doc = ""] # [doc = " `state` should be the the raw binary encoding of a state. (The start"] # [doc = " of the slice must correspond to the start of the state, but the slice"] # [doc = " may extend past the end of the encoding of the state.)"] fn read (alphabet_len : usize , is_match : bool , state : & 'a [u32]) -> State < 'a > { let kind = State :: kind (state) ; let match_len = if ! is_match { 0 } else { State :: match_len (alphabet_len , state) } ; let (trans , fail) = if kind == State :: KIND_DENSE { let fail = StateID :: from_u32_unchecked (state [1]) ; let class_to_next = & state [2 ..] [.. alphabet_len] ; (StateTrans :: Dense { class_to_next } , fail) } else if kind == State :: KIND_ONE { let fail = StateID :: from_u32_unchecked (state [1]) ; let class = state [State :: KIND] . low_u16 () . high_u8 () ; let next = state [2] ; (StateTrans :: One { class , next } , fail) } else { let fail = StateID :: from_u32_unchecked (state [1]) ; let trans_len = State :: sparse_trans_len (state) ; let classes_len = u32_len (trans_len) ; let classes = & state [2 ..] [.. classes_len] ; let nexts = & state [2 + classes_len ..] [.. trans_len] ; (StateTrans :: Sparse { classes , nexts , } , fail ,) } ; State { fail , match_len , trans } } # [doc = " Encode the \"old\" state from a noncontiguous NFA to its binary"] # [doc = " representation to the given `dst` slice. `classes` should be the byte"] # [doc = " classes computed for the noncontiguous NFA that the given state came"] # [doc = " from."] # [doc = ""] # [doc = " This returns an error if `dst` became so big that `StateID`s can no"] # [doc = " longer be created for new states. Otherwise, it returns the state ID of"] # [doc = " the new state created."] # [doc = ""] # [doc = " When `force_dense` is true, then the encoded state will always use a"] # [doc = " dense format. Otherwise, the choice between dense and sparse will be"] # [doc = " automatically chosen based on the old state."] fn write (nnfa : & noncontiguous :: NFA , oldsid : StateID , old : & noncontiguous :: State , classes : & ByteClasses , dst : & mut Vec < u32 > , force_dense : bool ,) -> Result < StateID , BuildError > { let sid = StateID :: new (dst . len ()) . map_err (| e | { BuildError :: state_id_overflow (StateID :: MAX . as_u64 () , e . attempted () ,) }) ? ; let old_len = nnfa . iter_trans (oldsid) . count () ; let kind = if force_dense || old_len > State :: MAX_SPARSE_TRANSITIONS { State :: KIND_DENSE } else if old_len == 1 && ! old . is_match () { State :: KIND_ONE } else { u32 :: try_from (old_len) . unwrap () } ; if kind == State :: KIND_DENSE { dst . push (kind) ; dst . push (old . fail () . as_u32 ()) ; State :: write_dense_trans (nnfa , oldsid , classes , dst) ? ; } else if kind == State :: KIND_ONE { let t = nnfa . iter_trans (oldsid) . next () . unwrap () ; let class = u32 :: from (classes . get (t . byte ())) ; dst . push (kind | (class << 8)) ; dst . push (old . fail () . as_u32 ()) ; dst . push (t . next () . as_u32 ()) ; } else { dst . push (kind) ; dst . push (old . fail () . as_u32 ()) ; State :: write_sparse_trans (nnfa , oldsid , classes , dst) ? ; } if old . is_match () { let matches_len = nnfa . iter_matches (oldsid) . count () ; if matches_len == 1 { let pid = nnfa . iter_matches (oldsid) . next () . unwrap () . as_u32 () ; match (& 0 , & (pid & (1 << 31))) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; dst . push ((1 << 31) | pid) ; } else { match (& 0 , & (matches_len & (1 << 31))) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; dst . push (matches_len . as_u32 ()) ; dst . extend (nnfa . iter_matches (oldsid) . map (| pid | pid . as_u32 ())) ; } } Ok (sid) } # [doc = " Encode the \"old\" state transitions from a noncontiguous NFA to its"] # [doc = " binary sparse representation to the given `dst` slice. `classes` should"] # [doc = " be the byte classes computed for the noncontiguous NFA that the given"] # [doc = " state came from."] # [doc = ""] # [doc = " This returns an error if `dst` became so big that `StateID`s can no"] # [doc = " longer be created for new states."] fn write_sparse_trans (nnfa : & noncontiguous :: NFA , oldsid : StateID , classes : & ByteClasses , dst : & mut Vec < u32 > ,) -> Result < () , BuildError > { let (mut chunk , mut len) = ([0 ; 4] , 0) ; for t in nnfa . iter_trans (oldsid) { chunk [len] = classes . get (t . byte ()) ; len += 1 ; if len == 4 { dst . push (u32 :: from_ne_bytes (chunk)) ; chunk = [0 ; 4] ; len = 0 ; } } if len > 0 { let repeat = chunk [len - 1] ; while len < 4 { chunk [len] = repeat ; len += 1 ; } dst . push (u32 :: from_ne_bytes (chunk)) ; } for t in nnfa . iter_trans (oldsid) { dst . push (t . next () . as_u32 ()) ; } Ok (()) } # [doc = " Encode the \"old\" state transitions from a noncontiguous NFA to its"] # [doc = " binary dense representation to the given `dst` slice. `classes` should"] # [doc = " be the byte classes computed for the noncontiguous NFA that the given"] # [doc = " state came from."] # [doc = ""] # [doc = " This returns an error if `dst` became so big that `StateID`s can no"] # [doc = " longer be created for new states."] fn write_dense_trans (nnfa : & noncontiguous :: NFA , oldsid : StateID , classes : & ByteClasses , dst : & mut Vec < u32 > ,) -> Result < () , BuildError > { let start = dst . len () ; dst . extend (core :: iter :: repeat (noncontiguous :: NFA :: FAIL . as_u32 ()) . take (classes . alphabet_len ()) ,) ; if ! (start < dst . len ()) { { :: core :: panicking :: panic_fmt (format_args ! ("equivalence classes are never empty") ,) ; } } for t in nnfa . iter_trans (oldsid) { dst [start + usize :: from (classes . get (t . byte ()))] = t . next () . as_u32 () ; } Ok (()) } # [doc = " Return an iterator over every explicitly defined transition in this"] # [doc = " state."] fn transitions (& self) -> impl Iterator < Item = (u8 , StateID) > + '_ { let mut i = 0 ; core :: iter :: from_fn (move | | match self . trans { StateTrans :: Sparse { classes , nexts } => { if i >= nexts . len () { return None ; } let chunk = classes [i / 4] ; let class = chunk . to_ne_bytes () [i % 4] ; let next = StateID :: from_u32_unchecked (nexts [i]) ; i += 1 ; Some ((class , next)) } StateTrans :: One { class , next } => { if i == 0 { i += 1 ; Some ((class , StateID :: from_u32_unchecked (next))) } else { None } } StateTrans :: Dense { class_to_next } => { if i >= class_to_next . len () { return None ; } let class = i . as_u8 () ; let next = StateID :: from_u32_unchecked (class_to_next [i]) ; i += 1 ; Some ((class , next)) } }) } } impl < 'a > core :: fmt :: Debug for State < 'a > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { use crate :: { automaton :: sparse_transitions , util :: debug :: DebugByte } ; let it = sparse_transitions (self . transitions ()) . filter (| & (_ , _ , sid) | sid != NFA :: FAIL) . enumerate () ; for (i , (start , end , sid)) in it { if i > 0 { f . write_fmt (format_args ! (", ")) ? ; } if start == end { f . write_fmt (format_args ! ("{0:?} => {1:?}" , DebugByte (start) , sid . as_usize () ,) ,) ? ; } else { f . write_fmt (format_args ! ("{0:?}-{1:?} => {2:?}" , DebugByte (start) , DebugByte (end) , sid . as_usize () ,) ,) ? ; } } Ok (()) } } # [doc = " A builder for configuring an Aho-Corasick contiguous NFA."] # [doc = ""] # [doc = " This builder has a subset of the options available to a"] # [doc = " [`AhoCorasickBuilder`](crate::AhoCorasickBuilder). Of the shared options,"] # [doc = " their behavior is identical."] pub struct Builder { noncontiguous : noncontiguous :: Builder , dense_depth : usize , byte_classes : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { noncontiguous : :: core :: clone :: Clone :: clone (& self . noncontiguous) , dense_depth : :: core :: clone :: Clone :: clone (& self . dense_depth) , byte_classes : :: core :: clone :: Clone :: clone (& self . byte_classes) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "noncontiguous" , & self . noncontiguous , "dense_depth" , & self . dense_depth , "byte_classes" , & & self . byte_classes ,) } } impl Default for Builder { fn default () -> Builder { Builder { noncontiguous : noncontiguous :: Builder :: new () , dense_depth : 2 , byte_classes : true , } } } impl Builder { # [doc = " Create a new builder for configuring an Aho-Corasick contiguous NFA."] pub fn new () -> Builder { Builder :: default () } # [doc = " Build an Aho-Corasick contiguous NFA from the given iterator of"] # [doc = " patterns."] # [doc = ""] # [doc = " A builder may be reused to create more NFAs."] pub fn build < I , P > (& self , patterns : I) -> Result < NFA , BuildError > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { let nnfa = self . noncontiguous . build (patterns) ? ; self . build_from_noncontiguous (& nnfa) } # [doc = " Build an Aho-Corasick contiguous NFA from the given noncontiguous NFA."] # [doc = ""] # [doc = " Note that when this method is used, only the `dense_depth` and"] # [doc = " `byte_classes` settings on this builder are respected. The other"] # [doc = " settings only apply to the initial construction of the Aho-Corasick"] # [doc = " automaton. Since using this method requires that initial construction"] # [doc = " has already completed, all settings impacting only initial construction"] # [doc = " are no longer relevant."] pub fn build_from_noncontiguous (& self , nnfa : & noncontiguous :: NFA ,) -> Result < NFA , BuildError > { let byte_classes = if self . byte_classes { nnfa . byte_classes () . clone () } else { ByteClasses :: singletons () } ; let mut index_to_state_id = :: alloc :: vec :: from_elem (NFA :: DEAD , nnfa . states () . len () ,) ; let mut nfa = NFA { repr : :: alloc :: vec :: Vec :: new () , pattern_lens : nnfa . pattern_lens_raw () . to_vec () , state_len : nnfa . states () . len () , prefilter : nnfa . prefilter () . map (| p | p . clone ()) , match_kind : nnfa . match_kind () , alphabet_len : byte_classes . alphabet_len () , byte_classes , min_pattern_len : nnfa . min_pattern_len () , max_pattern_len : nnfa . max_pattern_len () , special : Special :: zero () , } ; for (oldsid , state) in nnfa . states () . iter () . with_state_ids () { if oldsid == noncontiguous :: NFA :: FAIL { index_to_state_id [oldsid] = NFA :: FAIL ; continue ; } let force_dense = state . depth () . as_usize () < self . dense_depth ; let newsid = State :: write (nnfa , oldsid , state , & nfa . byte_classes , & mut nfa . repr , force_dense ,) ? ; index_to_state_id [oldsid] = newsid ; } for & newsid in index_to_state_id . iter () { if newsid == NFA :: FAIL { continue ; } let state = & mut nfa . repr [newsid . as_usize () ..] ; State :: remap (nfa . alphabet_len , & index_to_state_id , state) ? ; } let remap = & index_to_state_id ; let old = nnfa . special () ; let new = & mut nfa . special ; new . max_special_id = remap [old . max_special_id] ; new . max_match_id = remap [old . max_match_id] ; new . start_unanchored_id = remap [old . start_unanchored_id] ; new . start_anchored_id = remap [old . start_anchored_id] ; nfa . repr . shrink_to_fit () ; nfa . pattern_lens . shrink_to_fit () ; Ok (nfa) } # [doc = " Set the desired match semantics."] # [doc = ""] # [doc = " This only applies when using [`Builder::build`] and not"] # [doc = " [`Builder::build_from_noncontiguous`]."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasickBuilder::match_kind`](crate::AhoCorasickBuilder::match_kind)"] # [doc = " for more documentation and examples."] pub fn match_kind (& mut self , kind : MatchKind) -> & mut Builder { self . noncontiguous . match_kind (kind) ; self } # [doc = " Enable ASCII-aware case insensitive matching."] # [doc = ""] # [doc = " This only applies when using [`Builder::build`] and not"] # [doc = " [`Builder::build_from_noncontiguous`]."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasickBuilder::ascii_case_insensitive`](crate::AhoCorasickBuilder::ascii_case_insensitive)"] # [doc = " for more documentation and examples."] pub fn ascii_case_insensitive (& mut self , yes : bool) -> & mut Builder { self . noncontiguous . ascii_case_insensitive (yes) ; self } # [doc = " Enable heuristic prefilter optimizations."] # [doc = ""] # [doc = " This only applies when using [`Builder::build`] and not"] # [doc = " [`Builder::build_from_noncontiguous`]."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasickBuilder::prefilter`](crate::AhoCorasickBuilder::prefilter)"] # [doc = " for more documentation and examples."] pub fn prefilter (& mut self , yes : bool) -> & mut Builder { self . noncontiguous . prefilter (yes) ; self } # [doc = " Set the limit on how many states use a dense representation for their"] # [doc = " transitions. Other states will generally use a sparse representation."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasickBuilder::dense_depth`](crate::AhoCorasickBuilder::dense_depth)"] # [doc = " for more documentation and examples."] pub fn dense_depth (& mut self , depth : usize) -> & mut Builder { self . dense_depth = depth ; self } # [doc = " A debug setting for whether to attempt to shrink the size of the"] # [doc = " automaton's alphabet or not."] # [doc = ""] # [doc = " This should never be enabled unless you're debugging an automaton."] # [doc = " Namely, disabling byte classes makes transitions easier to reason"] # [doc = " about, since they use the actual bytes instead of equivalence classes."] # [doc = " Disabling this confers no performance benefit at search time."] # [doc = ""] # [doc = " See"] # [doc = " [`AhoCorasickBuilder::byte_classes`](crate::AhoCorasickBuilder::byte_classes)"] # [doc = " for more documentation and examples."] pub fn byte_classes (& mut self , yes : bool) -> & mut Builder { self . byte_classes = yes ; self } } # [doc = " Computes the number of u32 values needed to represent one byte per the"] # [doc = " number of transitions given."] fn u32_len (ntrans : usize) -> usize { if ntrans % 4 == 0 { ntrans >> 2 } else { (ntrans >> 2) + 1 } } }