# [inline (always)] fn try_find_fwd_imp < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > , pre : Option < & Prefilter > , anchored : Anchored , earliest : bool ,) -> Result < Option < Match > , MatchError > { let mut sid = aut . start_state (input . get_anchored ()) ? ; let mut at = input . start () ; let mut mat = None ; if aut . is_match (sid) { mat = Some (get_match (aut , sid , 0 , at)) ; if earliest { return Ok (mat) ; } } if let Some (pre) = pre { match pre . find_in (input . haystack () , input . get_span ()) { Candidate :: None => return Ok (None) , Candidate :: Match (m) => return Ok (Some (m)) , Candidate :: PossibleStartOfMatch (i) => { at = i ; } } } while at < input . end () { sid = aut . next_state (anchored , sid , input . haystack () [at]) ; if aut . is_special (sid) { if aut . is_dead (sid) { return Ok (mat) ; } else if aut . is_match (sid) { let m = get_match (aut , sid , 0 , at + 1) ; if ! (anchored . is_anchored () && m . start () > input . start ()) { mat = Some (m) ; if earliest { return Ok (mat) ; } } } else if let Some (pre) = pre { if true { if ! aut . is_start (sid) { :: core :: panicking :: panic ("assertion failed: aut.is_start(sid)" ,) } } let span = Span :: from (at .. input . end ()) ; match pre . find_in (input . haystack () , span) . into_option () { None => return Ok (None) , Some (i) => { if i > at { at = i ; continue ; } } } } else { if true { if ! false { { :: core :: panicking :: panic_fmt (format_args ! ("unreachable")) ; } } } } } at += 1 ; } Ok (mat) }