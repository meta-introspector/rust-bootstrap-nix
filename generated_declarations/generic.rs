mod generic { use core :: fmt :: Debug ; use alloc :: { boxed :: Box , collections :: BTreeMap , format , sync :: Arc , vec , vec :: Vec , } ; use crate :: { packed :: { ext :: Pointer , pattern :: Patterns , vector :: { FatVector , Vector } } , util :: int :: U32 , PatternID , } ; # [doc = " A match type specialized to the Teddy implementations below."] # [doc = ""] # [doc = " Essentially, instead of representing a match at byte offsets, we use"] # [doc = " raw pointers. This is because the implementations below operate on raw"] # [doc = " pointers, and so this is a more natural return type based on how the"] # [doc = " implementation works."] # [doc = ""] # [doc = " Also, the `PatternID` used here is a `u16`."] pub (crate) struct Match { pid : PatternID , start : * const u8 , end : * const u8 , } # [automatically_derived] impl :: core :: clone :: Clone for Match { # [inline] fn clone (& self) -> Match { let _ : :: core :: clone :: AssertParamIsClone < PatternID > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for Match { } # [automatically_derived] impl :: core :: fmt :: Debug for Match { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Match" , "pid" , & self . pid , "start" , & self . start , "end" , & & self . end ,) } } impl Match { # [doc = " Returns the ID of the pattern that matched."] pub (crate) fn pattern (& self) -> PatternID { self . pid } # [doc = " Returns a pointer into the haystack at which the match starts."] pub (crate) fn start (& self) -> * const u8 { self . start } # [doc = " Returns a pointer into the haystack at which the match ends."] pub (crate) fn end (& self) -> * const u8 { self . end } } # [doc = " A \"slim\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Slim < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"slim\" Teddy verification."] teddy : Teddy < 8 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Slim < V , BYTES > { # [inline] fn clone (& self) -> Slim < V , BYTES > { Slim { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Slim < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Slim" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : Vector , const BYTES : usize > Slim < V , BYTES > { # [doc = " Create a new \"slim\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Slim < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = SlimMaskBuilder :: from_teddy (& teddy) ; Slim { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: BYTES + (BYTES - 1) } } impl < V : Vector > Slim < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : Vector > Slim < V , 2 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : Vector > Slim < V , 3 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : Vector > Slim < V , 4 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " A \"fat\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Fat < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"fat\" Teddy verification."] teddy : Teddy < 16 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Fat < V , BYTES > { # [inline] fn clone (& self) -> Fat < V , BYTES > { Fat { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Fat < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Fat" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : FatVector , const BYTES : usize > Fat < V , BYTES > { # [doc = " Create a new \"fat\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Fat < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = FatMaskBuilder :: from_teddy (& teddy) ; Fat { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: Half :: BYTES + (BYTES - 1) } } impl < V : FatVector > Fat < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_half_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : FatVector > Fat < V , 2 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : FatVector > Fat < V , 3 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : FatVector > Fat < V , 4 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . half_shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " The common elements of all \"slim\" and \"fat\" Teddy search implementations."] # [doc = ""] # [doc = " Essentially, this contains the patterns and the buckets. Namely, it"] # [doc = " contains enough to implement the verification step after candidates are"] # [doc = " identified via the shuffle masks."] # [doc = ""] # [doc = " It is generic over the number of buckets used. In general, the number of"] # [doc = " buckets is either 8 (for \"slim\" Teddy) or 16 (for \"fat\" Teddy). The generic"] # [doc = " parameter isn't really meant to be instantiated for any value other than"] # [doc = " 8 or 16, although it is technically possible. The main hiccup is that there"] # [doc = " is some bit-shifting done in the critical part of verification that could"] # [doc = " be quite expensive if `N` is not a multiple of 2."] struct Teddy < const BUCKETS : usize > { # [doc = " The patterns we are searching for."] # [doc = ""] # [doc = " A pattern string can be found by its `PatternID`."] patterns : Arc < Patterns > , # [doc = " The allocation of patterns in buckets. This only contains the IDs of"] # [doc = " patterns. In order to do full verification, callers must provide the"] # [doc = " actual patterns when using Teddy."] buckets : [Vec < PatternID > ; BUCKETS] , } # [automatically_derived] impl < const BUCKETS : usize > :: core :: clone :: Clone for Teddy < BUCKETS > { # [inline] fn clone (& self) -> Teddy < BUCKETS > { Teddy { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , buckets : :: core :: clone :: Clone :: clone (& self . buckets) , } } } # [automatically_derived] impl < const BUCKETS : usize > :: core :: fmt :: Debug for Teddy < BUCKETS > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Teddy" , "patterns" , & self . patterns , "buckets" , & & self . buckets ,) } } impl < const BUCKETS : usize > Teddy < BUCKETS > { # [doc = " Create a new generic data structure for Teddy verification."] fn new (patterns : Arc < Patterns >) -> Teddy < BUCKETS > { match (& (0) , & (patterns . len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy requires at least one pattern") ,) ,) ; } } } ; match (& (0) , & (patterns . minimum_len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy does not support zero-length patterns") ,) ,) ; } } } ; if ! (BUCKETS == 8 || BUCKETS == 16) { { :: core :: panicking :: panic_fmt (format_args ! ("Teddy only supports 8 or 16 buckets") ,) ; } } let buckets = < [Vec < PatternID , > ; BUCKETS] > :: try_from (:: alloc :: vec :: from_elem (:: alloc :: vec :: Vec :: new () , BUCKETS) ,) . unwrap () ; let mut t = Teddy { patterns , buckets } ; let mut map : BTreeMap < Box < [u8] > , usize > = BTreeMap :: new () ; for (id , pattern) in t . patterns . iter () { let lonybs = pattern . low_nybbles (t . mask_len ()) ; if let Some (& bucket) = map . get (& lonybs) { t . buckets [bucket] . push (id) ; } else { let bucket = (BUCKETS - 1) - (id . as_usize () % BUCKETS) ; t . buckets [bucket] . push (id) ; map . insert (lonybs , bucket) ; } } t } # [doc = " Verify whether there are any matches starting at or after `cur` in the"] # [doc = " haystack. The candidate chunk given should correspond to 8-bit bitsets"] # [doc = " for N buckets."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [inline (always)] unsafe fn verify64 (& self , cur : * const u8 , end : * const u8 , mut candidate_chunk : u64 ,) -> Option < Match > { while candidate_chunk != 0 { let bit = candidate_chunk . trailing_zeros () . as_usize () ; candidate_chunk &= ! (1 << bit) ; let cur = cur . add (bit / BUCKETS) ; let bucket = bit % BUCKETS ; if let Some (m) = self . verify_bucket (cur , end , bucket) { return Some (m) ; } } None } # [doc = " Verify whether there are any matches starting at `at` in the given"] # [doc = " `haystack` corresponding only to patterns in the given bucket."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " The bucket index must be less than or equal to `self.buckets.len()`."] # [inline (always)] unsafe fn verify_bucket (& self , cur : * const u8 , end : * const u8 , bucket : usize ,) -> Option < Match > { if true { if ! (bucket < self . buckets . len ()) { :: core :: panicking :: panic ("assertion failed: bucket < self.buckets.len()" ,) } } for pid in self . buckets . get_unchecked (bucket) . iter () . copied () { if true { if ! (pid . as_usize () < self . patterns . len ()) { :: core :: panicking :: panic ("assertion failed: pid.as_usize() < self.patterns.len()" ,) } } let pat = self . patterns . get_unchecked (pid) ; if pat . is_prefix_raw (cur , end) { let start = cur ; let end = start . add (pat . len ()) ; return Some (Match { pid , start , end }) ; } } None } # [doc = " Returns the total number of masks required by the patterns in this"] # [doc = " Teddy searcher."] # [doc = ""] # [doc = " Basically, the mask length corresponds to the type of Teddy searcher"] # [doc = " to use: a 1-byte, 2-byte, 3-byte or 4-byte searcher. The bigger the"] # [doc = " better, typically, since searching for longer substrings usually"] # [doc = " decreases the rate of false positives. Therefore, the number of masks"] # [doc = " needed is the length of the shortest pattern in this searcher. If the"] # [doc = " length of the shortest pattern (in bytes) is bigger than 4, then the"] # [doc = " mask length is 4 since there are no Teddy searchers for more than 4"] # [doc = " bytes."] fn mask_len (& self) -> usize { core :: cmp :: min (4 , self . patterns . minimum_len ()) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] fn memory_usage (& self) -> usize { self . patterns . len () * core :: mem :: size_of :: < PatternID > () } } impl Teddy < 8 > { # [doc = " Runs the verification routine for \"slim\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + j` in `cur` is in the bucket `i`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : Vector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } candidate . for_each_64bit_lane (# [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (8) ; result } ,) } } impl Teddy < 16 > { # [doc = " Runs the verification routine for \"fat\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + (j < 16 ? j : j - 16)` in `cur` is in the"] # [doc = " bucket `j < 16 ? i : i + 8`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : FatVector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } let swapped = candidate . swap_halves () ; let r1 = candidate . interleave_low_8bit_lanes (swapped) ; let r2 = candidate . interleave_high_8bit_lanes (swapped) ; r1 . for_each_low_64bit_lane (r2 , # [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (4) ; result } ,) } } # [doc = " A vector generic mask for the low and high nybbles in a set of patterns."] # [doc = " Each 8-bit lane `j` in a vector corresponds to a bitset where the `i`th bit"] # [doc = " is set if and only if the nybble `j` is in the bucket `i` at a particular"] # [doc = " position."] # [doc = ""] # [doc = " This is slightly tweaked dependending on whether Slim or Fat Teddy is being"] # [doc = " used. For Slim Teddy, the bitsets in the lower half are the same as the"] # [doc = " bitsets in the higher half, so that we can search `V::BYTES` bytes at a"] # [doc = " time. (Remember, the nybbles in the haystack are used as indices into these"] # [doc = " masks, and 256-bit shuffles only operate on 128-bit lanes.)"] # [doc = ""] # [doc = " For Fat Teddy, the bitsets are not repeated, but instead, the high half"] # [doc = " bits correspond to an addition 8 buckets. So that a bitset `00100010` has"] # [doc = " buckets 1 and 5 set if it's in the lower half, but has buckets 9 and 13 set"] # [doc = " if it's in the higher half."] struct Mask < V > { lo : V , hi : V , } # [automatically_derived] impl < V : :: core :: clone :: Clone > :: core :: clone :: Clone for Mask < V > { # [inline] fn clone (& self) -> Mask < V > { Mask { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl < V : :: core :: marker :: Copy > :: core :: marker :: Copy for Mask < V > { } # [automatically_derived] impl < V : :: core :: fmt :: Debug > :: core :: fmt :: Debug for Mask < V > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Mask" , "lo" , & self . lo , "hi" , & & self . hi ,) } } impl < V : Vector > Mask < V > { # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 1-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If a candidate is returned, it will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. If no candidate is found, then the vector returned will have all"] # [doc = " lanes set to zero."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " `mask1` should correspond to a low/high mask for the first byte of all"] # [doc = " patterns that are being searched."] # [inline (always)] unsafe fn members1 (chunk : V , masks : [Mask < V > ; 1]) -> V { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand = masks [0] . lo . shuffle_bytes (hlo) ; let hicand = masks [0] . hi . shuffle_bytes (hhi) ; locand . and (hicand) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 2-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first and second bytes"] # [doc = " of the patterns being searched. If no candidate is found, then all of"] # [doc = " the lanes will be set to zero in at least one of the vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first and"] # [doc = " second bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members2 (chunk : V , masks : [Mask < V > ; 2]) -> (V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; (cand1 , cand2) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 3-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second and third"] # [doc = " bytes of the patterns being searched. If no candidate is found, then"] # [doc = " all of the lanes will be set to zero in at least one of the vectors"] # [doc = " returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first, second"] # [doc = " and third bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members3 (chunk : V , masks : [Mask < V > ; 3]) -> (V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; (cand1 , cand2 , cand3) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 4-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second, third"] # [doc = " and fourth bytes of the patterns being searched. If no candidate is"] # [doc = " found, then all of the lanes will be set to zero in at least one of the"] # [doc = " vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first,"] # [doc = " second, third and fourth bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members4 (chunk : V , masks : [Mask < V > ; 4]) -> (V , V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; let locand4 = masks [3] . lo . shuffle_bytes (hlo) ; let hicand4 = masks [3] . hi . shuffle_bytes (hhi) ; let cand4 = locand4 . and (hicand4) ; (cand1 , cand2 , cand3 , cand4) } } # [doc = " Represents the low and high nybble masks that will be used during"] # [doc = " search. Each mask is 32 bytes wide, although only the first 16 bytes are"] # [doc = " used for 128-bit vectors."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] # [doc = ""] # [doc = " Each mask is used as the target of a shuffle, where the indices for the"] # [doc = " shuffle are taken from the haystack. AND'ing the shuffles for both the"] # [doc = " low and high masks together also results in 8-bit bitsets, but where bit"] # [doc = " `i` is set if and only if the correspond *byte* is in the ith bucket."] struct SlimMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for SlimMaskBuilder { # [inline] fn clone (& self) -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl :: core :: default :: Default for SlimMaskBuilder { # [inline] fn default () -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl SlimMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-7."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 8`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 8) { :: core :: panicking :: panic ("assertion failed: bucket < 8") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; self . lo [byte_lo] |= 1 << bucket ; self . lo [byte_lo + 16] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; self . hi [byte_hi + 16] |= 1 << bucket ; } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a slim"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 8 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (SlimMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [SlimMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for SlimMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("SlimMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } # [doc = " Represents the low and high nybble masks that will be used during \"fat\""] # [doc = " Teddy search."] # [doc = ""] # [doc = " Each mask is 32 bytes wide, and at the time of writing, only 256-bit vectors"] # [doc = " support fat Teddy."] # [doc = ""] # [doc = " A fat Teddy mask is like a slim Teddy mask, except that instead of"] # [doc = " repeating the bitsets in the high and low 128-bits in 256-bit vectors, the"] # [doc = " high and low 128-bit halves each represent distinct buckets. (Bringing the"] # [doc = " total to 16 instead of 8.) This permits spreading the patterns out a bit"] # [doc = " more and thus putting less pressure on verification to be fast."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] struct FatMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for FatMaskBuilder { # [inline] fn clone (& self) -> FatMaskBuilder { let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for FatMaskBuilder { } # [automatically_derived] impl :: core :: default :: Default for FatMaskBuilder { # [inline] fn default () -> FatMaskBuilder { FatMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl FatMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-15."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 16`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 16) { :: core :: panicking :: panic ("assertion failed: bucket < 16") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; if bucket < 8 { self . lo [byte_lo] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; } else { self . lo [byte_lo + 16] |= 1 << (bucket % 8) ; self . hi [byte_hi + 16] |= 1 << (bucket % 8) ; } } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a fat"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 16 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (FatMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [FatMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for FatMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("FatMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } }