mod teddy { # ! [allow (dead_code)] pub (crate) use self :: builder :: { Builder , Searcher } ; mod builder { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; use alloc :: sync :: Arc ; use crate :: packed :: { ext :: Pointer , pattern :: Patterns , teddy :: generic :: Match } ; # [doc = " A builder for constructing a Teddy matcher."] # [doc = ""] # [doc = " The builder primarily permits fine grained configuration of the Teddy"] # [doc = " matcher. Most options are made only available for testing/benchmarking"] # [doc = " purposes. In reality, options are automatically determined by the nature"] # [doc = " and number of patterns given to the builder."] pub (crate) struct Builder { # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " slim Teddy is used (8 buckets) and `true` means fat Teddy is used"] # [doc = " (16 buckets). Fat Teddy requires AVX2, so if that CPU feature isn't"] # [doc = " available and Fat Teddy was requested, no matcher will be built."] only_fat : Option < bool > , # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " that 128-bit vectors will be used (up to SSSE3 instructions) where as"] # [doc = " `true` means that 256-bit vectors will be used. As with `fat`, if"] # [doc = " 256-bit vectors are requested and they aren't available, then a"] # [doc = " searcher will not be built."] only_256bit : Option < bool > , # [doc = " When true (the default), the number of patterns will be used as a"] # [doc = " heuristic for refusing construction of a Teddy searcher. The point here"] # [doc = " is that too many patterns can overwhelm Teddy. But this can be disabled"] # [doc = " in cases where the caller knows better."] heuristic_pattern_limits : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { only_fat : :: core :: clone :: Clone :: clone (& self . only_fat) , only_256bit : :: core :: clone :: Clone :: clone (& self . only_256bit) , heuristic_pattern_limits : :: core :: clone :: Clone :: clone (& self . heuristic_pattern_limits ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "only_fat" , & self . only_fat , "only_256bit" , & self . only_256bit , "heuristic_pattern_limits" , & & self . heuristic_pattern_limits ,) } } impl Default for Builder { fn default () -> Builder { Builder :: new () } } impl Builder { # [doc = " Create a new builder for configuring a Teddy matcher."] pub (crate) fn new () -> Builder { Builder { only_fat : None , only_256bit : None , heuristic_pattern_limits : true , } } # [doc = " Build a matcher for the set of patterns given. If a matcher could not"] # [doc = " be built, then `None` is returned."] # [doc = ""] # [doc = " Generally, a matcher isn't built if the necessary CPU features aren't"] # [doc = " available, an unsupported target or if the searcher is believed to be"] # [doc = " slower than standard techniques (i.e., if there are too many literals)."] pub (crate) fn build (& self , patterns : Arc < Patterns >) -> Option < Searcher > { self . build_imp (patterns) } # [doc = " Require the use of Fat (true) or Slim (false) Teddy. Fat Teddy uses"] # [doc = " 16 buckets where as Slim Teddy uses 8 buckets. More buckets are useful"] # [doc = " for a larger set of literals."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based"] # [doc = " on the number of literals and available CPU features."] pub (crate) fn only_fat (& mut self , yes : Option < bool >) -> & mut Builder { self . only_fat = yes ; self } # [doc = " Request the use of 256-bit vectors (true) or 128-bit vectors (false)."] # [doc = " Generally, a larger vector size is better since it either permits"] # [doc = " matching more patterns or matching more bytes in the haystack at once."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based on"] # [doc = " the number of literals and available CPU features."] pub (crate) fn only_256bit (& mut self , yes : Option < bool >) -> & mut Builder { self . only_256bit = yes ; self } # [doc = " Request that heuristic limitations on the number of patterns be"] # [doc = " employed. This useful to disable for benchmarking where one wants to"] # [doc = " explore how Teddy performs on large number of patterns even if the"] # [doc = " heuristics would otherwise refuse construction."] # [doc = ""] # [doc = " This is enabled by default."] pub (crate) fn heuristic_pattern_limits (& mut self , yes : bool ,) -> & mut Builder { self . heuristic_pattern_limits = yes ; self } fn build_imp (& self , patterns : Arc < Patterns >) -> Option < Searcher > { let patlimit = self . heuristic_pattern_limits ; if ! true { return None ; } if patlimit && patterns . len () > 64 { return None ; } { use self :: aarch64 :: SlimNeon ; let mask_len = core :: cmp :: min (4 , patterns . minimum_len ()) ; if self . only_256bit == Some (true) { return None ; } if self . only_fat == Some (true) { } match mask_len { 1 => { if patlimit && patterns . len () > 16 { } SlimNeon :: < 1 > :: new (& patterns) } 2 => { if patlimit && patterns . len () > 32 { } SlimNeon :: < 2 > :: new (& patterns) } 3 => { if patlimit && patterns . len () > 48 { } SlimNeon :: < 3 > :: new (& patterns) } 4 => { SlimNeon :: < 4 > :: new (& patterns) } _ => { None } } } } } # [doc = " A searcher that dispatches to one of several possible Teddy variants."] pub (crate) struct Searcher { # [doc = " The Teddy variant we use. We use dynamic dispatch under the theory that"] # [doc = " it results in better codegen then a enum, although this is a specious"] # [doc = " claim."] # [doc = ""] # [doc = " This `Searcher` is essentially a wrapper for a `SearcherT` trait"] # [doc = " object. We just make `memory_usage` and `minimum_len` available without"] # [doc = " going through dynamic dispatch."] imp : Arc < dyn SearcherT > , # [doc = " Total heap memory used by the Teddy variant."] memory_usage : usize , # [doc = " The minimum haystack length this searcher can handle. It is intended"] # [doc = " for callers to use some other search routine (such as Rabin-Karp) in"] # [doc = " cases where the haystack (or remainer of the haystack) is too short."] minimum_len : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Searcher { # [inline] fn clone (& self) -> Searcher { Searcher { imp : :: core :: clone :: Clone :: clone (& self . imp) , memory_usage : :: core :: clone :: Clone :: clone (& self . memory_usage) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Searcher { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Searcher" , "imp" , & self . imp , "memory_usage" , & self . memory_usage , "minimum_len" , & & self . minimum_len ,) } } impl Searcher { # [doc = " Look for the leftmost occurrence of any pattern in this search in the"] # [doc = " given haystack starting at the given position."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `haystack[at..].len()` is less than the minimum length"] # [doc = " for this haystack."] # [inline (always)] pub (crate) fn find (& self , haystack : & [u8] , at : usize ,) -> Option < crate :: Match > { if ! (haystack [at ..] . len () >= self . minimum_len) { :: core :: panicking :: panic ("assertion failed: haystack[at..].len() >= self.minimum_len" ,) } let hayptr = haystack . as_ptr () ; let teddym = unsafe { self . imp . find (hayptr . add (at) , hayptr . add (haystack . len ())) ? } ; let start = teddym . start () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let end = teddym . end () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let span = crate :: Span { start , end } ; let pid = crate :: PatternID :: new_unchecked (teddym . pattern () . as_usize () ,) ; let m = crate :: Match :: new (pid , span) ; Some (m) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . memory_usage } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { self . minimum_len } } # [doc = " A trait that provides dynamic dispatch over the different possible Teddy"] # [doc = " variants on the same algorithm."] # [doc = ""] # [doc = " On `x86_64` for example, it isn't known until runtime which of 12 possible"] # [doc = " variants will be used. One might use one of the four slim 128-bit vector"] # [doc = " variants, or one of the four 256-bit vector variants or even one of the"] # [doc = " four fat 256-bit vector variants."] # [doc = ""] # [doc = " Since this choice is generally made when the Teddy searcher is constructed"] # [doc = " and this choice is based on the patterns given and what the current CPU"] # [doc = " supports, it follows that there must be some kind of indirection at search"] # [doc = " time that \"selects\" the variant chosen at build time."] # [doc = ""] # [doc = " There are a few different ways to go about this. One approach is to use an"] # [doc = " enum. It works fine, but in my experiments, this generally results in worse"] # [doc = " codegen. Another approach, which is what we use here, is dynamic dispatch"] # [doc = " via a trait object. We basically implement this trait for each possible"] # [doc = " variant, select the variant we want at build time and convert it to a"] # [doc = " trait object for use at search time."] # [doc = ""] # [doc = " Another approach is to use function pointers and stick each of the possible"] # [doc = " variants into a union. This is essentially isomorphic to the dynamic"] # [doc = " dispatch approach, but doesn't require any allocations. Since this crate"] # [doc = " requires `alloc`, there's no real reason (AFAIK) to go down this path. (The"] # [doc = " `memchr` crate does this.)"] trait SearcherT : Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static { # [doc = " Execute a search on the given haystack (identified by `start` and `end`"] # [doc = " raw pointers)."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Essentially, the `start` and `end` pointers must be valid and point"] # [doc = " to a haystack one can read. As long as you derive them from, for"] # [doc = " example, a `&[u8]`, they should automatically satisfy all of the safety"] # [doc = " obligations:"] # [doc = ""] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [doc = " * It must be the case that `start <= end`."] # [doc = " * `end - start` must be greater than the minimum length for this"] # [doc = " searcher."] # [doc = ""] # [doc = " Also, it is expected that implementations of this trait will tag this"] # [doc = " method with a `target_feature` attribute. Callers must ensure that"] # [doc = " they are executing this method in an environment where that attribute"] # [doc = " is valid."] unsafe fn find (& self , start : * const u8 , end : * const u8) -> Option < Match > ; } mod aarch64 { use core :: arch :: aarch64 :: uint8x16_t ; use alloc :: sync :: Arc ; use crate :: packed :: { pattern :: Patterns , teddy :: generic :: { self , Match } } ; use super :: { Searcher , SearcherT } ; pub (super) struct SlimNeon < const BYTES : usize > { slim128 : generic :: Slim < uint8x16_t , BYTES > , } # [automatically_derived] impl < const BYTES : usize > :: core :: clone :: Clone for SlimNeon < BYTES > { # [inline] fn clone (& self) -> SlimNeon < BYTES > { SlimNeon { slim128 : :: core :: clone :: Clone :: clone (& self . slim128) , } } } # [automatically_derived] impl < const BYTES : usize > :: core :: fmt :: Debug for SlimNeon < BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter ,) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SlimNeon" , "slim128" , & & self . slim128 ,) } } impl SlimNeon < 1 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 1 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 1 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 1 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 2 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 2 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 2 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 2 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 3 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 3 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 3 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 3 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 4 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 4 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 4 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 4 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } } } mod generic { use core :: fmt :: Debug ; use alloc :: { boxed :: Box , collections :: BTreeMap , format , sync :: Arc , vec , vec :: Vec , } ; use crate :: { packed :: { ext :: Pointer , pattern :: Patterns , vector :: { FatVector , Vector } } , util :: int :: U32 , PatternID , } ; # [doc = " A match type specialized to the Teddy implementations below."] # [doc = ""] # [doc = " Essentially, instead of representing a match at byte offsets, we use"] # [doc = " raw pointers. This is because the implementations below operate on raw"] # [doc = " pointers, and so this is a more natural return type based on how the"] # [doc = " implementation works."] # [doc = ""] # [doc = " Also, the `PatternID` used here is a `u16`."] pub (crate) struct Match { pid : PatternID , start : * const u8 , end : * const u8 , } # [automatically_derived] impl :: core :: clone :: Clone for Match { # [inline] fn clone (& self) -> Match { let _ : :: core :: clone :: AssertParamIsClone < PatternID > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; let _ : :: core :: clone :: AssertParamIsClone < * const u8 > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for Match { } # [automatically_derived] impl :: core :: fmt :: Debug for Match { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Match" , "pid" , & self . pid , "start" , & self . start , "end" , & & self . end ,) } } impl Match { # [doc = " Returns the ID of the pattern that matched."] pub (crate) fn pattern (& self) -> PatternID { self . pid } # [doc = " Returns a pointer into the haystack at which the match starts."] pub (crate) fn start (& self) -> * const u8 { self . start } # [doc = " Returns a pointer into the haystack at which the match ends."] pub (crate) fn end (& self) -> * const u8 { self . end } } # [doc = " A \"slim\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Slim < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"slim\" Teddy verification."] teddy : Teddy < 8 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Slim < V , BYTES > { # [inline] fn clone (& self) -> Slim < V , BYTES > { Slim { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Slim < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Slim" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : Vector , const BYTES : usize > Slim < V , BYTES > { # [doc = " Create a new \"slim\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Slim < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = SlimMaskBuilder :: from_teddy (& teddy) ; Slim { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: BYTES + (BYTES - 1) } } impl < V : Vector > Slim < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : Vector > Slim < V , 2 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : Vector > Slim < V , 3 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : Vector > Slim < V , 4 > { # [doc = " See Slim<V, 1>::find."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: BYTES) ; } if cur < end { cur = end . sub (V :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::find_one."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See Slim<V, 1>::candidate."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " A \"fat\" Teddy implementation that is generic over both the vector type"] # [doc = " and the minimum length of the patterns being searched for."] # [doc = ""] # [doc = " Only 1, 2, 3 and 4 bytes are supported as minimum lengths."] pub (crate) struct Fat < V , const BYTES : usize > { # [doc = " A generic data structure for doing \"fat\" Teddy verification."] teddy : Teddy < 16 > , # [doc = " The masks used as inputs to the shuffle operation to generate"] # [doc = " candidates (which are fed into the verification routines)."] masks : [Mask < V > ; BYTES] , } # [automatically_derived] impl < V : :: core :: clone :: Clone , const BYTES : usize > :: core :: clone :: Clone for Fat < V , BYTES > { # [inline] fn clone (& self) -> Fat < V , BYTES > { Fat { teddy : :: core :: clone :: Clone :: clone (& self . teddy) , masks : :: core :: clone :: Clone :: clone (& self . masks) , } } } # [automatically_derived] impl < V : :: core :: fmt :: Debug , const BYTES : usize > :: core :: fmt :: Debug for Fat < V , BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Fat" , "teddy" , & self . teddy , "masks" , & & self . masks ,) } } impl < V : FatVector , const BYTES : usize > Fat < V , BYTES > { # [doc = " Create a new \"fat\" Teddy searcher for the given patterns."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `BYTES` is any value other than 1, 2, 3 or 4."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn new (patterns : Arc < Patterns >) -> Fat < V , BYTES > { if ! (1 <= BYTES && BYTES <= 4) { { :: core :: panicking :: panic_fmt (format_args ! ("only 1, 2, 3 or 4 bytes are supported") ,) ; } } let teddy = Teddy :: new (patterns) ; let masks = FatMaskBuilder :: from_teddy (& teddy) ; Fat { teddy , masks } } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . teddy . memory_usage () } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { V :: Half :: BYTES + (BYTES - 1) } } impl < V : FatVector > Fat < V , 1 > { # [doc = " Look for an occurrences of the patterns in this finder in the haystack"] # [doc = " given by the `start` and `end` pointers."] # [doc = ""] # [doc = " If no match could be found, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; if let Some (m) = self . find_one (cur , end) { return Some (m) ; } } None } # [doc = " Look for a match starting at the `V::BYTES` at and after `cur`. If"] # [doc = " there isn't one, then `None` is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from. They must also point to a region of memory that is at least the"] # [doc = " minimum length required by this searcher."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 ,) -> Option < Match > { let c = self . candidate (cur) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur , end , c) { return Some (m) ; } } None } # [doc = " Look for a candidate match (represented as a vector) starting at the"] # [doc = " `V::BYTES` at and after `cur`. If there isn't one, then a vector with"] # [doc = " all bits set to zero is returned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointer representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8) -> V { let chunk = V :: load_half_unaligned (cur) ; Mask :: members1 (chunk , self . masks) } } impl < V : FatVector > Fat < V , 2 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (1) ; let mut prev0 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (1) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1) = Mask :: members2 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_one_byte (* prev0) ; let res = res0prev0 . and (res1) ; * prev0 = res0 ; res } } impl < V : FatVector > Fat < V , 3 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (2) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (2) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2) = Mask :: members3 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_two_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_one_byte (* prev1) ; let res = res0prev0 . and (res1prev1) . and (res2) ; * prev0 = res0 ; * prev1 = res1 ; res } } impl < V : FatVector > Fat < V , 4 > { # [doc = " See `Fat<V, 1>::find`."] # [inline (always)] pub (crate) unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { let len = end . distance (start) ; if true { if ! (len >= self . minimum_len ()) { :: core :: panicking :: panic ("assertion failed: len >= self.minimum_len()" ,) } } let mut cur = start . add (3) ; let mut prev0 = V :: splat (0xFF) ; let mut prev1 = V :: splat (0xFF) ; let mut prev2 = V :: splat (0xFF) ; while cur <= end . sub (V :: Half :: BYTES) { if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } cur = cur . add (V :: Half :: BYTES) ; } if cur < end { cur = end . sub (V :: Half :: BYTES) ; prev0 = V :: splat (0xFF) ; prev1 = V :: splat (0xFF) ; prev2 = V :: splat (0xFF) ; if let Some (m) = self . find_one (cur , end , & mut prev0 , & mut prev1 , & mut prev2) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::find_one`."] # [inline (always)] unsafe fn find_one (& self , cur : * const u8 , end : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> Option < Match > { let c = self . candidate (cur , prev0 , prev1 , prev2) ; if ! c . is_zero () { if let Some (m) = self . teddy . verify (cur . sub (3) , end , c) { return Some (m) ; } } None } # [doc = " See `Fat<V, 1>::candidate`."] # [inline (always)] unsafe fn candidate (& self , cur : * const u8 , prev0 : & mut V , prev1 : & mut V , prev2 : & mut V ,) -> V { let chunk = V :: load_half_unaligned (cur) ; let (res0 , res1 , res2 , res3) = Mask :: members4 (chunk , self . masks) ; let res0prev0 = res0 . half_shift_in_three_bytes (* prev0) ; let res1prev1 = res1 . half_shift_in_two_bytes (* prev1) ; let res2prev2 = res2 . half_shift_in_one_byte (* prev2) ; let res = res0prev0 . and (res1prev1) . and (res2prev2) . and (res3) ; * prev0 = res0 ; * prev1 = res1 ; * prev2 = res2 ; res } } # [doc = " The common elements of all \"slim\" and \"fat\" Teddy search implementations."] # [doc = ""] # [doc = " Essentially, this contains the patterns and the buckets. Namely, it"] # [doc = " contains enough to implement the verification step after candidates are"] # [doc = " identified via the shuffle masks."] # [doc = ""] # [doc = " It is generic over the number of buckets used. In general, the number of"] # [doc = " buckets is either 8 (for \"slim\" Teddy) or 16 (for \"fat\" Teddy). The generic"] # [doc = " parameter isn't really meant to be instantiated for any value other than"] # [doc = " 8 or 16, although it is technically possible. The main hiccup is that there"] # [doc = " is some bit-shifting done in the critical part of verification that could"] # [doc = " be quite expensive if `N` is not a multiple of 2."] struct Teddy < const BUCKETS : usize > { # [doc = " The patterns we are searching for."] # [doc = ""] # [doc = " A pattern string can be found by its `PatternID`."] patterns : Arc < Patterns > , # [doc = " The allocation of patterns in buckets. This only contains the IDs of"] # [doc = " patterns. In order to do full verification, callers must provide the"] # [doc = " actual patterns when using Teddy."] buckets : [Vec < PatternID > ; BUCKETS] , } # [automatically_derived] impl < const BUCKETS : usize > :: core :: clone :: Clone for Teddy < BUCKETS > { # [inline] fn clone (& self) -> Teddy < BUCKETS > { Teddy { patterns : :: core :: clone :: Clone :: clone (& self . patterns) , buckets : :: core :: clone :: Clone :: clone (& self . buckets) , } } } # [automatically_derived] impl < const BUCKETS : usize > :: core :: fmt :: Debug for Teddy < BUCKETS > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Teddy" , "patterns" , & self . patterns , "buckets" , & & self . buckets ,) } } impl < const BUCKETS : usize > Teddy < BUCKETS > { # [doc = " Create a new generic data structure for Teddy verification."] fn new (patterns : Arc < Patterns >) -> Teddy < BUCKETS > { match (& (0) , & (patterns . len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy requires at least one pattern") ,) ,) ; } } } ; match (& (0) , & (patterns . minimum_len ())) { (left_val , right_val) => { if * left_val == * right_val { let kind = :: core :: panicking :: AssertKind :: Ne ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: Some (format_args ! ("Teddy does not support zero-length patterns") ,) ,) ; } } } ; if ! (BUCKETS == 8 || BUCKETS == 16) { { :: core :: panicking :: panic_fmt (format_args ! ("Teddy only supports 8 or 16 buckets") ,) ; } } let buckets = < [Vec < PatternID , > ; BUCKETS] > :: try_from (:: alloc :: vec :: from_elem (:: alloc :: vec :: Vec :: new () , BUCKETS) ,) . unwrap () ; let mut t = Teddy { patterns , buckets } ; let mut map : BTreeMap < Box < [u8] > , usize > = BTreeMap :: new () ; for (id , pattern) in t . patterns . iter () { let lonybs = pattern . low_nybbles (t . mask_len ()) ; if let Some (& bucket) = map . get (& lonybs) { t . buckets [bucket] . push (id) ; } else { let bucket = (BUCKETS - 1) - (id . as_usize () % BUCKETS) ; t . buckets [bucket] . push (id) ; map . insert (lonybs , bucket) ; } } t } # [doc = " Verify whether there are any matches starting at or after `cur` in the"] # [doc = " haystack. The candidate chunk given should correspond to 8-bit bitsets"] # [doc = " for N buckets."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [inline (always)] unsafe fn verify64 (& self , cur : * const u8 , end : * const u8 , mut candidate_chunk : u64 ,) -> Option < Match > { while candidate_chunk != 0 { let bit = candidate_chunk . trailing_zeros () . as_usize () ; candidate_chunk &= ! (1 << bit) ; let cur = cur . add (bit / BUCKETS) ; let bucket = bit % BUCKETS ; if let Some (m) = self . verify_bucket (cur , end , bucket) { return Some (m) ; } } None } # [doc = " Verify whether there are any matches starting at `at` in the given"] # [doc = " `haystack` corresponding only to patterns in the given bucket."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " The given pointers representing the haystack must be valid to read"] # [doc = " from."] # [doc = ""] # [doc = " The bucket index must be less than or equal to `self.buckets.len()`."] # [inline (always)] unsafe fn verify_bucket (& self , cur : * const u8 , end : * const u8 , bucket : usize ,) -> Option < Match > { if true { if ! (bucket < self . buckets . len ()) { :: core :: panicking :: panic ("assertion failed: bucket < self.buckets.len()" ,) } } for pid in self . buckets . get_unchecked (bucket) . iter () . copied () { if true { if ! (pid . as_usize () < self . patterns . len ()) { :: core :: panicking :: panic ("assertion failed: pid.as_usize() < self.patterns.len()" ,) } } let pat = self . patterns . get_unchecked (pid) ; if pat . is_prefix_raw (cur , end) { let start = cur ; let end = start . add (pat . len ()) ; return Some (Match { pid , start , end }) ; } } None } # [doc = " Returns the total number of masks required by the patterns in this"] # [doc = " Teddy searcher."] # [doc = ""] # [doc = " Basically, the mask length corresponds to the type of Teddy searcher"] # [doc = " to use: a 1-byte, 2-byte, 3-byte or 4-byte searcher. The bigger the"] # [doc = " better, typically, since searching for longer substrings usually"] # [doc = " decreases the rate of false positives. Therefore, the number of masks"] # [doc = " needed is the length of the shortest pattern in this searcher. If the"] # [doc = " length of the shortest pattern (in bytes) is bigger than 4, then the"] # [doc = " mask length is 4 since there are no Teddy searchers for more than 4"] # [doc = " bytes."] fn mask_len (& self) -> usize { core :: cmp :: min (4 , self . patterns . minimum_len ()) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] fn memory_usage (& self) -> usize { self . patterns . len () * core :: mem :: size_of :: < PatternID > () } } impl Teddy < 8 > { # [doc = " Runs the verification routine for \"slim\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + j` in `cur` is in the bucket `i`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : Vector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } candidate . for_each_64bit_lane (# [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (8) ; result } ,) } } impl Teddy < 16 > { # [doc = " Runs the verification routine for \"fat\" Teddy."] # [doc = ""] # [doc = " The candidate given should be a collection of 8-bit bitsets (one bitset"] # [doc = " per lane), where the ith bit is set in the jth lane if and only if the"] # [doc = " byte occurring at `at + (j < 16 ? j : j - 16)` in `cur` is in the"] # [doc = " bucket `j < 16 ? i : i + 8`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " The given pointers must be valid to read from."] # [inline (always)] unsafe fn verify < V : FatVector > (& self , mut cur : * const u8 , end : * const u8 , candidate : V ,) -> Option < Match > { if true { if ! ! candidate . is_zero () { :: core :: panicking :: panic ("assertion failed: !candidate.is_zero()" ,) } } let swapped = candidate . swap_halves () ; let r1 = candidate . interleave_low_8bit_lanes (swapped) ; let r2 = candidate . interleave_high_8bit_lanes (swapped) ; r1 . for_each_low_64bit_lane (r2 , # [inline (always)] | _ , chunk | { let result = self . verify64 (cur , end , chunk) ; cur = cur . add (4) ; result } ,) } } # [doc = " A vector generic mask for the low and high nybbles in a set of patterns."] # [doc = " Each 8-bit lane `j` in a vector corresponds to a bitset where the `i`th bit"] # [doc = " is set if and only if the nybble `j` is in the bucket `i` at a particular"] # [doc = " position."] # [doc = ""] # [doc = " This is slightly tweaked dependending on whether Slim or Fat Teddy is being"] # [doc = " used. For Slim Teddy, the bitsets in the lower half are the same as the"] # [doc = " bitsets in the higher half, so that we can search `V::BYTES` bytes at a"] # [doc = " time. (Remember, the nybbles in the haystack are used as indices into these"] # [doc = " masks, and 256-bit shuffles only operate on 128-bit lanes.)"] # [doc = ""] # [doc = " For Fat Teddy, the bitsets are not repeated, but instead, the high half"] # [doc = " bits correspond to an addition 8 buckets. So that a bitset `00100010` has"] # [doc = " buckets 1 and 5 set if it's in the lower half, but has buckets 9 and 13 set"] # [doc = " if it's in the higher half."] struct Mask < V > { lo : V , hi : V , } # [automatically_derived] impl < V : :: core :: clone :: Clone > :: core :: clone :: Clone for Mask < V > { # [inline] fn clone (& self) -> Mask < V > { Mask { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl < V : :: core :: marker :: Copy > :: core :: marker :: Copy for Mask < V > { } # [automatically_derived] impl < V : :: core :: fmt :: Debug > :: core :: fmt :: Debug for Mask < V > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Mask" , "lo" , & self . lo , "hi" , & & self . hi ,) } } impl < V : Vector > Mask < V > { # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 1-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If a candidate is returned, it will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. If no candidate is found, then the vector returned will have all"] # [doc = " lanes set to zero."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " `mask1` should correspond to a low/high mask for the first byte of all"] # [doc = " patterns that are being searched."] # [inline (always)] unsafe fn members1 (chunk : V , masks : [Mask < V > ; 1]) -> V { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand = masks [0] . lo . shuffle_bytes (hlo) ; let hicand = masks [0] . hi . shuffle_bytes (hhi) ; locand . and (hicand) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 2-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first and second bytes"] # [doc = " of the patterns being searched. If no candidate is found, then all of"] # [doc = " the lanes will be set to zero in at least one of the vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first and"] # [doc = " second bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members2 (chunk : V , masks : [Mask < V > ; 2]) -> (V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; (cand1 , cand2) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 3-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second and third"] # [doc = " bytes of the patterns being searched. If no candidate is found, then"] # [doc = " all of the lanes will be set to zero in at least one of the vectors"] # [doc = " returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first, second"] # [doc = " and third bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members3 (chunk : V , masks : [Mask < V > ; 3]) -> (V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; (cand1 , cand2 , cand3) } # [doc = " Return a candidate for Teddy (fat or slim) that is searching for 4-byte"] # [doc = " candidates."] # [doc = ""] # [doc = " If candidates are returned, each will be a collection of 8-bit bitsets"] # [doc = " (one bitset per lane), where the ith bit is set in the jth lane if and"] # [doc = " only if the byte occurring at the jth lane in `chunk` is in the bucket"] # [doc = " `i`. Each candidate returned corresponds to the first, second, third"] # [doc = " and fourth bytes of the patterns being searched. If no candidate is"] # [doc = " found, then all of the lanes will be set to zero in at least one of the"] # [doc = " vectors returned."] # [doc = ""] # [doc = " `chunk` should correspond to a `V::BYTES` window of the haystack (where"] # [doc = " the least significant byte corresponds to the start of the window). For"] # [doc = " fat Teddy, the haystack window length should be `V::BYTES / 2`, with"] # [doc = " the window repeated in each half of the vector."] # [doc = ""] # [doc = " The masks should correspond to the masks computed for the first,"] # [doc = " second, third and fourth bytes of all patterns that are being searched."] # [inline (always)] unsafe fn members4 (chunk : V , masks : [Mask < V > ; 4]) -> (V , V , V , V) { let lomask = V :: splat (0xF) ; let hlo = chunk . and (lomask) ; let hhi = chunk . shift_8bit_lane_right :: < 4 > () . and (lomask) ; let locand1 = masks [0] . lo . shuffle_bytes (hlo) ; let hicand1 = masks [0] . hi . shuffle_bytes (hhi) ; let cand1 = locand1 . and (hicand1) ; let locand2 = masks [1] . lo . shuffle_bytes (hlo) ; let hicand2 = masks [1] . hi . shuffle_bytes (hhi) ; let cand2 = locand2 . and (hicand2) ; let locand3 = masks [2] . lo . shuffle_bytes (hlo) ; let hicand3 = masks [2] . hi . shuffle_bytes (hhi) ; let cand3 = locand3 . and (hicand3) ; let locand4 = masks [3] . lo . shuffle_bytes (hlo) ; let hicand4 = masks [3] . hi . shuffle_bytes (hhi) ; let cand4 = locand4 . and (hicand4) ; (cand1 , cand2 , cand3 , cand4) } } # [doc = " Represents the low and high nybble masks that will be used during"] # [doc = " search. Each mask is 32 bytes wide, although only the first 16 bytes are"] # [doc = " used for 128-bit vectors."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] # [doc = ""] # [doc = " Each mask is used as the target of a shuffle, where the indices for the"] # [doc = " shuffle are taken from the haystack. AND'ing the shuffles for both the"] # [doc = " low and high masks together also results in 8-bit bitsets, but where bit"] # [doc = " `i` is set if and only if the correspond *byte* is in the ith bucket."] struct SlimMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for SlimMaskBuilder { # [inline] fn clone (& self) -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: clone :: Clone :: clone (& self . lo) , hi : :: core :: clone :: Clone :: clone (& self . hi) , } } } # [automatically_derived] impl :: core :: default :: Default for SlimMaskBuilder { # [inline] fn default () -> SlimMaskBuilder { SlimMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl SlimMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-7."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 8`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 8) { :: core :: panicking :: panic ("assertion failed: bucket < 8") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; self . lo [byte_lo] |= 1 << bucket ; self . lo [byte_lo + 16] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; self . hi [byte_hi + 16] |= 1 << bucket ; } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a slim"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 8 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (SlimMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [SlimMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for SlimMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("SlimMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } # [doc = " Represents the low and high nybble masks that will be used during \"fat\""] # [doc = " Teddy search."] # [doc = ""] # [doc = " Each mask is 32 bytes wide, and at the time of writing, only 256-bit vectors"] # [doc = " support fat Teddy."] # [doc = ""] # [doc = " A fat Teddy mask is like a slim Teddy mask, except that instead of"] # [doc = " repeating the bitsets in the high and low 128-bits in 256-bit vectors, the"] # [doc = " high and low 128-bit halves each represent distinct buckets. (Bringing the"] # [doc = " total to 16 instead of 8.) This permits spreading the patterns out a bit"] # [doc = " more and thus putting less pressure on verification to be fast."] # [doc = ""] # [doc = " Each byte in the mask corresponds to a 8-bit bitset, where bit `i` is set"] # [doc = " if and only if the corresponding nybble is in the ith bucket. The index of"] # [doc = " the byte (0-15, inclusive) corresponds to the nybble."] struct FatMaskBuilder { lo : [u8 ; 32] , hi : [u8 ; 32] , } # [automatically_derived] impl :: core :: clone :: Clone for FatMaskBuilder { # [inline] fn clone (& self) -> FatMaskBuilder { let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 32] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for FatMaskBuilder { } # [automatically_derived] impl :: core :: default :: Default for FatMaskBuilder { # [inline] fn default () -> FatMaskBuilder { FatMaskBuilder { lo : :: core :: default :: Default :: default () , hi : :: core :: default :: Default :: default () , } } } impl FatMaskBuilder { # [doc = " Update this mask by adding the given byte to the given bucket. The"] # [doc = " given bucket must be in the range 0-15."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `bucket >= 16`."] fn add (& mut self , bucket : usize , byte : u8) { if ! (bucket < 16) { :: core :: panicking :: panic ("assertion failed: bucket < 16") } let bucket = u8 :: try_from (bucket) . unwrap () ; let byte_lo = usize :: from (byte & 0xF) ; let byte_hi = usize :: from ((byte >> 4) & 0xF) ; if bucket < 8 { self . lo [byte_lo] |= 1 << bucket ; self . hi [byte_hi] |= 1 << bucket ; } else { self . lo [byte_lo + 16] |= 1 << (bucket % 8) ; self . hi [byte_hi + 16] |= 1 << (bucket % 8) ; } } # [doc = " Turn this builder into a vector mask."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn build < V : Vector > (& self) -> Mask < V > { if ! (V :: BYTES <= self . lo . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.lo.len()" ,) } if ! (V :: BYTES <= self . hi . len ()) { :: core :: panicking :: panic ("assertion failed: V::BYTES <= self.hi.len()" ,) } Mask { lo : V :: load_unaligned (self . lo [..] . as_ptr ()) , hi : V :: load_unaligned (self . hi [..] . as_ptr ()) , } } # [doc = " A convenience function for building `N` vector masks from a fat"] # [doc = " `Teddy` value."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " When `V` represents a vector bigger than what `MaskBytes` can contain."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [inline (always)] unsafe fn from_teddy < const BYTES : usize , V : Vector > (teddy : & Teddy < 16 > ,) -> [Mask < V > ; BYTES] { let mut mask_builders = :: alloc :: vec :: from_elem (FatMaskBuilder :: default () , BYTES ,) ; for (bucket_index , bucket) in teddy . buckets . iter () . enumerate () { for pid in bucket . iter () . copied () { let pat = teddy . patterns . get (pid) ; for (i , builder) in mask_builders . iter_mut () . enumerate () { builder . add (bucket_index , pat . bytes () [i]) ; } } } let array = < [FatMaskBuilder ; BYTES] > :: try_from (mask_builders) . unwrap () ; array . map (| builder | builder . build ()) } } impl Debug for FatMaskBuilder { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { let (mut parts_lo , mut parts_hi) = (:: alloc :: vec :: Vec :: new () , :: alloc :: vec :: Vec :: new () ,) ; for i in 0 .. 32 { parts_lo . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . lo [i]) ,) }) ,) ; parts_hi . push (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:02}: {1:08b}" , i , self . hi [i]) ,) }) ,) ; } f . debug_struct ("FatMaskBuilder") . field ("lo" , & parts_lo) . field ("hi" , & parts_hi) . finish () } } } }