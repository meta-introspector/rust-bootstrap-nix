# [doc = " Remappable is a tightly coupled abstraction that facilitates remapping"] # [doc = " state identifiers in DFAs."] # [doc = ""] # [doc = " The main idea behind remapping state IDs is that DFAs often need to check"] # [doc = " if a certain state is a \"special\" state of some kind (like a match state)"] # [doc = " during a search. Since this is extremely perf critical code, we want this"] # [doc = " check to be as fast as possible. Partitioning state IDs into, for example,"] # [doc = " into \"non-match\" and \"match\" states means one can tell if a state is a"] # [doc = " match state via a simple comparison of the state ID."] # [doc = ""] # [doc = " The issue is that during the DFA construction process, it's not"] # [doc = " particularly easy to partition the states. Instead, the simplest thing is"] # [doc = " to often just do a pass over all of the states and shuffle them into their"] # [doc = " desired partitionings. To do that, we need a mechanism for swapping states."] # [doc = " Hence, this abstraction."] # [doc = ""] # [doc = " Normally, for such little code, I would just duplicate it. But this is a"] # [doc = " key optimization and the implementation is a bit subtle. So the abstraction"] # [doc = " is basically a ham-fisted attempt at DRY. The only place we use this is in"] # [doc = " the dense and one-pass DFAs."] # [doc = ""] # [doc = " See also src/dfa/special.rs for a more detailed explanation of how dense"] # [doc = " DFAs are partitioned."] pub (crate) trait Remappable : core :: fmt :: Debug { # [doc = " Return the total number of states."] fn state_len (& self) -> usize ; # [doc = " Swap the states pointed to by the given IDs. The underlying finite"] # [doc = " state machine should be mutated such that all of the transitions in"] # [doc = " `id1` are now in the memory region where the transitions for `id2`"] # [doc = " were, and all of the transitions in `id2` are now in the memory region"] # [doc = " where the transitions for `id1` were."] # [doc = ""] # [doc = " Essentially, this \"moves\" `id1` to `id2` and `id2` to `id1`."] # [doc = ""] # [doc = " It is expected that, after calling this, the underlying state machine"] # [doc = " will be left in an inconsistent state, since any other transitions"] # [doc = " pointing to, e.g., `id1` need to be updated to point to `id2`, since"] # [doc = " that's where `id1` moved to."] # [doc = ""] # [doc = " In order to \"fix\" the underlying inconsistent state, a `Remapper`"] # [doc = " should be used to guarantee that `remap` is called at the appropriate"] # [doc = " time."] fn swap_states (& mut self , id1 : StateID , id2 : StateID) ; # [doc = " This must remap every single state ID in the underlying value according"] # [doc = " to the function given. For example, in a DFA, this should remap every"] # [doc = " transition and every starting state ID."] fn remap (& mut self , map : impl Fn (StateID) -> StateID) ; }