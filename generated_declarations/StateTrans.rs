# [doc = " The underlying representation of sparse or dense transitions for a state."] # [doc = ""] # [doc = " Note that like `State`, we don't typically construct values of this type"] # [doc = " during a search since we don't always need all values and thus would"] # [doc = " represent a lot of wasteful work."] enum StateTrans < 'a > { # [doc = " A sparse representation of transitions for a state, where only non-FAIL"] # [doc = " transitions are explicitly represented."] Sparse { classes : & 'a [u32] , # [doc = " The transitions for this state, where each transition is packed"] # [doc = " into a u32. The low 8 bits correspond to the byte class for the"] # [doc = " transition, and the high 24 bits correspond to the next state ID."] # [doc = ""] # [doc = " This packing is why the max state ID allowed for a contiguous"] # [doc = " NFA is 2^24-1."] nexts : & 'a [u32] , } , # [doc = " A \"one transition\" state that is never a match state."] # [doc = ""] # [doc = " These are by far the most common state, so we use a specialized and"] # [doc = " very compact representation for them."] One { # [doc = " The element of this NFA's alphabet that this transition is"] # [doc = " defined for."] class : u8 , # [doc = " The state this should transition to if the current symbol is"] # [doc = " equal to 'class'."] next : u32 , } , # [doc = " A dense representation of transitions for a state, where all"] # [doc = " transitions are explicitly represented, including transitions to the"] # [doc = " FAIL state."] Dense { # [doc = " A dense set of transitions to other states. The transitions may"] # [doc = " point to a FAIL state, in which case, the search should try the"] # [doc = " same transition lookup at 'fail'."] # [doc = ""] # [doc = " Note that this is indexed by byte equivalence classes and not"] # [doc = " byte values. That means 'class_to_next[byte]' is wrong and"] # [doc = " 'class_to_next[classes.get(byte)]' is correct. The number of"] # [doc = " transitions is always equivalent to 'classes.alphabet_len()'."] class_to_next : & 'a [u32] , } , }