# [doc = " A noncontiguous NFA implementation of Aho-Corasick."] # [doc = ""] # [doc = " When possible, prefer using [`AhoCorasick`](crate::AhoCorasick) instead of"] # [doc = " this type directly. Using an `NFA` directly is typically only necessary"] # [doc = " when one needs access to the [`Automaton`] trait implementation."] # [doc = ""] # [doc = " This NFA represents the \"core\" implementation of Aho-Corasick in this"] # [doc = " crate. Namely, constructing this NFA involving building a trie and then"] # [doc = " filling in the failure transitions between states, similar to what is"] # [doc = " described in any standard textbook description of Aho-Corasick."] # [doc = ""] # [doc = " In order to minimize heap usage and to avoid additional construction costs,"] # [doc = " this implementation represents the transitions of all states as distinct"] # [doc = " sparse memory allocations. This is where it gets its name from. That is,"] # [doc = " this NFA has no contiguous memory allocation for its transition table. Each"] # [doc = " state gets its own allocation."] # [doc = ""] # [doc = " While the sparse representation keeps memory usage to somewhat reasonable"] # [doc = " levels, it is still quite large and also results in somewhat mediocre"] # [doc = " search performance. For this reason, it is almost always a good idea to"] # [doc = " use a [`contiguous::NFA`](crate::nfa::contiguous::NFA) instead. It is"] # [doc = " marginally slower to build, but has higher throughput and can sometimes use"] # [doc = " an order of magnitude less memory. The main reason to use a noncontiguous"] # [doc = " NFA is when you need the fastest possible construction time, or when a"] # [doc = " contiguous NFA does not have the desired capacity. (The total number of NFA"] # [doc = " states it can have is fewer than a noncontiguous NFA.)"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to build an `NFA` directly and use it to execute"] # [doc = " [`Automaton::try_find`]:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::Automaton,"] # [doc = "     nfa::noncontiguous::NFA,"] # [doc = "     Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let nfa = NFA::new(patterns).unwrap();"] # [doc = " assert_eq!("] # [doc = "     Some(Match::must(0, 1..2)),"] # [doc = "     nfa.try_find(&Input::new(haystack))?,"] # [doc = " );"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " It is also possible to implement your own version of `try_find`. See the"] # [doc = " [`Automaton`] documentation for an example."] pub struct NFA { # [doc = " The match semantics built into this NFA."] match_kind : MatchKind , # [doc = " A set of states. Each state defines its own transitions, a fail"] # [doc = " transition and a set of indices corresponding to matches."] # [doc = ""] # [doc = " The first state is always the fail state, which is used only as a"] # [doc = " sentinel. Namely, in the final NFA, no transition into the fail state"] # [doc = " exists. (Well, they do, but they aren't followed. Instead, the state's"] # [doc = " failure transition is followed.)"] # [doc = ""] # [doc = " The second state (index 1) is always the dead state. Dead states are"] # [doc = " in every automaton, but only used when leftmost-{first,longest} match"] # [doc = " semantics are enabled. Specifically, they instruct search to stop"] # [doc = " at specific points in order to report the correct match location. In"] # [doc = " the standard Aho-Corasick construction, there are no transitions to"] # [doc = " the dead state."] # [doc = ""] # [doc = " The third state (index 2) is generally intended to be the starting or"] # [doc = " \"root\" state."] states : Vec < State > , # [doc = " Transitions stored in a sparse representation via a linked list."] # [doc = ""] # [doc = " Each transition contains three pieces of information: the byte it"] # [doc = " is defined for, the state it transitions to and a link to the next"] # [doc = " transition in the same state (or `StateID::ZERO` if it is the last"] # [doc = " transition)."] # [doc = ""] # [doc = " The first transition for each state is determined by `State::sparse`."] # [doc = ""] # [doc = " Note that this contains a complete set of all transitions in this NFA,"] # [doc = " including states that have a dense representation for transitions."] # [doc = " (Adding dense transitions for a state doesn't remove its sparse"] # [doc = " transitions, since deleting transitions from this particular sparse"] # [doc = " representation would be fairly expensive.)"] sparse : Vec < Transition > , # [doc = " Transitions stored in a dense representation."] # [doc = ""] # [doc = " A state has a row in this table if and only if `State::dense` is"] # [doc = " not equal to `StateID::ZERO`. When not zero, there are precisely"] # [doc = " `NFA::byte_classes::alphabet_len()` entries beginning at `State::dense`"] # [doc = " in this table."] # [doc = ""] # [doc = " Generally a very small minority of states have a dense representation"] # [doc = " since it uses so much memory."] dense : Vec < StateID > , # [doc = " Matches stored in linked list for each state."] # [doc = ""] # [doc = " Like sparse transitions, each match has a link to the next match in the"] # [doc = " state."] # [doc = ""] # [doc = " The first match for each state is determined by `State::matches`."] matches : Vec < Match > , # [doc = " The length, in bytes, of each pattern in this NFA. This slice is"] # [doc = " indexed by `PatternID`."] # [doc = ""] # [doc = " The number of entries in this vector corresponds to the total number of"] # [doc = " patterns in this automaton."] pattern_lens : Vec < SmallIndex > , # [doc = " A prefilter for quickly skipping to candidate matches, if pertinent."] prefilter : Option < Prefilter > , # [doc = " A set of equivalence classes in terms of bytes. We compute this while"] # [doc = " building the NFA, but don't use it in the NFA's states. Instead, we"] # [doc = " use this for building the DFA. We store it on the NFA since it's easy"] # [doc = " to compute while visiting the patterns."] byte_classes : ByteClasses , # [doc = " The length, in bytes, of the shortest pattern in this automaton. This"] # [doc = " information is useful for detecting whether an automaton matches the"] # [doc = " empty string or not."] min_pattern_len : usize , # [doc = " The length, in bytes, of the longest pattern in this automaton. This"] # [doc = " information is useful for keeping correct buffer sizes when searching"] # [doc = " on streams."] max_pattern_len : usize , # [doc = " The information required to deduce which states are \"special\" in this"] # [doc = " NFA."] # [doc = ""] # [doc = " Since the DEAD and FAIL states are always the first two states and"] # [doc = " there are only ever two start states (which follow all of the match"] # [doc = " states), it follows that we can determine whether a state is a fail,"] # [doc = " dead, match or start with just a few comparisons on the ID itself:"] # [doc = ""] # [doc = "    is_dead(sid): sid == NFA::DEAD"] # [doc = "    is_fail(sid): sid == NFA::FAIL"] # [doc = "   is_match(sid): NFA::FAIL < sid && sid <= max_match_id"] # [doc = "   is_start(sid): sid == start_unanchored_id || sid == start_anchored_id"] # [doc = ""] # [doc = " Note that this only applies to the NFA after it has been constructed."] # [doc = " During construction, the start states are the first ones added and the"] # [doc = " match states are inter-leaved with non-match states. Once all of the"] # [doc = " states have been added, the states are shuffled such that the above"] # [doc = " predicates hold."] special : Special , }