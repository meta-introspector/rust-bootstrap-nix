pub (crate) mod error { use crate :: util :: { primitives :: { PatternID , SmallIndex } , search :: MatchKind , } ; # [doc = " An error that occurred during the construction of an Aho-Corasick"] # [doc = " automaton."] # [doc = ""] # [doc = " Build errors occur when some kind of limit has been exceeded, either in the"] # [doc = " number of states, the number of patterns of the length of a pattern. These"] # [doc = " limits aren't part of the public API, but they should generally be large"] # [doc = " enough to handle most use cases."] # [doc = ""] # [doc = " When the `std` feature is enabled, this implements the `std::error::Error`"] # [doc = " trait."] pub struct BuildError { kind : ErrorKind , } # [automatically_derived] impl :: core :: clone :: Clone for BuildError { # [inline] fn clone (& self) -> BuildError { BuildError { kind : :: core :: clone :: Clone :: clone (& self . kind) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for BuildError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "BuildError" , "kind" , & & self . kind ,) } } # [doc = " The kind of error that occurred."] enum ErrorKind { # [doc = " An error that occurs when allocating a new state would result in an"] # [doc = " identifier that exceeds the capacity of a `StateID`."] StateIDOverflow { # [doc = " The maximum possible id."] max : u64 , # [doc = " The maximum ID requested."] requested_max : u64 , } , # [doc = " An error that occurs when adding a pattern to an Aho-Corasick"] # [doc = " automaton would result in an identifier that exceeds the capacity of a"] # [doc = " `PatternID`."] PatternIDOverflow { # [doc = " The maximum possible id."] max : u64 , # [doc = " The maximum ID requested."] requested_max : u64 , } , # [doc = " Occurs when a pattern string is given to the Aho-Corasick constructor"] # [doc = " that is too long."] PatternTooLong { # [doc = " The ID of the pattern that was too long."] pattern : PatternID , # [doc = " The length that was too long."] len : usize , } , } # [automatically_derived] impl :: core :: clone :: Clone for ErrorKind { # [inline] fn clone (& self) -> ErrorKind { match self { ErrorKind :: StateIDOverflow { max : __self_0 , requested_max : __self_1 , } => { ErrorKind :: StateIDOverflow { max : :: core :: clone :: Clone :: clone (__self_0) , requested_max : :: core :: clone :: Clone :: clone (__self_1) , } } ErrorKind :: PatternIDOverflow { max : __self_0 , requested_max : __self_1 , } => { ErrorKind :: PatternIDOverflow { max : :: core :: clone :: Clone :: clone (__self_0) , requested_max : :: core :: clone :: Clone :: clone (__self_1) , } } ErrorKind :: PatternTooLong { pattern : __self_0 , len : __self_1 } => { ErrorKind :: PatternTooLong { pattern : :: core :: clone :: Clone :: clone (__self_0) , len : :: core :: clone :: Clone :: clone (__self_1) , } } } } } # [automatically_derived] impl :: core :: fmt :: Debug for ErrorKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { ErrorKind :: StateIDOverflow { max : __self_0 , requested_max : __self_1 , } => { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "StateIDOverflow" , "max" , __self_0 , "requested_max" , & __self_1 ,) } ErrorKind :: PatternIDOverflow { max : __self_0 , requested_max : __self_1 , } => { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "PatternIDOverflow" , "max" , __self_0 , "requested_max" , & __self_1 ,) } ErrorKind :: PatternTooLong { pattern : __self_0 , len : __self_1 } => { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "PatternTooLong" , "pattern" , __self_0 , "len" , & __self_1 ,) } } } } impl BuildError { pub (crate) fn state_id_overflow (max : u64 , requested_max : u64) -> BuildError { BuildError { kind : ErrorKind :: StateIDOverflow { max , requested_max , } , } } pub (crate) fn pattern_id_overflow (max : u64 , requested_max : u64 ,) -> BuildError { BuildError { kind : ErrorKind :: PatternIDOverflow { max , requested_max , } , } } pub (crate) fn pattern_too_long (pattern : PatternID , len : usize ,) -> BuildError { BuildError { kind : ErrorKind :: PatternTooLong { pattern , len , } , } } } impl std :: error :: Error for BuildError { } impl core :: fmt :: Display for BuildError { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { match self . kind { ErrorKind :: StateIDOverflow { max , requested_max } => { f . write_fmt (format_args ! ("state identifier overflow: failed to create state ID from {0}, which exceeds the max of {1}" , requested_max , max ,) ,) } ErrorKind :: PatternIDOverflow { max , requested_max } => { f . write_fmt (format_args ! ("pattern identifier overflow: failed to create pattern ID from {0}, which exceeds the max of {1}" , requested_max , max ,) ,) } ErrorKind :: PatternTooLong { pattern , len } => { f . write_fmt (format_args ! ("pattern {0} with length {1} exceeds the maximum pattern length of {2}" , pattern . as_usize () , len , SmallIndex :: MAX . as_usize () ,) ,) } } } } # [doc = " An error that occurred during an Aho-Corasick search."] # [doc = ""] # [doc = " An error that occurs during a search is limited to some kind of"] # [doc = " misconfiguration that resulted in an illegal call. Stated differently,"] # [doc = " whether an error occurs is not dependent on the specific bytes in the"] # [doc = " haystack."] # [doc = ""] # [doc = " Examples of misconfiguration:"] # [doc = ""] # [doc = " * Executing a stream or overlapping search on a searcher that was built was"] # [doc = " something other than [`MatchKind::Standard`](crate::MatchKind::Standard)"] # [doc = " semantics."] # [doc = " * Requested an anchored or an unanchored search on a searcher that doesn't"] # [doc = " support unanchored or anchored searches, respectively."] # [doc = ""] # [doc = " When the `std` feature is enabled, this implements the `std::error::Error`"] # [doc = " trait."] pub struct MatchError (alloc :: boxed :: Box < MatchErrorKind >) ; # [automatically_derived] impl :: core :: clone :: Clone for MatchError { # [inline] fn clone (& self) -> MatchError { MatchError (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for MatchError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "MatchError" , & & self . 0 ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for MatchError { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < alloc :: boxed :: Box < MatchErrorKind > > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for MatchError { } # [automatically_derived] impl :: core :: cmp :: PartialEq for MatchError { # [inline] fn eq (& self , other : & MatchError) -> bool { self . 0 == other . 0 } } impl MatchError { # [doc = " Create a new error value with the given kind."] # [doc = ""] # [doc = " This is a more verbose version of the kind-specific constructors, e.g.,"] # [doc = " `MatchError::unsupported_stream`."] pub fn new (kind : MatchErrorKind) -> MatchError { MatchError (alloc :: boxed :: Box :: new (kind)) } # [doc = " Returns a reference to the underlying error kind."] pub fn kind (& self) -> & MatchErrorKind { & self . 0 } # [doc = " Create a new \"invalid anchored search\" error. This occurs when the"] # [doc = " caller requests an anchored search but where anchored searches aren't"] # [doc = " supported."] # [doc = ""] # [doc = " This is the same as calling `MatchError::new` with a"] # [doc = " [`MatchErrorKind::InvalidInputAnchored`] kind."] pub fn invalid_input_anchored () -> MatchError { MatchError :: new (MatchErrorKind :: InvalidInputAnchored) } # [doc = " Create a new \"invalid unanchored search\" error. This occurs when the"] # [doc = " caller requests an unanchored search but where unanchored searches"] # [doc = " aren't supported."] # [doc = ""] # [doc = " This is the same as calling `MatchError::new` with a"] # [doc = " [`MatchErrorKind::InvalidInputUnanchored`] kind."] pub fn invalid_input_unanchored () -> MatchError { MatchError :: new (MatchErrorKind :: InvalidInputUnanchored) } # [doc = " Create a new \"unsupported stream search\" error. This occurs when the"] # [doc = " caller requests a stream search while using an Aho-Corasick automaton"] # [doc = " with a match kind other than [`MatchKind::Standard`]."] # [doc = ""] # [doc = " The match kind given should be the match kind of the automaton. It"] # [doc = " should never be `MatchKind::Standard`."] pub fn unsupported_stream (got : MatchKind) -> MatchError { MatchError :: new (MatchErrorKind :: UnsupportedStream { got , }) } # [doc = " Create a new \"unsupported overlapping search\" error. This occurs when"] # [doc = " the caller requests an overlapping search while using an Aho-Corasick"] # [doc = " automaton with a match kind other than [`MatchKind::Standard`]."] # [doc = ""] # [doc = " The match kind given should be the match kind of the automaton. It"] # [doc = " should never be `MatchKind::Standard`."] pub fn unsupported_overlapping (got : MatchKind) -> MatchError { MatchError :: new (MatchErrorKind :: UnsupportedOverlapping { got , }) } # [doc = " Create a new \"unsupported empty pattern\" error. This occurs when the"] # [doc = " caller requests a search for which matching an automaton that contains"] # [doc = " an empty pattern string is not supported."] pub fn unsupported_empty () -> MatchError { MatchError :: new (MatchErrorKind :: UnsupportedEmpty) } } # [doc = " The underlying kind of a [`MatchError`]."] # [doc = ""] # [doc = " This is a **non-exhaustive** enum. That means new variants may be added in"] # [doc = " a semver-compatible release."] # [non_exhaustive] pub enum MatchErrorKind { # [doc = " An error indicating that an anchored search was requested, but from a"] # [doc = " searcher that was built without anchored support."] InvalidInputAnchored , # [doc = " An error indicating that an unanchored search was requested, but from a"] # [doc = " searcher that was built without unanchored support."] InvalidInputUnanchored , # [doc = " An error indicating that a stream search was attempted on an"] # [doc = " Aho-Corasick automaton with an unsupported `MatchKind`."] UnsupportedStream { # [doc = " The match semantics for the automaton that was used."] got : MatchKind , } , # [doc = " An error indicating that an overlapping search was attempted on an"] # [doc = " Aho-Corasick automaton with an unsupported `MatchKind`."] UnsupportedOverlapping { # [doc = " The match semantics for the automaton that was used."] got : MatchKind , } , # [doc = " An error indicating that the operation requested doesn't support"] # [doc = " automatons that contain an empty pattern string."] UnsupportedEmpty , } # [automatically_derived] impl :: core :: clone :: Clone for MatchErrorKind { # [inline] fn clone (& self) -> MatchErrorKind { match self { MatchErrorKind :: InvalidInputAnchored => { MatchErrorKind :: InvalidInputAnchored } MatchErrorKind :: InvalidInputUnanchored => { MatchErrorKind :: InvalidInputUnanchored } MatchErrorKind :: UnsupportedStream { got : __self_0 } => { MatchErrorKind :: UnsupportedStream { got : :: core :: clone :: Clone :: clone (__self_0) , } } MatchErrorKind :: UnsupportedOverlapping { got : __self_0 } => { MatchErrorKind :: UnsupportedOverlapping { got : :: core :: clone :: Clone :: clone (__self_0) , } } MatchErrorKind :: UnsupportedEmpty => MatchErrorKind :: UnsupportedEmpty , } } } # [automatically_derived] impl :: core :: fmt :: Debug for MatchErrorKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { MatchErrorKind :: InvalidInputAnchored => { :: core :: fmt :: Formatter :: write_str (f , "InvalidInputAnchored") } MatchErrorKind :: InvalidInputUnanchored => { :: core :: fmt :: Formatter :: write_str (f , "InvalidInputUnanchored") } MatchErrorKind :: UnsupportedStream { got : __self_0 } => { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "UnsupportedStream" , "got" , & __self_0 ,) } MatchErrorKind :: UnsupportedOverlapping { got : __self_0 } => { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "UnsupportedOverlapping" , "got" , & __self_0 ,) } MatchErrorKind :: UnsupportedEmpty => { :: core :: fmt :: Formatter :: write_str (f , "UnsupportedEmpty") } } } } # [automatically_derived] impl :: core :: cmp :: Eq for MatchErrorKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < MatchKind > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for MatchErrorKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for MatchErrorKind { # [inline] fn eq (& self , other : & MatchErrorKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr && match (self , other) { (MatchErrorKind :: UnsupportedStream { got : __self_0 } , MatchErrorKind :: UnsupportedStream { got : __arg1_0 } ,) => __self_0 == __arg1_0 , (MatchErrorKind :: UnsupportedOverlapping { got : __self_0 } , MatchErrorKind :: UnsupportedOverlapping { got : __arg1_0 } ,) => __self_0 == __arg1_0 , _ => true , } } } impl std :: error :: Error for MatchError { } impl core :: fmt :: Display for MatchError { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { match * self . kind () { MatchErrorKind :: InvalidInputAnchored => { f . write_fmt (format_args ! ("anchored searches are not supported or enabled" ,) ,) } MatchErrorKind :: InvalidInputUnanchored => { f . write_fmt (format_args ! ("unanchored searches are not supported or enabled" ,) ,) } MatchErrorKind :: UnsupportedStream { got } => { f . write_fmt (format_args ! ("match kind {0:?} does not support stream searching" , got ,) ,) } MatchErrorKind :: UnsupportedOverlapping { got } => { f . write_fmt (format_args ! ("match kind {0:?} does not support overlapping searches" , got ,) ,) } MatchErrorKind :: UnsupportedEmpty => { f . write_fmt (format_args ! ("matching with an empty pattern string is not supported for this operation" ,) ,) } } } } }