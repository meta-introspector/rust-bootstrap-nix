pub mod dist { use build_helper :: prelude :: * ; use config_macros :: define_config ; pub struct Dist { pub sign_folder : Option < String > , pub upload_addr : Option < String > , pub src_tarball : Option < bool > , pub compression_formats : Option < Vec < String > > , pub compression_profile : Option < String > , pub include_mingw_linker : Option < bool > , pub vendor : Option < bool > , } # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for Dist { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "sign_folder" => _serde :: __private228 :: Ok (__Field :: __field0) , "upload_addr" => _serde :: __private228 :: Ok (__Field :: __field1) , "src_tarball" => _serde :: __private228 :: Ok (__Field :: __field2) , "compression_formats" => { _serde :: __private228 :: Ok (__Field :: __field3) } "compression_profile" => { _serde :: __private228 :: Ok (__Field :: __field4) } "include_mingw_linker" => { _serde :: __private228 :: Ok (__Field :: __field5) } "vendor" => _serde :: __private228 :: Ok (__Field :: __field6) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"sign_folder" => _serde :: __private228 :: Ok (__Field :: __field0) , b"upload_addr" => _serde :: __private228 :: Ok (__Field :: __field1) , b"src_tarball" => _serde :: __private228 :: Ok (__Field :: __field2) , b"compression_formats" => { _serde :: __private228 :: Ok (__Field :: __field3) } b"compression_profile" => { _serde :: __private228 :: Ok (__Field :: __field4) } b"include_mingw_linker" => { _serde :: __private228 :: Ok (__Field :: __field5) } b"vendor" => _serde :: __private228 :: Ok (__Field :: __field6) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < Dist > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Dist ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct Dist" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < Vec < String > > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct Dist with 7 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct Dist with 7 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (Dist { sign_folder : __field0 , upload_addr : __field1 , src_tarball : __field2 , compression_formats : __field3 , compression_profile : __field4 , include_mingw_linker : __field5 , vendor : __field6 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < Vec < String > > , > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < String > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("sign_folder" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("upload_addr" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("src_tarball" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("compression_formats" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < Vec < String > > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("compression_profile" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("include_mingw_linker" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("vendor") ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("sign_folder") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("upload_addr") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("src_tarball") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("compression_formats" ,) ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("compression_profile" ,) ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("include_mingw_linker" ,) ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("vendor") ? } } ; _serde :: __private228 :: Ok (Dist { sign_folder : __field0 , upload_addr : __field1 , src_tarball : __field2 , compression_formats : __field3 , compression_profile : __field4 , include_mingw_linker : __field5 , vendor : __field6 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["sign_folder" , "upload_addr" , "src_tarball" , "compression_formats" , "compression_profile" , "include_mingw_linker" , "vendor" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "Dist" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < Dist > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } } ; impl config_core :: Merge for Dist { fn merge (& mut self , other : Self , replace : config_core :: ReplaceOpt) { match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . sign_folder . is_none () { self . sign_folder = other . sign_folder ; } } config_core :: ReplaceOpt :: Override => { if other . sign_folder . is_some () { self . sign_folder = other . sign_folder ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . sign_folder . is_some () { if self . sign_folder . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "sign-folder" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . sign_folder = other . sign_folder ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . upload_addr . is_none () { self . upload_addr = other . upload_addr ; } } config_core :: ReplaceOpt :: Override => { if other . upload_addr . is_some () { self . upload_addr = other . upload_addr ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . upload_addr . is_some () { if self . upload_addr . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "upload-addr" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . upload_addr = other . upload_addr ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . src_tarball . is_none () { self . src_tarball = other . src_tarball ; } } config_core :: ReplaceOpt :: Override => { if other . src_tarball . is_some () { self . src_tarball = other . src_tarball ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . src_tarball . is_some () { if self . src_tarball . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "src-tarball" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . src_tarball = other . src_tarball ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . compression_formats . is_none () { self . compression_formats = other . compression_formats ; } } config_core :: ReplaceOpt :: Override => { if other . compression_formats . is_some () { self . compression_formats = other . compression_formats ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . compression_formats . is_some () { if self . compression_formats . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "compression-formats" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . compression_formats = other . compression_formats ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . compression_profile . is_none () { self . compression_profile = other . compression_profile ; } } config_core :: ReplaceOpt :: Override => { if other . compression_profile . is_some () { self . compression_profile = other . compression_profile ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . compression_profile . is_some () { if self . compression_profile . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "compression-profile" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . compression_profile = other . compression_profile ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . include_mingw_linker . is_none () { self . include_mingw_linker = other . include_mingw_linker ; } } config_core :: ReplaceOpt :: Override => { if other . include_mingw_linker . is_some () { self . include_mingw_linker = other . include_mingw_linker ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . include_mingw_linker . is_some () { if self . include_mingw_linker . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "include-mingw-linker" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . include_mingw_linker = other . include_mingw_linker ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . vendor . is_none () { self . vendor = other . vendor ; } } config_core :: ReplaceOpt :: Override => { if other . vendor . is_some () { self . vendor = other . vendor ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . vendor . is_some () { if self . vendor . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "vendor" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . vendor = other . vendor ; } } } } } }