pub (crate) mod search { use core :: ops :: { Range , RangeBounds } ; use crate :: util :: primitives :: PatternID ; # [doc = " The configuration and the haystack to use for an Aho-Corasick search."] # [doc = ""] # [doc = " When executing a search, there are a few parameters one might want to"] # [doc = " configure:"] # [doc = ""] # [doc = " * The haystack to search, provided to the [`Input::new`] constructor. This"] # [doc = " is the only required parameter."] # [doc = " * The span _within_ the haystack to limit a search to. (The default"] # [doc = " is the entire haystack.) This is configured via [`Input::span`] or"] # [doc = " [`Input::range`]."] # [doc = " * Whether to run an unanchored (matches can occur anywhere after the"] # [doc = " start of the search) or anchored (matches can only occur beginning at"] # [doc = " the start of the search) search. Unanchored search is the default. This is"] # [doc = " configured via [`Input::anchored`]."] # [doc = " * Whether to quit the search as soon as a match has been found, regardless"] # [doc = " of the [`MatchKind`] that the searcher was built with. This is configured"] # [doc = " via [`Input::earliest`]."] # [doc = ""] # [doc = " For most cases, the defaults for all optional parameters are appropriate."] # [doc = " The utility of this type is that it keeps the default or common case simple"] # [doc = " while permitting tweaking parameters in more niche use cases while reusing"] # [doc = " the same search APIs."] # [doc = ""] # [doc = " # Valid bounds and search termination"] # [doc = ""] # [doc = " An `Input` permits setting the bounds of a search via either"] # [doc = " [`Input::span`] or [`Input::range`]. The bounds set must be valid, or"] # [doc = " else a panic will occur. Bounds are valid if and only if:"] # [doc = ""] # [doc = " * The bounds represent a valid range into the input's haystack."] # [doc = " * **or** the end bound is a valid ending bound for the haystack *and*"] # [doc = " the start bound is exactly one greater than the end bound."] # [doc = ""] # [doc = " In the latter case, [`Input::is_done`] will return true and indicates any"] # [doc = " search receiving such an input should immediately return with no match."] # [doc = ""] # [doc = " Other than representing \"search is complete,\" the `Input::span` and"] # [doc = " `Input::range` APIs are never necessary. Instead, callers can slice the"] # [doc = " haystack instead, e.g., with `&haystack[start..end]`. With that said, they"] # [doc = " can be more convenient than slicing because the match positions reported"] # [doc = " when using `Input::span` or `Input::range` are in terms of the original"] # [doc = " haystack. If you instead use `&haystack[start..end]`, then you'll need to"] # [doc = " add `start` to any match position returned in order for it to be a correct"] # [doc = " index into `haystack`."] # [doc = ""] # [doc = " # Example: `&str` and `&[u8]` automatically convert to an `Input`"] # [doc = ""] # [doc = " There is a `From<&T> for Input` implementation for all `T: AsRef<[u8]>`."] # [doc = " Additionally, the [`AhoCorasick`](crate::AhoCorasick) search APIs accept"] # [doc = " a `Into<Input>`. These two things combined together mean you can provide"] # [doc = " things like `&str` and `&[u8]` to search APIs when the defaults are"] # [doc = " suitable, but also an `Input` when they're not. For example:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Anchored, Input, Match, StartKind};"] # [doc = ""] # [doc = " // Build a searcher that supports both unanchored and anchored modes."] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .start_kind(StartKind::Both)"] # [doc = "     .build(&[\"abcd\", \"b\"])"] # [doc = "     .unwrap();"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " // A search using default parameters is unanchored. With standard"] # [doc = " // semantics, this finds `b` first."] # [doc = " assert_eq!("] # [doc = "     Some(Match::must(1, 1..2)),"] # [doc = "     ac.find(haystack),"] # [doc = " );"] # [doc = " // Using the same 'find' routine, we can provide an 'Input' explicitly"] # [doc = " // that is configured to do an anchored search. Since 'b' doesn't start"] # [doc = " // at the beginning of the search, it is not reported as a match."] # [doc = " assert_eq!("] # [doc = "     Some(Match::must(0, 0..4)),"] # [doc = "     ac.find(Input::new(haystack).anchored(Anchored::Yes)),"] # [doc = " );"] # [doc = " ```"] pub struct Input < 'h > { haystack : & 'h [u8] , span : Span , anchored : Anchored , earliest : bool , } # [automatically_derived] impl < 'h > :: core :: clone :: Clone for Input < 'h > { # [inline] fn clone (& self) -> Input < 'h > { Input { haystack : :: core :: clone :: Clone :: clone (& self . haystack) , span : :: core :: clone :: Clone :: clone (& self . span) , anchored : :: core :: clone :: Clone :: clone (& self . anchored) , earliest : :: core :: clone :: Clone :: clone (& self . earliest) , } } } impl < 'h > Input < 'h > { # [doc = " Create a new search configuration for the given haystack."] # [inline] pub fn new < H : ? Sized + AsRef < [u8] > > (haystack : & 'h H) -> Input < 'h > { Input { haystack : haystack . as_ref () , span : Span { start : 0 , end : haystack . as_ref () . len () , } , anchored : Anchored :: No , earliest : false , } } # [doc = " Set the span for this search."] # [doc = ""] # [doc = " This routine is generic over how a span is provided. While"] # [doc = " a [`Span`] may be given directly, one may also provide a"] # [doc = " `std::ops::Range<usize>`. To provide anything supported by range"] # [doc = " syntax, use the [`Input::range`] method."] # [doc = ""] # [doc = " The default span is the entire haystack."] # [doc = ""] # [doc = " Note that [`Input::range`] overrides this method and vice versa."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if the given span does not correspond to valid bounds in"] # [doc = " the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how the span of the search can impact whether a"] # [doc = " match is reported or not."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Input, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abcd\", \"abc\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).span(0..3);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " // Without the span stopping the search early, 'abcd' would be reported"] # [doc = " // because it is the correct leftmost-first match."] # [doc = " assert_eq!(\"abc\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [inline] pub fn span < S : Into < Span > > (mut self , span : S) -> Input < 'h > { self . set_span (span) ; self } # [doc = " Like `Input::span`, but accepts any range instead."] # [doc = ""] # [doc = " The default range is the entire haystack."] # [doc = ""] # [doc = " Note that [`Input::span`] overrides this method and vice versa."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This routine will panic if the given range could not be converted"] # [doc = " to a valid [`Range`]. For example, this would panic when given"] # [doc = " `0..=usize::MAX` since it cannot be represented using a half-open"] # [doc = " interval in terms of `usize`."] # [doc = ""] # [doc = " This routine also panics if the given range does not correspond to"] # [doc = " valid bounds in the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\").range(2..=4);"] # [doc = " assert_eq!(2..5, input.get_range());"] # [doc = " ```"] # [inline] pub fn range < R : RangeBounds < usize > > (mut self , range : R) -> Input < 'h > { self . set_range (range) ; self } # [doc = " Sets the anchor mode of a search."] # [doc = ""] # [doc = " When a search is anchored (via [`Anchored::Yes`]), a match must begin"] # [doc = " at the start of a search. When a search is not anchored (that's"] # [doc = " [`Anchored::No`]), searchers will look for a match anywhere in the"] # [doc = " haystack."] # [doc = ""] # [doc = " By default, the anchored mode is [`Anchored::No`]."] # [doc = ""] # [doc = " # Support for anchored searches"] # [doc = ""] # [doc = " Anchored or unanchored searches might not always be available,"] # [doc = " depending on the type of searcher used and its configuration:"] # [doc = ""] # [doc = " * [`noncontiguous::NFA`](crate::nfa::noncontiguous::NFA) always"] # [doc = " supports both unanchored and anchored searches."] # [doc = " * [`contiguous::NFA`](crate::nfa::contiguous::NFA) always supports both"] # [doc = " unanchored and anchored searches."] # [doc = " * [`dfa::DFA`](crate::dfa::DFA) supports only unanchored"] # [doc = " searches by default."] # [doc = " [`dfa::Builder::start_kind`](crate::dfa::Builder::start_kind) can"] # [doc = " be used to change the default to supporting both kinds of searches"] # [doc = " or even just anchored searches."] # [doc = " * [`AhoCorasick`](crate::AhoCorasick) inherits the same setup as a"] # [doc = " `DFA`. Namely, it only supports unanchored searches by default, but"] # [doc = " [`AhoCorasickBuilder::start_kind`](crate::AhoCorasickBuilder::start_kind)"] # [doc = " can change this."] # [doc = ""] # [doc = " If you try to execute a search using a `try_` (\"fallible\") method with"] # [doc = " an unsupported anchor mode, then an error will be returned. For calls"] # [doc = " to infallible search methods, a panic will result."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This demonstrates the differences between an anchored search and"] # [doc = " an unanchored search. Notice that we build our `AhoCorasick` searcher"] # [doc = " with [`StartKind::Both`] so that it supports both unanchored and"] # [doc = " anchored searches simultaneously."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     AhoCorasick, Anchored, Input, MatchKind, StartKind,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"bcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .start_kind(StartKind::Both)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = ""] # [doc = " // Note that 'Anchored::No' is the default, so it doesn't need to"] # [doc = " // be explicitly specified here."] # [doc = " let input = Input::new(haystack);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"bcd\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " // While 'bcd' occurs in the haystack, it does not begin where our"] # [doc = " // search begins, so no match is found."] # [doc = " let input = Input::new(haystack).anchored(Anchored::Yes);"] # [doc = " assert_eq!(None, ac.try_find(input)?);"] # [doc = ""] # [doc = " // However, if we start our search where 'bcd' starts, then we will"] # [doc = " // find a match."] # [doc = " let input = Input::new(haystack).range(1..).anchored(Anchored::Yes);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"bcd\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [inline] pub fn anchored (mut self , mode : Anchored) -> Input < 'h > { self . set_anchored (mode) ; self } # [doc = " Whether to execute an \"earliest\" search or not."] # [doc = ""] # [doc = " When running a non-overlapping search, an \"earliest\" search will"] # [doc = " return the match location as early as possible. For example, given"] # [doc = " the patterns `abc` and `b`, and a haystack of `abc`, a normal"] # [doc = " leftmost-first search will return `abc` as a match. But an \"earliest\""] # [doc = " search will return as soon as it is known that a match occurs, which"] # [doc = " happens once `b` is seen."] # [doc = ""] # [doc = " Note that when using [`MatchKind::Standard`], the \"earliest\" option"] # [doc = " has no effect since standard semantics are already \"earliest.\" Note"] # [doc = " also that this has no effect in overlapping searches, since overlapping"] # [doc = " searches also use standard semantics and report all possible matches."] # [doc = ""] # [doc = " This is disabled by default."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows the difference between \"earliest\" searching and"] # [doc = " normal leftmost searching."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Anchored, Input, MatchKind, StartKind};"] # [doc = ""] # [doc = " let patterns = &[\"abc\", \"b\"];"] # [doc = " let haystack = \"abc\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = ""] # [doc = " // The normal leftmost-first match."] # [doc = " let input = Input::new(haystack);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"abc\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " // The \"earliest\" possible match, even if it isn't leftmost-first."] # [doc = " let input = Input::new(haystack).earliest(true);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"b\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [inline] pub fn earliest (mut self , yes : bool) -> Input < 'h > { self . set_earliest (yes) ; self } # [doc = " Set the span for this search configuration."] # [doc = ""] # [doc = " This is like the [`Input::span`] method, except this mutates the"] # [doc = " span in place."] # [doc = ""] # [doc = " This routine is generic over how a span is provided. While"] # [doc = " a [`Span`] may be given directly, one may also provide a"] # [doc = " `std::ops::Range<usize>`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if the given span does not correspond to valid bounds in"] # [doc = " the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = " input.set_span(2..4);"] # [doc = " assert_eq!(2..4, input.get_range());"] # [doc = " ```"] # [inline] pub fn set_span < S : Into < Span > > (& mut self , span : S) { let span = span . into () ; if ! (span . end <= self . haystack . len () && span . start <= span . end . wrapping_add (1)) { { :: core :: panicking :: panic_fmt (format_args ! ("invalid span {0:?} for haystack of length {1}" , span , self . haystack . len () ,) ,) ; } } self . span = span ; } # [doc = " Set the span for this search configuration given any range."] # [doc = ""] # [doc = " This is like the [`Input::range`] method, except this mutates the"] # [doc = " span in place."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This routine will panic if the given range could not be converted"] # [doc = " to a valid [`Range`]. For example, this would panic when given"] # [doc = " `0..=usize::MAX` since it cannot be represented using a half-open"] # [doc = " interval in terms of `usize`."] # [doc = ""] # [doc = " This routine also panics if the given range does not correspond to"] # [doc = " valid bounds in the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = " input.set_range(2..=4);"] # [doc = " assert_eq!(2..5, input.get_range());"] # [doc = " ```"] # [inline] pub fn set_range < R : RangeBounds < usize > > (& mut self , range : R) { use core :: ops :: Bound ; let start = match range . start_bound () { Bound :: Included (& i) => i , Bound :: Excluded (& i) => i . checked_add (1) . unwrap () , Bound :: Unbounded => 0 , } ; let end = match range . end_bound () { Bound :: Included (& i) => i . checked_add (1) . unwrap () , Bound :: Excluded (& i) => i , Bound :: Unbounded => self . haystack () . len () , } ; self . set_span (Span { start , end }) ; } # [doc = " Set the starting offset for the span for this search configuration."] # [doc = ""] # [doc = " This is a convenience routine for only mutating the start of a span"] # [doc = " without having to set the entire span."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if the given span does not correspond to valid bounds in"] # [doc = " the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = " input.set_start(5);"] # [doc = " assert_eq!(5..6, input.get_range());"] # [doc = " ```"] # [inline] pub fn set_start (& mut self , start : usize) { self . set_span (Span { start , .. self . get_span () }) ; } # [doc = " Set the ending offset for the span for this search configuration."] # [doc = ""] # [doc = " This is a convenience routine for only mutating the end of a span"] # [doc = " without having to set the entire span."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if the given span does not correspond to valid bounds in"] # [doc = " the haystack or the termination of a search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = " input.set_end(5);"] # [doc = " assert_eq!(0..5, input.get_range());"] # [doc = " ```"] # [inline] pub fn set_end (& mut self , end : usize) { self . set_span (Span { end , .. self . get_span () }) ; } # [doc = " Set the anchor mode of a search."] # [doc = ""] # [doc = " This is like [`Input::anchored`], except it mutates the search"] # [doc = " configuration in place."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{Anchored, Input};"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(Anchored::No, input.get_anchored());"] # [doc = ""] # [doc = " input.set_anchored(Anchored::Yes);"] # [doc = " assert_eq!(Anchored::Yes, input.get_anchored());"] # [doc = " ```"] # [inline] pub fn set_anchored (& mut self , mode : Anchored) { self . anchored = mode ; } # [doc = " Set whether the search should execute in \"earliest\" mode or not."] # [doc = ""] # [doc = " This is like [`Input::earliest`], except it mutates the search"] # [doc = " configuration in place."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert!(!input.get_earliest());"] # [doc = " input.set_earliest(true);"] # [doc = " assert!(input.get_earliest());"] # [doc = " ```"] # [inline] pub fn set_earliest (& mut self , yes : bool) { self . earliest = yes ; } # [doc = " Return a borrow of the underlying haystack as a slice of bytes."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(b\"foobar\", input.haystack());"] # [doc = " ```"] # [inline] pub fn haystack (& self) -> & [u8] { self . haystack } # [doc = " Return the start position of this search."] # [doc = ""] # [doc = " This is a convenience routine for `search.get_span().start()`."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0, input.start());"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\").span(2..4);"] # [doc = " assert_eq!(2, input.start());"] # [doc = " ```"] # [inline] pub fn start (& self) -> usize { self . get_span () . start } # [doc = " Return the end position of this search."] # [doc = ""] # [doc = " This is a convenience routine for `search.get_span().end()`."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(6, input.end());"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\").span(2..4);"] # [doc = " assert_eq!(4, input.end());"] # [doc = " ```"] # [inline] pub fn end (& self) -> usize { self . get_span () . end } # [doc = " Return the span for this search configuration."] # [doc = ""] # [doc = " If one was not explicitly set, then the span corresponds to the entire"] # [doc = " range of the haystack."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{Input, Span};"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(Span { start: 0, end: 6 }, input.get_span());"] # [doc = " ```"] # [inline] pub fn get_span (& self) -> Span { self . span } # [doc = " Return the span as a range for this search configuration."] # [doc = ""] # [doc = " If one was not explicitly set, then the span corresponds to the entire"] # [doc = " range of the haystack."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert_eq!(0..6, input.get_range());"] # [doc = " ```"] # [inline] pub fn get_range (& self) -> Range < usize > { self . get_span () . range () } # [doc = " Return the anchored mode for this search configuration."] # [doc = ""] # [doc = " If no anchored mode was set, then it defaults to [`Anchored::No`]."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{Anchored, Input};"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert_eq!(Anchored::No, input.get_anchored());"] # [doc = ""] # [doc = " input.set_anchored(Anchored::Yes);"] # [doc = " assert_eq!(Anchored::Yes, input.get_anchored());"] # [doc = " ```"] # [inline] pub fn get_anchored (& self) -> Anchored { self . anchored } # [doc = " Return whether this search should execute in \"earliest\" mode."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let input = Input::new(\"foobar\");"] # [doc = " assert!(!input.get_earliest());"] # [doc = " ```"] # [inline] pub fn get_earliest (& self) -> bool { self . earliest } # [doc = " Return true if this input has been exhausted, which in turn means all"] # [doc = " subsequent searches will return no matches."] # [doc = ""] # [doc = " This occurs precisely when the start position of this search is greater"] # [doc = " than the end position of the search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Input;"] # [doc = ""] # [doc = " let mut input = Input::new(\"foobar\");"] # [doc = " assert!(!input.is_done());"] # [doc = " input.set_start(6);"] # [doc = " assert!(!input.is_done());"] # [doc = " input.set_start(7);"] # [doc = " assert!(input.is_done());"] # [doc = " ```"] # [inline] pub fn is_done (& self) -> bool { self . get_span () . start > self . get_span () . end } } impl < 'h > core :: fmt :: Debug for Input < 'h > { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { let mut fmter = f . debug_struct ("Input") ; match core :: str :: from_utf8 (self . haystack ()) { Ok (nice) => fmter . field ("haystack" , & nice) , Err (_) => fmter . field ("haystack" , & self . haystack ()) , } . field ("span" , & self . span) . field ("anchored" , & self . anchored) . field ("earliest" , & self . earliest) . finish () } } impl < 'h , H : ? Sized + AsRef < [u8] > > From < & 'h H > for Input < 'h > { # [inline] fn from (haystack : & 'h H) -> Input < 'h > { Input :: new (haystack) } } # [doc = " A representation of a range in a haystack."] # [doc = ""] # [doc = " A span corresponds to the starting and ending _byte offsets_ of a"] # [doc = " contiguous region of bytes. The starting offset is inclusive while the"] # [doc = " ending offset is exclusive. That is, a span is a half-open interval."] # [doc = ""] # [doc = " A span is used to report the offsets of a match, but it is also used to"] # [doc = " convey which region of a haystack should be searched via routines like"] # [doc = " [`Input::span`]."] # [doc = ""] # [doc = " This is basically equivalent to a `std::ops::Range<usize>`, except this"] # [doc = " type implements `Copy` which makes it more ergonomic to use in the context"] # [doc = " of this crate. Indeed, `Span` exists only because `Range<usize>` does"] # [doc = " not implement `Copy`. Like a range, this implements `Index` for `[u8]`"] # [doc = " and `str`, and `IndexMut` for `[u8]`. For convenience, this also impls"] # [doc = " `From<Range>`, which means things like `Span::from(5..10)` work."] # [doc = ""] # [doc = " There are no constraints on the values of a span. It is, for example, legal"] # [doc = " to create a span where `start > end`."] pub struct Span { # [doc = " The start offset of the span, inclusive."] pub start : usize , # [doc = " The end offset of the span, exclusive."] pub end : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Span { # [inline] fn clone (& self) -> Span { let _ : :: core :: clone :: AssertParamIsClone < usize > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for Span { } # [automatically_derived] impl :: core :: cmp :: Eq for Span { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < usize > ; } } # [automatically_derived] impl :: core :: hash :: Hash for Span { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . start , state) ; :: core :: hash :: Hash :: hash (& self . end , state) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for Span { } # [automatically_derived] impl :: core :: cmp :: PartialEq for Span { # [inline] fn eq (& self , other : & Span) -> bool { self . start == other . start && self . end == other . end } } impl Span { # [doc = " Returns this span as a range."] # [inline] pub fn range (& self) -> Range < usize > { Range :: from (* self) } # [doc = " Returns true when this span is empty. That is, when `start >= end`."] # [inline] pub fn is_empty (& self) -> bool { self . start >= self . end } # [doc = " Returns the length of this span."] # [doc = ""] # [doc = " This returns `0` in precisely the cases that `is_empty` returns `true`."] # [inline] pub fn len (& self) -> usize { self . end . saturating_sub (self . start) } # [doc = " Returns true when the given offset is contained within this span."] # [doc = ""] # [doc = " Note that an empty span contains no offsets and will always return"] # [doc = " false."] # [inline] pub fn contains (& self , offset : usize) -> bool { ! self . is_empty () && self . start <= offset && offset <= self . end } # [doc = " Returns a new span with `offset` added to this span's `start` and `end`"] # [doc = " values."] # [inline] pub fn offset (& self , offset : usize) -> Span { Span { start : self . start + offset , end : self . end + offset , } } } impl core :: fmt :: Debug for Span { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . write_fmt (format_args ! ("{0}..{1}" , self . start , self . end)) } } impl core :: ops :: Index < Span > for [u8] { type Output = [u8] ; # [inline] fn index (& self , index : Span) -> & [u8] { & self [index . range ()] } } impl core :: ops :: IndexMut < Span > for [u8] { # [inline] fn index_mut (& mut self , index : Span) -> & mut [u8] { & mut self [index . range ()] } } impl core :: ops :: Index < Span > for str { type Output = str ; # [inline] fn index (& self , index : Span) -> & str { & self [index . range ()] } } impl From < Range < usize > > for Span { # [inline] fn from (range : Range < usize >) -> Span { Span { start : range . start , end : range . end , } } } impl From < Span > for Range < usize > { # [inline] fn from (span : Span) -> Range < usize > { Range { start : span . start , end : span . end , } } } impl PartialEq < Range < usize > > for Span { # [inline] fn eq (& self , range : & Range < usize >) -> bool { self . start == range . start && self . end == range . end } } impl PartialEq < Span > for Range < usize > { # [inline] fn eq (& self , span : & Span) -> bool { self . start == span . start && self . end == span . end } } # [doc = " The type of anchored search to perform."] # [doc = ""] # [doc = " If an Aho-Corasick searcher does not support the anchored mode selected,"] # [doc = " then the search will return an error or panic, depending on whether a"] # [doc = " fallible or an infallible routine was called."] # [non_exhaustive] pub enum Anchored { # [doc = " Run an unanchored search. This means a match may occur anywhere at or"] # [doc = " after the start position of the search up until the end position of the"] # [doc = " search."] No , # [doc = " Run an anchored search. This means that a match must begin at the start"] # [doc = " position of the search and end before the end position of the search."] Yes , } # [automatically_derived] impl :: core :: clone :: Clone for Anchored { # [inline] fn clone (& self) -> Anchored { * self } } # [automatically_derived] impl :: core :: marker :: Copy for Anchored { } # [automatically_derived] impl :: core :: fmt :: Debug for Anchored { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { Anchored :: No => "No" , Anchored :: Yes => "Yes" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for Anchored { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for Anchored { } # [automatically_derived] impl :: core :: cmp :: PartialEq for Anchored { # [inline] fn eq (& self , other : & Anchored) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl Anchored { # [doc = " Returns true if and only if this anchor mode corresponds to an anchored"] # [doc = " search."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Anchored;"] # [doc = ""] # [doc = " assert!(!Anchored::No.is_anchored());"] # [doc = " assert!(Anchored::Yes.is_anchored());"] # [doc = " ```"] # [inline] pub fn is_anchored (& self) -> bool { # [allow (non_exhaustive_omitted_patterns)] match * self { Anchored :: Yes => true , _ => false , } } } # [doc = " A representation of a match reported by an Aho-Corasick searcher."] # [doc = ""] # [doc = " A match has two essential pieces of information: the [`PatternID`] that"] # [doc = " matches, and the [`Span`] of the match in a haystack."] # [doc = ""] # [doc = " The pattern is identified by an ID, which corresponds to its position"] # [doc = " (starting from `0`) relative to other patterns used to construct the"] # [doc = " corresponding searcher. If only a single pattern is provided, then all"] # [doc = " matches are guaranteed to have a pattern ID of `0`."] # [doc = ""] # [doc = " Every match reported by a searcher guarantees that its span has its start"] # [doc = " offset as less than or equal to its end offset."] pub struct Match { # [doc = " The pattern ID."] pattern : PatternID , # [doc = " The underlying match span."] span : Span , } # [automatically_derived] impl :: core :: clone :: Clone for Match { # [inline] fn clone (& self) -> Match { let _ : :: core :: clone :: AssertParamIsClone < PatternID > ; let _ : :: core :: clone :: AssertParamIsClone < Span > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for Match { } # [automatically_derived] impl :: core :: fmt :: Debug for Match { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "Match" , "pattern" , & self . pattern , "span" , & & self . span ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for Match { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < PatternID > ; let _ : :: core :: cmp :: AssertParamIsEq < Span > ; } } # [automatically_derived] impl :: core :: hash :: Hash for Match { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . pattern , state) ; :: core :: hash :: Hash :: hash (& self . span , state) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for Match { } # [automatically_derived] impl :: core :: cmp :: PartialEq for Match { # [inline] fn eq (& self , other : & Match) -> bool { self . pattern == other . pattern && self . span == other . span } } impl Match { # [doc = " Create a new match from a pattern ID and a span."] # [doc = ""] # [doc = " This constructor is generic over how a span is provided. While"] # [doc = " a [`Span`] may be given directly, one may also provide a"] # [doc = " `std::ops::Range<usize>`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if `end < start`."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This shows how to create a match for the first pattern in an"] # [doc = " Aho-Corasick searcher using convenient range syntax."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{Match, PatternID};"] # [doc = ""] # [doc = " let m = Match::new(PatternID::ZERO, 5..10);"] # [doc = " assert_eq!(0, m.pattern().as_usize());"] # [doc = " assert_eq!(5, m.start());"] # [doc = " assert_eq!(10, m.end());"] # [doc = " ```"] # [inline] pub fn new < S : Into < Span > > (pattern : PatternID , span : S) -> Match { let span = span . into () ; if ! (span . start <= span . end) { { :: core :: panicking :: panic_fmt (format_args ! ("invalid match span")) ; } } Match { pattern , span } } # [doc = " Create a new match from a pattern ID and a byte offset span."] # [doc = ""] # [doc = " This constructor is generic over how a span is provided. While"] # [doc = " a [`Span`] may be given directly, one may also provide a"] # [doc = " `std::ops::Range<usize>`."] # [doc = ""] # [doc = " This is like [`Match::new`], but accepts a `usize` instead of a"] # [doc = " [`PatternID`]. This panics if the given `usize` is not representable"] # [doc = " as a `PatternID`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics if `end < start` or if `pattern > PatternID::MAX`."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This shows how to create a match for the third pattern in an"] # [doc = " Aho-Corasick searcher using convenient range syntax."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::Match;"] # [doc = ""] # [doc = " let m = Match::must(3, 5..10);"] # [doc = " assert_eq!(3, m.pattern().as_usize());"] # [doc = " assert_eq!(5, m.start());"] # [doc = " assert_eq!(10, m.end());"] # [doc = " ```"] # [inline] pub fn must < S : Into < Span > > (pattern : usize , span : S) -> Match { Match :: new (PatternID :: must (pattern) , span) } # [doc = " Returns the ID of the pattern that matched."] # [doc = ""] # [doc = " The ID of a pattern is derived from the position in which it was"] # [doc = " originally inserted into the corresponding searcher. The first pattern"] # [doc = " has identifier `0`, and each subsequent pattern is `1`, `2` and so on."] # [inline] pub fn pattern (& self) -> PatternID { self . pattern } # [doc = " The starting position of the match."] # [doc = ""] # [doc = " This is a convenience routine for `Match::span().start`."] # [inline] pub fn start (& self) -> usize { self . span () . start } # [doc = " The ending position of the match."] # [doc = ""] # [doc = " This is a convenience routine for `Match::span().end`."] # [inline] pub fn end (& self) -> usize { self . span () . end } # [doc = " Returns the match span as a range."] # [doc = ""] # [doc = " This is a convenience routine for `Match::span().range()`."] # [inline] pub fn range (& self) -> core :: ops :: Range < usize > { self . span () . range () } # [doc = " Returns the span for this match."] # [inline] pub fn span (& self) -> Span { self . span } # [doc = " Returns true when the span in this match is empty."] # [doc = ""] # [doc = " An empty match can only be returned when empty pattern is in the"] # [doc = " Aho-Corasick searcher."] # [inline] pub fn is_empty (& self) -> bool { self . span () . is_empty () } # [doc = " Returns the length of this match."] # [doc = ""] # [doc = " This returns `0` in precisely the cases that `is_empty` returns `true`."] # [inline] pub fn len (& self) -> usize { self . span () . len () } # [doc = " Returns a new match with `offset` added to its span's `start` and `end`"] # [doc = " values."] # [inline] pub fn offset (& self , offset : usize) -> Match { Match { pattern : self . pattern , span : Span { start : self . start () + offset , end : self . end () + offset , } , } } } # [doc = " A knob for controlling the match semantics of an Aho-Corasick automaton."] # [doc = ""] # [doc = " There are two generally different ways that Aho-Corasick automatons can"] # [doc = " report matches. The first way is the \"standard\" approach that results from"] # [doc = " implementing most textbook explanations of Aho-Corasick. The second way is"] # [doc = " to report only the leftmost non-overlapping matches. The leftmost approach"] # [doc = " is in turn split into two different ways of resolving ambiguous matches:"] # [doc = " leftmost-first and leftmost-longest."] # [doc = ""] # [doc = " The `Standard` match kind is the default and is the only one that supports"] # [doc = " overlapping matches and stream searching. (Trying to find overlapping or"] # [doc = " streaming matches using leftmost match semantics will result in an error in"] # [doc = " fallible APIs and a panic when using infallibe APIs.) The `Standard` match"] # [doc = " kind will report matches as they are seen. When searching for overlapping"] # [doc = " matches, then all possible matches are reported. When searching for"] # [doc = " non-overlapping matches, the first match seen is reported. For example, for"] # [doc = " non-overlapping matches, given the patterns `abcd` and `b` and the haystack"] # [doc = " `abcdef`, only a match for `b` is reported since it is detected first. The"] # [doc = " `abcd` match is never reported since it overlaps with the `b` match."] # [doc = ""] # [doc = " In contrast, the leftmost match kind always prefers the leftmost match"] # [doc = " among all possible matches. Given the same example as above with `abcd` and"] # [doc = " `b` as patterns and `abcdef` as the haystack, the leftmost match is `abcd`"] # [doc = " since it begins before the `b` match, even though the `b` match is detected"] # [doc = " before the `abcd` match. In this case, the `b` match is not reported at all"] # [doc = " since it overlaps with the `abcd` match."] # [doc = ""] # [doc = " The difference between leftmost-first and leftmost-longest is in how they"] # [doc = " resolve ambiguous matches when there are multiple leftmost matches to"] # [doc = " choose from. Leftmost-first always chooses the pattern that was provided"] # [doc = " earliest, where as leftmost-longest always chooses the longest matching"] # [doc = " pattern. For example, given the patterns `a` and `ab` and the subject"] # [doc = " string `ab`, the leftmost-first match is `a` but the leftmost-longest match"] # [doc = " is `ab`. Conversely, if the patterns were given in reverse order, i.e.,"] # [doc = " `ab` and `a`, then both the leftmost-first and leftmost-longest matches"] # [doc = " would be `ab`. Stated differently, the leftmost-first match depends on the"] # [doc = " order in which the patterns were given to the Aho-Corasick automaton."] # [doc = " Because of that, when leftmost-first matching is used, if a pattern `A`"] # [doc = " that appears before a pattern `B` is a prefix of `B`, then it is impossible"] # [doc = " to ever observe a match of `B`."] # [doc = ""] # [doc = " If you're not sure which match kind to pick, then stick with the standard"] # [doc = " kind, which is the default. In particular, if you need overlapping or"] # [doc = " streaming matches, then you _must_ use the standard kind. The leftmost"] # [doc = " kinds are useful in specific circumstances. For example, leftmost-first can"] # [doc = " be very useful as a way to implement match priority based on the order of"] # [doc = " patterns given and leftmost-longest can be useful for dictionary searching"] # [doc = " such that only the longest matching words are reported."] # [doc = ""] # [doc = " # Relationship with regular expression alternations"] # [doc = ""] # [doc = " Understanding match semantics can be a little tricky, and one easy way"] # [doc = " to conceptualize non-overlapping matches from an Aho-Corasick automaton"] # [doc = " is to think about them as a simple alternation of literals in a regular"] # [doc = " expression. For example, let's say we wanted to match the strings"] # [doc = " `Sam` and `Samwise`, which would turn into the regex `Sam|Samwise`. It"] # [doc = " turns out that regular expression engines have two different ways of"] # [doc = " matching this alternation. The first way, leftmost-longest, is commonly"] # [doc = " found in POSIX compatible implementations of regular expressions (such as"] # [doc = " `grep`). The second way, leftmost-first, is commonly found in backtracking"] # [doc = " implementations such as Perl. (Some regex engines, such as RE2 and Rust's"] # [doc = " regex engine do not use backtracking, but still implement leftmost-first"] # [doc = " semantics in an effort to match the behavior of dominant backtracking"] # [doc = " regex engines such as those found in Perl, Ruby, Python, Javascript and"] # [doc = " PHP.)"] # [doc = ""] # [doc = " That is, when matching `Sam|Samwise` against `Samwise`, a POSIX regex"] # [doc = " will match `Samwise` because it is the longest possible match, but a"] # [doc = " Perl-like regex will match `Sam` since it appears earlier in the"] # [doc = " alternation. Indeed, the regex `Sam|Samwise` in a Perl-like regex engine"] # [doc = " will never match `Samwise` since `Sam` will always have higher priority."] # [doc = " Conversely, matching the regex `Samwise|Sam` against `Samwise` will lead to"] # [doc = " a match of `Samwise` in both POSIX and Perl-like regexes since `Samwise` is"] # [doc = " still longest match, but it also appears earlier than `Sam`."] # [doc = ""] # [doc = " The \"standard\" match semantics of Aho-Corasick generally don't correspond"] # [doc = " to the match semantics of any large group of regex implementations, so"] # [doc = " there's no direct analogy that can be made here. Standard match semantics"] # [doc = " are generally useful for overlapping matches, or if you just want to see"] # [doc = " matches as they are detected."] # [doc = ""] # [doc = " The main conclusion to draw from this section is that the match semantics"] # [doc = " can be tweaked to precisely match either Perl-like regex alternations or"] # [doc = " POSIX regex alternations."] # [non_exhaustive] pub enum MatchKind { # [doc = " Use standard match semantics, which support overlapping matches. When"] # [doc = " used with non-overlapping matches, matches are reported as they are"] # [doc = " seen."] Standard , # [doc = " Use leftmost-first match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the match"] # [doc = " corresponding to the pattern that appeared earlier when constructing"] # [doc = " the automaton is reported."] # [doc = ""] # [doc = " This does **not** support overlapping matches or stream searching. If"] # [doc = " this match kind is used, attempting to find overlapping matches or"] # [doc = " stream matches will fail."] LeftmostFirst , # [doc = " Use leftmost-longest match semantics, which reports leftmost matches."] # [doc = " When there are multiple possible leftmost matches, the longest match"] # [doc = " is chosen."] # [doc = ""] # [doc = " This does **not** support overlapping matches or stream searching. If"] # [doc = " this match kind is used, attempting to find overlapping matches or"] # [doc = " stream matches will fail."] LeftmostLongest , } # [automatically_derived] impl :: core :: clone :: Clone for MatchKind { # [inline] fn clone (& self) -> MatchKind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for MatchKind { } # [automatically_derived] impl :: core :: fmt :: Debug for MatchKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { MatchKind :: Standard => "Standard" , MatchKind :: LeftmostFirst => "LeftmostFirst" , MatchKind :: LeftmostLongest => "LeftmostLongest" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for MatchKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for MatchKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for MatchKind { # [inline] fn eq (& self , other : & MatchKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } # [doc = " The default match kind is `MatchKind::Standard`."] impl Default for MatchKind { fn default () -> MatchKind { MatchKind :: Standard } } impl MatchKind { # [inline] pub (crate) fn is_standard (& self) -> bool { # [allow (non_exhaustive_omitted_patterns)] match * self { MatchKind :: Standard => true , _ => false , } } # [inline] pub (crate) fn is_leftmost (& self) -> bool { # [allow (non_exhaustive_omitted_patterns)] match * self { MatchKind :: LeftmostFirst | MatchKind :: LeftmostLongest => true , _ => false , } } # [inline] pub (crate) fn is_leftmost_first (& self) -> bool { # [allow (non_exhaustive_omitted_patterns)] match * self { MatchKind :: LeftmostFirst => true , _ => false , } } # [doc = " Convert this match kind into a packed match kind. If this match kind"] # [doc = " corresponds to standard semantics, then this returns None, since"] # [doc = " packed searching does not support standard semantics."] # [inline] pub (crate) fn as_packed (& self) -> Option < crate :: packed :: MatchKind > { match * self { MatchKind :: Standard => None , MatchKind :: LeftmostFirst => { Some (crate :: packed :: MatchKind :: LeftmostFirst) } MatchKind :: LeftmostLongest => { Some (crate :: packed :: MatchKind :: LeftmostLongest) } } } } # [doc = " The kind of anchored starting configurations to support in an Aho-Corasick"] # [doc = " searcher."] # [doc = ""] # [doc = " Depending on which searcher is used internally by"] # [doc = " [`AhoCorasick`](crate::AhoCorasick), supporting both unanchored"] # [doc = " and anchored searches can be quite costly. For this reason,"] # [doc = " [`AhoCorasickBuilder::start_kind`](crate::AhoCorasickBuilder::start_kind)"] # [doc = " can be used to configure whether your searcher supports unanchored,"] # [doc = " anchored or both kinds of searches."] # [doc = ""] # [doc = " This searcher configuration knob works in concert with the search time"] # [doc = " configuration [`Input::anchored`]. Namely, if one requests an unsupported"] # [doc = " anchored mode, then the search will either panic or return an error,"] # [doc = " depending on whether you're using infallible or fallibe APIs, respectively."] # [doc = ""] # [doc = " `AhoCorasick` by default only supports unanchored searches."] pub enum StartKind { # [doc = " Support both anchored and unanchored searches."] Both , # [doc = " Support only unanchored searches. Requesting an anchored search will"] # [doc = " return an error in fallible APIs and panic in infallible APIs."] Unanchored , # [doc = " Support only anchored searches. Requesting an unanchored search will"] # [doc = " return an error in fallible APIs and panic in infallible APIs."] Anchored , } # [automatically_derived] impl :: core :: clone :: Clone for StartKind { # [inline] fn clone (& self) -> StartKind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for StartKind { } # [automatically_derived] impl :: core :: fmt :: Debug for StartKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { StartKind :: Both => "Both" , StartKind :: Unanchored => "Unanchored" , StartKind :: Anchored => "Anchored" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for StartKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for StartKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for StartKind { # [inline] fn eq (& self , other : & StartKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl Default for StartKind { fn default () -> StartKind { StartKind :: Unanchored } } }