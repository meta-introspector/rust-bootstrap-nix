pub mod lld_mode { use std :: fmt ; use serde :: { Deserialize , Deserializer } ; pub enum LldMode { # [doc = " Do not use LLD"] # [default] Unused , # [doc = " Use `rust-lld` from the compiler's sysroot"] SelfContained , # [doc = " Use an externally provided `lld` binary."] # [doc = " Note that the linker name cannot be overridden, the binary has to be named `lld` and it has"] # [doc = " to be in $PATH."] External , } # [automatically_derived] impl :: core :: marker :: Copy for LldMode { } # [automatically_derived] impl :: core :: clone :: Clone for LldMode { # [inline] fn clone (& self) -> LldMode { * self } } # [automatically_derived] impl :: core :: default :: Default for LldMode { # [inline] fn default () -> LldMode { Self :: Unused } } # [automatically_derived] impl :: core :: fmt :: Debug for LldMode { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { LldMode :: Unused => "Unused" , LldMode :: SelfContained => "SelfContained" , LldMode :: External => "External" , } ,) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for LldMode { } # [automatically_derived] impl :: core :: cmp :: PartialEq for LldMode { # [inline] fn eq (& self , other : & LldMode) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl LldMode { pub fn is_used (& self) -> bool { match self { LldMode :: SelfContained | LldMode :: External => true , LldMode :: Unused => false , } } } impl < 'de > Deserialize < 'de > for LldMode { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : Deserializer < 'de > , { struct LldModeVisitor ; impl serde :: de :: Visitor < '_ > for LldModeVisitor { type Value = LldMode ; fn expecting (& self , formatter : & mut fmt :: Formatter < '_ >) -> fmt :: Result { formatter . write_str ("one of true, 'self-contained' or 'external'") } fn visit_bool < E > (self , v : bool) -> Result < Self :: Value , E > where E : serde :: de :: Error , { Ok (if v { LldMode :: External } else { LldMode :: Unused }) } fn visit_str < E > (self , v : & str) -> Result < Self :: Value , E > where E : serde :: de :: Error , { match v { "external" => Ok (LldMode :: External) , "self-contained" => Ok (LldMode :: SelfContained) , _ => { Err (E :: custom (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("unknown mode {0}" , v)) }) ,) ,) } } } } deserializer . deserialize_any (LldModeVisitor) } } }