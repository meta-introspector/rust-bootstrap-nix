pub mod stage0_parser { use crate :: prelude :: * ; pub struct Stage0 { pub compiler : VersionMetadata , pub rustfmt : Option < VersionMetadata > , pub config : Stage0Config , pub checksums_sha256 : BTreeMap < String , String > , } # [automatically_derived] impl :: core :: default :: Default for Stage0 { # [inline] fn default () -> Stage0 { Stage0 { compiler : :: core :: default :: Default :: default () , rustfmt : :: core :: default :: Default :: default () , config : :: core :: default :: Default :: default () , checksums_sha256 : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: clone :: Clone for Stage0 { # [inline] fn clone (& self) -> Stage0 { Stage0 { compiler : :: core :: clone :: Clone :: clone (& self . compiler) , rustfmt : :: core :: clone :: Clone :: clone (& self . rustfmt) , config : :: core :: clone :: Clone :: clone (& self . config) , checksums_sha256 : :: core :: clone :: Clone :: clone (& self . checksums_sha256) , } } } pub struct VersionMetadata { pub date : String , pub version : String , } # [automatically_derived] impl :: core :: default :: Default for VersionMetadata { # [inline] fn default () -> VersionMetadata { VersionMetadata { date : :: core :: default :: Default :: default () , version : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: clone :: Clone for VersionMetadata { # [inline] fn clone (& self) -> VersionMetadata { VersionMetadata { date : :: core :: clone :: Clone :: clone (& self . date) , version : :: core :: clone :: Clone :: clone (& self . version) , } } } pub struct Stage0Config { pub dist_server : String , pub artifacts_server : String , pub artifacts_with_llvm_assertions_server : String , pub git_merge_commit_email : String , pub git_repository : String , pub nightly_branch : String , } # [automatically_derived] impl :: core :: default :: Default for Stage0Config { # [inline] fn default () -> Stage0Config { Stage0Config { dist_server : :: core :: default :: Default :: default () , artifacts_server : :: core :: default :: Default :: default () , artifacts_with_llvm_assertions_server : :: core :: default :: Default :: default () , git_merge_commit_email : :: core :: default :: Default :: default () , git_repository : :: core :: default :: Default :: default () , nightly_branch : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: clone :: Clone for Stage0Config { # [inline] fn clone (& self) -> Stage0Config { Stage0Config { dist_server : :: core :: clone :: Clone :: clone (& self . dist_server) , artifacts_server : :: core :: clone :: Clone :: clone (& self . artifacts_server) , artifacts_with_llvm_assertions_server : :: core :: clone :: Clone :: clone (& self . artifacts_with_llvm_assertions_server ,) , git_merge_commit_email : :: core :: clone :: Clone :: clone (& self . git_merge_commit_email ,) , git_repository : :: core :: clone :: Clone :: clone (& self . git_repository) , nightly_branch : :: core :: clone :: Clone :: clone (& self . nightly_branch) , } } } pub fn parse_stage0_file (path : & Path) -> Stage0 { let stage0_content = std :: fs :: read_to_string (path) . expect (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read stage0 file: {0}" , path . display ()) ,) }) ,) ; let mut stage0 = Stage0 :: default () ; for line in stage0_content . lines () { let line = line . trim () ; if line . is_empty () { continue ; } if line . starts_with ('#') { continue ; } let (key , value) = line . split_once ('=') . unwrap () ; match key { "dist_server" => stage0 . config . dist_server = value . to_owned () , "artifacts_server" => stage0 . config . artifacts_server = value . to_owned () , "artifacts_with_llvm_assertions_server" => { stage0 . config . artifacts_with_llvm_assertions_server = value . to_owned () ; } "git_merge_commit_email" => { stage0 . config . git_merge_commit_email = value . to_owned () ; } "git_repository" => stage0 . config . git_repository = value . to_owned () , "nightly_branch" => stage0 . config . nightly_branch = value . to_owned () , "compiler_date" => stage0 . compiler . date = value . to_owned () , "compiler_version" => stage0 . compiler . version = value . to_owned () , "rustfmt_date" => { stage0 . rustfmt . get_or_insert (VersionMetadata :: default ()) . date = value . to_owned () ; } "rustfmt_version" => { stage0 . rustfmt . get_or_insert (VersionMetadata :: default ()) . version = value . to_owned () ; } dist if dist . starts_with ("dist") => { stage0 . checksums_sha256 . insert (key . to_owned () , value . to_owned ()) ; } unsupported => { { :: std :: io :: _print (format_args ! ("\'{0}\' field is not supported.\n" , unsupported ,) ,) ; } ; } } } stage0 } }