pub async fn extract_all_declarations_from_crate (manifest_path : & Path , _args : & crate :: Args , _type_map : & HashMap < String , type_extractor :: TypeInfo > , filter_names : & Option < Vec < String > > , rustc_info : & RustcInfo , cache_dir : & Path , gem_config : & GemConfig ,) -> anyhow :: Result < (Vec < Declaration > , usize , usize , usize , usize , usize , usize , HashMap < usize , usize > , Vec < ErrorSample > ,) , > { let mut all_declarations : Vec < Declaration > = Vec :: new () ; let mut all_collected_errors : Vec < ErrorSample > = Vec :: new () ; let mut total_files_processed = 0 ; let mut total_fns = 0 ; let mut total_structs = 0 ; let mut total_enums = 0 ; let mut total_statics = 0 ; let mut total_other_items = 0 ; let total_structs_per_layer : HashMap < usize , usize > = HashMap :: new () ; let metadata = cargo_metadata :: MetadataCommand :: new () . manifest_path (manifest_path) . exec () ? ; let package = metadata . packages . into_iter () . find (| p | p . manifest_path == manifest_path . to_path_buf ()) . context (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Package with manifest path {0} not found in metadata" , manifest_path . display () ,) ,) }) ,) ? ; let crate_root = manifest_path . parent () . unwrap () ; for target in package . targets { if target . kind . contains (& "lib" . to_string ()) || target . kind . contains (& "bin" . to_string ()) { let path = target . src_path . into_std_path_buf () ; if let Some (names) = filter_names { if ! names . iter () . any (| name | path . to_string_lossy () . contains (name)) { continue ; } } total_files_processed += 1 ; { :: std :: io :: _print (format_args ! ("  Processing file: {0}\n" , path . display ()) ,) ; } ; let mut writer = tokio :: io :: stdout () ; let (file , error_sample) = expand_macros_and_parse (& mut writer , & path , & crate_root , manifest_path , rustc_info , cache_dir ,) . await . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to expand macros and parse file: {0}" , path . display () ,) ,) })) ? ; if let Some (err) = error_sample { all_collected_errors . push (err) ; continue ; } let mut visitor = DeclsVisitor :: new (gem_config) ; visitor . visit_file (& file) ; all_declarations . extend (visitor . declarations) ; total_fns += visitor . fn_count ; total_structs += visitor . struct_count ; total_enums += visitor . enum_count ; total_statics += visitor . static_count ; total_other_items += visitor . other_item_count ; } } Ok ((all_declarations , total_files_processed , total_fns , total_structs , total_enums , total_statics , total_other_items , total_structs_per_layer , all_collected_errors ,)) }