# [doc = " A DFA implementation of Aho-Corasick."] # [doc = ""] # [doc = " When possible, prefer using [`AhoCorasick`](crate::AhoCorasick) instead of"] # [doc = " this type directly. Using a `DFA` directly is typically only necessary when"] # [doc = " one needs access to the [`Automaton`] trait implementation."] # [doc = ""] # [doc = " This DFA can only be built by first constructing a [`noncontiguous::NFA`]."] # [doc = " Both [`DFA::new`] and [`Builder::build`] do this for you automatically, but"] # [doc = " [`Builder::build_from_noncontiguous`] permits doing it explicitly."] # [doc = ""] # [doc = " A DFA provides the best possible search performance (in this crate) via two"] # [doc = " mechanisms:"] # [doc = ""] # [doc = " * All states use a dense representation for their transitions."] # [doc = " * All failure transitions are pre-computed such that they are never"] # [doc = " explicitly handled at search time."] # [doc = ""] # [doc = " These two facts combined mean that every state transition is performed"] # [doc = " using a constant number of instructions. However, this comes at"] # [doc = " great cost. The memory usage of a DFA can be quite exorbitant."] # [doc = " It is potentially multiple orders of magnitude greater than a"] # [doc = " [`contiguous::NFA`](crate::nfa::contiguous::NFA) for example. In exchange,"] # [doc = " a DFA will typically have better search speed than a `contiguous::NFA`, but"] # [doc = " not by orders of magnitude."] # [doc = ""] # [doc = " Unless you have a small number of patterns or memory usage is not a concern"] # [doc = " and search performance is critical, a DFA is usually not the best choice."] # [doc = ""] # [doc = " Moreover, unlike the NFAs in this crate, it is costly for a DFA to"] # [doc = " support for anchored and unanchored search configurations. Namely,"] # [doc = " since failure transitions are pre-computed, supporting both anchored"] # [doc = " and unanchored searches requires a duplication of the transition table,"] # [doc = " making the memory usage of such a DFA ever bigger. (The NFAs in this crate"] # [doc = " unconditionally support both anchored and unanchored searches because there"] # [doc = " is essentially no added cost for doing so.) It is for this reason that"] # [doc = " a DFA's support for anchored and unanchored searches can be configured"] # [doc = " via [`Builder::start_kind`]. By default, a DFA only supports unanchored"] # [doc = " searches."] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This example shows how to build an `DFA` directly and use it to execute"] # [doc = " [`Automaton::try_find`]:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::Automaton,"] # [doc = "     dfa::DFA,"] # [doc = "     Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let nfa = DFA::new(patterns).unwrap();"] # [doc = " assert_eq!("] # [doc = "     Some(Match::must(0, 1..2)),"] # [doc = "     nfa.try_find(&Input::new(haystack))?,"] # [doc = " );"] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " It is also possible to implement your own version of `try_find`. See the"] # [doc = " [`Automaton`] documentation for an example."] pub struct DFA { # [doc = " The DFA transition table. IDs in this table are pre-multiplied. So"] # [doc = " instead of the IDs being 0, 1, 2, 3, ..., they are 0*stride, 1*stride,"] # [doc = " 2*stride, 3*stride, ..."] trans : Vec < StateID > , # [doc = " The matches for every match state in this DFA. This is first indexed by"] # [doc = " state index (so that's `sid >> stride2`) and then by order in which the"] # [doc = " matches are meant to occur."] matches : Vec < Vec < PatternID > > , # [doc = " The amount of heap memory used, in bytes, by the inner Vecs of"] # [doc = " 'matches'."] matches_memory_usage : usize , # [doc = " The length of each pattern. This is used to compute the start offset"] # [doc = " of a match."] pattern_lens : Vec < SmallIndex > , # [doc = " A prefilter for accelerating searches, if one exists."] prefilter : Option < Prefilter > , # [doc = " The match semantics built into this DFA."] match_kind : MatchKind , # [doc = " The total number of states in this DFA."] state_len : usize , # [doc = " The alphabet size, or total number of equivalence classes, for this"] # [doc = " DFA. Note that the actual number of transitions in each state is"] # [doc = " stride=2^stride2, where stride is the smallest power of 2 greater than"] # [doc = " or equal to alphabet_len. We do things this way so that we can use"] # [doc = " bitshifting to go from a state ID to an index into 'matches'."] alphabet_len : usize , # [doc = " The exponent with a base 2, such that stride=2^stride2. Given a state"] # [doc = " index 'i', its state identifier is 'i << stride2'. Given a state"] # [doc = " identifier 'sid', its state index is 'sid >> stride2'."] stride2 : usize , # [doc = " The equivalence classes for this DFA. All transitions are defined on"] # [doc = " equivalence classes and not on the 256 distinct byte values."] byte_classes : ByteClasses , # [doc = " The length of the shortest pattern in this automaton."] min_pattern_len : usize , # [doc = " The length of the longest pattern in this automaton."] max_pattern_len : usize , # [doc = " The information required to deduce which states are \"special\" in this"] # [doc = " DFA."] special : Special , }