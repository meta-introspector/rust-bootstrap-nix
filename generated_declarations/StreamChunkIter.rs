# [doc = " An iterator that reports matches in a stream."] # [doc = ""] # [doc = " (This doesn't actually implement the `Iterator` trait because it returns"] # [doc = " something with a lifetime attached to a buffer it owns, but that's OK. It"] # [doc = " still has a `next` method and is iterator-like enough to be fine.)"] # [doc = ""] # [doc = " This iterator yields elements of type `io::Result<StreamChunk>`, where"] # [doc = " an error is reported if there was a problem reading from the underlying"] # [doc = " stream. The iterator terminates only when the underlying stream reaches"] # [doc = " `EOF`."] # [doc = ""] # [doc = " The idea here is that each chunk represents either a match or a non-match,"] # [doc = " and if you concatenated all of the chunks together, you'd reproduce the"] # [doc = " entire contents of the stream, byte-for-byte."] # [doc = ""] # [doc = " This chunk machinery is a bit complicated and it isn't strictly required"] # [doc = " for a stream searcher that just reports matches. But we do need something"] # [doc = " like this to deal with the \"replacement\" API, which needs to know which"] # [doc = " chunks it can copy and which it needs to replace."] struct StreamChunkIter < 'a , A , R > { # [doc = " The underlying automaton to do the search."] aut : & 'a A , # [doc = " The source of bytes we read from."] rdr : R , # [doc = " A roll buffer for managing bytes from `rdr`. Basically, this is used"] # [doc = " to handle the case of a match that is split by two different"] # [doc = " calls to `rdr.read()`. This isn't strictly needed if all we needed to"] # [doc = " do was report matches, but here we are reporting chunks of non-matches"] # [doc = " and matches and in order to do that, we really just cannot treat our"] # [doc = " stream as non-overlapping blocks of bytes. We need to permit some"] # [doc = " overlap while we retain bytes from a previous `read` call in memory."] buf : crate :: util :: buffer :: Buffer , # [doc = " The unanchored starting state of this automaton."] start : StateID , # [doc = " The state of the automaton."] sid : StateID , # [doc = " The absolute position over the entire stream."] absolute_pos : usize , # [doc = " The position we're currently at within `buf`."] buffer_pos : usize , # [doc = " The buffer position of the end of the bytes that we last returned"] # [doc = " to the caller. Basically, whenever we find a match, we look to see if"] # [doc = " there is a difference between where the match started and the position"] # [doc = " of the last byte we returned to the caller. If there's a difference,"] # [doc = " then we need to return a 'NonMatch' chunk."] buffer_reported_pos : usize , }