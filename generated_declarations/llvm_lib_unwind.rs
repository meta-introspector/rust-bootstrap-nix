pub mod llvm_lib_unwind { use std :: str :: FromStr ; pub enum LlvmLibunwind { # [default] No , InTree , System , } # [automatically_derived] impl :: core :: fmt :: Debug for LlvmLibunwind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { LlvmLibunwind :: No => "No" , LlvmLibunwind :: InTree => "InTree" , LlvmLibunwind :: System => "System" , } ,) } } # [automatically_derived] impl :: core :: default :: Default for LlvmLibunwind { # [inline] fn default () -> LlvmLibunwind { Self :: No } } # [automatically_derived] impl :: core :: clone :: Clone for LlvmLibunwind { # [inline] fn clone (& self) -> LlvmLibunwind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for LlvmLibunwind { } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for LlvmLibunwind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for LlvmLibunwind { # [inline] fn eq (& self , other : & LlvmLibunwind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } # [automatically_derived] impl :: core :: cmp :: Eq for LlvmLibunwind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } impl FromStr for LlvmLibunwind { type Err = String ; fn from_str (value : & str) -> Result < Self , Self :: Err > { match value { "no" => Ok (Self :: No) , "in-tree" => Ok (Self :: InTree) , "system" => Ok (Self :: System) , invalid => { Err (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Invalid value \'{0}\' for rust.llvm-libunwind config." , invalid ,) ,) }) ,) } } } } }