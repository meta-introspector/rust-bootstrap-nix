//! A tool to automatically generate preludes for Rust crates.
//!
//! This tool scans all crates in a workspace, extracts all `use` statements,
//! generates a `prelude.rs` file for each crate, and replaces the original
//! `use` statements with a single `use crate::prelude::*;`.

use anyhow::{Context, Result};
use clap::Parser;
use serde::Deserialize;
use std::collections::HashSet;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;
use syn::Item;
use walkdir::WalkDir;

/// Command-line arguments for the prelude generator.
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Run in dry-run mode, printing changes without modifying files.
    #[arg(long)]
    dry_run: bool,

    /// The path to the workspace root.
    #[arg(default_value = ".")]
    path: PathBuf,
}

#[derive(Deserialize, Debug)]
struct Metadata {
    packages: Vec<Package>,
    workspace_root: PathBuf,
}

#[derive(Deserialize, Debug)]
struct Package {
    name: String,
    manifest_path: PathBuf,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Run `cargo metadata`
    let output = Command::new("cargo")
        .arg("metadata")
        .arg("--no-deps")
        .arg("--format-version=1")
        .current_dir(&args.path)
        .output()?;

    if !output.status.success() {
        anyhow::bail!(
            "cargo metadata failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    let metadata: Metadata = serde_json::from_slice(&output.stdout)?;

    println!(
        "Starting prelude generation in workspace: {}",
        metadata.workspace_root.display()
    );

    for package in metadata.packages {
        let crate_root = package.manifest_path.parent().unwrap();
        println!("\nProcessing crate: {} ({})", package.name, crate_root.display());
        process_crate(crate_root, args.dry_run)?;
    }

    println!("\nPrelude generation complete.");
    Ok(())
}

/// Processes a single crate, generating its prelude and modifying its source files.
fn process_crate(crate_root: &Path, dry_run: bool) -> Result<()> {
    let src_dir = crate_root.join("src");
    if !src_dir.is_dir() {
        println!("  -> No src directory found, skipping.");
        return Ok(())
    }

    let mut use_statements = HashSet::new();
    let mut rust_files = Vec::new();

    // First pass: collect all use statements
    for entry in WalkDir::new(&src_dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| {
            let path = e.path();
            path.extension().map_or(false, |ext| ext == "rs")
                && path.file_name().map_or(false, |name| name != "prelude.rs")
        })
    {
        let path = entry.path();
        rust_files.push(path.to_path_buf());
        let content = fs::read_to_string(path)?;
        println!("--> Parsing file: {}", path.display());
        let ast = syn::parse_file(&content)
            .with_context(|| format!("Failed to parse {}", path.display()))?;

        for item in &ast.items {
            if let Item::Use(use_item) = item {
                let use_string = quote::quote!(#use_item).to_string();
                use_statements.insert(use_string);
            }
        }
    }

    if use_statements.is_empty() {
        println!("  -> No use statements found, skipping.");
        return Ok(())
    }

    // Generate the prelude file
    generate_prelude(&src_dir, &use_statements, dry_run)?;

    // Second pass: modify files to use the prelude
    for path in &rust_files {
        modify_file(path, dry_run)?;
    }
    
    // Modify crate root to include the prelude
    modify_crate_root(&src_dir, dry_run)?;

    Ok(())
}

/// Generates the `prelude.rs` file for a crate.
fn generate_prelude(
    src_dir: &Path,
    use_statements: &HashSet<String>,
    dry_run: bool,
) -> Result<()> {
    let prelude_path = src_dir.join("prelude.rs");
    let mut prelude_content =
        String::from("// This file is auto-generated by prelude-generator. Do not edit.\n\n");

    let mut sorted_uses: Vec<_> = use_statements.iter().collect();
    sorted_uses.sort();

    for use_stmt in sorted_uses {
        let pub_use = format!("pub {}", use_stmt);
        prelude_content.push_str(&pub_use);
        prelude_content.push_str("\n");
    }

    if dry_run {
        println!(
            "[DRY RUN] Would generate prelude file: {}\n---\n{}---",
            prelude_path.display(),
            prelude_content
        );
    } else {
        println!("  -> Generating prelude file: {}", prelude_path.display());
        fs::write(&prelude_path, prelude_content)?;
    }

    Ok(())
}

/// Modifies a source file to remove its `use` statements and add `use crate::prelude::*;`.
fn modify_file(path: &Path, dry_run: bool) -> Result<()> {
    let content = fs::read_to_string(path)?;
    let ast = syn::parse_file(&content)?;

    let mut new_items = Vec::new();
    let mut has_use_statements = false;

    // Filter out old use statements
    for item in &ast.items {
        if let Item::Use(_) = item {
            has_use_statements = true;
        } else {
            new_items.push(item.clone());
        }
    }

    // If there were use statements, add the prelude import
    if has_use_statements {
        let prelude_use: Item = syn::parse_quote! { use crate::prelude::*; };
        new_items.insert(0, prelude_use);

        let mut new_ast = ast.clone();
        new_ast.items = new_items;

        let new_content = prettyplease::unparse(&new_ast);

        if dry_run {
            println!(
                "[DRY RUN] Would modify file: {}\n---\n{}---",
                path.display(),
                new_content
            );
        } else {
            println!("  -> Modifying file: {}", path.display());
            fs::write(path, new_content)?;
        }
    }

    Ok(())
}

/// Modifies the crate root (`lib.rs` or `main.rs`) to ensure it contains `pub mod prelude;`.
fn modify_crate_root(src_dir: &Path, dry_run: bool) -> Result<()> {
    let lib_rs = src_dir.join("lib.rs");
    let main_rs = src_dir.join("main.rs");
    let crate_root_path = if lib_rs.exists() {
        lib_rs
    } else if main_rs.exists() {
        main_rs
    } else {
        return Ok(())
    };

    let content = fs::read_to_string(&crate_root_path)?;
    let ast = syn::parse_file(&content)?;

    let mut has_prelude_mod = false;
    for item in &ast.items {
        if let Item::Mod(mod_item) = item {
            if mod_item.ident == "prelude" {
                has_prelude_mod = true;
                break;
            }
        }
    }

    if !has_prelude_mod {
        let mut new_ast = ast.clone();
        let prelude_mod: Item = syn::parse_quote! { pub mod prelude; };
        new_ast.items.insert(0, prelude_mod);
        
        let new_content = prettyplease::unparse(&new_ast);

        if dry_run {
             println!(
                "[DRY RUN] Would add 'pub mod prelude;' to: {}",
                crate_root_path.display()
            );
        } else {
            println!("  -> Adding 'pub mod prelude;' to: {}", crate_root_path.display());
            fs::write(&crate_root_path, new_content)?;
        }
    }

    Ok(())
}
