# Nix-Rust Integration Process: Passing Flake URLs via config.toml

## 1. Goal

The primary objective is to deeply integrate the Rust project's build process with the Nix ecosystem. This involves using Nix flake URLs as inputs to the Rust build system, enabling Rust to query Nix for build information, and ultimately building a specific version of Rust (e.g., from `github:meta-introspector/rust?ref=feature/CRQ-016-nixify`) through an 8-level bootstrap process managed by Nix.

## 2. `bootstrap-config-builder` Role: Generating `config.toml`

The `bootstrap-config-builder` is a Rust utility responsible for generating the `config.toml` file, which serves as the primary configuration input for the Rust bootstrap process. This builder is now capable of incorporating Nix flake URLs and paths into the generated `config.toml`.

### Key Mechanisms:

*   **`example.toml` Template:** The builder uses `bootstrap-config-builder/src/example.toml` as a template. This template defines the structure of the output `config.toml` and includes named placeholders (e.g., `{system}`, `{nixpkgs_path}`, `{rust_src_flake_ref}`) for dynamic values.

*   **`format_file` Function:** The `bootstrap-config-builder/src/utils/format_file.rs` module contains the `format_file` function, which reads the `example.toml` template and replaces its placeholders with actual values provided via command-line arguments or a configuration file.

*   **Configuration Loading and Overrides:** The `bootstrap-config-builder` now supports loading configuration from an external `config.toml` file (specified via `--config-file`) and merging it with command-line arguments. Command-line arguments take precedence, allowing for flexible overrides.
    *   **`bootstrap-config-builder/src/args.rs`**: Defines command-line arguments, including `config_file` and various Nix-related paths and flake references.
    *   **`bootstrap-config-builder/src/config.rs`**: Defines the `AppConfig` struct, which can be deserialized from a TOML file and includes a `merge_with_args` method to apply command-line overrides.
    *   **`bootstrap-config-builder/src/main.rs`**: Orchestrates the parsing of CLI arguments, loading of `config.toml`, merging configurations, and then using the final `AppConfig` to generate the output `config.toml` content.

## 3. Rust Bootstrap (`standalonex`) Configuration Consumption

The `standalonex/src/bootstrap` component of the Rust project is being refactored to consume the `config.toml` generated by `bootstrap-config-builder`. This enables the Rust bootstrap to understand and utilize the Nix-related configuration.

### Key Components for Consumption:

*   **`LocalTomlConfig` (`standalonex/src/bootstrap/src/core/config_utils/src/local_toml_config.rs`):** This struct represents the overall structure of the `config.toml` file as understood by the Rust bootstrap. It now includes a `nix: Option<LocalNixConfig>` field to specifically capture the Nix-related configuration.

*   **`LocalNixConfig` (`standalonex/src/bootstrap/src/core/config_utils/src/local_nix_config.rs`):** A newly introduced struct that mirrors the `[nix]` section of the `config.toml`. It contains fields for `nixpkgs_path`, `rust_overlay_path`, `rust_bootstrap_nix_path`, `configuration_nix_path`, `rust_src_flake_path`, `rust_bootstrap_nix_flake_ref`, and `rust_src_flake_ref`.

*   **`NixConfigApplicator` (`standalonex/src/bootstrap/src/core/config_utils/src/nix_config.rs`):** This is a `ConfigApplicator` implementation responsible for taking the deserialized `LocalNixConfig` values and applying them to the `ParsedConfig` struct, which holds the final, merged configuration for the Rust bootstrap.

*   **`ParsedConfig` (`standalonex/src/bootstrap/src/core/config_utils/src/parsed_config.rs`):** This central struct now includes dedicated fields to store the Nix-related paths and flake references, making them accessible throughout the Rust bootstrap logic.

*   **`parse.rs` (`standalonex/src/bootstrap/src/core/config_utils/src/parse.rs`):** This module orchestrates the configuration parsing. It now includes `NixConfigApplicator` in its list of applicators, ensuring that the Nix configuration is processed and applied during the bootstrap's configuration phase.

## 4. Next Steps (High-Level)

With the `config.toml` generation and consumption mechanisms in place, the subsequent steps will focus on enabling the Rust bootstrap to actively interact with Nix:

1.  **Nix Interaction from Rust:** Implement logic within the Rust bootstrap to execute Nix commands (e.g., `nix eval`, `nix build`) using the paths and flake references obtained from `ParsedConfig`.
2.  **Parsing Nix Output:** Process the output of Nix commands to extract necessary information (e.g., resolved Nix store paths for dependencies, build artifacts).
3.  **Integration into Rust Build:** Integrate the resolved Nix information into the existing Rust 8-level bootstrap build process, ensuring that the Rust compiler and its components are built using Nix-managed inputs.
4.  **Flake Generation:** Develop a mechanism to generate a new Nix flake or a virtual flake that encapsulates the entire Rust build process, making it fully reproducible and Nix-driven.