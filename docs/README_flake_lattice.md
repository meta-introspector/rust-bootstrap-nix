# Rust-Driven Nix Flake Generation: Building a Flake Lattice

This document outlines the plan to dynamically generate Nix flakes using Rust, starting with a core configuration and building up a "flake lattice" incrementally. The goal is to leverage Rust for managing and templating Nix configurations, enabling a more programmatic and verifiable approach to Nix flake development.

## Overall Goal

To create a system where Rust programs generate and manage Nix flake definitions, allowing for:
*   Dynamic configuration of Nix builds.
*   Programmatic generation of Nix expressions.
*   A "flake lattice" where each flake adds a feature or dependency, building upon previous ones.

### The `generated/` Directory: Output for the Flake Lattice

The `generated/` directory will serve as the primary output location for the dynamically generated components of the flake lattice. For each individual function or declaration that is transformed into a self-contained unit (as part of the "lattice of functions" goal), the `generated/` directory will contain:

*   `Cargo.toml`: The Rust package manifest for the generated library.
*   `flake.nix`: The Nix flake definition for building and integrating this specific generated library.
*   `lib.rs`: The Rust source code for the generated function or declaration, encapsulated as a library.

This approach ensures that each node in our "flake lattice" is a fully functional, reproducible, and independently manageable unit, built and integrated via Nix.

## Immediate Focus: Generating a Seed Config Flake

Our immediate goal is to successfully generate a minimal, functional Nix flake directory using Rust. This flake will contain a `flake.nix` generated from a Rust template and will expose a `config.toml` file (generated by `bootstrap-config-builder`) as a Nix package. This will serve as our "seed config" flake.

## Detailed Plan: Small, Verifiable Steps

### Phase 1: Ensure `bootstrap-config-builder` can generate `config.toml`

This phase verifies that our Rust component responsible for generating the core configuration is working correctly in isolation.

1.  **Verify `bootstrap-config-builder` output:**
    *   **Action:** Navigate to the `bootstrap-config-builder` directory.
    *   **Command:** `cargo run --bin bootstrap-config-generator -- --output generated_config.toml`
    *   **Verification:** Confirm that `generated_config.toml` is created in the `bootstrap-config-builder` directory and contains the expected TOML content.
    *   **Debugging:** If this fails, debug errors within `bootstrap-config-builder/src/` (Rust code) until a valid `config.toml` is produced.

### Phase 2: Create a New Rust Crate for Generating `flake.nix` from a Template

This phase involves building the Rust component that will take our generated `config.toml` and embed it into a dynamically created `flake.nix`.

1.  **Create a new Rust crate:**
    *   **Action:** Create a new Rust project (e.g., `flake-template-generator`) within the main project's `vendor/rust/` directory.
    *   **Purpose:** This crate will be responsible for:
        *   Reading the `config.toml` generated in Phase 1.
        *   Reading a predefined `flake.nix` template.
        *   Substituting placeholders in the template with values from `config.toml` or other dynamic data.
        *   Writing the resulting `flake.nix` to a specified output directory.
2.  **Define a basic `flake.nix` template:**
    *   **Action:** Create a minimal `flake.nix` template file (e.g., `flake_template.nix`) within the `flake-template-generator` crate's resources.
    *   **Content (Example):**
        ```nix
        {
          description = "Dynamically generated config flake";

          outputs = { self, nixpkgs }:
            let
              pkgs = import nixpkgs { system = "aarch64-linux"; }; # Assuming aarch64-linux for now
              configTomlContent = builtins.readFile ./config.toml;
            in
            {
              packages.aarch64-linux.default = pkgs.runCommand "generated-config-toml" { } ''
                mkdir -p $out
                echo "${configTomlContent}" > $out/config.toml
              '';
              # Add other outputs as needed, e.g., devShells
            };
        }
        ```
    *   **Placeholders:** The template might include placeholders for system architecture, flake inputs, or other dynamic values that the Rust generator will fill in. For this initial step, we'll keep it simple.

### Phase 3: Integrate and Test the New Flake Generation

This phase executes the Rust generator and verifies that the dynamically created flake is valid and functional.

1.  **Run `flake-template-generator`:**
    *   **Action:** Execute the `flake-template-generator` Rust binary.
    *   **Command (Example):** `cargo run --bin flake-template-generator -- --config-path ../bootstrap-config-builder/generated_config.toml --output-dir target/generated-flake`
    *   **Verification:** Confirm that a new directory (e.g., `target/generated-flake`) is created, containing a `flake.nix` and a `config.toml`.
2.  **Build the generated flake:**
    *   **Action:** Navigate to the newly generated flake directory (e.g., `target/generated-flake`).
    *   **Command:** `nix build .#default` (assuming the template exposes the config as the default package).
    *   **Verification:** Confirm that the build succeeds and the output (`result`) contains the `config.toml` file.
    *   **Debugging:** If this fails, debug the generated `flake.nix` and the `flake-template-generator` Rust code.

### Phase 4: Integrate the Generated Flake into the Root Project

Once the seed config flake can be reliably generated and built, we will integrate it into the main project's root `flake.nix`.

1.  **Add the generated flake as an input to the root `flake.nix`:**
    *   **Action:** In the root `flake.nix`, add an input pointing to the dynamically generated flake directory (e.g., `configFlake.url = "./target/generated-flake";`).
2.  **Consume the generated config:**
    *   **Action:** Modify the root `flake.nix` to consume the `config.toml` from `configFlake.packages.${pkgs.system}.default` (or whatever the output is named).
    *   **Purpose:** This will replace the direct dependency on `bootstrap-config-builder` for the `config.toml` content.
3.  **Run `nix build .#default` (root):**
    *   **Verification:** Confirm that the main project can now build using the dynamically generated config.

This structured approach ensures that each component is tested and verified before integration, making the debugging process much more manageable.
