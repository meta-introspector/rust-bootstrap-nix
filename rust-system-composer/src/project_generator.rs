
use std::collections::HashSet;

pub fn generate_cargo_toml_content(project_name: &str) -> String {
    format!(
        r#"[package]
name = "{}"
version = "0.1.0"
edition = "2021"

[lib]
# This will be set to proc-macro = true if proc macros are detected

[dependencies]
anyhow = "1.0"
clap = {{ version = "4.0", features = ["derive"] }}
chrono = {{ version = "0.4", features = ["serde"] }}
cargo_metadata = "0.18.1"
proc-macro2 = "1.0"
quote = "1.0"
serde = {{ version = "1.0", features = ["derive"] }}
serde_json = "1.0"
syn = {{ version = "2.0", features = ["full", "extra-traits"] }}
tokio = {{ version = "1", features = ["full"] }}
walkdir = "2.0"
lazy_static = "1.4.0"
once_cell = "1.19.0"

split-expanded-lib = {{ path = "../../split-expanded-lib" }}
build_helper = {{ path = "../../standalonex/src/build_helper" }}
config_macros = {{ path = "../../standalonex/src/config_macros" }}
config_core = {{ path = "../../standalonex/src/config_core" }}
"#,
        project_name
    )
}

pub fn generate_lib_rs_content(
    generated_module_names: &[String],
    has_proc_macros: bool,
    feature_attributes: &HashSet<String>,
    extern_crates: &HashSet<String>,
    source_file_name: &str,
) -> String {
    let mut lib_rs_content = String::new();
    lib_rs_content.push_str(&format!("// This file is automatically generated by project-generator from {}.\n", source_file_name));
    lib_rs_content.push_str("// Do not modify this file directly.\n\n");

    // Add feature attributes
    for feature in feature_attributes {
        lib_rs_content.push_str(&format!("#![feature({})]\n", feature));
    }
    if has_proc_macros {
        lib_rs_content.push_str("#![feature(proc_macro_span)]\n"); // Required for some proc macros
        lib_rs_content.push_str("#![feature(stmt_expr_attributes)]\n"); // Required for attributes on expressions
    }
    lib_rs_content.push_str("\n");

    // Add extern crate declarations
    for extern_crate in extern_crates {
        lib_rs_content.push_str(&format!("extern crate {};\n", extern_crate));
    }
    lib_rs_content.push_str("\n");

    lib_rs_content.push_str("use build_helper::prelude::*;\n\n");

    for module_name in generated_module_names {
        lib_rs_content.push_str(&format!("pub mod {};\n", module_name));
    }
    lib_rs_content
}

pub fn get_common_imports() -> HashSet<String> {
    let mut common_imports = HashSet::new();
    common_imports.insert("use std::path::{Path, PathBuf};".to_string());
    common_imports.insert("use std::process::Command;".to_string());
    common_imports.insert("use std::collections::{BTreeMap, HashMap, HashSet};".to_string());
    common_imports.insert("use anyhow::{Context, Result};".to_string());
    common_imports.insert("use clap::{Args, Parser, Subcommand};".to_string());
    common_imports.insert("use serde::{Deserialize, Serialize};".to_string());
    common_imports
}

pub fn generate_prelude_rs_content(
    global_uses: &HashSet<String>,
    feature_attributes: &HashSet<String>,
    common_imports: &HashSet<String>,
) -> String {
    let mut prelude_content = String::new();
    prelude_content.push_str("// This file is automatically generated by project-generator.\n");
    prelude_content.push_str("// Do not modify this file directly.\n\n");

    // Add feature attributes
    for feature in feature_attributes {
        prelude_content.push_str(&format!("#![feature({})]\n", feature));
    }
    prelude_content.push_str("\n");

    // Add common use statements
    for use_stmt in common_imports {
        prelude_content.push_str(&format!("{}\n", use_stmt));
    }
    prelude_content.push_str("\n");

    // Add global use statements
    for use_stmt in global_uses {
        prelude_content.push_str(&format!("{}\n", use_stmt));
    }
    prelude_content.push_str("\n");

    prelude_content
}
