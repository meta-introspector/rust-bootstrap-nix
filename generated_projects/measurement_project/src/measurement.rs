use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod measurement { use std :: time :: Instant ; use std :: collections :: HashMap ; use std :: sync :: Mutex ; use serde :: Serialize ; pub struct FunctionMetrics { # [serde (skip)] pub start_time : Instant , # [serde (skip)] pub end_time : Option < Instant > , pub duration_micros : Option < u128 > , pub call_count : u64 , } # [automatically_derived] impl :: core :: fmt :: Debug for FunctionMetrics { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "FunctionMetrics" , "start_time" , & self . start_time , "end_time" , & self . end_time , "duration_micros" , & self . duration_micros , "call_count" , & & self . call_count ,) } } # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for FunctionMetrics { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "FunctionMetrics" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "duration_micros" , & self . duration_micros ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "call_count" , & self . call_count ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } } ; # [automatically_derived] impl :: core :: clone :: Clone for FunctionMetrics { # [inline] fn clone (& self) -> FunctionMetrics { FunctionMetrics { start_time : :: core :: clone :: Clone :: clone (& self . start_time) , end_time : :: core :: clone :: Clone :: clone (& self . end_time) , duration_micros : :: core :: clone :: Clone :: clone (& self . duration_micros) , call_count : :: core :: clone :: Clone :: clone (& self . call_count) , } } } impl FunctionMetrics { pub fn new () -> Self { FunctionMetrics { start_time : Instant :: now () , end_time : None , duration_micros : None , call_count : 0 , } } } # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)] # [allow (dead_code)] struct METRICS { __private_field : () , } # [doc (hidden)] # [allow (non_upper_case_globals)] static METRICS : METRICS = METRICS { __private_field : () } ; impl :: lazy_static :: __Deref for METRICS { type Target = Mutex < HashMap < String , FunctionMetrics > > ; fn deref (& self) -> & Mutex < HashMap < String , FunctionMetrics > > { # [inline (always)] fn __static_ref_initialize () -> Mutex < HashMap < String , FunctionMetrics > > { Mutex :: new (HashMap :: new ()) } # [inline (always)] fn __stability () -> & 'static Mutex < HashMap < String , FunctionMetrics > > { static LAZY : :: lazy_static :: lazy :: Lazy < Mutex < HashMap < String , FunctionMetrics > > , > = :: lazy_static :: lazy :: Lazy :: INIT ; LAZY . get (__static_ref_initialize) } __stability () } } impl :: lazy_static :: LazyStatic for METRICS { fn initialize (lazy : & Self) { let _ = & * * lazy ; } } pub fn record_function_entry (function_name : & str) { let mut metrics = METRICS . lock () . unwrap () ; let entry = metrics . entry (function_name . to_string ()) . or_insert_with (FunctionMetrics :: new) ; entry . start_time = Instant :: now () ; entry . call_count += 1 ; } pub fn record_function_exit (function_name : & str) { let mut metrics = METRICS . lock () . unwrap () ; if let Some (entry) = metrics . get_mut (function_name) { entry . end_time = Some (Instant :: now ()) ; let duration = entry . end_time . unwrap () . duration_since (entry . start_time) ; entry . duration_micros = Some (duration . as_micros ()) ; } } pub fn get_collected_metrics () -> HashMap < String , FunctionMetrics > { METRICS . lock () . unwrap () . clone () } }