use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod warnings { use clap :: * ; # [doc = " Whether to deny warnings, emit them as warnings, or use the default behavior"] pub enum Warnings { Deny , Warn , # [default] Default , } # [automatically_derived] impl :: core :: marker :: Copy for Warnings { } # [automatically_derived] impl :: core :: clone :: Clone for Warnings { # [inline] fn clone (& self) -> Warnings { * self } } # [automatically_derived] impl :: core :: default :: Default for Warnings { # [inline] fn default () -> Warnings { Self :: Default } } # [automatically_derived] impl :: core :: fmt :: Debug for Warnings { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { Warnings :: Deny => "Deny" , Warnings :: Warn => "Warn" , Warnings :: Default => "Default" , } ,) } } # [allow (dead_code , unreachable_code , unused_variables , unused_braces , unused_qualifications ,)] # [allow (clippy :: style , clippy :: complexity , clippy :: pedantic , clippy :: restriction , clippy :: perf , clippy :: deprecated , clippy :: nursery , clippy :: cargo , clippy :: suspicious_else_formatting , clippy :: almost_swapped , clippy :: redundant_locals ,)] # [automatically_derived] impl clap :: ValueEnum for Warnings { fn value_variants < 'a > () -> & 'a [Self] { & [Self :: Deny , Self :: Warn , Self :: Default] } fn to_possible_value < 'a > (& self ,) -> :: std :: option :: Option < clap :: builder :: PossibleValue > { match self { Self :: Deny => Some ({ clap :: builder :: PossibleValue :: new ("deny") }) , Self :: Warn => Some ({ clap :: builder :: PossibleValue :: new ("warn") }) , Self :: Default => Some ({ clap :: builder :: PossibleValue :: new ("default") }) , _ => None , } } } }