use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

fn expand_macros_and_parse (file_path : & Path , content : & str , rustc_info : & RustcInfo , cache_dir : & Path ,) -> Result < syn :: File > { let mut hasher = Sha256 :: new () ; hasher . update (content . as_bytes ()) ; let content_hash = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("{0:x}" , hasher . finalize ())) }) ; let cache_key = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("expanded_{0}_{1}_{2}_{3}_{4}" , content_hash , rustc_info . version , rustc_info . host , "lib" , "2021" ,) ,) }) ; let cached_file_path = cache_dir . join (cache_key) ; if cached_file_path . exists () { { :: std :: io :: _print (format_args ! ("      -> Using cached expanded code for: {0}\n" , file_path . display () ,) ,) ; } ; let expanded_code = fs :: read_to_string (& cached_file_path) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read cached expanded code for {0}" , file_path . display () ,) ,) })) ? ; return syn :: parse_file (& expanded_code) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse cached expanded code for {0}" , file_path . display () ,) ,) })) ; } let temp_crate_dir = tempfile :: tempdir () ? ; let temp_crate_path = temp_crate_dir . path () ; let cargo_toml_content = r#"[package]
name = "temp_crate"
version = "0.1.0"
edition = "2021"

[dependencies]
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
# Add other common dependencies that might contain macros
"# ; fs :: write (temp_crate_path . join ("Cargo.toml") , cargo_toml_content) ? ; let temp_src_dir = temp_crate_path . join ("src") ; fs :: create_dir (& temp_src_dir) ? ; let temp_rs_file_name = file_path . file_name () . unwrap_or_else (| | "temp_file.rs" . as_ref ()) ; let temp_rs_file_path = temp_src_dir . join (temp_rs_file_name) ; fs :: write (& temp_rs_file_path , content) ? ; let lib_rs_content = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("#![allow(unused_imports)]\n#![allow(dead_code)]\ninclude!(\"{0}\");\n" , temp_rs_file_name . to_string_lossy () ,) ,) }) ; fs :: write (temp_src_dir . join ("lib.rs") , lib_rs_content) ? ; { :: std :: io :: _print (format_args ! ("        -> PATH environment variable: {0:?}\n" , std :: env :: var ("PATH") ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("        -> Running cargo rustc -Zunpretty=expanded for: {0}\n" , file_path . display () ,) ,) ; } ; let output = Command :: new ("cargo") . arg ("rustc") . arg ("--") . arg ("-Zunpretty=expanded") . arg ("--crate-type") . arg ("lib") . current_dir (temp_crate_path) . output () ? ; { :: std :: io :: _print (format_args ! ("        -> cargo rustc status for {0}: {1}\n" , file_path . display () , output . status ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("        -> cargo rustc stdout for {0}: {1}\n\n" , file_path . display () , String :: from_utf8_lossy (& output . stdout) ,) ,) ; } ; if ! output . status . success () { { :: std :: io :: _print (format_args ! ("        -> cargo rustc stderr for {0}: {1}\n" , file_path . display () , String :: from_utf8_lossy (& output . stderr) ,) ,) ; } ; return :: anyhow :: __private :: Err (:: anyhow :: Error :: msg (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("cargo rustc -Zunpretty=expanded failed for {0}: {1}\nStderr: {2}" , file_path . display () , String :: from_utf8_lossy (& output . stdout) , String :: from_utf8_lossy (& output . stderr) ,) ,) }) ,) ,) ; } let expanded_code = String :: from_utf8_lossy (& output . stdout) . to_string () ; let search_string = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("// {0}\n" , temp_rs_file_name . to_string_lossy ()) ,) }) ; let start_index = expanded_code . find (& search_string) . unwrap_or (0) ; let end_index = expanded_code [start_index ..] . find ("// ") . map_or (expanded_code . len () , | i | start_index + i) ; let relevant_expanded_code = expanded_code [start_index .. end_index] . to_string () ; { :: std :: io :: _print (format_args ! ("        -> Writing expanded code to cache for: {0}\n" , file_path . display () ,) ,) ; } ; fs :: write (& cached_file_path , & relevant_expanded_code) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write expanded code to cache for {0}" , file_path . display () ,) ,) })) ? ; { :: std :: io :: _print (format_args ! ("      -> Wrote expanded code to cache: {0}\n" , cached_file_path . display () ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("        -> Parsing expanded code for: {0}\n" , file_path . display () ,) ,) ; } ; syn :: parse_file (& relevant_expanded_code) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse expanded code for {0}" , file_path . display () ,) ,) })) }