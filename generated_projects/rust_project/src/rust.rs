use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod rust { use std :: collections :: * ; use build_helper :: prelude :: * ; use crate :: define_config ; use crate :: RustOptimize ; use crate :: LldMode ; use crate :: StringOrBool ; pub struct Rust { pub optimize : Option < RustOptimize > , pub debug : Option < bool > , pub codegen_units : Option < u32 > , pub codegen_units_std : Option < u32 > , pub rustc_debug_assertions : Option < bool > , pub randomize_layout : Option < bool > , pub std_debug_assertions : Option < bool > , pub overflow_checks : Option < bool > , pub overflow_checks_std : Option < bool > , pub debug_logging : Option < bool > , pub backtrace : Option < bool > , pub incremental : Option < bool > , pub parallel_compiler : Option < bool > , pub default_linker : Option < String > , pub channel : Option < String > , pub description : Option < String > , pub musl_root : Option < String > , pub rpath : Option < bool > , pub strip : Option < bool > , pub frame_pointers : Option < bool > , pub stack_protector : Option < String > , pub verbose_tests : Option < bool > , pub optimize_tests : Option < bool > , pub codegen_tests : Option < bool > , pub omit_git_hash : Option < bool > , pub dist_src : Option < bool > , pub save_toolstates : Option < String > , pub codegen_backends : Option < Vec < String > > , pub llvm_bitcode_linker : Option < bool > , pub lld : Option < bool > , pub lld_mode : Option < LldMode > , pub llvm_tools : Option < bool > , pub deny_warnings : Option < bool > , pub backtrace_on_ice : Option < bool > , pub verify_llvm_ir : Option < bool > , pub thin_lto_import_instr_limit : Option < u32 > , pub remap_debuginfo : Option < bool > , pub jemalloc : Option < bool > , pub test_compare_mode : Option < bool > , pub llvm_libunwind : Option < String > , pub control_flow_guard : Option < bool > , pub ehcont_guard : Option < bool > , pub new_symbol_mangling : Option < bool > , pub profile_generate : Option < String > , pub profile_use : Option < String > , pub download_rustc : Option < StringOrBool > , pub lto : Option < String > , pub validate_mir_opts : Option < u32 > , pub std_features : Option < BTreeSet < String > > , } # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for Rust { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __field2 , __field3 , __field4 , __field5 , __field6 , __field7 , __field8 , __field9 , __field10 , __field11 , __field12 , __field13 , __field14 , __field15 , __field16 , __field17 , __field18 , __field19 , __field20 , __field21 , __field22 , __field23 , __field24 , __field25 , __field26 , __field27 , __field28 , __field29 , __field30 , __field31 , __field32 , __field33 , __field34 , __field35 , __field36 , __field37 , __field38 , __field39 , __field40 , __field41 , __field42 , __field43 , __field44 , __field45 , __field46 , __field47 , __field48 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , 2u64 => _serde :: __private228 :: Ok (__Field :: __field2) , 3u64 => _serde :: __private228 :: Ok (__Field :: __field3) , 4u64 => _serde :: __private228 :: Ok (__Field :: __field4) , 5u64 => _serde :: __private228 :: Ok (__Field :: __field5) , 6u64 => _serde :: __private228 :: Ok (__Field :: __field6) , 7u64 => _serde :: __private228 :: Ok (__Field :: __field7) , 8u64 => _serde :: __private228 :: Ok (__Field :: __field8) , 9u64 => _serde :: __private228 :: Ok (__Field :: __field9) , 10u64 => _serde :: __private228 :: Ok (__Field :: __field10) , 11u64 => _serde :: __private228 :: Ok (__Field :: __field11) , 12u64 => _serde :: __private228 :: Ok (__Field :: __field12) , 13u64 => _serde :: __private228 :: Ok (__Field :: __field13) , 14u64 => _serde :: __private228 :: Ok (__Field :: __field14) , 15u64 => _serde :: __private228 :: Ok (__Field :: __field15) , 16u64 => _serde :: __private228 :: Ok (__Field :: __field16) , 17u64 => _serde :: __private228 :: Ok (__Field :: __field17) , 18u64 => _serde :: __private228 :: Ok (__Field :: __field18) , 19u64 => _serde :: __private228 :: Ok (__Field :: __field19) , 20u64 => _serde :: __private228 :: Ok (__Field :: __field20) , 21u64 => _serde :: __private228 :: Ok (__Field :: __field21) , 22u64 => _serde :: __private228 :: Ok (__Field :: __field22) , 23u64 => _serde :: __private228 :: Ok (__Field :: __field23) , 24u64 => _serde :: __private228 :: Ok (__Field :: __field24) , 25u64 => _serde :: __private228 :: Ok (__Field :: __field25) , 26u64 => _serde :: __private228 :: Ok (__Field :: __field26) , 27u64 => _serde :: __private228 :: Ok (__Field :: __field27) , 28u64 => _serde :: __private228 :: Ok (__Field :: __field28) , 29u64 => _serde :: __private228 :: Ok (__Field :: __field29) , 30u64 => _serde :: __private228 :: Ok (__Field :: __field30) , 31u64 => _serde :: __private228 :: Ok (__Field :: __field31) , 32u64 => _serde :: __private228 :: Ok (__Field :: __field32) , 33u64 => _serde :: __private228 :: Ok (__Field :: __field33) , 34u64 => _serde :: __private228 :: Ok (__Field :: __field34) , 35u64 => _serde :: __private228 :: Ok (__Field :: __field35) , 36u64 => _serde :: __private228 :: Ok (__Field :: __field36) , 37u64 => _serde :: __private228 :: Ok (__Field :: __field37) , 38u64 => _serde :: __private228 :: Ok (__Field :: __field38) , 39u64 => _serde :: __private228 :: Ok (__Field :: __field39) , 40u64 => _serde :: __private228 :: Ok (__Field :: __field40) , 41u64 => _serde :: __private228 :: Ok (__Field :: __field41) , 42u64 => _serde :: __private228 :: Ok (__Field :: __field42) , 43u64 => _serde :: __private228 :: Ok (__Field :: __field43) , 44u64 => _serde :: __private228 :: Ok (__Field :: __field44) , 45u64 => _serde :: __private228 :: Ok (__Field :: __field45) , 46u64 => _serde :: __private228 :: Ok (__Field :: __field46) , 47u64 => _serde :: __private228 :: Ok (__Field :: __field47) , 48u64 => _serde :: __private228 :: Ok (__Field :: __field48) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "optimize" => _serde :: __private228 :: Ok (__Field :: __field0) , "debug" => _serde :: __private228 :: Ok (__Field :: __field1) , "codegen_units" => { _serde :: __private228 :: Ok (__Field :: __field2) } "codegen_units_std" => { _serde :: __private228 :: Ok (__Field :: __field3) } "rustc_debug_assertions" => { _serde :: __private228 :: Ok (__Field :: __field4) } "randomize_layout" => { _serde :: __private228 :: Ok (__Field :: __field5) } "std_debug_assertions" => { _serde :: __private228 :: Ok (__Field :: __field6) } "overflow_checks" => { _serde :: __private228 :: Ok (__Field :: __field7) } "overflow_checks_std" => { _serde :: __private228 :: Ok (__Field :: __field8) } "debug_logging" => { _serde :: __private228 :: Ok (__Field :: __field9) } "backtrace" => _serde :: __private228 :: Ok (__Field :: __field10) , "incremental" => _serde :: __private228 :: Ok (__Field :: __field11) , "parallel_compiler" => { _serde :: __private228 :: Ok (__Field :: __field12) } "default_linker" => { _serde :: __private228 :: Ok (__Field :: __field13) } "channel" => _serde :: __private228 :: Ok (__Field :: __field14) , "description" => _serde :: __private228 :: Ok (__Field :: __field15) , "musl_root" => _serde :: __private228 :: Ok (__Field :: __field16) , "rpath" => _serde :: __private228 :: Ok (__Field :: __field17) , "strip" => _serde :: __private228 :: Ok (__Field :: __field18) , "frame_pointers" => { _serde :: __private228 :: Ok (__Field :: __field19) } "stack_protector" => { _serde :: __private228 :: Ok (__Field :: __field20) } "verbose_tests" => { _serde :: __private228 :: Ok (__Field :: __field21) } "optimize_tests" => { _serde :: __private228 :: Ok (__Field :: __field22) } "codegen_tests" => { _serde :: __private228 :: Ok (__Field :: __field23) } "omit_git_hash" => { _serde :: __private228 :: Ok (__Field :: __field24) } "dist_src" => _serde :: __private228 :: Ok (__Field :: __field25) , "save_toolstates" => { _serde :: __private228 :: Ok (__Field :: __field26) } "codegen_backends" => { _serde :: __private228 :: Ok (__Field :: __field27) } "llvm_bitcode_linker" => { _serde :: __private228 :: Ok (__Field :: __field28) } "lld" => _serde :: __private228 :: Ok (__Field :: __field29) , "lld_mode" => _serde :: __private228 :: Ok (__Field :: __field30) , "llvm_tools" => _serde :: __private228 :: Ok (__Field :: __field31) , "deny_warnings" => { _serde :: __private228 :: Ok (__Field :: __field32) } "backtrace_on_ice" => { _serde :: __private228 :: Ok (__Field :: __field33) } "verify_llvm_ir" => { _serde :: __private228 :: Ok (__Field :: __field34) } "thin_lto_import_instr_limit" => { _serde :: __private228 :: Ok (__Field :: __field35) } "remap_debuginfo" => { _serde :: __private228 :: Ok (__Field :: __field36) } "jemalloc" => _serde :: __private228 :: Ok (__Field :: __field37) , "test_compare_mode" => { _serde :: __private228 :: Ok (__Field :: __field38) } "llvm_libunwind" => { _serde :: __private228 :: Ok (__Field :: __field39) } "control_flow_guard" => { _serde :: __private228 :: Ok (__Field :: __field40) } "ehcont_guard" => { _serde :: __private228 :: Ok (__Field :: __field41) } "new_symbol_mangling" => { _serde :: __private228 :: Ok (__Field :: __field42) } "profile_generate" => { _serde :: __private228 :: Ok (__Field :: __field43) } "profile_use" => _serde :: __private228 :: Ok (__Field :: __field44) , "download_rustc" => { _serde :: __private228 :: Ok (__Field :: __field45) } "lto" => _serde :: __private228 :: Ok (__Field :: __field46) , "validate_mir_opts" => { _serde :: __private228 :: Ok (__Field :: __field47) } "std_features" => { _serde :: __private228 :: Ok (__Field :: __field48) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"optimize" => _serde :: __private228 :: Ok (__Field :: __field0) , b"debug" => _serde :: __private228 :: Ok (__Field :: __field1) , b"codegen_units" => { _serde :: __private228 :: Ok (__Field :: __field2) } b"codegen_units_std" => { _serde :: __private228 :: Ok (__Field :: __field3) } b"rustc_debug_assertions" => { _serde :: __private228 :: Ok (__Field :: __field4) } b"randomize_layout" => { _serde :: __private228 :: Ok (__Field :: __field5) } b"std_debug_assertions" => { _serde :: __private228 :: Ok (__Field :: __field6) } b"overflow_checks" => { _serde :: __private228 :: Ok (__Field :: __field7) } b"overflow_checks_std" => { _serde :: __private228 :: Ok (__Field :: __field8) } b"debug_logging" => { _serde :: __private228 :: Ok (__Field :: __field9) } b"backtrace" => _serde :: __private228 :: Ok (__Field :: __field10) , b"incremental" => { _serde :: __private228 :: Ok (__Field :: __field11) } b"parallel_compiler" => { _serde :: __private228 :: Ok (__Field :: __field12) } b"default_linker" => { _serde :: __private228 :: Ok (__Field :: __field13) } b"channel" => _serde :: __private228 :: Ok (__Field :: __field14) , b"description" => { _serde :: __private228 :: Ok (__Field :: __field15) } b"musl_root" => _serde :: __private228 :: Ok (__Field :: __field16) , b"rpath" => _serde :: __private228 :: Ok (__Field :: __field17) , b"strip" => _serde :: __private228 :: Ok (__Field :: __field18) , b"frame_pointers" => { _serde :: __private228 :: Ok (__Field :: __field19) } b"stack_protector" => { _serde :: __private228 :: Ok (__Field :: __field20) } b"verbose_tests" => { _serde :: __private228 :: Ok (__Field :: __field21) } b"optimize_tests" => { _serde :: __private228 :: Ok (__Field :: __field22) } b"codegen_tests" => { _serde :: __private228 :: Ok (__Field :: __field23) } b"omit_git_hash" => { _serde :: __private228 :: Ok (__Field :: __field24) } b"dist_src" => _serde :: __private228 :: Ok (__Field :: __field25) , b"save_toolstates" => { _serde :: __private228 :: Ok (__Field :: __field26) } b"codegen_backends" => { _serde :: __private228 :: Ok (__Field :: __field27) } b"llvm_bitcode_linker" => { _serde :: __private228 :: Ok (__Field :: __field28) } b"lld" => _serde :: __private228 :: Ok (__Field :: __field29) , b"lld_mode" => _serde :: __private228 :: Ok (__Field :: __field30) , b"llvm_tools" => _serde :: __private228 :: Ok (__Field :: __field31) , b"deny_warnings" => { _serde :: __private228 :: Ok (__Field :: __field32) } b"backtrace_on_ice" => { _serde :: __private228 :: Ok (__Field :: __field33) } b"verify_llvm_ir" => { _serde :: __private228 :: Ok (__Field :: __field34) } b"thin_lto_import_instr_limit" => { _serde :: __private228 :: Ok (__Field :: __field35) } b"remap_debuginfo" => { _serde :: __private228 :: Ok (__Field :: __field36) } b"jemalloc" => _serde :: __private228 :: Ok (__Field :: __field37) , b"test_compare_mode" => { _serde :: __private228 :: Ok (__Field :: __field38) } b"llvm_libunwind" => { _serde :: __private228 :: Ok (__Field :: __field39) } b"control_flow_guard" => { _serde :: __private228 :: Ok (__Field :: __field40) } b"ehcont_guard" => { _serde :: __private228 :: Ok (__Field :: __field41) } b"new_symbol_mangling" => { _serde :: __private228 :: Ok (__Field :: __field42) } b"profile_generate" => { _serde :: __private228 :: Ok (__Field :: __field43) } b"profile_use" => { _serde :: __private228 :: Ok (__Field :: __field44) } b"download_rustc" => { _serde :: __private228 :: Ok (__Field :: __field45) } b"lto" => _serde :: __private228 :: Ok (__Field :: __field46) , b"validate_mir_opts" => { _serde :: __private228 :: Ok (__Field :: __field47) } b"std_features" => { _serde :: __private228 :: Ok (__Field :: __field48) } _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < Rust > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = Rust ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct Rust" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < Option < RustOptimize > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field2 = match _serde :: de :: SeqAccess :: next_element :: < Option < u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field3 = match _serde :: de :: SeqAccess :: next_element :: < Option < u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field4 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field5 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (5usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field6 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (6usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field7 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (7usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field8 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (8usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field9 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (9usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field10 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (10usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field11 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (11usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field12 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (12usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field13 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (13usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field14 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (14usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field15 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (15usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field16 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (16usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field17 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (17usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field18 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (18usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field19 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (19usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field20 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (20usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field21 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (21usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field22 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (22usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field23 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (23usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field24 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (24usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field25 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (25usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field26 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (26usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field27 = match _serde :: de :: SeqAccess :: next_element :: < Option < Vec < String > > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (27usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field28 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (28usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field29 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (29usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field30 = match _serde :: de :: SeqAccess :: next_element :: < Option < LldMode > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (30usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field31 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (31usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field32 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (32usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field33 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (33usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field34 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (34usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field35 = match _serde :: de :: SeqAccess :: next_element :: < Option < u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (35usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field36 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (36usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field37 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (37usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field38 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (38usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field39 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (39usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field40 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (40usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field41 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (41usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field42 = match _serde :: de :: SeqAccess :: next_element :: < Option < bool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (42usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field43 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (43usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field44 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (44usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field45 = match _serde :: de :: SeqAccess :: next_element :: < Option < StringOrBool > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (45usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field46 = match _serde :: de :: SeqAccess :: next_element :: < Option < String > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (46usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field47 = match _serde :: de :: SeqAccess :: next_element :: < Option < u32 > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (47usize , & "struct Rust with 49 elements" ,) ,) ; } } ; let __field48 = match _serde :: de :: SeqAccess :: next_element :: < Option < BTreeSet < String > > , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (48usize , & "struct Rust with 49 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (Rust { optimize : __field0 , debug : __field1 , codegen_units : __field2 , codegen_units_std : __field3 , rustc_debug_assertions : __field4 , randomize_layout : __field5 , std_debug_assertions : __field6 , overflow_checks : __field7 , overflow_checks_std : __field8 , debug_logging : __field9 , backtrace : __field10 , incremental : __field11 , parallel_compiler : __field12 , default_linker : __field13 , channel : __field14 , description : __field15 , musl_root : __field16 , rpath : __field17 , strip : __field18 , frame_pointers : __field19 , stack_protector : __field20 , verbose_tests : __field21 , optimize_tests : __field22 , codegen_tests : __field23 , omit_git_hash : __field24 , dist_src : __field25 , save_toolstates : __field26 , codegen_backends : __field27 , llvm_bitcode_linker : __field28 , lld : __field29 , lld_mode : __field30 , llvm_tools : __field31 , deny_warnings : __field32 , backtrace_on_ice : __field33 , verify_llvm_ir : __field34 , thin_lto_import_instr_limit : __field35 , remap_debuginfo : __field36 , jemalloc : __field37 , test_compare_mode : __field38 , llvm_libunwind : __field39 , control_flow_guard : __field40 , ehcont_guard : __field41 , new_symbol_mangling : __field42 , profile_generate : __field43 , profile_use : __field44 , download_rustc : __field45 , lto : __field46 , validate_mir_opts : __field47 , std_features : __field48 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < Option < RustOptimize > , > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field2 : _serde :: __private228 :: Option < Option < u32 > > = _serde :: __private228 :: None ; let mut __field3 : _serde :: __private228 :: Option < Option < u32 > > = _serde :: __private228 :: None ; let mut __field4 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field5 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field6 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field7 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field8 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field9 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field10 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field11 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field12 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field13 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field14 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field15 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field16 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field17 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field18 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field19 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field20 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field21 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field22 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field23 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field24 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field25 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field26 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field27 : _serde :: __private228 :: Option < Option < Vec < String > > , > = _serde :: __private228 :: None ; let mut __field28 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field29 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field30 : _serde :: __private228 :: Option < Option < LldMode > , > = _serde :: __private228 :: None ; let mut __field31 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field32 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field33 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field34 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field35 : _serde :: __private228 :: Option < Option < u32 > > = _serde :: __private228 :: None ; let mut __field36 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field37 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field38 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field39 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field40 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field41 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field42 : _serde :: __private228 :: Option < Option < bool > > = _serde :: __private228 :: None ; let mut __field43 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field44 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field45 : _serde :: __private228 :: Option < Option < StringOrBool > , > = _serde :: __private228 :: None ; let mut __field46 : _serde :: __private228 :: Option < Option < String > , > = _serde :: __private228 :: None ; let mut __field47 : _serde :: __private228 :: Option < Option < u32 > > = _serde :: __private228 :: None ; let mut __field48 : _serde :: __private228 :: Option < Option < BTreeSet < String > > , > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("optimize" ,) ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < RustOptimize > , > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("debug") ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field2 => { if _serde :: __private228 :: Option :: is_some (& __field2) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("codegen_units" ,) ,) ; } __field2 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < u32 > , > (& mut __map) ? ,) ; } __Field :: __field3 => { if _serde :: __private228 :: Option :: is_some (& __field3) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("codegen_units_std" ,) ,) ; } __field3 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < u32 > , > (& mut __map) ? ,) ; } __Field :: __field4 => { if _serde :: __private228 :: Option :: is_some (& __field4) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("rustc_debug_assertions" ,) ,) ; } __field4 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field5 => { if _serde :: __private228 :: Option :: is_some (& __field5) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("randomize_layout" ,) ,) ; } __field5 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field6 => { if _serde :: __private228 :: Option :: is_some (& __field6) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("std_debug_assertions" ,) ,) ; } __field6 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field7 => { if _serde :: __private228 :: Option :: is_some (& __field7) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("overflow_checks" ,) ,) ; } __field7 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field8 => { if _serde :: __private228 :: Option :: is_some (& __field8) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("overflow_checks_std" ,) ,) ; } __field8 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field9 => { if _serde :: __private228 :: Option :: is_some (& __field9) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("debug_logging" ,) ,) ; } __field9 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field10 => { if _serde :: __private228 :: Option :: is_some (& __field10) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("backtrace" ,) ,) ; } __field10 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field11 => { if _serde :: __private228 :: Option :: is_some (& __field11) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("incremental" ,) ,) ; } __field11 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field12 => { if _serde :: __private228 :: Option :: is_some (& __field12) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("parallel_compiler" ,) ,) ; } __field12 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field13 => { if _serde :: __private228 :: Option :: is_some (& __field13) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("default_linker" ,) ,) ; } __field13 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field14 => { if _serde :: __private228 :: Option :: is_some (& __field14) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("channel" ,) ,) ; } __field14 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field15 => { if _serde :: __private228 :: Option :: is_some (& __field15) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("description" ,) ,) ; } __field15 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field16 => { if _serde :: __private228 :: Option :: is_some (& __field16) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("musl_root" ,) ,) ; } __field16 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field17 => { if _serde :: __private228 :: Option :: is_some (& __field17) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("rpath") ,) ; } __field17 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field18 => { if _serde :: __private228 :: Option :: is_some (& __field18) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("strip") ,) ; } __field18 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field19 => { if _serde :: __private228 :: Option :: is_some (& __field19) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("frame_pointers" ,) ,) ; } __field19 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field20 => { if _serde :: __private228 :: Option :: is_some (& __field20) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("stack_protector" ,) ,) ; } __field20 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field21 => { if _serde :: __private228 :: Option :: is_some (& __field21) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("verbose_tests" ,) ,) ; } __field21 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field22 => { if _serde :: __private228 :: Option :: is_some (& __field22) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("optimize_tests" ,) ,) ; } __field22 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field23 => { if _serde :: __private228 :: Option :: is_some (& __field23) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("codegen_tests" ,) ,) ; } __field23 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field24 => { if _serde :: __private228 :: Option :: is_some (& __field24) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("omit_git_hash" ,) ,) ; } __field24 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field25 => { if _serde :: __private228 :: Option :: is_some (& __field25) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("dist_src" ,) ,) ; } __field25 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field26 => { if _serde :: __private228 :: Option :: is_some (& __field26) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("save_toolstates" ,) ,) ; } __field26 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field27 => { if _serde :: __private228 :: Option :: is_some (& __field27) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("codegen_backends" ,) ,) ; } __field27 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < Vec < String > > , > (& mut __map) ? ,) ; } __Field :: __field28 => { if _serde :: __private228 :: Option :: is_some (& __field28) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("llvm_bitcode_linker" ,) ,) ; } __field28 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field29 => { if _serde :: __private228 :: Option :: is_some (& __field29) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("lld") ,) ; } __field29 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field30 => { if _serde :: __private228 :: Option :: is_some (& __field30) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("lld_mode" ,) ,) ; } __field30 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < LldMode > , > (& mut __map) ? ,) ; } __Field :: __field31 => { if _serde :: __private228 :: Option :: is_some (& __field31) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("llvm_tools" ,) ,) ; } __field31 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field32 => { if _serde :: __private228 :: Option :: is_some (& __field32) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("deny_warnings" ,) ,) ; } __field32 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field33 => { if _serde :: __private228 :: Option :: is_some (& __field33) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("backtrace_on_ice" ,) ,) ; } __field33 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field34 => { if _serde :: __private228 :: Option :: is_some (& __field34) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("verify_llvm_ir" ,) ,) ; } __field34 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field35 => { if _serde :: __private228 :: Option :: is_some (& __field35) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("thin_lto_import_instr_limit" ,) ,) ; } __field35 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < u32 > , > (& mut __map) ? ,) ; } __Field :: __field36 => { if _serde :: __private228 :: Option :: is_some (& __field36) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("remap_debuginfo" ,) ,) ; } __field36 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field37 => { if _serde :: __private228 :: Option :: is_some (& __field37) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("jemalloc" ,) ,) ; } __field37 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field38 => { if _serde :: __private228 :: Option :: is_some (& __field38) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("test_compare_mode" ,) ,) ; } __field38 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field39 => { if _serde :: __private228 :: Option :: is_some (& __field39) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("llvm_libunwind" ,) ,) ; } __field39 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field40 => { if _serde :: __private228 :: Option :: is_some (& __field40) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("control_flow_guard" ,) ,) ; } __field40 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field41 => { if _serde :: __private228 :: Option :: is_some (& __field41) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("ehcont_guard" ,) ,) ; } __field41 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field42 => { if _serde :: __private228 :: Option :: is_some (& __field42) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("new_symbol_mangling" ,) ,) ; } __field42 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < bool > , > (& mut __map) ? ,) ; } __Field :: __field43 => { if _serde :: __private228 :: Option :: is_some (& __field43) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("profile_generate" ,) ,) ; } __field43 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field44 => { if _serde :: __private228 :: Option :: is_some (& __field44) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("profile_use" ,) ,) ; } __field44 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field45 => { if _serde :: __private228 :: Option :: is_some (& __field45) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("download_rustc" ,) ,) ; } __field45 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < StringOrBool > , > (& mut __map) ? ,) ; } __Field :: __field46 => { if _serde :: __private228 :: Option :: is_some (& __field46) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("lto") ,) ; } __field46 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < String > , > (& mut __map) ? ,) ; } __Field :: __field47 => { if _serde :: __private228 :: Option :: is_some (& __field47) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("validate_mir_opts" ,) ,) ; } __field47 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < u32 > , > (& mut __map) ? ,) ; } __Field :: __field48 => { if _serde :: __private228 :: Option :: is_some (& __field48) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("std_features" ,) ,) ; } __field48 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < Option < BTreeSet < String > > , > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("optimize") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("debug") ? } } ; let __field2 = match __field2 { _serde :: __private228 :: Some (__field2) => __field2 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("codegen_units") ? } } ; let __field3 = match __field3 { _serde :: __private228 :: Some (__field3) => __field3 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("codegen_units_std" ,) ? } } ; let __field4 = match __field4 { _serde :: __private228 :: Some (__field4) => __field4 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("rustc_debug_assertions" ,) ? } } ; let __field5 = match __field5 { _serde :: __private228 :: Some (__field5) => __field5 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("randomize_layout") ? } } ; let __field6 = match __field6 { _serde :: __private228 :: Some (__field6) => __field6 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("std_debug_assertions" ,) ? } } ; let __field7 = match __field7 { _serde :: __private228 :: Some (__field7) => __field7 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("overflow_checks") ? } } ; let __field8 = match __field8 { _serde :: __private228 :: Some (__field8) => __field8 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("overflow_checks_std" ,) ? } } ; let __field9 = match __field9 { _serde :: __private228 :: Some (__field9) => __field9 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("debug_logging") ? } } ; let __field10 = match __field10 { _serde :: __private228 :: Some (__field10) => __field10 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("backtrace") ? } } ; let __field11 = match __field11 { _serde :: __private228 :: Some (__field11) => __field11 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("incremental") ? } } ; let __field12 = match __field12 { _serde :: __private228 :: Some (__field12) => __field12 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("parallel_compiler" ,) ? } } ; let __field13 = match __field13 { _serde :: __private228 :: Some (__field13) => __field13 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("default_linker") ? } } ; let __field14 = match __field14 { _serde :: __private228 :: Some (__field14) => __field14 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("channel") ? } } ; let __field15 = match __field15 { _serde :: __private228 :: Some (__field15) => __field15 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("description") ? } } ; let __field16 = match __field16 { _serde :: __private228 :: Some (__field16) => __field16 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("musl_root") ? } } ; let __field17 = match __field17 { _serde :: __private228 :: Some (__field17) => __field17 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("rpath") ? } } ; let __field18 = match __field18 { _serde :: __private228 :: Some (__field18) => __field18 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("strip") ? } } ; let __field19 = match __field19 { _serde :: __private228 :: Some (__field19) => __field19 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("frame_pointers") ? } } ; let __field20 = match __field20 { _serde :: __private228 :: Some (__field20) => __field20 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("stack_protector") ? } } ; let __field21 = match __field21 { _serde :: __private228 :: Some (__field21) => __field21 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("verbose_tests") ? } } ; let __field22 = match __field22 { _serde :: __private228 :: Some (__field22) => __field22 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("optimize_tests") ? } } ; let __field23 = match __field23 { _serde :: __private228 :: Some (__field23) => __field23 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("codegen_tests") ? } } ; let __field24 = match __field24 { _serde :: __private228 :: Some (__field24) => __field24 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("omit_git_hash") ? } } ; let __field25 = match __field25 { _serde :: __private228 :: Some (__field25) => __field25 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("dist_src") ? } } ; let __field26 = match __field26 { _serde :: __private228 :: Some (__field26) => __field26 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("save_toolstates") ? } } ; let __field27 = match __field27 { _serde :: __private228 :: Some (__field27) => __field27 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("codegen_backends") ? } } ; let __field28 = match __field28 { _serde :: __private228 :: Some (__field28) => __field28 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("llvm_bitcode_linker" ,) ? } } ; let __field29 = match __field29 { _serde :: __private228 :: Some (__field29) => __field29 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("lld") ? } } ; let __field30 = match __field30 { _serde :: __private228 :: Some (__field30) => __field30 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("lld_mode") ? } } ; let __field31 = match __field31 { _serde :: __private228 :: Some (__field31) => __field31 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("llvm_tools") ? } } ; let __field32 = match __field32 { _serde :: __private228 :: Some (__field32) => __field32 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("deny_warnings") ? } } ; let __field33 = match __field33 { _serde :: __private228 :: Some (__field33) => __field33 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("backtrace_on_ice") ? } } ; let __field34 = match __field34 { _serde :: __private228 :: Some (__field34) => __field34 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("verify_llvm_ir") ? } } ; let __field35 = match __field35 { _serde :: __private228 :: Some (__field35) => __field35 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("thin_lto_import_instr_limit" ,) ? } } ; let __field36 = match __field36 { _serde :: __private228 :: Some (__field36) => __field36 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("remap_debuginfo") ? } } ; let __field37 = match __field37 { _serde :: __private228 :: Some (__field37) => __field37 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("jemalloc") ? } } ; let __field38 = match __field38 { _serde :: __private228 :: Some (__field38) => __field38 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("test_compare_mode" ,) ? } } ; let __field39 = match __field39 { _serde :: __private228 :: Some (__field39) => __field39 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("llvm_libunwind") ? } } ; let __field40 = match __field40 { _serde :: __private228 :: Some (__field40) => __field40 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("control_flow_guard" ,) ? } } ; let __field41 = match __field41 { _serde :: __private228 :: Some (__field41) => __field41 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("ehcont_guard") ? } } ; let __field42 = match __field42 { _serde :: __private228 :: Some (__field42) => __field42 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("new_symbol_mangling" ,) ? } } ; let __field43 = match __field43 { _serde :: __private228 :: Some (__field43) => __field43 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("profile_generate") ? } } ; let __field44 = match __field44 { _serde :: __private228 :: Some (__field44) => __field44 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("profile_use") ? } } ; let __field45 = match __field45 { _serde :: __private228 :: Some (__field45) => __field45 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("download_rustc") ? } } ; let __field46 = match __field46 { _serde :: __private228 :: Some (__field46) => __field46 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("lto") ? } } ; let __field47 = match __field47 { _serde :: __private228 :: Some (__field47) => __field47 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("validate_mir_opts" ,) ? } } ; let __field48 = match __field48 { _serde :: __private228 :: Some (__field48) => __field48 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("std_features") ? } } ; _serde :: __private228 :: Ok (Rust { optimize : __field0 , debug : __field1 , codegen_units : __field2 , codegen_units_std : __field3 , rustc_debug_assertions : __field4 , randomize_layout : __field5 , std_debug_assertions : __field6 , overflow_checks : __field7 , overflow_checks_std : __field8 , debug_logging : __field9 , backtrace : __field10 , incremental : __field11 , parallel_compiler : __field12 , default_linker : __field13 , channel : __field14 , description : __field15 , musl_root : __field16 , rpath : __field17 , strip : __field18 , frame_pointers : __field19 , stack_protector : __field20 , verbose_tests : __field21 , optimize_tests : __field22 , codegen_tests : __field23 , omit_git_hash : __field24 , dist_src : __field25 , save_toolstates : __field26 , codegen_backends : __field27 , llvm_bitcode_linker : __field28 , lld : __field29 , lld_mode : __field30 , llvm_tools : __field31 , deny_warnings : __field32 , backtrace_on_ice : __field33 , verify_llvm_ir : __field34 , thin_lto_import_instr_limit : __field35 , remap_debuginfo : __field36 , jemalloc : __field37 , test_compare_mode : __field38 , llvm_libunwind : __field39 , control_flow_guard : __field40 , ehcont_guard : __field41 , new_symbol_mangling : __field42 , profile_generate : __field43 , profile_use : __field44 , download_rustc : __field45 , lto : __field46 , validate_mir_opts : __field47 , std_features : __field48 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["optimize" , "debug" , "codegen_units" , "codegen_units_std" , "rustc_debug_assertions" , "randomize_layout" , "std_debug_assertions" , "overflow_checks" , "overflow_checks_std" , "debug_logging" , "backtrace" , "incremental" , "parallel_compiler" , "default_linker" , "channel" , "description" , "musl_root" , "rpath" , "strip" , "frame_pointers" , "stack_protector" , "verbose_tests" , "optimize_tests" , "codegen_tests" , "omit_git_hash" , "dist_src" , "save_toolstates" , "codegen_backends" , "llvm_bitcode_linker" , "lld" , "lld_mode" , "llvm_tools" , "deny_warnings" , "backtrace_on_ice" , "verify_llvm_ir" , "thin_lto_import_instr_limit" , "remap_debuginfo" , "jemalloc" , "test_compare_mode" , "llvm_libunwind" , "control_flow_guard" , "ehcont_guard" , "new_symbol_mangling" , "profile_generate" , "profile_use" , "download_rustc" , "lto" , "validate_mir_opts" , "std_features" ,] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "Rust" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < Rust > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } } ; impl config_core :: Merge for Rust { fn merge (& mut self , other : Self , replace : config_core :: ReplaceOpt) { match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . optimize . is_none () { self . optimize = other . optimize ; } } config_core :: ReplaceOpt :: Override => { if other . optimize . is_some () { self . optimize = other . optimize ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . optimize . is_some () { if self . optimize . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "optimize" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . optimize = other . optimize ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . debug . is_none () { self . debug = other . debug ; } } config_core :: ReplaceOpt :: Override => { if other . debug . is_some () { self . debug = other . debug ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . debug . is_some () { if self . debug . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "debug") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . debug = other . debug ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . codegen_units . is_none () { self . codegen_units = other . codegen_units ; } } config_core :: ReplaceOpt :: Override => { if other . codegen_units . is_some () { self . codegen_units = other . codegen_units ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . codegen_units . is_some () { if self . codegen_units . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "codegen-units" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . codegen_units = other . codegen_units ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . codegen_units_std . is_none () { self . codegen_units_std = other . codegen_units_std ; } } config_core :: ReplaceOpt :: Override => { if other . codegen_units_std . is_some () { self . codegen_units_std = other . codegen_units_std ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . codegen_units_std . is_some () { if self . codegen_units_std . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "codegen-units-std" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . codegen_units_std = other . codegen_units_std ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . rustc_debug_assertions . is_none () { self . rustc_debug_assertions = other . rustc_debug_assertions ; } } config_core :: ReplaceOpt :: Override => { if other . rustc_debug_assertions . is_some () { self . rustc_debug_assertions = other . rustc_debug_assertions ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . rustc_debug_assertions . is_some () { if self . rustc_debug_assertions . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "debug-assertions" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . rustc_debug_assertions = other . rustc_debug_assertions ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . randomize_layout . is_none () { self . randomize_layout = other . randomize_layout ; } } config_core :: ReplaceOpt :: Override => { if other . randomize_layout . is_some () { self . randomize_layout = other . randomize_layout ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . randomize_layout . is_some () { if self . randomize_layout . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "randomize-layout" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . randomize_layout = other . randomize_layout ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . std_debug_assertions . is_none () { self . std_debug_assertions = other . std_debug_assertions ; } } config_core :: ReplaceOpt :: Override => { if other . std_debug_assertions . is_some () { self . std_debug_assertions = other . std_debug_assertions ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . std_debug_assertions . is_some () { if self . std_debug_assertions . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "debug-assertions-std" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . std_debug_assertions = other . std_debug_assertions ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . overflow_checks . is_none () { self . overflow_checks = other . overflow_checks ; } } config_core :: ReplaceOpt :: Override => { if other . overflow_checks . is_some () { self . overflow_checks = other . overflow_checks ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . overflow_checks . is_some () { if self . overflow_checks . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "overflow-checks" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . overflow_checks = other . overflow_checks ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . overflow_checks_std . is_none () { self . overflow_checks_std = other . overflow_checks_std ; } } config_core :: ReplaceOpt :: Override => { if other . overflow_checks_std . is_some () { self . overflow_checks_std = other . overflow_checks_std ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . overflow_checks_std . is_some () { if self . overflow_checks_std . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "overflow-checks-std" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . overflow_checks_std = other . overflow_checks_std ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . debug_logging . is_none () { self . debug_logging = other . debug_logging ; } } config_core :: ReplaceOpt :: Override => { if other . debug_logging . is_some () { self . debug_logging = other . debug_logging ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . debug_logging . is_some () { if self . debug_logging . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "debug-logging" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . debug_logging = other . debug_logging ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . backtrace . is_none () { self . backtrace = other . backtrace ; } } config_core :: ReplaceOpt :: Override => { if other . backtrace . is_some () { self . backtrace = other . backtrace ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . backtrace . is_some () { if self . backtrace . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "backtrace" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . backtrace = other . backtrace ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . incremental . is_none () { self . incremental = other . incremental ; } } config_core :: ReplaceOpt :: Override => { if other . incremental . is_some () { self . incremental = other . incremental ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . incremental . is_some () { if self . incremental . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "incremental" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . incremental = other . incremental ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . parallel_compiler . is_none () { self . parallel_compiler = other . parallel_compiler ; } } config_core :: ReplaceOpt :: Override => { if other . parallel_compiler . is_some () { self . parallel_compiler = other . parallel_compiler ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . parallel_compiler . is_some () { if self . parallel_compiler . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "parallel-compiler" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . parallel_compiler = other . parallel_compiler ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . default_linker . is_none () { self . default_linker = other . default_linker ; } } config_core :: ReplaceOpt :: Override => { if other . default_linker . is_some () { self . default_linker = other . default_linker ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . default_linker . is_some () { if self . default_linker . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "default-linker" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . default_linker = other . default_linker ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . channel . is_none () { self . channel = other . channel ; } } config_core :: ReplaceOpt :: Override => { if other . channel . is_some () { self . channel = other . channel ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . channel . is_some () { if self . channel . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "channel" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . channel = other . channel ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . description . is_none () { self . description = other . description ; } } config_core :: ReplaceOpt :: Override => { if other . description . is_some () { self . description = other . description ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . description . is_some () { if self . description . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "description" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . description = other . description ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . musl_root . is_none () { self . musl_root = other . musl_root ; } } config_core :: ReplaceOpt :: Override => { if other . musl_root . is_some () { self . musl_root = other . musl_root ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . musl_root . is_some () { if self . musl_root . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "musl-root" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . musl_root = other . musl_root ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . rpath . is_none () { self . rpath = other . rpath ; } } config_core :: ReplaceOpt :: Override => { if other . rpath . is_some () { self . rpath = other . rpath ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . rpath . is_some () { if self . rpath . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "rpath") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . rpath = other . rpath ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . strip . is_none () { self . strip = other . strip ; } } config_core :: ReplaceOpt :: Override => { if other . strip . is_some () { self . strip = other . strip ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . strip . is_some () { if self . strip . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "strip") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . strip = other . strip ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . frame_pointers . is_none () { self . frame_pointers = other . frame_pointers ; } } config_core :: ReplaceOpt :: Override => { if other . frame_pointers . is_some () { self . frame_pointers = other . frame_pointers ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . frame_pointers . is_some () { if self . frame_pointers . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "frame-pointers" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . frame_pointers = other . frame_pointers ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . stack_protector . is_none () { self . stack_protector = other . stack_protector ; } } config_core :: ReplaceOpt :: Override => { if other . stack_protector . is_some () { self . stack_protector = other . stack_protector ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . stack_protector . is_some () { if self . stack_protector . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "stack-protector" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . stack_protector = other . stack_protector ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . verbose_tests . is_none () { self . verbose_tests = other . verbose_tests ; } } config_core :: ReplaceOpt :: Override => { if other . verbose_tests . is_some () { self . verbose_tests = other . verbose_tests ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . verbose_tests . is_some () { if self . verbose_tests . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "verbose-tests" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . verbose_tests = other . verbose_tests ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . optimize_tests . is_none () { self . optimize_tests = other . optimize_tests ; } } config_core :: ReplaceOpt :: Override => { if other . optimize_tests . is_some () { self . optimize_tests = other . optimize_tests ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . optimize_tests . is_some () { if self . optimize_tests . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "optimize-tests" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . optimize_tests = other . optimize_tests ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . codegen_tests . is_none () { self . codegen_tests = other . codegen_tests ; } } config_core :: ReplaceOpt :: Override => { if other . codegen_tests . is_some () { self . codegen_tests = other . codegen_tests ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . codegen_tests . is_some () { if self . codegen_tests . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "codegen-tests" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . codegen_tests = other . codegen_tests ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . omit_git_hash . is_none () { self . omit_git_hash = other . omit_git_hash ; } } config_core :: ReplaceOpt :: Override => { if other . omit_git_hash . is_some () { self . omit_git_hash = other . omit_git_hash ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . omit_git_hash . is_some () { if self . omit_git_hash . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "omit-git-hash" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . omit_git_hash = other . omit_git_hash ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . dist_src . is_none () { self . dist_src = other . dist_src ; } } config_core :: ReplaceOpt :: Override => { if other . dist_src . is_some () { self . dist_src = other . dist_src ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . dist_src . is_some () { if self . dist_src . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "dist-src" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . dist_src = other . dist_src ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . save_toolstates . is_none () { self . save_toolstates = other . save_toolstates ; } } config_core :: ReplaceOpt :: Override => { if other . save_toolstates . is_some () { self . save_toolstates = other . save_toolstates ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . save_toolstates . is_some () { if self . save_toolstates . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "save-toolstates" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . save_toolstates = other . save_toolstates ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . codegen_backends . is_none () { self . codegen_backends = other . codegen_backends ; } } config_core :: ReplaceOpt :: Override => { if other . codegen_backends . is_some () { self . codegen_backends = other . codegen_backends ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . codegen_backends . is_some () { if self . codegen_backends . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "codegen-backends" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . codegen_backends = other . codegen_backends ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . llvm_bitcode_linker . is_none () { self . llvm_bitcode_linker = other . llvm_bitcode_linker ; } } config_core :: ReplaceOpt :: Override => { if other . llvm_bitcode_linker . is_some () { self . llvm_bitcode_linker = other . llvm_bitcode_linker ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . llvm_bitcode_linker . is_some () { if self . llvm_bitcode_linker . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "llvm-bitcode-linker" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . llvm_bitcode_linker = other . llvm_bitcode_linker ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . lld . is_none () { self . lld = other . lld ; } } config_core :: ReplaceOpt :: Override => { if other . lld . is_some () { self . lld = other . lld ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . lld . is_some () { if self . lld . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "lld") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . lld = other . lld ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . lld_mode . is_none () { self . lld_mode = other . lld_mode ; } } config_core :: ReplaceOpt :: Override => { if other . lld_mode . is_some () { self . lld_mode = other . lld_mode ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . lld_mode . is_some () { if self . lld_mode . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "use-lld" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . lld_mode = other . lld_mode ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . llvm_tools . is_none () { self . llvm_tools = other . llvm_tools ; } } config_core :: ReplaceOpt :: Override => { if other . llvm_tools . is_some () { self . llvm_tools = other . llvm_tools ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . llvm_tools . is_some () { if self . llvm_tools . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "llvm-tools" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . llvm_tools = other . llvm_tools ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . deny_warnings . is_none () { self . deny_warnings = other . deny_warnings ; } } config_core :: ReplaceOpt :: Override => { if other . deny_warnings . is_some () { self . deny_warnings = other . deny_warnings ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . deny_warnings . is_some () { if self . deny_warnings . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "deny-warnings" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . deny_warnings = other . deny_warnings ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . backtrace_on_ice . is_none () { self . backtrace_on_ice = other . backtrace_on_ice ; } } config_core :: ReplaceOpt :: Override => { if other . backtrace_on_ice . is_some () { self . backtrace_on_ice = other . backtrace_on_ice ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . backtrace_on_ice . is_some () { if self . backtrace_on_ice . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "backtrace-on-ice" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . backtrace_on_ice = other . backtrace_on_ice ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . verify_llvm_ir . is_none () { self . verify_llvm_ir = other . verify_llvm_ir ; } } config_core :: ReplaceOpt :: Override => { if other . verify_llvm_ir . is_some () { self . verify_llvm_ir = other . verify_llvm_ir ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . verify_llvm_ir . is_some () { if self . verify_llvm_ir . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "verify-llvm-ir" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . verify_llvm_ir = other . verify_llvm_ir ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . thin_lto_import_instr_limit . is_none () { self . thin_lto_import_instr_limit = other . thin_lto_import_instr_limit ; } } config_core :: ReplaceOpt :: Override => { if other . thin_lto_import_instr_limit . is_some () { self . thin_lto_import_instr_limit = other . thin_lto_import_instr_limit ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . thin_lto_import_instr_limit . is_some () { if self . thin_lto_import_instr_limit . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "thin-lto-import-instr-limit" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . thin_lto_import_instr_limit = other . thin_lto_import_instr_limit ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . remap_debuginfo . is_none () { self . remap_debuginfo = other . remap_debuginfo ; } } config_core :: ReplaceOpt :: Override => { if other . remap_debuginfo . is_some () { self . remap_debuginfo = other . remap_debuginfo ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . remap_debuginfo . is_some () { if self . remap_debuginfo . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "remap-debuginfo" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . remap_debuginfo = other . remap_debuginfo ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . jemalloc . is_none () { self . jemalloc = other . jemalloc ; } } config_core :: ReplaceOpt :: Override => { if other . jemalloc . is_some () { self . jemalloc = other . jemalloc ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . jemalloc . is_some () { if self . jemalloc . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "jemalloc" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . jemalloc = other . jemalloc ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . test_compare_mode . is_none () { self . test_compare_mode = other . test_compare_mode ; } } config_core :: ReplaceOpt :: Override => { if other . test_compare_mode . is_some () { self . test_compare_mode = other . test_compare_mode ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . test_compare_mode . is_some () { if self . test_compare_mode . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "test-compare-mode" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . test_compare_mode = other . test_compare_mode ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . llvm_libunwind . is_none () { self . llvm_libunwind = other . llvm_libunwind ; } } config_core :: ReplaceOpt :: Override => { if other . llvm_libunwind . is_some () { self . llvm_libunwind = other . llvm_libunwind ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . llvm_libunwind . is_some () { if self . llvm_libunwind . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "llvm-libunwind" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . llvm_libunwind = other . llvm_libunwind ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . control_flow_guard . is_none () { self . control_flow_guard = other . control_flow_guard ; } } config_core :: ReplaceOpt :: Override => { if other . control_flow_guard . is_some () { self . control_flow_guard = other . control_flow_guard ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . control_flow_guard . is_some () { if self . control_flow_guard . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "control-flow-guard" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . control_flow_guard = other . control_flow_guard ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . ehcont_guard . is_none () { self . ehcont_guard = other . ehcont_guard ; } } config_core :: ReplaceOpt :: Override => { if other . ehcont_guard . is_some () { self . ehcont_guard = other . ehcont_guard ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . ehcont_guard . is_some () { if self . ehcont_guard . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "ehcont-guard" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . ehcont_guard = other . ehcont_guard ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . new_symbol_mangling . is_none () { self . new_symbol_mangling = other . new_symbol_mangling ; } } config_core :: ReplaceOpt :: Override => { if other . new_symbol_mangling . is_some () { self . new_symbol_mangling = other . new_symbol_mangling ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . new_symbol_mangling . is_some () { if self . new_symbol_mangling . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "new-symbol-mangling" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . new_symbol_mangling = other . new_symbol_mangling ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . profile_generate . is_none () { self . profile_generate = other . profile_generate ; } } config_core :: ReplaceOpt :: Override => { if other . profile_generate . is_some () { self . profile_generate = other . profile_generate ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . profile_generate . is_some () { if self . profile_generate . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "profile-generate" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . profile_generate = other . profile_generate ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . profile_use . is_none () { self . profile_use = other . profile_use ; } } config_core :: ReplaceOpt :: Override => { if other . profile_use . is_some () { self . profile_use = other . profile_use ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . profile_use . is_some () { if self . profile_use . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "profile-use" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . profile_use = other . profile_use ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . download_rustc . is_none () { self . download_rustc = other . download_rustc ; } } config_core :: ReplaceOpt :: Override => { if other . download_rustc . is_some () { self . download_rustc = other . download_rustc ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . download_rustc . is_some () { if self . download_rustc . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "download-rustc" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . download_rustc = other . download_rustc ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . lto . is_none () { self . lto = other . lto ; } } config_core :: ReplaceOpt :: Override => { if other . lto . is_some () { self . lto = other . lto ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . lto . is_some () { if self . lto . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "lto") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . lto = other . lto ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . validate_mir_opts . is_none () { self . validate_mir_opts = other . validate_mir_opts ; } } config_core :: ReplaceOpt :: Override => { if other . validate_mir_opts . is_some () { self . validate_mir_opts = other . validate_mir_opts ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . validate_mir_opts . is_some () { if self . validate_mir_opts . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "validate-mir-opts" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . validate_mir_opts = other . validate_mir_opts ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . std_features . is_none () { self . std_features = other . std_features ; } } config_core :: ReplaceOpt :: Override => { if other . std_features . is_some () { self . std_features = other . std_features ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . std_features . is_some () { if self . std_features . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "std-features" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . std_features = other . std_features ; } } } } } }