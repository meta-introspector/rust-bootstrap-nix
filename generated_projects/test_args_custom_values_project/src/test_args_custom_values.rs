use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub fn test_args_custom_values () { let args = Args :: parse_from (& ["prelude-generator" , "--dry-run" , "--path" , "/tmp/my_project" , "--exclude-crates" , "crate1,crate2" , "--report" , "--results-file" , "custom_results.json" , "--cache-report" , "--timeout" , "60" , "--force" ,] ,) ; if ! args . dry_run { :: core :: panicking :: panic ("assertion failed: args.dry_run") } match (& args . path , & PathBuf :: from ("/tmp/my_project")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; match (& args . exclude_crates , & < [_] > :: into_vec (:: alloc :: boxed :: box_new (["crate1" . to_string () , "crate2" . to_string ()]) ,) ,) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . report { :: core :: panicking :: panic ("assertion failed: args.report") } match (& args . results_file , & PathBuf :: from ("custom_results.json")) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . cache_report { :: core :: panicking :: panic ("assertion failed: args.cache_report") } match (& args . timeout , & Some (60)) { (left_val , right_val) => { if ! (* left_val == * right_val) { let kind = :: core :: panicking :: AssertKind :: Eq ; :: core :: panicking :: assert_failed (kind , & * left_val , & * right_val , :: core :: option :: Option :: None ,) ; } } } ; if ! args . force { :: core :: panicking :: panic ("assertion failed: args.force") } }