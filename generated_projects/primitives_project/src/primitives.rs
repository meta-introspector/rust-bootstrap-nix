use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub (crate) mod primitives { # ! [doc = "\nLower level primitive types that are useful in a variety of circumstances.\n\n# Overview\n\nThis list represents the principle types in this module and briefly describes\nwhen you might want to use them.\n\n* [`PatternID`] - A type that represents the identifier of a regex pattern.\nThis is probably the most widely used type in this module (which is why it's\nalso re-exported in the crate root).\n* [`StateID`] - A type the represents the identifier of a finite automaton\nstate. This is used for both NFAs and DFAs, with the notable exception of\nthe hybrid NFA/DFA. (The hybrid NFA/DFA uses a special purpose \"lazy\" state\nidentifier.)\n* [`SmallIndex`] - The internal representation of both a `PatternID` and a\n`StateID`. Its purpose is to serve as a type that can index memory without\nbeing as big as a `usize` on 64-bit targets. The main idea behind this type\nis that there are many things in regex engines that will, in practice, never\noverflow a 32-bit integer. (For example, like the number of patterns in a regex\nor the number of states in an NFA.) Thus, a `SmallIndex` can be used to index\nmemory without peppering `as` casts everywhere. Moreover, it forces callers\nto handle errors in the case where, somehow, the value would otherwise overflow\neither a 32-bit integer or a `usize` (e.g., on 16-bit targets).\n"] # ! [allow (dead_code)] use alloc :: vec :: Vec ; use crate :: util :: int :: { Usize , U16 , U32 , U64 } ; # [doc = " A type that represents a \"small\" index."] # [doc = ""] # [doc = " The main idea of this type is to provide something that can index memory,"] # [doc = " but uses less memory than `usize` on 64-bit systems. Specifically, its"] # [doc = " representation is always a `u32` and has `repr(transparent)` enabled. (So"] # [doc = " it is safe to transmute between a `u32` and a `SmallIndex`.)"] # [doc = ""] # [doc = " A small index is typically useful in cases where there is no practical way"] # [doc = " that the index will overflow a 32-bit integer. A good example of this is"] # [doc = " an NFA state. If you could somehow build an NFA with `2^30` states, its"] # [doc = " memory usage would be exorbitant and its runtime execution would be so"] # [doc = " slow as to be completely worthless. Therefore, this crate generally deems"] # [doc = " it acceptable to return an error if it would otherwise build an NFA that"] # [doc = " requires a slice longer than what a 32-bit integer can index. In exchange,"] # [doc = " we can use 32-bit indices instead of 64-bit indices in various places."] # [doc = ""] # [doc = " This type ensures this by providing a constructor that will return an error"] # [doc = " if its argument cannot fit into the type. This makes it much easier to"] # [doc = " handle these sorts of boundary cases that are otherwise extremely subtle."] # [doc = ""] # [doc = " On all targets, this type guarantees that its value will fit in a `u32`,"] # [doc = " `i32`, `usize` and an `isize`. This means that on 16-bit targets, for"] # [doc = " example, this type's maximum value will never overflow an `isize`,"] # [doc = " which means it will never overflow a `i16` even though its internal"] # [doc = " representation is still a `u32`."] # [doc = ""] # [doc = " The purpose for making the type fit into even signed integer types like"] # [doc = " `isize` is to guarantee that the difference between any two small indices"] # [doc = " is itself also a small index. This is useful in certain contexts, e.g.,"] # [doc = " for delta encoding."] # [doc = ""] # [doc = " # Other types"] # [doc = ""] # [doc = " The following types wrap `SmallIndex` to provide a more focused use case:"] # [doc = ""] # [doc = " * [`PatternID`] is for representing the identifiers of patterns."] # [doc = " * [`StateID`] is for representing the identifiers of states in finite"] # [doc = " automata. It is used for both NFAs and DFAs."] # [doc = ""] # [doc = " # Representation"] # [doc = ""] # [doc = " This type is always represented internally by a `u32` and is marked as"] # [doc = " `repr(transparent)`. Thus, this type always has the same representation as"] # [doc = " a `u32`. It is thus safe to transmute between a `u32` and a `SmallIndex`."] # [doc = ""] # [doc = " # Indexing"] # [doc = ""] # [doc = " For convenience, callers may use a `SmallIndex` to index slices."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " While a `SmallIndex` is meant to guarantee that its value fits into `usize`"] # [doc = " without using as much space as a `usize` on all targets, callers must"] # [doc = " not rely on this property for safety. Callers may choose to rely on this"] # [doc = " property for correctness however. For example, creating a `SmallIndex` with"] # [doc = " an invalid value can be done in entirely safe code. This may in turn result"] # [doc = " in panics or silent logical errors."] # [repr (transparent)] pub (crate) struct SmallIndex (u32) ; # [automatically_derived] impl :: core :: clone :: Clone for SmallIndex { # [inline] fn clone (& self) -> SmallIndex { let _ : :: core :: clone :: AssertParamIsClone < u32 > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for SmallIndex { } # [automatically_derived] impl :: core :: fmt :: Debug for SmallIndex { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "SmallIndex" , & & self . 0 ,) } } # [automatically_derived] impl :: core :: default :: Default for SmallIndex { # [inline] fn default () -> SmallIndex { SmallIndex (:: core :: default :: Default :: default ()) } } # [automatically_derived] impl :: core :: cmp :: Eq for SmallIndex { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < u32 > ; } } # [automatically_derived] impl :: core :: hash :: Hash for SmallIndex { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . 0 , state) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for SmallIndex { } # [automatically_derived] impl :: core :: cmp :: PartialEq for SmallIndex { # [inline] fn eq (& self , other : & SmallIndex) -> bool { self . 0 == other . 0 } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for SmallIndex { # [inline] fn partial_cmp (& self , other : & SmallIndex ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { :: core :: cmp :: PartialOrd :: partial_cmp (& self . 0 , & other . 0) } } # [automatically_derived] impl :: core :: cmp :: Ord for SmallIndex { # [inline] fn cmp (& self , other : & SmallIndex) -> :: core :: cmp :: Ordering { :: core :: cmp :: Ord :: cmp (& self . 0 , & other . 0) } } impl SmallIndex { # [doc = " The maximum index value."] pub const MAX : SmallIndex = SmallIndex :: new_unchecked (core :: i32 :: MAX as usize - 1 ,) ; # [doc = " The total number of values that can be represented as a small index."] pub const LIMIT : usize = SmallIndex :: MAX . as_usize () + 1 ; # [doc = " The zero index value."] pub const ZERO : SmallIndex = SmallIndex :: new_unchecked (0) ; # [doc = " The number of bytes that a single small index uses in memory."] pub const SIZE : usize = core :: mem :: size_of :: < SmallIndex > () ; # [doc = " Create a new small index."] # [doc = ""] # [doc = " If the given index exceeds [`SmallIndex::MAX`], then this returns"] # [doc = " an error."] # [inline] pub fn new (index : usize) -> Result < SmallIndex , SmallIndexError > { SmallIndex :: try_from (index) } # [doc = " Create a new small index without checking whether the given value"] # [doc = " exceeds [`SmallIndex::MAX`]."] # [doc = ""] # [doc = " Using this routine with an invalid index value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In particular, an"] # [doc = " invalid index value is likely to cause panics or possibly even silent"] # [doc = " logical errors."] # [doc = ""] # [doc = " Callers must never rely on a `SmallIndex` to be within a certain range"] # [doc = " for memory safety."] # [inline] pub const fn new_unchecked (index : usize) -> SmallIndex { SmallIndex :: from_u32_unchecked (index as u32) } # [doc = " Create a new small index from a `u32` without checking whether the"] # [doc = " given value exceeds [`SmallIndex::MAX`]."] # [doc = ""] # [doc = " Using this routine with an invalid index value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In particular, an"] # [doc = " invalid index value is likely to cause panics or possibly even silent"] # [doc = " logical errors."] # [doc = ""] # [doc = " Callers must never rely on a `SmallIndex` to be within a certain range"] # [doc = " for memory safety."] # [inline] pub const fn from_u32_unchecked (index : u32) -> SmallIndex { SmallIndex (index) } # [doc = " Like [`SmallIndex::new`], but panics if the given index is not valid."] # [inline] pub fn must (index : usize) -> SmallIndex { SmallIndex :: new (index) . expect ("invalid small index") } # [doc = " Return this small index as a `usize`. This is guaranteed to never"] # [doc = " overflow `usize`."] # [inline] pub const fn as_usize (& self) -> usize { self . 0 as usize } # [doc = " Return this small index as a `u64`. This is guaranteed to never"] # [doc = " overflow."] # [inline] pub const fn as_u64 (& self) -> u64 { self . 0 as u64 } # [doc = " Return the internal `u32` of this small index. This is guaranteed to"] # [doc = " never overflow `u32`."] # [inline] pub const fn as_u32 (& self) -> u32 { self . 0 } # [doc = " Return the internal `u32` of this small index represented as an `i32`."] # [doc = " This is guaranteed to never overflow an `i32`."] # [inline] pub const fn as_i32 (& self) -> i32 { self . 0 as i32 } # [doc = " Returns one more than this small index as a usize."] # [doc = ""] # [doc = " Since a small index has constraints on its maximum value, adding `1` to"] # [doc = " it will always fit in a `usize`, `isize`, `u32` and a `i32`."] # [inline] pub fn one_more (& self) -> usize { self . as_usize () + 1 } # [doc = " Decode this small index from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " If the decoded integer is not representable as a small index for the"] # [doc = " current target, then this returns an error."] # [inline] pub fn from_ne_bytes (bytes : [u8 ; 4]) -> Result < SmallIndex , SmallIndexError > { let id = u32 :: from_ne_bytes (bytes) ; if id > SmallIndex :: MAX . as_u32 () { return Err (SmallIndexError { attempted : u64 :: from (id) , }) ; } Ok (SmallIndex :: new_unchecked (id . as_usize ())) } # [doc = " Decode this small index from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " This is analogous to [`SmallIndex::new_unchecked`] in that is does not"] # [doc = " check whether the decoded integer is representable as a small index."] # [inline] pub fn from_ne_bytes_unchecked (bytes : [u8 ; 4]) -> SmallIndex { SmallIndex :: new_unchecked (u32 :: from_ne_bytes (bytes) . as_usize ()) } # [doc = " Return the underlying small index integer as raw bytes in native endian"] # [doc = " format."] # [inline] pub fn to_ne_bytes (& self) -> [u8 ; 4] { self . 0 . to_ne_bytes () } } impl < T > core :: ops :: Index < SmallIndex > for [T] { type Output = T ; # [inline] fn index (& self , index : SmallIndex) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < SmallIndex > for [T] { # [inline] fn index_mut (& mut self , index : SmallIndex) -> & mut T { & mut self [index . as_usize ()] } } impl < T > core :: ops :: Index < SmallIndex > for Vec < T > { type Output = T ; # [inline] fn index (& self , index : SmallIndex) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < SmallIndex > for Vec < T > { # [inline] fn index_mut (& mut self , index : SmallIndex) -> & mut T { & mut self [index . as_usize ()] } } impl From < StateID > for SmallIndex { fn from (sid : StateID) -> SmallIndex { sid . 0 } } impl From < PatternID > for SmallIndex { fn from (pid : PatternID) -> SmallIndex { pid . 0 } } impl From < u8 > for SmallIndex { fn from (index : u8) -> SmallIndex { SmallIndex :: new_unchecked (usize :: from (index)) } } impl TryFrom < u16 > for SmallIndex { type Error = SmallIndexError ; fn try_from (index : u16) -> Result < SmallIndex , SmallIndexError > { if u32 :: from (index) > SmallIndex :: MAX . as_u32 () { return Err (SmallIndexError { attempted : u64 :: from (index) , }) ; } Ok (SmallIndex :: new_unchecked (index . as_usize ())) } } impl TryFrom < u32 > for SmallIndex { type Error = SmallIndexError ; fn try_from (index : u32) -> Result < SmallIndex , SmallIndexError > { if index > SmallIndex :: MAX . as_u32 () { return Err (SmallIndexError { attempted : u64 :: from (index) , }) ; } Ok (SmallIndex :: new_unchecked (index . as_usize ())) } } impl TryFrom < u64 > for SmallIndex { type Error = SmallIndexError ; fn try_from (index : u64) -> Result < SmallIndex , SmallIndexError > { if index > SmallIndex :: MAX . as_u64 () { return Err (SmallIndexError { attempted : index , }) ; } Ok (SmallIndex :: new_unchecked (index . as_usize ())) } } impl TryFrom < usize > for SmallIndex { type Error = SmallIndexError ; fn try_from (index : usize) -> Result < SmallIndex , SmallIndexError > { if index > SmallIndex :: MAX . as_usize () { return Err (SmallIndexError { attempted : index . as_u64 () , }) ; } Ok (SmallIndex :: new_unchecked (index)) } } # [doc = " This error occurs when a small index could not be constructed."] # [doc = ""] # [doc = " This occurs when given an integer exceeding the maximum small index value."] # [doc = ""] # [doc = " When the `std` feature is enabled, this implements the `Error` trait."] pub struct SmallIndexError { attempted : u64 , } # [automatically_derived] impl :: core :: clone :: Clone for SmallIndexError { # [inline] fn clone (& self) -> SmallIndexError { SmallIndexError { attempted : :: core :: clone :: Clone :: clone (& self . attempted) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for SmallIndexError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SmallIndexError" , "attempted" , & & self . attempted ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for SmallIndexError { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < u64 > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for SmallIndexError { } # [automatically_derived] impl :: core :: cmp :: PartialEq for SmallIndexError { # [inline] fn eq (& self , other : & SmallIndexError) -> bool { self . attempted == other . attempted } } impl SmallIndexError { # [doc = " Returns the value that could not be converted to a small index."] pub fn attempted (& self) -> u64 { self . attempted } } impl std :: error :: Error for SmallIndexError { } impl core :: fmt :: Display for SmallIndexError { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . write_fmt (format_args ! ("failed to create small index from {0:?}, which exceeds {1:?}" , self . attempted () , SmallIndex :: MAX ,) ,) } } pub (crate) struct SmallIndexIter { rng : core :: ops :: Range < usize > , } # [automatically_derived] impl :: core :: clone :: Clone for SmallIndexIter { # [inline] fn clone (& self) -> SmallIndexIter { SmallIndexIter { rng : :: core :: clone :: Clone :: clone (& self . rng) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for SmallIndexIter { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SmallIndexIter" , "rng" , & & self . rng ,) } } impl Iterator for SmallIndexIter { type Item = SmallIndex ; fn next (& mut self) -> Option < SmallIndex > { if self . rng . start >= self . rng . end { return None ; } let next_id = self . rng . start + 1 ; let id = core :: mem :: replace (& mut self . rng . start , next_id) ; Some (SmallIndex :: new_unchecked (id)) } } # [doc = " The identifier of a pattern in an Aho-Corasick automaton."] # [doc = ""] # [doc = " It is represented by a `u32` even on 64-bit systems in order to conserve"] # [doc = " space. Namely, on all targets, this type guarantees that its value will"] # [doc = " fit in a `u32`, `i32`, `usize` and an `isize`. This means that on 16-bit"] # [doc = " targets, for example, this type's maximum value will never overflow an"] # [doc = " `isize`, which means it will never overflow a `i16` even though its"] # [doc = " internal representation is still a `u32`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " While a `PatternID` is meant to guarantee that its value fits into `usize`"] # [doc = " without using as much space as a `usize` on all targets, callers must"] # [doc = " not rely on this property for safety. Callers may choose to rely on this"] # [doc = " property for correctness however. For example, creating a `StateID` with an"] # [doc = " invalid value can be done in entirely safe code. This may in turn result in"] # [doc = " panics or silent logical errors."] # [repr (transparent)] pub struct PatternID (SmallIndex) ; # [automatically_derived] impl :: core :: clone :: Clone for PatternID { # [inline] fn clone (& self) -> PatternID { let _ : :: core :: clone :: AssertParamIsClone < SmallIndex > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for PatternID { } # [automatically_derived] impl :: core :: default :: Default for PatternID { # [inline] fn default () -> PatternID { PatternID (:: core :: default :: Default :: default ()) } } # [automatically_derived] impl :: core :: cmp :: Eq for PatternID { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < SmallIndex > ; } } # [automatically_derived] impl :: core :: hash :: Hash for PatternID { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . 0 , state) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for PatternID { } # [automatically_derived] impl :: core :: cmp :: PartialEq for PatternID { # [inline] fn eq (& self , other : & PatternID) -> bool { self . 0 == other . 0 } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for PatternID { # [inline] fn partial_cmp (& self , other : & PatternID ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { :: core :: cmp :: PartialOrd :: partial_cmp (& self . 0 , & other . 0) } } # [automatically_derived] impl :: core :: cmp :: Ord for PatternID { # [inline] fn cmp (& self , other : & PatternID) -> :: core :: cmp :: Ordering { :: core :: cmp :: Ord :: cmp (& self . 0 , & other . 0) } } # [doc = " The identifier of a finite automaton state."] # [doc = ""] # [doc = " It is represented by a `u32` even on 64-bit systems in order to conserve"] # [doc = " space. Namely, on all targets, this type guarantees that its value will"] # [doc = " fit in a `u32`, `i32`, `usize` and an `isize`. This means that on 16-bit"] # [doc = " targets, for example, this type's maximum value will never overflow an"] # [doc = " `isize`, which means it will never overflow a `i16` even though its"] # [doc = " internal representation is still a `u32`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " While a `StateID` is meant to guarantee that its value fits into `usize`"] # [doc = " without using as much space as a `usize` on all targets, callers must"] # [doc = " not rely on this property for safety. Callers may choose to rely on this"] # [doc = " property for correctness however. For example, creating a `StateID` with an"] # [doc = " invalid value can be done in entirely safe code. This may in turn result in"] # [doc = " panics or silent logical errors."] # [repr (transparent)] pub struct StateID (SmallIndex) ; # [automatically_derived] impl :: core :: clone :: Clone for StateID { # [inline] fn clone (& self) -> StateID { let _ : :: core :: clone :: AssertParamIsClone < SmallIndex > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for StateID { } # [automatically_derived] impl :: core :: default :: Default for StateID { # [inline] fn default () -> StateID { StateID (:: core :: default :: Default :: default ()) } } # [automatically_derived] impl :: core :: cmp :: Eq for StateID { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < SmallIndex > ; } } # [automatically_derived] impl :: core :: hash :: Hash for StateID { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . 0 , state) } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for StateID { } # [automatically_derived] impl :: core :: cmp :: PartialEq for StateID { # [inline] fn eq (& self , other : & StateID) -> bool { self . 0 == other . 0 } } # [automatically_derived] impl :: core :: cmp :: PartialOrd for StateID { # [inline] fn partial_cmp (& self , other : & StateID ,) -> :: core :: option :: Option < :: core :: cmp :: Ordering > { :: core :: cmp :: PartialOrd :: partial_cmp (& self . 0 , & other . 0) } } # [automatically_derived] impl :: core :: cmp :: Ord for StateID { # [inline] fn cmp (& self , other : & StateID) -> :: core :: cmp :: Ordering { :: core :: cmp :: Ord :: cmp (& self . 0 , & other . 0) } } impl PatternID { # [doc = " The maximum value."] pub const MAX : PatternID = PatternID (SmallIndex :: MAX) ; # [doc = " The total number of values that can be represented."] pub const LIMIT : usize = SmallIndex :: LIMIT ; # [doc = " The zero value."] pub const ZERO : PatternID = PatternID (SmallIndex :: ZERO) ; # [doc = " The number of bytes that a single value uses in memory."] pub const SIZE : usize = SmallIndex :: SIZE ; # [doc = " Create a new value that is represented by a \"small index.\""] # [doc = ""] # [doc = " If the given index exceeds the maximum allowed value, then this"] # [doc = " returns an error."] # [inline] pub fn new (value : usize) -> Result < PatternID , PatternIDError > { SmallIndex :: new (value) . map (PatternID) . map_err (PatternIDError) } # [doc = " Create a new value without checking whether the given argument"] # [doc = " exceeds the maximum."] # [doc = ""] # [doc = " Using this routine with an invalid value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In"] # [doc = " particular, an invalid ID value is likely to cause panics or"] # [doc = " possibly even silent logical errors."] # [doc = ""] # [doc = " Callers must never rely on this type to be within a certain"] # [doc = " range for memory safety."] # [inline] pub const fn new_unchecked (value : usize) -> PatternID { PatternID (SmallIndex :: new_unchecked (value)) } # [doc = " Create a new value from a `u32` without checking whether the"] # [doc = " given value exceeds the maximum."] # [doc = ""] # [doc = " Using this routine with an invalid value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In"] # [doc = " particular, an invalid ID value is likely to cause panics or"] # [doc = " possibly even silent logical errors."] # [doc = ""] # [doc = " Callers must never rely on this type to be within a certain"] # [doc = " range for memory safety."] # [inline] pub const fn from_u32_unchecked (index : u32) -> PatternID { PatternID (SmallIndex :: from_u32_unchecked (index)) } # [doc = " Like `new`, but panics if the given value is not valid."] # [inline] pub fn must (value : usize) -> PatternID { PatternID :: new (value) . expect ("invalid PatternID value") } # [doc = " Return the internal value as a `usize`. This is guaranteed to"] # [doc = " never overflow `usize`."] # [inline] pub const fn as_usize (& self) -> usize { self . 0 . as_usize () } # [doc = " Return the internal value as a `u64`. This is guaranteed to"] # [doc = " never overflow."] # [inline] pub const fn as_u64 (& self) -> u64 { self . 0 . as_u64 () } # [doc = " Return the internal value as a `u32`. This is guaranteed to"] # [doc = " never overflow `u32`."] # [inline] pub const fn as_u32 (& self) -> u32 { self . 0 . as_u32 () } # [doc = " Return the internal value as a `i32`. This is guaranteed to"] # [doc = " never overflow an `i32`."] # [inline] pub const fn as_i32 (& self) -> i32 { self . 0 . as_i32 () } # [doc = " Returns one more than this value as a usize."] # [doc = ""] # [doc = " Since values represented by a \"small index\" have constraints"] # [doc = " on their maximum value, adding `1` to it will always fit in a"] # [doc = " `usize`, `u32` and a `i32`."] # [inline] pub fn one_more (& self) -> usize { self . 0 . one_more () } # [doc = " Decode this value from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " If the decoded integer is not representable as a small index"] # [doc = " for the current target, then this returns an error."] # [inline] pub fn from_ne_bytes (bytes : [u8 ; 4]) -> Result < PatternID , PatternIDError > { SmallIndex :: from_ne_bytes (bytes) . map (PatternID) . map_err (PatternIDError) } # [doc = " Decode this value from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " This is analogous to `new_unchecked` in that is does not check"] # [doc = " whether the decoded integer is representable as a small index."] # [inline] pub fn from_ne_bytes_unchecked (bytes : [u8 ; 4]) -> PatternID { PatternID (SmallIndex :: from_ne_bytes_unchecked (bytes)) } # [doc = " Return the underlying integer as raw bytes in native endian"] # [doc = " format."] # [inline] pub fn to_ne_bytes (& self) -> [u8 ; 4] { self . 0 . to_ne_bytes () } # [doc = " Returns an iterator over all values from 0 up to and not"] # [doc = " including the given length."] # [doc = ""] # [doc = " If the given length exceeds this type's limit, then this"] # [doc = " panics."] pub (crate) fn iter (len : usize) -> PatternIDIter { PatternIDIter :: new (len) } } impl core :: fmt :: Debug for PatternID { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_tuple ("PatternID") . field (& self . as_u32 ()) . finish () } } impl < T > core :: ops :: Index < PatternID > for [T] { type Output = T ; # [inline] fn index (& self , index : PatternID) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < PatternID > for [T] { # [inline] fn index_mut (& mut self , index : PatternID) -> & mut T { & mut self [index . as_usize ()] } } impl < T > core :: ops :: Index < PatternID > for Vec < T > { type Output = T ; # [inline] fn index (& self , index : PatternID) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < PatternID > for Vec < T > { # [inline] fn index_mut (& mut self , index : PatternID) -> & mut T { & mut self [index . as_usize ()] } } impl From < SmallIndex > for PatternID { fn from (index : SmallIndex) -> PatternID { PatternID (index) } } impl From < u8 > for PatternID { fn from (value : u8) -> PatternID { PatternID (SmallIndex :: from (value)) } } impl TryFrom < u16 > for PatternID { type Error = PatternIDError ; fn try_from (value : u16) -> Result < PatternID , PatternIDError > { SmallIndex :: try_from (value) . map (PatternID) . map_err (PatternIDError) } } impl TryFrom < u32 > for PatternID { type Error = PatternIDError ; fn try_from (value : u32) -> Result < PatternID , PatternIDError > { SmallIndex :: try_from (value) . map (PatternID) . map_err (PatternIDError) } } impl TryFrom < u64 > for PatternID { type Error = PatternIDError ; fn try_from (value : u64) -> Result < PatternID , PatternIDError > { SmallIndex :: try_from (value) . map (PatternID) . map_err (PatternIDError) } } impl TryFrom < usize > for PatternID { type Error = PatternIDError ; fn try_from (value : usize) -> Result < PatternID , PatternIDError > { SmallIndex :: try_from (value) . map (PatternID) . map_err (PatternIDError) } } # [doc = " This error occurs when an ID could not be constructed."] # [doc = ""] # [doc = " This occurs when given an integer exceeding the maximum allowed"] # [doc = " value."] # [doc = ""] # [doc = " When the `std` feature is enabled, this implements the `Error`"] # [doc = " trait."] pub struct PatternIDError (SmallIndexError) ; # [automatically_derived] impl :: core :: clone :: Clone for PatternIDError { # [inline] fn clone (& self) -> PatternIDError { PatternIDError (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for PatternIDError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "PatternIDError" , & & self . 0 ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for PatternIDError { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < SmallIndexError > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for PatternIDError { } # [automatically_derived] impl :: core :: cmp :: PartialEq for PatternIDError { # [inline] fn eq (& self , other : & PatternIDError) -> bool { self . 0 == other . 0 } } impl PatternIDError { # [doc = " Returns the value that could not be converted to an ID."] pub fn attempted (& self) -> u64 { self . 0 . attempted () } } impl std :: error :: Error for PatternIDError { } impl core :: fmt :: Display for PatternIDError { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . write_fmt (format_args ! ("failed to create {0} from {1:?}, which exceeds {2:?}" , "PatternID" , self . attempted () , PatternID :: MAX ,) ,) } } pub (crate) struct PatternIDIter (SmallIndexIter) ; # [automatically_derived] impl :: core :: clone :: Clone for PatternIDIter { # [inline] fn clone (& self) -> PatternIDIter { PatternIDIter (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for PatternIDIter { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "PatternIDIter" , & & self . 0 ,) } } impl PatternIDIter { fn new (len : usize) -> PatternIDIter { if ! (len <= PatternID :: LIMIT) { { :: core :: panicking :: panic_fmt (format_args ! ("cannot create iterator for {0} when number of elements exceed {1:?}" , "PatternID" , PatternID :: LIMIT ,) ,) ; } } PatternIDIter (SmallIndexIter { rng : 0 .. len }) } } impl Iterator for PatternIDIter { type Item = PatternID ; fn next (& mut self) -> Option < PatternID > { self . 0 . next () . map (PatternID) } } # [doc = " An iterator adapter that is like std::iter::Enumerate, but attaches"] # [doc = " small index values instead. It requires `ExactSizeIterator`. At"] # [doc = " construction, it ensures that the index of each element in the"] # [doc = " iterator is representable in the corresponding small index type."] pub (crate) struct WithPatternIDIter < I > { it : I , ids : PatternIDIter , } # [automatically_derived] impl < I : :: core :: clone :: Clone > :: core :: clone :: Clone for WithPatternIDIter < I > { # [inline] fn clone (& self) -> WithPatternIDIter < I > { WithPatternIDIter { it : :: core :: clone :: Clone :: clone (& self . it) , ids : :: core :: clone :: Clone :: clone (& self . ids) , } } } # [automatically_derived] impl < I : :: core :: fmt :: Debug > :: core :: fmt :: Debug for WithPatternIDIter < I > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "WithPatternIDIter" , "it" , & self . it , "ids" , & & self . ids ,) } } impl < I : Iterator + ExactSizeIterator > WithPatternIDIter < I > { fn new (it : I) -> WithPatternIDIter < I > { let ids = PatternID :: iter (it . len ()) ; WithPatternIDIter { it , ids } } } impl < I : Iterator + ExactSizeIterator > Iterator for WithPatternIDIter < I > { type Item = (PatternID , I :: Item) ; fn next (& mut self) -> Option < (PatternID , I :: Item) > { let item = self . it . next () ? ; let id = self . ids . next () . unwrap () ; Some ((id , item)) } } impl StateID { # [doc = " The maximum value."] pub const MAX : StateID = StateID (SmallIndex :: MAX) ; # [doc = " The total number of values that can be represented."] pub const LIMIT : usize = SmallIndex :: LIMIT ; # [doc = " The zero value."] pub const ZERO : StateID = StateID (SmallIndex :: ZERO) ; # [doc = " The number of bytes that a single value uses in memory."] pub const SIZE : usize = SmallIndex :: SIZE ; # [doc = " Create a new value that is represented by a \"small index.\""] # [doc = ""] # [doc = " If the given index exceeds the maximum allowed value, then this"] # [doc = " returns an error."] # [inline] pub fn new (value : usize) -> Result < StateID , StateIDError > { SmallIndex :: new (value) . map (StateID) . map_err (StateIDError) } # [doc = " Create a new value without checking whether the given argument"] # [doc = " exceeds the maximum."] # [doc = ""] # [doc = " Using this routine with an invalid value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In"] # [doc = " particular, an invalid ID value is likely to cause panics or"] # [doc = " possibly even silent logical errors."] # [doc = ""] # [doc = " Callers must never rely on this type to be within a certain"] # [doc = " range for memory safety."] # [inline] pub const fn new_unchecked (value : usize) -> StateID { StateID (SmallIndex :: new_unchecked (value)) } # [doc = " Create a new value from a `u32` without checking whether the"] # [doc = " given value exceeds the maximum."] # [doc = ""] # [doc = " Using this routine with an invalid value will result in"] # [doc = " unspecified behavior, but *not* undefined behavior. In"] # [doc = " particular, an invalid ID value is likely to cause panics or"] # [doc = " possibly even silent logical errors."] # [doc = ""] # [doc = " Callers must never rely on this type to be within a certain"] # [doc = " range for memory safety."] # [inline] pub const fn from_u32_unchecked (index : u32) -> StateID { StateID (SmallIndex :: from_u32_unchecked (index)) } # [doc = " Like `new`, but panics if the given value is not valid."] # [inline] pub fn must (value : usize) -> StateID { StateID :: new (value) . expect ("invalid StateID value") } # [doc = " Return the internal value as a `usize`. This is guaranteed to"] # [doc = " never overflow `usize`."] # [inline] pub const fn as_usize (& self) -> usize { self . 0 . as_usize () } # [doc = " Return the internal value as a `u64`. This is guaranteed to"] # [doc = " never overflow."] # [inline] pub const fn as_u64 (& self) -> u64 { self . 0 . as_u64 () } # [doc = " Return the internal value as a `u32`. This is guaranteed to"] # [doc = " never overflow `u32`."] # [inline] pub const fn as_u32 (& self) -> u32 { self . 0 . as_u32 () } # [doc = " Return the internal value as a `i32`. This is guaranteed to"] # [doc = " never overflow an `i32`."] # [inline] pub const fn as_i32 (& self) -> i32 { self . 0 . as_i32 () } # [doc = " Returns one more than this value as a usize."] # [doc = ""] # [doc = " Since values represented by a \"small index\" have constraints"] # [doc = " on their maximum value, adding `1` to it will always fit in a"] # [doc = " `usize`, `u32` and a `i32`."] # [inline] pub fn one_more (& self) -> usize { self . 0 . one_more () } # [doc = " Decode this value from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " If the decoded integer is not representable as a small index"] # [doc = " for the current target, then this returns an error."] # [inline] pub fn from_ne_bytes (bytes : [u8 ; 4]) -> Result < StateID , StateIDError > { SmallIndex :: from_ne_bytes (bytes) . map (StateID) . map_err (StateIDError) } # [doc = " Decode this value from the bytes given using the native endian"] # [doc = " byte order for the current target."] # [doc = ""] # [doc = " This is analogous to `new_unchecked` in that is does not check"] # [doc = " whether the decoded integer is representable as a small index."] # [inline] pub fn from_ne_bytes_unchecked (bytes : [u8 ; 4]) -> StateID { StateID (SmallIndex :: from_ne_bytes_unchecked (bytes)) } # [doc = " Return the underlying integer as raw bytes in native endian"] # [doc = " format."] # [inline] pub fn to_ne_bytes (& self) -> [u8 ; 4] { self . 0 . to_ne_bytes () } # [doc = " Returns an iterator over all values from 0 up to and not"] # [doc = " including the given length."] # [doc = ""] # [doc = " If the given length exceeds this type's limit, then this"] # [doc = " panics."] pub (crate) fn iter (len : usize) -> StateIDIter { StateIDIter :: new (len) } } impl core :: fmt :: Debug for StateID { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_tuple ("StateID") . field (& self . as_u32 ()) . finish () } } impl < T > core :: ops :: Index < StateID > for [T] { type Output = T ; # [inline] fn index (& self , index : StateID) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < StateID > for [T] { # [inline] fn index_mut (& mut self , index : StateID) -> & mut T { & mut self [index . as_usize ()] } } impl < T > core :: ops :: Index < StateID > for Vec < T > { type Output = T ; # [inline] fn index (& self , index : StateID) -> & T { & self [index . as_usize ()] } } impl < T > core :: ops :: IndexMut < StateID > for Vec < T > { # [inline] fn index_mut (& mut self , index : StateID) -> & mut T { & mut self [index . as_usize ()] } } impl From < SmallIndex > for StateID { fn from (index : SmallIndex) -> StateID { StateID (index) } } impl From < u8 > for StateID { fn from (value : u8) -> StateID { StateID (SmallIndex :: from (value)) } } impl TryFrom < u16 > for StateID { type Error = StateIDError ; fn try_from (value : u16) -> Result < StateID , StateIDError > { SmallIndex :: try_from (value) . map (StateID) . map_err (StateIDError) } } impl TryFrom < u32 > for StateID { type Error = StateIDError ; fn try_from (value : u32) -> Result < StateID , StateIDError > { SmallIndex :: try_from (value) . map (StateID) . map_err (StateIDError) } } impl TryFrom < u64 > for StateID { type Error = StateIDError ; fn try_from (value : u64) -> Result < StateID , StateIDError > { SmallIndex :: try_from (value) . map (StateID) . map_err (StateIDError) } } impl TryFrom < usize > for StateID { type Error = StateIDError ; fn try_from (value : usize) -> Result < StateID , StateIDError > { SmallIndex :: try_from (value) . map (StateID) . map_err (StateIDError) } } # [doc = " This error occurs when an ID could not be constructed."] # [doc = ""] # [doc = " This occurs when given an integer exceeding the maximum allowed"] # [doc = " value."] # [doc = ""] # [doc = " When the `std` feature is enabled, this implements the `Error`"] # [doc = " trait."] pub struct StateIDError (SmallIndexError) ; # [automatically_derived] impl :: core :: clone :: Clone for StateIDError { # [inline] fn clone (& self) -> StateIDError { StateIDError (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for StateIDError { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "StateIDError" , & & self . 0 ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for StateIDError { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < SmallIndexError > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for StateIDError { } # [automatically_derived] impl :: core :: cmp :: PartialEq for StateIDError { # [inline] fn eq (& self , other : & StateIDError) -> bool { self . 0 == other . 0 } } impl StateIDError { # [doc = " Returns the value that could not be converted to an ID."] pub fn attempted (& self) -> u64 { self . 0 . attempted () } } impl std :: error :: Error for StateIDError { } impl core :: fmt :: Display for StateIDError { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . write_fmt (format_args ! ("failed to create {0} from {1:?}, which exceeds {2:?}" , "StateID" , self . attempted () , StateID :: MAX ,) ,) } } pub (crate) struct StateIDIter (SmallIndexIter) ; # [automatically_derived] impl :: core :: clone :: Clone for StateIDIter { # [inline] fn clone (& self) -> StateIDIter { StateIDIter (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for StateIDIter { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "StateIDIter" , & & self . 0 ,) } } impl StateIDIter { fn new (len : usize) -> StateIDIter { if ! (len <= StateID :: LIMIT) { { :: core :: panicking :: panic_fmt (format_args ! ("cannot create iterator for {0} when number of elements exceed {1:?}" , "StateID" , StateID :: LIMIT ,) ,) ; } } StateIDIter (SmallIndexIter { rng : 0 .. len }) } } impl Iterator for StateIDIter { type Item = StateID ; fn next (& mut self) -> Option < StateID > { self . 0 . next () . map (StateID) } } # [doc = " An iterator adapter that is like std::iter::Enumerate, but attaches"] # [doc = " small index values instead. It requires `ExactSizeIterator`. At"] # [doc = " construction, it ensures that the index of each element in the"] # [doc = " iterator is representable in the corresponding small index type."] pub (crate) struct WithStateIDIter < I > { it : I , ids : StateIDIter , } # [automatically_derived] impl < I : :: core :: clone :: Clone > :: core :: clone :: Clone for WithStateIDIter < I > { # [inline] fn clone (& self) -> WithStateIDIter < I > { WithStateIDIter { it : :: core :: clone :: Clone :: clone (& self . it) , ids : :: core :: clone :: Clone :: clone (& self . ids) , } } } # [automatically_derived] impl < I : :: core :: fmt :: Debug > :: core :: fmt :: Debug for WithStateIDIter < I > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "WithStateIDIter" , "it" , & self . it , "ids" , & & self . ids ,) } } impl < I : Iterator + ExactSizeIterator > WithStateIDIter < I > { fn new (it : I) -> WithStateIDIter < I > { let ids = StateID :: iter (it . len ()) ; WithStateIDIter { it , ids } } } impl < I : Iterator + ExactSizeIterator > Iterator for WithStateIDIter < I > { type Item = (StateID , I :: Item) ; fn next (& mut self) -> Option < (StateID , I :: Item) > { let item = self . it . next () ? ; let id = self . ids . next () . unwrap () ; Some ((id , item)) } } # [doc = " A utility trait that defines a couple of adapters for making it convenient"] # [doc = " to access indices as \"small index\" types. We require ExactSizeIterator so"] # [doc = " that iterator construction can do a single check to make sure the index of"] # [doc = " each element is representable by its small index type."] pub (crate) trait IteratorIndexExt : Iterator { fn with_pattern_ids (self) -> WithPatternIDIter < Self > where Self : Sized + ExactSizeIterator , { WithPatternIDIter :: new (self) } fn with_state_ids (self) -> WithStateIDIter < Self > where Self : Sized + ExactSizeIterator , { WithStateIDIter :: new (self) } } impl < I : Iterator > IteratorIndexExt for I { } }