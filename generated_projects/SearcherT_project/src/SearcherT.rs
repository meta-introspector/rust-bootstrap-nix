use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " A trait that provides dynamic dispatch over the different possible Teddy"] # [doc = " variants on the same algorithm."] # [doc = ""] # [doc = " On `x86_64` for example, it isn't known until runtime which of 12 possible"] # [doc = " variants will be used. One might use one of the four slim 128-bit vector"] # [doc = " variants, or one of the four 256-bit vector variants or even one of the"] # [doc = " four fat 256-bit vector variants."] # [doc = ""] # [doc = " Since this choice is generally made when the Teddy searcher is constructed"] # [doc = " and this choice is based on the patterns given and what the current CPU"] # [doc = " supports, it follows that there must be some kind of indirection at search"] # [doc = " time that \"selects\" the variant chosen at build time."] # [doc = ""] # [doc = " There are a few different ways to go about this. One approach is to use an"] # [doc = " enum. It works fine, but in my experiments, this generally results in worse"] # [doc = " codegen. Another approach, which is what we use here, is dynamic dispatch"] # [doc = " via a trait object. We basically implement this trait for each possible"] # [doc = " variant, select the variant we want at build time and convert it to a"] # [doc = " trait object for use at search time."] # [doc = ""] # [doc = " Another approach is to use function pointers and stick each of the possible"] # [doc = " variants into a union. This is essentially isomorphic to the dynamic"] # [doc = " dispatch approach, but doesn't require any allocations. Since this crate"] # [doc = " requires `alloc`, there's no real reason (AFAIK) to go down this path. (The"] # [doc = " `memchr` crate does this.)"] trait SearcherT : Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static { # [doc = " Execute a search on the given haystack (identified by `start` and `end`"] # [doc = " raw pointers)."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Essentially, the `start` and `end` pointers must be valid and point"] # [doc = " to a haystack one can read. As long as you derive them from, for"] # [doc = " example, a `&[u8]`, they should automatically satisfy all of the safety"] # [doc = " obligations:"] # [doc = ""] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [doc = " * It must be the case that `start <= end`."] # [doc = " * `end - start` must be greater than the minimum length for this"] # [doc = " searcher."] # [doc = ""] # [doc = " Also, it is expected that implementations of this trait will tag this"] # [doc = " method with a `target_feature` attribute. Callers must ensure that"] # [doc = " they are executing this method in an environment where that attribute"] # [doc = " is valid."] unsafe fn find (& self , start : * const u8 , end : * const u8) -> Option < Match > ; }