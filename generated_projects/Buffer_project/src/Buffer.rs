use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " A fairly simple roll buffer for supporting stream searches."] # [doc = ""] # [doc = " This buffer acts as a temporary place to store a fixed amount of data when"] # [doc = " reading from a stream. Its central purpose is to allow \"rolling\" some"] # [doc = " suffix of the data to the beginning of the buffer before refilling it with"] # [doc = " more data from the stream. For example, let's say we are trying to match"] # [doc = " \"foobar\" on a stream. When we report the match, we'd like to not only"] # [doc = " report the correct offsets at which the match occurs, but also the matching"] # [doc = " bytes themselves. So let's say our stream is a file with the following"] # [doc = " contents: `test test foobar test test`. Now assume that we happen to read"] # [doc = " the aforementioned file in two chunks: `test test foo` and `bar test test`."] # [doc = " Naively, it would not be possible to report a single contiguous `foobar`"] # [doc = " match, but this roll buffer allows us to do that. Namely, after the second"] # [doc = " read, the contents of the buffer should be `st foobar test test`, where the"] # [doc = " search should ultimately resume immediately after `foo`. (The prefix `st `"] # [doc = " is included because the roll buffer saves N bytes at the end of the buffer,"] # [doc = " where N is the maximum possible length of a match.)"] # [doc = ""] # [doc = " A lot of the logic for dealing with this is unfortunately split out between"] # [doc = " this roll buffer and the `StreamChunkIter`."] # [doc = ""] # [doc = " Note also that this buffer is not actually required to just report matches."] # [doc = " Because a `Match` is just some offsets. But it *is* required for supporting"] # [doc = " things like `try_stream_replace_all` because that needs some mechanism for"] # [doc = " knowing which bytes in the stream correspond to a match and which don't. So"] # [doc = " when a match occurs across two `read` calls, *something* needs to retain"] # [doc = " the bytes from the previous `read` call because you don't know before the"] # [doc = " second read call whether a match exists or not."] pub (crate) struct Buffer { # [doc = " The raw buffer contents. This has a fixed size and never increases."] buf : Vec < u8 > , # [doc = " The minimum size of the buffer, which is equivalent to the maximum"] # [doc = " possible length of a match. This corresponds to the amount that we"] # [doc = " roll"] min : usize , # [doc = " The end of the contents of this buffer."] end : usize , }