use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " This trait extends the `Vector` trait with additional operations to support"] # [doc = " Fat Teddy."] # [doc = ""] # [doc = " Fat Teddy uses 16 buckets instead of 8, but reads half as many bytes (as"] # [doc = " the vector size) instead of the full size of a vector per iteration. For"] # [doc = " example, when using a 256-bit vector, Slim Teddy reads 32 bytes at a timr"] # [doc = " but Fat Teddy reads 16 bytes at a time."] # [doc = ""] # [doc = " Fat Teddy is useful when searching for a large number of literals."] # [doc = " The extra number of buckets spreads the literals out more and reduces"] # [doc = " verification time."] # [doc = ""] # [doc = " Currently we only implement this for AVX on x86_64. It would be nice to"] # [doc = " implement this for SSE on x86_64 and NEON on aarch64, with the latter two"] # [doc = " only reading 8 bytes at a time. It's not clear how well it would work, but"] # [doc = " there are some tricky things to figure out in terms of implementation. The"] # [doc = " `half_shift_in_{one,two,three}_bytes` methods in particular are probably"] # [doc = " the trickiest of the bunch. For AVX2, these are implemented by taking"] # [doc = " advantage of the fact that `_mm256_alignr_epi8` operates on each 128-bit"] # [doc = " half instead of the full 256-bit vector. (Where as `_mm_alignr_epi8`"] # [doc = " operates on the full 128-bit vector and not on each 64-bit half.) I didn't"] # [doc = " do a careful survey of NEON to see if it could easily support these"] # [doc = " operations."] pub (crate) trait FatVector : Vector { type Half : Vector ; # [doc = " Read a half-vector-size number of bytes from the given pointer, and"] # [doc = " broadcast it across both halfs of a full vector. The pointer does not"] # [doc = " need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `Self::HALF::BYTES` bytes are"] # [doc = " readable from `data`."] unsafe fn load_half_unaligned (data : * const u8) -> Self ; # [doc = " Like `Vector::shift_in_one_byte`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Like `Vector::shift_in_two_bytes`, except this is done for each half"] # [doc = " of the vector instead."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn half_shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Swap the 128-bit lanes in this vector."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn swap_halves (self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the low 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_low_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Unpack and interleave the 8-bit lanes from the high 128 bits of each"] # [doc = " vector and return the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn interleave_high_8bit_lanes (self , vector2 : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in the lower half"] # [doc = " of this vector and then in the other vector. The given function is"] # [doc = " provided the lane index and lane value as a `u64`. (The high 128-bits"] # [doc = " of each vector are ignored.)"] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_low_64bit_lane < T > (self , vector2 : Self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; }