use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod builder { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; use alloc :: sync :: Arc ; use crate :: packed :: { ext :: Pointer , pattern :: Patterns , teddy :: generic :: Match } ; # [doc = " A builder for constructing a Teddy matcher."] # [doc = ""] # [doc = " The builder primarily permits fine grained configuration of the Teddy"] # [doc = " matcher. Most options are made only available for testing/benchmarking"] # [doc = " purposes. In reality, options are automatically determined by the nature"] # [doc = " and number of patterns given to the builder."] pub (crate) struct Builder { # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " slim Teddy is used (8 buckets) and `true` means fat Teddy is used"] # [doc = " (16 buckets). Fat Teddy requires AVX2, so if that CPU feature isn't"] # [doc = " available and Fat Teddy was requested, no matcher will be built."] only_fat : Option < bool > , # [doc = " When none, this is automatically determined. Otherwise, `false` means"] # [doc = " that 128-bit vectors will be used (up to SSSE3 instructions) where as"] # [doc = " `true` means that 256-bit vectors will be used. As with `fat`, if"] # [doc = " 256-bit vectors are requested and they aren't available, then a"] # [doc = " searcher will not be built."] only_256bit : Option < bool > , # [doc = " When true (the default), the number of patterns will be used as a"] # [doc = " heuristic for refusing construction of a Teddy searcher. The point here"] # [doc = " is that too many patterns can overwhelm Teddy. But this can be disabled"] # [doc = " in cases where the caller knows better."] heuristic_pattern_limits : bool , } # [automatically_derived] impl :: core :: clone :: Clone for Builder { # [inline] fn clone (& self) -> Builder { Builder { only_fat : :: core :: clone :: Clone :: clone (& self . only_fat) , only_256bit : :: core :: clone :: Clone :: clone (& self . only_256bit) , heuristic_pattern_limits : :: core :: clone :: Clone :: clone (& self . heuristic_pattern_limits ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Builder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Builder" , "only_fat" , & self . only_fat , "only_256bit" , & self . only_256bit , "heuristic_pattern_limits" , & & self . heuristic_pattern_limits ,) } } impl Default for Builder { fn default () -> Builder { Builder :: new () } } impl Builder { # [doc = " Create a new builder for configuring a Teddy matcher."] pub (crate) fn new () -> Builder { Builder { only_fat : None , only_256bit : None , heuristic_pattern_limits : true , } } # [doc = " Build a matcher for the set of patterns given. If a matcher could not"] # [doc = " be built, then `None` is returned."] # [doc = ""] # [doc = " Generally, a matcher isn't built if the necessary CPU features aren't"] # [doc = " available, an unsupported target or if the searcher is believed to be"] # [doc = " slower than standard techniques (i.e., if there are too many literals)."] pub (crate) fn build (& self , patterns : Arc < Patterns >) -> Option < Searcher > { self . build_imp (patterns) } # [doc = " Require the use of Fat (true) or Slim (false) Teddy. Fat Teddy uses"] # [doc = " 16 buckets where as Slim Teddy uses 8 buckets. More buckets are useful"] # [doc = " for a larger set of literals."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based"] # [doc = " on the number of literals and available CPU features."] pub (crate) fn only_fat (& mut self , yes : Option < bool >) -> & mut Builder { self . only_fat = yes ; self } # [doc = " Request the use of 256-bit vectors (true) or 128-bit vectors (false)."] # [doc = " Generally, a larger vector size is better since it either permits"] # [doc = " matching more patterns or matching more bytes in the haystack at once."] # [doc = ""] # [doc = " `None` is the default, which results in an automatic selection based on"] # [doc = " the number of literals and available CPU features."] pub (crate) fn only_256bit (& mut self , yes : Option < bool >) -> & mut Builder { self . only_256bit = yes ; self } # [doc = " Request that heuristic limitations on the number of patterns be"] # [doc = " employed. This useful to disable for benchmarking where one wants to"] # [doc = " explore how Teddy performs on large number of patterns even if the"] # [doc = " heuristics would otherwise refuse construction."] # [doc = ""] # [doc = " This is enabled by default."] pub (crate) fn heuristic_pattern_limits (& mut self , yes : bool ,) -> & mut Builder { self . heuristic_pattern_limits = yes ; self } fn build_imp (& self , patterns : Arc < Patterns >) -> Option < Searcher > { let patlimit = self . heuristic_pattern_limits ; if ! true { return None ; } if patlimit && patterns . len () > 64 { return None ; } { use self :: aarch64 :: SlimNeon ; let mask_len = core :: cmp :: min (4 , patterns . minimum_len ()) ; if self . only_256bit == Some (true) { return None ; } if self . only_fat == Some (true) { } match mask_len { 1 => { if patlimit && patterns . len () > 16 { } SlimNeon :: < 1 > :: new (& patterns) } 2 => { if patlimit && patterns . len () > 32 { } SlimNeon :: < 2 > :: new (& patterns) } 3 => { if patlimit && patterns . len () > 48 { } SlimNeon :: < 3 > :: new (& patterns) } 4 => { SlimNeon :: < 4 > :: new (& patterns) } _ => { None } } } } } # [doc = " A searcher that dispatches to one of several possible Teddy variants."] pub (crate) struct Searcher { # [doc = " The Teddy variant we use. We use dynamic dispatch under the theory that"] # [doc = " it results in better codegen then a enum, although this is a specious"] # [doc = " claim."] # [doc = ""] # [doc = " This `Searcher` is essentially a wrapper for a `SearcherT` trait"] # [doc = " object. We just make `memory_usage` and `minimum_len` available without"] # [doc = " going through dynamic dispatch."] imp : Arc < dyn SearcherT > , # [doc = " Total heap memory used by the Teddy variant."] memory_usage : usize , # [doc = " The minimum haystack length this searcher can handle. It is intended"] # [doc = " for callers to use some other search routine (such as Rabin-Karp) in"] # [doc = " cases where the haystack (or remainer of the haystack) is too short."] minimum_len : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Searcher { # [inline] fn clone (& self) -> Searcher { Searcher { imp : :: core :: clone :: Clone :: clone (& self . imp) , memory_usage : :: core :: clone :: Clone :: clone (& self . memory_usage) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Searcher { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Searcher" , "imp" , & self . imp , "memory_usage" , & self . memory_usage , "minimum_len" , & & self . minimum_len ,) } } impl Searcher { # [doc = " Look for the leftmost occurrence of any pattern in this search in the"] # [doc = " given haystack starting at the given position."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `haystack[at..].len()` is less than the minimum length"] # [doc = " for this haystack."] # [inline (always)] pub (crate) fn find (& self , haystack : & [u8] , at : usize ,) -> Option < crate :: Match > { if ! (haystack [at ..] . len () >= self . minimum_len) { :: core :: panicking :: panic ("assertion failed: haystack[at..].len() >= self.minimum_len" ,) } let hayptr = haystack . as_ptr () ; let teddym = unsafe { self . imp . find (hayptr . add (at) , hayptr . add (haystack . len ())) ? } ; let start = teddym . start () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let end = teddym . end () . as_usize () . wrapping_sub (hayptr . as_usize ()) ; let span = crate :: Span { start , end } ; let pid = crate :: PatternID :: new_unchecked (teddym . pattern () . as_usize () ,) ; let m = crate :: Match :: new (pid , span) ; Some (m) } # [doc = " Returns the approximate total amount of heap used by this type, in"] # [doc = " units of bytes."] # [inline (always)] pub (crate) fn memory_usage (& self) -> usize { self . memory_usage } # [doc = " Returns the minimum length, in bytes, that a haystack must be in order"] # [doc = " to use it with this searcher."] # [inline (always)] pub (crate) fn minimum_len (& self) -> usize { self . minimum_len } } # [doc = " A trait that provides dynamic dispatch over the different possible Teddy"] # [doc = " variants on the same algorithm."] # [doc = ""] # [doc = " On `x86_64` for example, it isn't known until runtime which of 12 possible"] # [doc = " variants will be used. One might use one of the four slim 128-bit vector"] # [doc = " variants, or one of the four 256-bit vector variants or even one of the"] # [doc = " four fat 256-bit vector variants."] # [doc = ""] # [doc = " Since this choice is generally made when the Teddy searcher is constructed"] # [doc = " and this choice is based on the patterns given and what the current CPU"] # [doc = " supports, it follows that there must be some kind of indirection at search"] # [doc = " time that \"selects\" the variant chosen at build time."] # [doc = ""] # [doc = " There are a few different ways to go about this. One approach is to use an"] # [doc = " enum. It works fine, but in my experiments, this generally results in worse"] # [doc = " codegen. Another approach, which is what we use here, is dynamic dispatch"] # [doc = " via a trait object. We basically implement this trait for each possible"] # [doc = " variant, select the variant we want at build time and convert it to a"] # [doc = " trait object for use at search time."] # [doc = ""] # [doc = " Another approach is to use function pointers and stick each of the possible"] # [doc = " variants into a union. This is essentially isomorphic to the dynamic"] # [doc = " dispatch approach, but doesn't require any allocations. Since this crate"] # [doc = " requires `alloc`, there's no real reason (AFAIK) to go down this path. (The"] # [doc = " `memchr` crate does this.)"] trait SearcherT : Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static { # [doc = " Execute a search on the given haystack (identified by `start` and `end`"] # [doc = " raw pointers)."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Essentially, the `start` and `end` pointers must be valid and point"] # [doc = " to a haystack one can read. As long as you derive them from, for"] # [doc = " example, a `&[u8]`, they should automatically satisfy all of the safety"] # [doc = " obligations:"] # [doc = ""] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [doc = " * It must be the case that `start <= end`."] # [doc = " * `end - start` must be greater than the minimum length for this"] # [doc = " searcher."] # [doc = ""] # [doc = " Also, it is expected that implementations of this trait will tag this"] # [doc = " method with a `target_feature` attribute. Callers must ensure that"] # [doc = " they are executing this method in an environment where that attribute"] # [doc = " is valid."] unsafe fn find (& self , start : * const u8 , end : * const u8) -> Option < Match > ; } mod aarch64 { use core :: arch :: aarch64 :: uint8x16_t ; use alloc :: sync :: Arc ; use crate :: packed :: { pattern :: Patterns , teddy :: generic :: { self , Match } } ; use super :: { Searcher , SearcherT } ; pub (super) struct SlimNeon < const BYTES : usize > { slim128 : generic :: Slim < uint8x16_t , BYTES > , } # [automatically_derived] impl < const BYTES : usize > :: core :: clone :: Clone for SlimNeon < BYTES > { # [inline] fn clone (& self) -> SlimNeon < BYTES > { SlimNeon { slim128 : :: core :: clone :: Clone :: clone (& self . slim128) , } } } # [automatically_derived] impl < const BYTES : usize > :: core :: fmt :: Debug for SlimNeon < BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter ,) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SlimNeon" , "slim128" , & & self . slim128 ,) } } impl SlimNeon < 1 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 1 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 1 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 1 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 2 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 2 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 2 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 2 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 3 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 3 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 3 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 3 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 4 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 4 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 4 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 4 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } } }