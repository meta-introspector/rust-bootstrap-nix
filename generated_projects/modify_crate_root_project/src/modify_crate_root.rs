use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod modify_crate_root { use anyhow :: Result ; use std :: fs ; use std :: path :: Path ; use syn :: Item ; use prettyplease ; # [doc = " Modifies the crate root (`lib.rs` or `main.rs`) to ensure it contains `pub mod prelude;`."] pub fn modify_crate_root (src_dir : & Path , dry_run : bool , force : bool) -> Result < () > { { :: std :: io :: _print (format_args ! ("  -> Entering modify_crate_root for src_dir: {0}\n" , src_dir . display () ,) ,) ; } ; let lib_rs = src_dir . join ("lib.rs") ; let main_rs = src_dir . join ("main.rs") ; let crate_root_path = if lib_rs . exists () { lib_rs } else if main_rs . exists () { main_rs } else { return Ok (()) ; } ; let content = fs :: read_to_string (& crate_root_path) ? ; let ast = syn :: parse_file (& content) ? ; let mut has_prelude_mod = false ; for item in & ast . items { if let Item :: Mod (mod_item) = item { if mod_item . ident == "prelude" { has_prelude_mod = true ; break ; } } } if ! has_prelude_mod { let mut new_ast = ast . clone () ; let prelude_mod : Item = :: syn :: __private :: parse_quote ({ let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "pub") ; :: quote :: __private :: push_ident (& mut _s , "mod") ; :: quote :: __private :: push_ident (& mut _s , "prelude") ; :: quote :: __private :: push_semi (& mut _s) ; _s }) ; new_ast . items . insert (0 , prelude_mod) ; let new_content = prettyplease :: unparse (& new_ast) ; if dry_run { { :: std :: io :: _print (format_args ! ("[DRY RUN] Would add \'pub mod prelude;\' to: {0}\n" , crate_root_path . display () ,) ,) ; } ; } else { if crate_root_path . exists () && ! force { { :: std :: io :: _print (format_args ! ("  -> Skipping crate root modification for {0} (file exists, use --force to overwrite).\n" , crate_root_path . display () ,) ,) ; } ; } else { { :: std :: io :: _print (format_args ! ("  -> Adding \'pub mod prelude;\' to: {0}\n" , crate_root_path . display () ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("    -> Writing modified content to: {0}\n" , crate_root_path . display () ,) ,) ; } ; fs :: write (& crate_root_path , new_content) ? ; } } } Ok (()) } }