use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " Generates a test verification script and a Markdown report."] pub fn generate_test_verification_script_and_report (output_dir : & Path , test_infos : Vec < TestInfo > ,) -> Result < () > { fs :: create_dir_all (output_dir) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to create output directory {0}" , output_dir . display () ,) ,) })) ? ; let script_path = output_dir . join ("run_all_tests.sh") ; let report_path = output_dir . join ("Test_Verification_Report.md") ; let mut script_content = String :: new () ; script_content . push_str ("#!/bin/bash\n\n") ; script_content . push_str ("set -e\n\n") ; let mut unique_crate_paths = HashSet :: new () ; let repo_root = PathBuf :: from (".") ; for entry in WalkDir :: new (& repo_root) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file () && e . file_name () == "Cargo.toml") { let cargo_toml_path = entry . path () ; if let Some (parent) = cargo_toml_path . parent () { if ! parent . components () . any (| c | c . as_os_str () == "target") { unique_crate_paths . insert (parent . to_path_buf ()) ; } } } let mut sorted_crate_paths : Vec < & PathBuf > = unique_crate_paths . iter () . collect () ; sorted_crate_paths . sort_by (| a , b | a . cmp (b)) ; for crate_path in sorted_crate_paths { script_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("echo \"Running tests in {0}...\"\n" , crate_path . display () ,) ,) }) ,) ; script_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("pushd \"{0}\"\n" , crate_path . display ()) ,) }) ,) ; script_content . push_str ("cargo test\n") ; script_content . push_str ("popd\n\n") ; } fs :: write (& script_path , script_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write run_all_tests.sh to {0}" , script_path . display () ,) ,) })) ? ; let mut perms = fs :: metadata (& script_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& script_path , perms) ? ; { :: std :: io :: _print (format_args ! ("Test verification script generated at: {0}\n" , script_path . display () ,) ,) ; } ; let mut report_content = String :: new () ; report_content . push_str ("# Test Verification Report\n\n") ; report_content . push_str ("This report summarizes the tests found and provides a script to run them.\n\n" ,) ; report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Total unique test functions found: {0}\n\n" , test_infos . len () ,) ,) }) ,) ; report_content . push_str ("## How to Run Tests\n") ; report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("To run all tests, execute the generated script:\n\n```bash\n./{0}\n```\n\n" , script_path . file_name () . unwrap () . to_str () . unwrap () ,) ,) }) ,) ; report_content . push_str ("The script will navigate to each identified Rust crate and run `cargo test` within it.\n\n" ,) ; report_content . push_str ("## Tests by Crate\n") ; let mut tests_by_crate : HashMap < PathBuf , Vec < String > > = HashMap :: new () ; for info in test_infos { let mut current_path = info . file_path . as_path () ; while let Some (parent) = current_path . parent () { if parent . join ("Cargo.toml") . exists () { tests_by_crate . entry (parent . to_path_buf ()) . or_default () . push (info . name) ; break ; } current_path = parent ; } } let mut sorted_crates : Vec < & PathBuf > = tests_by_crate . keys () . collect () ; sorted_crates . sort_by (| a , b | a . cmp (b)) ; for crate_path in sorted_crates { report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("### Crate: {0}\n" , crate_path . display ()) ,) }) ,) ; let mut sorted_test_names = tests_by_crate . get (crate_path) . unwrap () . clone () ; sorted_test_names . sort () ; for test_name in sorted_test_names { report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("- {0}\n" , test_name)) }) ,) ; } report_content . push_str ("\n") ; } fs :: write (& report_path , report_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write Test_Verification_Report.md to {0}" , report_path . display () ,) ,) })) ? ; { :: std :: io :: _print (format_args ! ("Test verification report generated at: {0}\n" , report_path . display () ,) ,) ; } ; Ok (()) }