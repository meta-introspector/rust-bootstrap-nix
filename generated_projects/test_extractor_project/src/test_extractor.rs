use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod test_extractor { use anyhow :: { Context , Result } ; use std :: fs ; use std :: path :: { Path , PathBuf } ; use syn :: Item ; use walkdir :: WalkDir ; use std :: collections :: { HashSet , HashMap } ; use serde :: { Serialize , Deserialize } ; use std :: os :: unix :: fs :: PermissionsExt ; pub struct TestInfo { pub name : String , pub file_path : PathBuf , } # [automatically_derived] impl :: core :: fmt :: Debug for TestInfo { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "TestInfo" , "name" , & self . name , "file_path" , & & self . file_path ,) } } # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl _serde :: Serialize for TestInfo { fn serialize < __S > (& self , __serializer : __S ,) -> _serde :: __private228 :: Result < __S :: Ok , __S :: Error > where __S : _serde :: Serializer , { let mut __serde_state = _serde :: Serializer :: serialize_struct (__serializer , "TestInfo" , false as usize + 1 + 1 ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "name" , & self . name ,) ? ; _serde :: ser :: SerializeStruct :: serialize_field (& mut __serde_state , "file_path" , & self . file_path ,) ? ; _serde :: ser :: SerializeStruct :: end (__serde_state) } } } ; # [doc (hidden)] # [allow (non_upper_case_globals , unused_attributes , unused_qualifications , clippy :: absolute_paths ,)] const _ : () = { # [allow (unused_extern_crates , clippy :: useless_attribute)] extern crate serde as _serde ; # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for TestInfo { fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { # [allow (non_camel_case_types)] # [doc (hidden)] enum __Field { __field0 , __field1 , __ignore , } # [doc (hidden)] struct __FieldVisitor ; # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __FieldVisitor { type Value = __Field ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "field identifier" ,) } fn visit_u64 < __E > (self , __value : u64 ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { 0u64 => _serde :: __private228 :: Ok (__Field :: __field0) , 1u64 => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_str < __E > (self , __value : & str ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { "name" => _serde :: __private228 :: Ok (__Field :: __field0) , "file_path" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } fn visit_bytes < __E > (self , __value : & [u8] ,) -> _serde :: __private228 :: Result < Self :: Value , __E > where __E : _serde :: de :: Error , { match __value { b"name" => _serde :: __private228 :: Ok (__Field :: __field0) , b"file_path" => _serde :: __private228 :: Ok (__Field :: __field1) , _ => _serde :: __private228 :: Ok (__Field :: __ignore) , } } } # [automatically_derived] impl < 'de > _serde :: Deserialize < 'de > for __Field { # [inline] fn deserialize < __D > (__deserializer : __D ,) -> _serde :: __private228 :: Result < Self , __D :: Error > where __D : _serde :: Deserializer < 'de > , { _serde :: Deserializer :: deserialize_identifier (__deserializer , __FieldVisitor ,) } } # [doc (hidden)] struct __Visitor < 'de > { marker : _serde :: __private228 :: PhantomData < TestInfo > , lifetime : _serde :: __private228 :: PhantomData < & 'de () > , } # [automatically_derived] impl < 'de > _serde :: de :: Visitor < 'de > for __Visitor < 'de > { type Value = TestInfo ; fn expecting (& self , __formatter : & mut _serde :: __private228 :: Formatter ,) -> _serde :: __private228 :: fmt :: Result { _serde :: __private228 :: Formatter :: write_str (__formatter , "struct TestInfo" ,) } # [inline] fn visit_seq < __A > (self , mut __seq : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: SeqAccess < 'de > , { let __field0 = match _serde :: de :: SeqAccess :: next_element :: < String , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct TestInfo with 2 elements" ,) ,) ; } } ; let __field1 = match _serde :: de :: SeqAccess :: next_element :: < PathBuf , > (& mut __seq) ? { _serde :: __private228 :: Some (__value) => __value , _serde :: __private228 :: None => { return _serde :: __private228 :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct TestInfo with 2 elements" ,) ,) ; } } ; _serde :: __private228 :: Ok (TestInfo { name : __field0 , file_path : __field1 , }) } # [inline] fn visit_map < __A > (self , mut __map : __A ,) -> _serde :: __private228 :: Result < Self :: Value , __A :: Error > where __A : _serde :: de :: MapAccess < 'de > , { let mut __field0 : _serde :: __private228 :: Option < String > = _serde :: __private228 :: None ; let mut __field1 : _serde :: __private228 :: Option < PathBuf > = _serde :: __private228 :: None ; while let _serde :: __private228 :: Some (__key) = _serde :: de :: MapAccess :: next_key :: < __Field , > (& mut __map) ? { match __key { __Field :: __field0 => { if _serde :: __private228 :: Option :: is_some (& __field0) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name") ,) ; } __field0 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < String > (& mut __map) ? ,) ; } __Field :: __field1 => { if _serde :: __private228 :: Option :: is_some (& __field1) { return _serde :: __private228 :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("file_path" ,) ,) ; } __field1 = _serde :: __private228 :: Some (_serde :: de :: MapAccess :: next_value :: < PathBuf > (& mut __map) ? ,) ; } _ => { let _ = _serde :: de :: MapAccess :: next_value :: < _serde :: de :: IgnoredAny , > (& mut __map) ? ; } } } let __field0 = match __field0 { _serde :: __private228 :: Some (__field0) => __field0 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("name") ? } } ; let __field1 = match __field1 { _serde :: __private228 :: Some (__field1) => __field1 , _serde :: __private228 :: None => { _serde :: __private228 :: de :: missing_field ("file_path") ? } } ; _serde :: __private228 :: Ok (TestInfo { name : __field0 , file_path : __field1 , }) } } # [doc (hidden)] const FIELDS : & 'static [& 'static str] = & ["name" , "file_path"] ; _serde :: Deserializer :: deserialize_struct (__deserializer , "TestInfo" , FIELDS , __Visitor { marker : _serde :: __private228 :: PhantomData :: < TestInfo > , lifetime : _serde :: __private228 :: PhantomData , } ,) } } } ; # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for TestInfo { } # [automatically_derived] impl :: core :: cmp :: PartialEq for TestInfo { # [inline] fn eq (& self , other : & TestInfo) -> bool { self . name == other . name && self . file_path == other . file_path } } # [automatically_derived] impl :: core :: cmp :: Eq for TestInfo { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < String > ; let _ : :: core :: cmp :: AssertParamIsEq < PathBuf > ; } } # [automatically_derived] impl :: core :: hash :: Hash for TestInfo { # [inline] fn hash < __H : :: core :: hash :: Hasher > (& self , state : & mut __H) -> () { :: core :: hash :: Hash :: hash (& self . name , state) ; :: core :: hash :: Hash :: hash (& self . file_path , state) } } # [automatically_derived] impl :: core :: clone :: Clone for TestInfo { # [inline] fn clone (& self) -> TestInfo { TestInfo { name : :: core :: clone :: Clone :: clone (& self . name) , file_path : :: core :: clone :: Clone :: clone (& self . file_path) , } } } # [doc = " Recursively extracts test functions from a list of AST items."] fn extract_test_functions_from_items (items : Vec < Item > , file_path : & Path ,) -> Vec < TestInfo > { let mut test_functions = Vec :: new () ; for item in items { match item { Item :: Fn (func) => { if func . attrs . iter () . any (| attr | attr . path () . is_ident ("test")) { test_functions . push (TestInfo { name : func . sig . ident . to_string () , file_path : file_path . to_path_buf () , }) ; } } Item :: Mod (module) => { if let Some ((_ , module_items)) = module . content { test_functions . extend (extract_test_functions_from_items (module_items , file_path) ,) ; } } _ => { } } } test_functions } # [doc = " Extracts test functions from a single Rust file."] fn extract_test_cases_from_file (file_path : & Path) -> Result < Vec < TestInfo > > { let content = fs :: read_to_string (file_path) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to read file: {0}" , file_path . display ()) ,) })) ? ; let ast = syn :: parse_file (& content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to parse Rust file: {0}" , file_path . display ()) ,) })) ? ; Ok (extract_test_functions_from_items (ast . items , file_path)) } # [doc = " Collects all unique test functions from the repository."] pub fn collect_all_test_cases (repo_root : & Path) -> Result < Vec < TestInfo > > { let mut all_test_functions = Vec :: new () ; let mut seen_test_names = HashSet :: new () ; for entry in WalkDir :: new (repo_root) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | { e . file_type () . is_file () && e . path () . extension () . map_or (false , | ext | ext == "rs") }) { let file_path = entry . path () ; { :: std :: io :: _print (format_args ! ("  -> Processing file for tests: {0}\n" , file_path . display () ,) ,) ; } ; match extract_test_cases_from_file (file_path) { Ok (functions) => { for func_info in functions { if seen_test_names . insert (func_info . name . clone ()) { all_test_functions . push (func_info) ; } } } Err (e) => { { :: std :: io :: _eprint (format_args ! ("Warning: Could not extract tests from {0}: {1}\n" , file_path . display () , e ,) ,) ; } ; } } } Ok (all_test_functions) } # [doc = " Generates a JSON report of all collected test cases."] pub fn generate_test_report_json (output_path : & Path , test_functions : Vec < TestInfo > ,) -> Result < () > { let json_content = serde_json :: to_string_pretty (& test_functions) . context ("Failed to serialize test info to JSON") ? ; fs :: write (output_path , json_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write aggregated test report to {0}" , output_path . display () ,) ,) })) ? ; { :: std :: io :: _print (format_args ! ("Aggregated test report generated at: {0}\n" , output_path . display () ,) ,) ; } ; Ok (()) } # [doc = " Generates a test verification script and a Markdown report."] pub fn generate_test_verification_script_and_report (output_dir : & Path , test_infos : Vec < TestInfo > ,) -> Result < () > { fs :: create_dir_all (output_dir) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to create output directory {0}" , output_dir . display () ,) ,) })) ? ; let script_path = output_dir . join ("run_all_tests.sh") ; let report_path = output_dir . join ("Test_Verification_Report.md") ; let mut script_content = String :: new () ; script_content . push_str ("#!/bin/bash\n\n") ; script_content . push_str ("set -e\n\n") ; let mut unique_crate_paths = HashSet :: new () ; let repo_root = PathBuf :: from (".") ; for entry in WalkDir :: new (& repo_root) . into_iter () . filter_map (| e | e . ok ()) . filter (| e | e . file_type () . is_file () && e . file_name () == "Cargo.toml") { let cargo_toml_path = entry . path () ; if let Some (parent) = cargo_toml_path . parent () { if ! parent . components () . any (| c | c . as_os_str () == "target") { unique_crate_paths . insert (parent . to_path_buf ()) ; } } } let mut sorted_crate_paths : Vec < & PathBuf > = unique_crate_paths . iter () . collect () ; sorted_crate_paths . sort_by (| a , b | a . cmp (b)) ; for crate_path in sorted_crate_paths { script_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("echo \"Running tests in {0}...\"\n" , crate_path . display () ,) ,) }) ,) ; script_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("pushd \"{0}\"\n" , crate_path . display ()) ,) }) ,) ; script_content . push_str ("cargo test\n") ; script_content . push_str ("popd\n\n") ; } fs :: write (& script_path , script_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write run_all_tests.sh to {0}" , script_path . display () ,) ,) })) ? ; let mut perms = fs :: metadata (& script_path) ? . permissions () ; perms . set_mode (0o755) ; fs :: set_permissions (& script_path , perms) ? ; { :: std :: io :: _print (format_args ! ("Test verification script generated at: {0}\n" , script_path . display () ,) ,) ; } ; let mut report_content = String :: new () ; report_content . push_str ("# Test Verification Report\n\n") ; report_content . push_str ("This report summarizes the tests found and provides a script to run them.\n\n" ,) ; report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Total unique test functions found: {0}\n\n" , test_infos . len () ,) ,) }) ,) ; report_content . push_str ("## How to Run Tests\n") ; report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("To run all tests, execute the generated script:\n\n```bash\n./{0}\n```\n\n" , script_path . file_name () . unwrap () . to_str () . unwrap () ,) ,) }) ,) ; report_content . push_str ("The script will navigate to each identified Rust crate and run `cargo test` within it.\n\n" ,) ; report_content . push_str ("## Tests by Crate\n") ; let mut tests_by_crate : HashMap < PathBuf , Vec < String > > = HashMap :: new () ; for info in test_infos { let mut current_path = info . file_path . as_path () ; while let Some (parent) = current_path . parent () { if parent . join ("Cargo.toml") . exists () { tests_by_crate . entry (parent . to_path_buf ()) . or_default () . push (info . name) ; break ; } current_path = parent ; } } let mut sorted_crates : Vec < & PathBuf > = tests_by_crate . keys () . collect () ; sorted_crates . sort_by (| a , b | a . cmp (b)) ; for crate_path in sorted_crates { report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("### Crate: {0}\n" , crate_path . display ()) ,) }) ,) ; let mut sorted_test_names = tests_by_crate . get (crate_path) . unwrap () . clone () ; sorted_test_names . sort () ; for test_name in sorted_test_names { report_content . push_str (& :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("- {0}\n" , test_name)) }) ,) ; } report_content . push_str ("\n") ; } fs :: write (& report_path , report_content) . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to write Test_Verification_Report.md to {0}" , report_path . display () ,) ,) })) ? ; { :: std :: io :: _print (format_args ! ("Test verification report generated at: {0}\n" , report_path . display () ,) ,) ; } ; Ok (()) } }