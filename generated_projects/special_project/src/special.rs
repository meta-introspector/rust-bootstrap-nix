use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub (crate) mod special { use crate :: util :: primitives :: StateID ; # [doc = " A collection of sentinel state IDs for Aho-Corasick automata."] # [doc = ""] # [doc = " This specifically enables the technique by which we determine which states"] # [doc = " are dead, matches or start states. Namely, by arranging states in a"] # [doc = " particular order, we can determine the type of a state simply by looking at"] # [doc = " its ID."] pub (crate) struct Special { # [doc = " The maximum ID of all the \"special\" states. This corresponds either to"] # [doc = " start_anchored_id when a prefilter is active and max_match_id when a"] # [doc = " prefilter is not active. The idea here is that if there is no prefilter,"] # [doc = " then there is no point in treating start states as special."] pub (crate) max_special_id : StateID , # [doc = " The maximum ID of all the match states. Any state ID bigger than this"] # [doc = " is guaranteed to be a non-match ID."] # [doc = ""] # [doc = " It is possible and legal for max_match_id to be equal to"] # [doc = " start_anchored_id, which occurs precisely in the case where the empty"] # [doc = " string is a pattern that was added to the underlying automaton."] pub (crate) max_match_id : StateID , # [doc = " The state ID of the start state used for unanchored searches."] pub (crate) start_unanchored_id : StateID , # [doc = " The state ID of the start state used for anchored searches. This is"] # [doc = " always start_unanchored_id+1."] pub (crate) start_anchored_id : StateID , } # [automatically_derived] impl :: core :: clone :: Clone for Special { # [inline] fn clone (& self) -> Special { Special { max_special_id : :: core :: clone :: Clone :: clone (& self . max_special_id) , max_match_id : :: core :: clone :: Clone :: clone (& self . max_match_id) , start_unanchored_id : :: core :: clone :: Clone :: clone (& self . start_unanchored_id ,) , start_anchored_id : :: core :: clone :: Clone :: clone (& self . start_anchored_id ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Special { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field4_finish (f , "Special" , "max_special_id" , & self . max_special_id , "max_match_id" , & self . max_match_id , "start_unanchored_id" , & self . start_unanchored_id , "start_anchored_id" , & & self . start_anchored_id ,) } } impl Special { # [doc = " Create a new set of \"special\" state IDs with all IDs initialized to"] # [doc = " zero. The general idea here is that they will be updated and set to"] # [doc = " correct values later."] pub (crate) fn zero () -> Special { Special { max_special_id : StateID :: ZERO , max_match_id : StateID :: ZERO , start_unanchored_id : StateID :: ZERO , start_anchored_id : StateID :: ZERO , } } } }