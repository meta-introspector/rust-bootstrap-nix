use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod args { use clap :: Parser ; # [command (author , version , about , long_about = None)] pub struct Args { # [doc = " Name of the person to greet"] # [arg (short , long , default_value = "World")] pub name : String , } # [automatically_derived] # [allow (unused_qualifications , clippy :: redundant_locals)] impl clap :: Parser for Args { } # [allow (dead_code , unreachable_code , unused_variables , unused_braces , unused_qualifications ,)] # [allow (clippy :: style , clippy :: complexity , clippy :: pedantic , clippy :: restriction , clippy :: perf , clippy :: deprecated , clippy :: nursery , clippy :: cargo , clippy :: suspicious_else_formatting , clippy :: almost_swapped , clippy :: redundant_locals ,)] # [automatically_derived] impl clap :: CommandFactory for Args { fn command < 'b > () -> clap :: Command { let __clap_app = clap :: Command :: new ("rust-system-composer") ; < Self as clap :: Args > :: augment_args (__clap_app) } fn command_for_update < 'b > () -> clap :: Command { let __clap_app = clap :: Command :: new ("rust-system-composer") ; < Self as clap :: Args > :: augment_args_for_update (__clap_app) } } # [allow (dead_code , unreachable_code , unused_variables , unused_braces , unused_qualifications ,)] # [allow (clippy :: style , clippy :: complexity , clippy :: pedantic , clippy :: restriction , clippy :: perf , clippy :: deprecated , clippy :: nursery , clippy :: cargo , clippy :: suspicious_else_formatting , clippy :: almost_swapped , clippy :: redundant_locals ,)] # [automatically_derived] impl clap :: FromArgMatches for Args { fn from_arg_matches (__clap_arg_matches : & clap :: ArgMatches ,) -> :: std :: result :: Result < Self , clap :: Error > { Self :: from_arg_matches_mut (& mut __clap_arg_matches . clone ()) } fn from_arg_matches_mut (__clap_arg_matches : & mut clap :: ArgMatches ,) -> :: std :: result :: Result < Self , clap :: Error > { # ! [allow (deprecated)] let v = Args { name : __clap_arg_matches . remove_one :: < String > ("name") . ok_or_else (| | clap :: Error :: raw (clap :: error :: ErrorKind :: MissingRequiredArgument , "the following required argument was not provided: name" ,)) ? , } ; :: std :: result :: Result :: Ok (v) } fn update_from_arg_matches (& mut self , __clap_arg_matches : & clap :: ArgMatches ,) -> :: std :: result :: Result < () , clap :: Error > { self . update_from_arg_matches_mut (& mut __clap_arg_matches . clone ()) } fn update_from_arg_matches_mut (& mut self , __clap_arg_matches : & mut clap :: ArgMatches ,) -> :: std :: result :: Result < () , clap :: Error > { # ! [allow (deprecated)] if __clap_arg_matches . contains_id ("name") { # [allow (non_snake_case)] let name = & mut self . name ; * name = __clap_arg_matches . remove_one :: < String > ("name") . ok_or_else (| | clap :: Error :: raw (clap :: error :: ErrorKind :: MissingRequiredArgument , "the following required argument was not provided: name" ,)) ? ; } :: std :: result :: Result :: Ok (()) } } # [allow (dead_code , unreachable_code , unused_variables , unused_braces , unused_qualifications ,)] # [allow (clippy :: style , clippy :: complexity , clippy :: pedantic , clippy :: restriction , clippy :: perf , clippy :: deprecated , clippy :: nursery , clippy :: cargo , clippy :: suspicious_else_formatting , clippy :: almost_swapped , clippy :: redundant_locals ,)] # [automatically_derived] impl clap :: Args for Args { fn group_id () -> Option < clap :: Id > { Some (clap :: Id :: from ("Args")) } fn augment_args < 'b > (__clap_app : clap :: Command) -> clap :: Command { { let __clap_app = __clap_app . group (clap :: ArgGroup :: new ("Args") . multiple (true) . args ({ let members : [clap :: Id ; 1usize] = [clap :: Id :: from ("name")] ; members }) ,) ; let __clap_app = __clap_app . arg ({ # [allow (deprecated)] let arg = clap :: Arg :: new ("name") . value_name ("NAME") . required (false && clap :: ArgAction :: Set . takes_values ()) . value_parser ({ use :: clap_builder :: builder :: impl_prelude :: * ; let auto = :: clap_builder :: builder :: _infer_ValueParser_for :: < String , > :: new () ; (& & & & & & auto) . value_parser () }) . action (clap :: ArgAction :: Set) ; let arg = arg . help ("Name of the person to greet") . long_help (None) . short ('n') . long ("name") . default_value ("World") ; let arg = arg ; arg }) ; __clap_app . version ("0.1.0") . long_about (None) } } fn augment_args_for_update < 'b > (__clap_app : clap :: Command) -> clap :: Command { { let __clap_app = __clap_app . group (clap :: ArgGroup :: new ("Args") . multiple (true) . args ({ let members : [clap :: Id ; 1usize] = [clap :: Id :: from ("name")] ; members }) ,) ; let __clap_app = __clap_app . arg ({ # [allow (deprecated)] let arg = clap :: Arg :: new ("name") . value_name ("NAME") . required (false && clap :: ArgAction :: Set . takes_values ()) . value_parser ({ use :: clap_builder :: builder :: impl_prelude :: * ; let auto = :: clap_builder :: builder :: _infer_ValueParser_for :: < String , > :: new () ; (& & & & & & auto) . value_parser () }) . action (clap :: ArgAction :: Set) ; let arg = arg . help ("Name of the person to greet") . long_help (None) . short ('n') . long ("name") . default_value ("World") ; let arg = arg . required (false) ; arg }) ; __clap_app . version ("0.1.0") . long_about (None) } } } # [automatically_derived] impl :: core :: fmt :: Debug for Args { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "Args" , "name" , & & self . name ,) } } }