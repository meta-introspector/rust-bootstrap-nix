use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " Compare `n` bytes at the given pointers for equality."] # [doc = ""] # [doc = " This returns true if and only if `*x.add(i) == *y.add(i)` for all"] # [doc = " `0 <= i < n`."] # [doc = ""] # [doc = " # Inlining"] # [doc = ""] # [doc = " This routine is marked `inline(always)`. If you want to call this function"] # [doc = " in a way that is not always inlined, you'll need to wrap a call to it in"] # [doc = " another function that is marked as `inline(never)` or just `inline`."] # [doc = ""] # [doc = " # Motivation"] # [doc = ""] # [doc = " Why not use slice equality instead? Well, slice equality usually results in"] # [doc = " a call out to the current platform's `libc` which might not be inlineable"] # [doc = " or have other overhead. This routine isn't guaranteed to be a win, but it"] # [doc = " might be in some cases."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " * Both `x` and `y` must be valid for reads of up to `n` bytes."] # [doc = " * Both `x` and `y` must point to an initialized value."] # [doc = " * Both `x` and `y` must each point to an allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object. `x` and `y` do not need to point to the same allocated"] # [doc = " object, but they may."] # [doc = " * Both `x` and `y` must be _derived from_ a pointer to their respective"] # [doc = " allocated objects."] # [doc = " * The distance between `x` and `x+n` must not overflow `isize`. Similarly"] # [doc = " for `y` and `y+n`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [inline (always)] unsafe fn is_equal_raw (mut x : * const u8 , mut y : * const u8 , n : usize) -> bool { if n < 4 { return match n { 0 => true , 1 => x . read () == y . read () , 2 => { x . cast :: < u16 > () . read_unaligned () == y . cast :: < u16 > () . read_unaligned () } 3 => x . cast :: < [u8 ; 3] > () . read () == y . cast :: < [u8 ; 3] > () . read () , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ; } let xend = x . add (n . wrapping_sub (4)) ; let yend = y . add (n . wrapping_sub (4)) ; while x < xend { let vx = x . cast :: < u32 > () . read_unaligned () ; let vy = y . cast :: < u32 > () . read_unaligned () ; if vx != vy { return false ; } x = x . add (4) ; y = y . add (4) ; } let vx = xend . cast :: < u32 > () . read_unaligned () ; let vy = yend . cast :: < u32 > () . read_unaligned () ; vx == vy }