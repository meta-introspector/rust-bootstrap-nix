use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " An implementation of the Rabin-Karp algorithm. The main idea of this"] # [doc = " algorithm is to maintain a rolling hash as it moves through the input, and"] # [doc = " then check whether that hash corresponds to the same hash for any of the"] # [doc = " patterns we're looking for."] # [doc = ""] # [doc = " A draw back of naively scaling Rabin-Karp to multiple patterns is that"] # [doc = " it requires all of the patterns to be the same length, which in turn"] # [doc = " corresponds to the number of bytes to hash. We adapt this to work for"] # [doc = " multiple patterns of varying size by fixing the number of bytes to hash"] # [doc = " to be the length of the smallest pattern. We also split the patterns into"] # [doc = " several buckets to hopefully make the confirmation step faster."] # [doc = ""] # [doc = " Wikipedia has a decent explanation, if a bit heavy on the theory:"] # [doc = " https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm"] # [doc = ""] # [doc = " But ESMAJ provides something a bit more concrete:"] # [doc = " https://www-igm.univ-mlv.fr/~lecroq/string/node5.html"] pub (crate) struct RabinKarp { # [doc = " The patterns we're searching for."] patterns : Arc < Patterns > , # [doc = " The order of patterns in each bucket is significant. Namely, they are"] # [doc = " arranged such that the first one to match is the correct match. This"] # [doc = " may not necessarily correspond to the order provided by the caller."] # [doc = " For example, if leftmost-longest semantics are used, then the patterns"] # [doc = " are sorted by their length in descending order. If leftmost-first"] # [doc = " semantics are used, then the patterns are sorted by their pattern ID"] # [doc = " in ascending order (which corresponds to the caller's order)."] buckets : Vec < Vec < (Hash , PatternID) > > , # [doc = " The length of the hashing window. Generally, this corresponds to the"] # [doc = " length of the smallest pattern."] hash_len : usize , # [doc = " The factor to subtract out of a hash before updating it with a new"] # [doc = " byte."] hash_2pow : usize , }