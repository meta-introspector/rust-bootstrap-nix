use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub (crate) mod buffer { use alloc :: { vec , vec :: Vec } ; # [doc = " The default buffer capacity that we use for the stream buffer."] const DEFAULT_BUFFER_CAPACITY : usize = 64 * (1 << 10) ; # [doc = " A fairly simple roll buffer for supporting stream searches."] # [doc = ""] # [doc = " This buffer acts as a temporary place to store a fixed amount of data when"] # [doc = " reading from a stream. Its central purpose is to allow \"rolling\" some"] # [doc = " suffix of the data to the beginning of the buffer before refilling it with"] # [doc = " more data from the stream. For example, let's say we are trying to match"] # [doc = " \"foobar\" on a stream. When we report the match, we'd like to not only"] # [doc = " report the correct offsets at which the match occurs, but also the matching"] # [doc = " bytes themselves. So let's say our stream is a file with the following"] # [doc = " contents: `test test foobar test test`. Now assume that we happen to read"] # [doc = " the aforementioned file in two chunks: `test test foo` and `bar test test`."] # [doc = " Naively, it would not be possible to report a single contiguous `foobar`"] # [doc = " match, but this roll buffer allows us to do that. Namely, after the second"] # [doc = " read, the contents of the buffer should be `st foobar test test`, where the"] # [doc = " search should ultimately resume immediately after `foo`. (The prefix `st `"] # [doc = " is included because the roll buffer saves N bytes at the end of the buffer,"] # [doc = " where N is the maximum possible length of a match.)"] # [doc = ""] # [doc = " A lot of the logic for dealing with this is unfortunately split out between"] # [doc = " this roll buffer and the `StreamChunkIter`."] # [doc = ""] # [doc = " Note also that this buffer is not actually required to just report matches."] # [doc = " Because a `Match` is just some offsets. But it *is* required for supporting"] # [doc = " things like `try_stream_replace_all` because that needs some mechanism for"] # [doc = " knowing which bytes in the stream correspond to a match and which don't. So"] # [doc = " when a match occurs across two `read` calls, *something* needs to retain"] # [doc = " the bytes from the previous `read` call because you don't know before the"] # [doc = " second read call whether a match exists or not."] pub (crate) struct Buffer { # [doc = " The raw buffer contents. This has a fixed size and never increases."] buf : Vec < u8 > , # [doc = " The minimum size of the buffer, which is equivalent to the maximum"] # [doc = " possible length of a match. This corresponds to the amount that we"] # [doc = " roll"] min : usize , # [doc = " The end of the contents of this buffer."] end : usize , } # [automatically_derived] impl :: core :: fmt :: Debug for Buffer { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "Buffer" , "buf" , & self . buf , "min" , & self . min , "end" , & & self . end ,) } } impl Buffer { # [doc = " Create a new buffer for stream searching. The minimum buffer length"] # [doc = " given should be the size of the maximum possible match length."] pub (crate) fn new (min_buffer_len : usize) -> Buffer { let min = core :: cmp :: max (1 , min_buffer_len) ; let capacity = core :: cmp :: max (min * 8 , DEFAULT_BUFFER_CAPACITY) ; Buffer { buf : :: alloc :: vec :: from_elem (0 , capacity) , min , end : 0 , } } # [doc = " Return the contents of this buffer."] # [inline] pub (crate) fn buffer (& self) -> & [u8] { & self . buf [.. self . end] } # [doc = " Return the minimum size of the buffer. The only way a buffer may be"] # [doc = " smaller than this is if the stream itself contains less than the"] # [doc = " minimum buffer amount."] # [inline] pub (crate) fn min_buffer_len (& self) -> usize { self . min } # [doc = " Return all free capacity in this buffer."] fn free_buffer (& mut self) -> & mut [u8] { & mut self . buf [self . end ..] } # [doc = " Refill the contents of this buffer by reading as much as possible into"] # [doc = " this buffer's free capacity. If no more bytes could be read, then this"] # [doc = " returns false. Otherwise, this reads until it has filled the buffer"] # [doc = " past the minimum amount."] pub (crate) fn fill < R : std :: io :: Read > (& mut self , mut rdr : R ,) -> std :: io :: Result < bool > { let mut readany = false ; loop { let readlen = rdr . read (self . free_buffer ()) ? ; if readlen == 0 { return Ok (readany) ; } readany = true ; self . end += readlen ; if self . buffer () . len () >= self . min { return Ok (true) ; } } } # [doc = " Roll the contents of the buffer so that the suffix of this buffer is"] # [doc = " moved to the front and all other contents are dropped. The size of the"] # [doc = " suffix corresponds precisely to the minimum buffer length."] # [doc = ""] # [doc = " This should only be called when the entire contents of this buffer have"] # [doc = " been searched."] pub (crate) fn roll (& mut self) { let roll_start = self . end . checked_sub (self . min) . expect ("buffer capacity should be bigger than minimum amount") ; let roll_end = roll_start + self . min ; if ! (roll_end <= self . end) { :: core :: panicking :: panic ("assertion failed: roll_end <= self.end") } self . buf . copy_within (roll_start .. roll_end , 0) ; self . end = self . min ; } } }