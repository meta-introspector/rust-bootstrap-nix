use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod pattern { use core :: { cmp , fmt , mem , u16 , usize } ; use alloc :: { boxed :: Box , string :: String , vec , vec :: Vec } ; use crate :: { packed :: { api :: MatchKind , ext :: Pointer } , PatternID , } ; # [doc = " A non-empty collection of non-empty patterns to search for."] # [doc = ""] # [doc = " This collection of patterns is what is passed around to both execute"] # [doc = " searches and to construct the searchers themselves. Namely, this permits"] # [doc = " searches to avoid copying all of the patterns, and allows us to keep only"] # [doc = " one copy throughout all packed searchers."] # [doc = ""] # [doc = " Note that this collection is not a set. The same pattern can appear more"] # [doc = " than once."] pub (crate) struct Patterns { # [doc = " The match semantics supported by this collection of patterns."] # [doc = ""] # [doc = " The match semantics determines the order of the iterator over patterns."] # [doc = " For leftmost-first, patterns are provided in the same order as were"] # [doc = " provided by the caller. For leftmost-longest, patterns are provided in"] # [doc = " descending order of length, with ties broken by the order in which they"] # [doc = " were provided by the caller."] kind : MatchKind , # [doc = " The collection of patterns, indexed by their identifier."] by_id : Vec < Vec < u8 > > , # [doc = " The order of patterns defined for iteration, given by pattern"] # [doc = " identifiers. The order of `by_id` and `order` is always the same for"] # [doc = " leftmost-first semantics, but may be different for leftmost-longest"] # [doc = " semantics."] order : Vec < PatternID > , # [doc = " The length of the smallest pattern, in bytes."] minimum_len : usize , # [doc = " The total number of pattern bytes across the entire collection. This"] # [doc = " is used for reporting total heap usage in constant time."] total_pattern_bytes : usize , } # [automatically_derived] impl :: core :: clone :: Clone for Patterns { # [inline] fn clone (& self) -> Patterns { Patterns { kind : :: core :: clone :: Clone :: clone (& self . kind) , by_id : :: core :: clone :: Clone :: clone (& self . by_id) , order : :: core :: clone :: Clone :: clone (& self . order) , minimum_len : :: core :: clone :: Clone :: clone (& self . minimum_len) , total_pattern_bytes : :: core :: clone :: Clone :: clone (& self . total_pattern_bytes ,) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for Patterns { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field5_finish (f , "Patterns" , "kind" , & self . kind , "by_id" , & self . by_id , "order" , & self . order , "minimum_len" , & self . minimum_len , "total_pattern_bytes" , & & self . total_pattern_bytes ,) } } impl Patterns { # [doc = " Create a new collection of patterns for the given match semantics. The"] # [doc = " ID of each pattern is the index of the pattern at which it occurs in"] # [doc = " the `by_id` slice."] # [doc = ""] # [doc = " If any of the patterns in the slice given are empty, then this panics."] # [doc = " Similarly, if the number of patterns given is zero, then this also"] # [doc = " panics."] pub (crate) fn new () -> Patterns { Patterns { kind : MatchKind :: default () , by_id : :: alloc :: vec :: Vec :: new () , order : :: alloc :: vec :: Vec :: new () , minimum_len : usize :: MAX , total_pattern_bytes : 0 , } } # [doc = " Add a pattern to this collection."] # [doc = ""] # [doc = " This panics if the pattern given is empty."] pub (crate) fn add (& mut self , bytes : & [u8]) { if ! ! bytes . is_empty () { :: core :: panicking :: panic ("assertion failed: !bytes.is_empty()") } if ! (self . by_id . len () <= u16 :: MAX as usize) { :: core :: panicking :: panic ("assertion failed: self.by_id.len() <= u16::MAX as usize" ,) } let id = PatternID :: new (self . by_id . len ()) . unwrap () ; self . order . push (id) ; self . by_id . push (bytes . to_vec ()) ; self . minimum_len = cmp :: min (self . minimum_len , bytes . len ()) ; self . total_pattern_bytes += bytes . len () ; } # [doc = " Set the match kind semantics for this collection of patterns."] # [doc = ""] # [doc = " If the kind is not set, then the default is leftmost-first."] pub (crate) fn set_match_kind (& mut self , kind : MatchKind) { self . kind = kind ; match self . kind { MatchKind :: LeftmostFirst => { self . order . sort () ; } MatchKind :: LeftmostLongest => { let (order , by_id) = (& mut self . order , & mut self . by_id) ; order . sort_by (| & id1 , & id2 | { by_id [id1] . len () . cmp (& by_id [id2] . len ()) . reverse () }) ; } } } # [doc = " Return the number of patterns in this collection."] # [doc = ""] # [doc = " This is guaranteed to be greater than zero."] pub (crate) fn len (& self) -> usize { self . by_id . len () } # [doc = " Returns true if and only if this collection of patterns is empty."] pub (crate) fn is_empty (& self) -> bool { self . len () == 0 } # [doc = " Returns the approximate total amount of heap used by these patterns, in"] # [doc = " units of bytes."] pub (crate) fn memory_usage (& self) -> usize { self . order . len () * mem :: size_of :: < PatternID > () + self . by_id . len () * mem :: size_of :: < Vec < u8 > > () + self . total_pattern_bytes } # [doc = " Clears all heap memory associated with this collection of patterns and"] # [doc = " resets all state such that it is a valid empty collection."] pub (crate) fn reset (& mut self) { self . kind = MatchKind :: default () ; self . by_id . clear () ; self . order . clear () ; self . minimum_len = usize :: MAX ; } # [doc = " Returns the length, in bytes, of the smallest pattern."] # [doc = ""] # [doc = " This is guaranteed to be at least one."] pub (crate) fn minimum_len (& self) -> usize { self . minimum_len } # [doc = " Returns the match semantics used by these patterns."] pub (crate) fn match_kind (& self) -> & MatchKind { & self . kind } # [doc = " Return the pattern with the given identifier. If such a pattern does"] # [doc = " not exist, then this panics."] pub (crate) fn get (& self , id : PatternID) -> Pattern < '_ > { Pattern (& self . by_id [id]) } # [doc = " Return the pattern with the given identifier without performing bounds"] # [doc = " checks."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that a pattern with the given identifier exists"] # [doc = " before using this method."] pub (crate) unsafe fn get_unchecked (& self , id : PatternID) -> Pattern < '_ > { Pattern (self . by_id . get_unchecked (id . as_usize ())) } # [doc = " Return an iterator over all the patterns in this collection, in the"] # [doc = " order in which they should be matched."] # [doc = ""] # [doc = " Specifically, in a naive multi-pattern matcher, the following is"] # [doc = " guaranteed to satisfy the match semantics of this collection of"] # [doc = " patterns:"] # [doc = ""] # [doc = " ```ignore"] # [doc = " for i in 0..haystack.len():"] # [doc = "   for p in patterns.iter():"] # [doc = "     if haystack[i..].starts_with(p.bytes()):"] # [doc = "       return Match(p.id(), i, i + p.bytes().len())"] # [doc = " ```"] # [doc = ""] # [doc = " Namely, among the patterns in a collection, if they are matched in"] # [doc = " the order provided by this iterator, then the result is guaranteed"] # [doc = " to satisfy the correct match semantics. (Either leftmost-first or"] # [doc = " leftmost-longest.)"] pub (crate) fn iter (& self) -> PatternIter < '_ > { PatternIter { patterns : self , i : 0 , } } } # [doc = " An iterator over the patterns in the `Patterns` collection."] # [doc = ""] # [doc = " The order of the patterns provided by this iterator is consistent with the"] # [doc = " match semantics of the originating collection of patterns."] # [doc = ""] # [doc = " The lifetime `'p` corresponds to the lifetime of the collection of patterns"] # [doc = " this is iterating over."] pub (crate) struct PatternIter < 'p > { patterns : & 'p Patterns , i : usize , } # [automatically_derived] impl < 'p > :: core :: fmt :: Debug for PatternIter < 'p > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "PatternIter" , "patterns" , & self . patterns , "i" , & & self . i ,) } } impl < 'p > Iterator for PatternIter < 'p > { type Item = (PatternID , Pattern < 'p >) ; fn next (& mut self) -> Option < (PatternID , Pattern < 'p >) > { if self . i >= self . patterns . len () { return None ; } let id = self . patterns . order [self . i] ; let p = self . patterns . get (id) ; self . i += 1 ; Some ((id , p)) } } # [doc = " A pattern that is used in packed searching."] pub (crate) struct Pattern < 'a > (& 'a [u8]) ; # [automatically_derived] impl < 'a > :: core :: clone :: Clone for Pattern < 'a > { # [inline] fn clone (& self) -> Pattern < 'a > { Pattern (:: core :: clone :: Clone :: clone (& self . 0)) } } impl < 'a > fmt :: Debug for Pattern < 'a > { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { f . debug_struct ("Pattern") . field ("lit" , & String :: from_utf8_lossy (self . 0)) . finish () } } impl < 'p > Pattern < 'p > { # [doc = " Returns the length of this pattern, in bytes."] pub (crate) fn len (& self) -> usize { self . 0 . len () } # [doc = " Returns the bytes of this pattern."] pub (crate) fn bytes (& self) -> & [u8] { self . 0 } # [doc = " Returns the first `len` low nybbles from this pattern. If this pattern"] # [doc = " is shorter than `len`, then this panics."] pub (crate) fn low_nybbles (& self , len : usize) -> Box < [u8] > { let mut nybs = :: alloc :: vec :: from_elem (0 , len) . into_boxed_slice () ; for (i , byte) in self . bytes () . iter () . take (len) . enumerate () { nybs [i] = byte & 0xF ; } nybs } # [doc = " Returns true if this pattern is a prefix of the given bytes."] # [inline (always)] pub (crate) fn is_prefix (& self , bytes : & [u8]) -> bool { is_prefix (bytes , self . bytes ()) } # [doc = " Returns true if this pattern is a prefix of the haystack given by the"] # [doc = " raw `start` and `end` pointers."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " * It must be the case that `start < end` and that the distance between"] # [doc = " them is at least equal to `V::BYTES`. That is, it must always be valid"] # [doc = " to do at least an unaligned load of `V` at `start`."] # [doc = " * Both `start` and `end` must be valid for reads."] # [doc = " * Both `start` and `end` must point to an initialized value."] # [doc = " * Both `start` and `end` must point to the same allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object."] # [doc = " * Both `start` and `end` must be _derived from_ a pointer to the same"] # [doc = " object."] # [doc = " * The distance between `start` and `end` must not overflow `isize`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [inline (always)] pub (crate) unsafe fn is_prefix_raw (& self , start : * const u8 , end : * const u8 ,) -> bool { let patlen = self . bytes () . len () ; let haylen = end . distance (start) ; if patlen > haylen { return false ; } is_equal_raw (start , self . bytes () . as_ptr () , patlen) } } # [doc = " Returns true if and only if `needle` is a prefix of `haystack`."] # [doc = ""] # [doc = " This uses a latency optimized variant of `memcmp` internally which *might*"] # [doc = " make this faster for very short strings."] # [doc = ""] # [doc = " # Inlining"] # [doc = ""] # [doc = " This routine is marked `inline(always)`. If you want to call this function"] # [doc = " in a way that is not always inlined, you'll need to wrap a call to it in"] # [doc = " another function that is marked as `inline(never)` or just `inline`."] # [inline (always)] fn is_prefix (haystack : & [u8] , needle : & [u8]) -> bool { if needle . len () > haystack . len () { return false ; } unsafe { is_equal_raw (haystack . as_ptr () , needle . as_ptr () , needle . len ()) } } # [doc = " Compare `n` bytes at the given pointers for equality."] # [doc = ""] # [doc = " This returns true if and only if `*x.add(i) == *y.add(i)` for all"] # [doc = " `0 <= i < n`."] # [doc = ""] # [doc = " # Inlining"] # [doc = ""] # [doc = " This routine is marked `inline(always)`. If you want to call this function"] # [doc = " in a way that is not always inlined, you'll need to wrap a call to it in"] # [doc = " another function that is marked as `inline(never)` or just `inline`."] # [doc = ""] # [doc = " # Motivation"] # [doc = ""] # [doc = " Why not use slice equality instead? Well, slice equality usually results in"] # [doc = " a call out to the current platform's `libc` which might not be inlineable"] # [doc = " or have other overhead. This routine isn't guaranteed to be a win, but it"] # [doc = " might be in some cases."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " * Both `x` and `y` must be valid for reads of up to `n` bytes."] # [doc = " * Both `x` and `y` must point to an initialized value."] # [doc = " * Both `x` and `y` must each point to an allocated object and"] # [doc = " must either be in bounds or at most one byte past the end of the"] # [doc = " allocated object. `x` and `y` do not need to point to the same allocated"] # [doc = " object, but they may."] # [doc = " * Both `x` and `y` must be _derived from_ a pointer to their respective"] # [doc = " allocated objects."] # [doc = " * The distance between `x` and `x+n` must not overflow `isize`. Similarly"] # [doc = " for `y` and `y+n`."] # [doc = " * The distance being in bounds must not rely on \"wrapping around\" the"] # [doc = " address space."] # [inline (always)] unsafe fn is_equal_raw (mut x : * const u8 , mut y : * const u8 , n : usize) -> bool { if n < 4 { return match n { 0 => true , 1 => x . read () == y . read () , 2 => { x . cast :: < u16 > () . read_unaligned () == y . cast :: < u16 > () . read_unaligned () } 3 => x . cast :: < [u8 ; 3] > () . read () == y . cast :: < [u8 ; 3] > () . read () , _ => { :: core :: panicking :: panic ("internal error: entered unreachable code" ,) } } ; } let xend = x . add (n . wrapping_sub (4)) ; let yend = y . add (n . wrapping_sub (4)) ; while x < xend { let vx = x . cast :: < u32 > () . read_unaligned () ; let vy = y . cast :: < u32 > () . read_unaligned () ; if vx != vy { return false ; } x = x . add (4) ; y = y . add (4) ; } let vx = xend . cast :: < u32 > () . read_unaligned () ; let vy = yend . cast :: < u32 > () . read_unaligned () ; vx == vy } }