use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [inline (always)] fn try_find_overlapping_fwd_imp < A : Automaton + ? Sized > (aut : & A , input : & Input < '_ > , pre : Option < & Prefilter > , state : & mut OverlappingState ,) -> Result < () , MatchError > { let mut sid = match state . id { None => { let sid = aut . start_state (input . get_anchored ()) ? ; if aut . is_match (sid) { let i = state . next_match_index . unwrap_or (0) ; let len = aut . match_len (sid) ; if i < len { state . next_match_index = Some (i + 1) ; state . mat = Some (get_match (aut , sid , i , input . start ())) ; return Ok (()) ; } } state . at = input . start () ; state . id = Some (sid) ; state . next_match_index = None ; state . mat = None ; sid } Some (sid) => { if let Some (i) = state . next_match_index { let len = aut . match_len (sid) ; if i < len { state . next_match_index = Some (i + 1) ; state . mat = Some (get_match (aut , sid , i , state . at + 1)) ; return Ok (()) ; } state . at += 1 ; state . next_match_index = None ; state . mat = None ; } sid } } ; while state . at < input . end () { sid = aut . next_state (input . get_anchored () , sid , input . haystack () [state . at]) ; if aut . is_special (sid) { state . id = Some (sid) ; if aut . is_dead (sid) { return Ok (()) ; } else if aut . is_match (sid) { state . next_match_index = Some (1) ; state . mat = Some (get_match (aut , sid , 0 , state . at + 1)) ; return Ok (()) ; } else if let Some (pre) = pre { if true { if ! aut . is_start (sid) { :: core :: panicking :: panic ("assertion failed: aut.is_start(sid)" ,) } } let span = Span :: from (state . at .. input . end ()) ; match pre . find_in (input . haystack () , span) . into_option () { None => return Ok (()) , Some (i) => { if i > state . at { state . at = i ; continue ; } } } } else { } } state . at += 1 ; } state . id = Some (sid) ; Ok (()) }