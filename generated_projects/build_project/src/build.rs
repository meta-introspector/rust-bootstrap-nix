use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod build { use std :: collections :: * ; use build_helper :: prelude :: * ; use config_macros :: define_config ; # [doc = " TOML representation of various global build decisions."] pub struct BuildConfig { pub build : Option < String > , pub src : Option < PathBuf > , pub host : Option < Vec < String > > , pub target : Option < Vec < String > > , pub build_dir : Option < String > , pub cargo : Option < PathBuf > , pub rustc : Option < PathBuf > , pub rustfmt : Option < PathBuf > , pub cargo_clippy : Option < PathBuf > , pub docs : Option < bool > , pub compiler_docs : Option < bool > , pub library_docs_private_items : Option < bool > , pub docs_minification : Option < bool > , pub submodules : Option < bool > , pub gdb : Option < String > , pub lldb : Option < String > , pub nodejs : Option < String > , pub npm : Option < String > , pub python : Option < String > , pub reuse : Option < String > , pub locked_deps : Option < bool > , pub vendor : Option < bool > , pub full_bootstrap : Option < bool > , pub bootstrap_cache_path : Option < PathBuf > , pub extended : Option < bool > , pub tools : Option < HashSet < String > > , pub verbose : Option < usize > , pub sanitizers : Option < bool > , pub profiler : Option < bool > , pub cargo_native_static : Option < bool > , pub low_priority : Option < bool > , pub configure_args : Option < Vec < String > > , pub local_rebuild : Option < bool > , pub print_step_timings : Option < bool > , pub print_step_rusage : Option < bool > , pub check_stage : Option < u32 > , pub doc_stage : Option < u32 > , pub build_stage : Option < u32 > , pub test_stage : Option < u32 > , pub install_stage : Option < u32 > , pub dist_stage : Option < u32 > , pub bench_stage : Option < u32 > , pub patch_binaries_for_nix : Option < bool > , pub metrics : Option < bool > , pub android_ndk : Option < PathBuf > , pub optimized_compiler_builtins : Option < bool > , pub jobs : Option < u32 > , pub compiletest_diff_tool : Option < String > , } # [automatically_derived] impl :: core :: default :: Default for BuildConfig { # [inline] fn default () -> BuildConfig { BuildConfig { build : :: core :: default :: Default :: default () , src : :: core :: default :: Default :: default () , host : :: core :: default :: Default :: default () , target : :: core :: default :: Default :: default () , build_dir : :: core :: default :: Default :: default () , cargo : :: core :: default :: Default :: default () , rustc : :: core :: default :: Default :: default () , rustfmt : :: core :: default :: Default :: default () , cargo_clippy : :: core :: default :: Default :: default () , docs : :: core :: default :: Default :: default () , compiler_docs : :: core :: default :: Default :: default () , library_docs_private_items : :: core :: default :: Default :: default () , docs_minification : :: core :: default :: Default :: default () , submodules : :: core :: default :: Default :: default () , gdb : :: core :: default :: Default :: default () , lldb : :: core :: default :: Default :: default () , nodejs : :: core :: default :: Default :: default () , npm : :: core :: default :: Default :: default () , python : :: core :: default :: Default :: default () , reuse : :: core :: default :: Default :: default () , locked_deps : :: core :: default :: Default :: default () , vendor : :: core :: default :: Default :: default () , full_bootstrap : :: core :: default :: Default :: default () , bootstrap_cache_path : :: core :: default :: Default :: default () , extended : :: core :: default :: Default :: default () , tools : :: core :: default :: Default :: default () , verbose : :: core :: default :: Default :: default () , sanitizers : :: core :: default :: Default :: default () , profiler : :: core :: default :: Default :: default () , cargo_native_static : :: core :: default :: Default :: default () , low_priority : :: core :: default :: Default :: default () , configure_args : :: core :: default :: Default :: default () , local_rebuild : :: core :: default :: Default :: default () , print_step_timings : :: core :: default :: Default :: default () , print_step_rusage : :: core :: default :: Default :: default () , check_stage : :: core :: default :: Default :: default () , doc_stage : :: core :: default :: Default :: default () , build_stage : :: core :: default :: Default :: default () , test_stage : :: core :: default :: Default :: default () , install_stage : :: core :: default :: Default :: default () , dist_stage : :: core :: default :: Default :: default () , bench_stage : :: core :: default :: Default :: default () , patch_binaries_for_nix : :: core :: default :: Default :: default () , metrics : :: core :: default :: Default :: default () , android_ndk : :: core :: default :: Default :: default () , optimized_compiler_builtins : :: core :: default :: Default :: default () , jobs : :: core :: default :: Default :: default () , compiletest_diff_tool : :: core :: default :: Default :: default () , } } } impl config_core :: Merge for BuildConfig { fn merge (& mut self , other : Self , replace : config_core :: ReplaceOpt) { match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . build . is_none () { self . build = other . build ; } } config_core :: ReplaceOpt :: Override => { if other . build . is_some () { self . build = other . build ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . build . is_some () { if self . build . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "build") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . build = other . build ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . src . is_none () { self . src = other . src ; } } config_core :: ReplaceOpt :: Override => { if other . src . is_some () { self . src = other . src ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . src . is_some () { if self . src . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "src") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . src = other . src ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . host . is_none () { self . host = other . host ; } } config_core :: ReplaceOpt :: Override => { if other . host . is_some () { self . host = other . host ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . host . is_some () { if self . host . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "host") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . host = other . host ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . target . is_none () { self . target = other . target ; } } config_core :: ReplaceOpt :: Override => { if other . target . is_some () { self . target = other . target ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . target . is_some () { if self . target . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "target" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . target = other . target ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . build_dir . is_none () { self . build_dir = other . build_dir ; } } config_core :: ReplaceOpt :: Override => { if other . build_dir . is_some () { self . build_dir = other . build_dir ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . build_dir . is_some () { if self . build_dir . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "build-dir" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . build_dir = other . build_dir ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . cargo . is_none () { self . cargo = other . cargo ; } } config_core :: ReplaceOpt :: Override => { if other . cargo . is_some () { self . cargo = other . cargo ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . cargo . is_some () { if self . cargo . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "cargo") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . cargo = other . cargo ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . rustc . is_none () { self . rustc = other . rustc ; } } config_core :: ReplaceOpt :: Override => { if other . rustc . is_some () { self . rustc = other . rustc ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . rustc . is_some () { if self . rustc . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "rustc") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . rustc = other . rustc ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . rustfmt . is_none () { self . rustfmt = other . rustfmt ; } } config_core :: ReplaceOpt :: Override => { if other . rustfmt . is_some () { self . rustfmt = other . rustfmt ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . rustfmt . is_some () { if self . rustfmt . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "rustfmt" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . rustfmt = other . rustfmt ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . cargo_clippy . is_none () { self . cargo_clippy = other . cargo_clippy ; } } config_core :: ReplaceOpt :: Override => { if other . cargo_clippy . is_some () { self . cargo_clippy = other . cargo_clippy ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . cargo_clippy . is_some () { if self . cargo_clippy . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "cargo-clippy" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . cargo_clippy = other . cargo_clippy ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . docs . is_none () { self . docs = other . docs ; } } config_core :: ReplaceOpt :: Override => { if other . docs . is_some () { self . docs = other . docs ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . docs . is_some () { if self . docs . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "docs") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . docs = other . docs ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . compiler_docs . is_none () { self . compiler_docs = other . compiler_docs ; } } config_core :: ReplaceOpt :: Override => { if other . compiler_docs . is_some () { self . compiler_docs = other . compiler_docs ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . compiler_docs . is_some () { if self . compiler_docs . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "compiler-docs" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . compiler_docs = other . compiler_docs ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . library_docs_private_items . is_none () { self . library_docs_private_items = other . library_docs_private_items ; } } config_core :: ReplaceOpt :: Override => { if other . library_docs_private_items . is_some () { self . library_docs_private_items = other . library_docs_private_items ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . library_docs_private_items . is_some () { if self . library_docs_private_items . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "library-docs-private-items" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . library_docs_private_items = other . library_docs_private_items ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . docs_minification . is_none () { self . docs_minification = other . docs_minification ; } } config_core :: ReplaceOpt :: Override => { if other . docs_minification . is_some () { self . docs_minification = other . docs_minification ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . docs_minification . is_some () { if self . docs_minification . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "docs-minification" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . docs_minification = other . docs_minification ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . submodules . is_none () { self . submodules = other . submodules ; } } config_core :: ReplaceOpt :: Override => { if other . submodules . is_some () { self . submodules = other . submodules ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . submodules . is_some () { if self . submodules . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "submodules" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . submodules = other . submodules ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . gdb . is_none () { self . gdb = other . gdb ; } } config_core :: ReplaceOpt :: Override => { if other . gdb . is_some () { self . gdb = other . gdb ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . gdb . is_some () { if self . gdb . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "gdb") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . gdb = other . gdb ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . lldb . is_none () { self . lldb = other . lldb ; } } config_core :: ReplaceOpt :: Override => { if other . lldb . is_some () { self . lldb = other . lldb ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . lldb . is_some () { if self . lldb . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "lldb") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . lldb = other . lldb ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . nodejs . is_none () { self . nodejs = other . nodejs ; } } config_core :: ReplaceOpt :: Override => { if other . nodejs . is_some () { self . nodejs = other . nodejs ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . nodejs . is_some () { if self . nodejs . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "nodejs" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . nodejs = other . nodejs ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . npm . is_none () { self . npm = other . npm ; } } config_core :: ReplaceOpt :: Override => { if other . npm . is_some () { self . npm = other . npm ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . npm . is_some () { if self . npm . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "npm") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . npm = other . npm ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . python . is_none () { self . python = other . python ; } } config_core :: ReplaceOpt :: Override => { if other . python . is_some () { self . python = other . python ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . python . is_some () { if self . python . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "python" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . python = other . python ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . reuse . is_none () { self . reuse = other . reuse ; } } config_core :: ReplaceOpt :: Override => { if other . reuse . is_some () { self . reuse = other . reuse ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . reuse . is_some () { if self . reuse . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "reuse") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . reuse = other . reuse ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . locked_deps . is_none () { self . locked_deps = other . locked_deps ; } } config_core :: ReplaceOpt :: Override => { if other . locked_deps . is_some () { self . locked_deps = other . locked_deps ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . locked_deps . is_some () { if self . locked_deps . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "locked-deps" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . locked_deps = other . locked_deps ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . vendor . is_none () { self . vendor = other . vendor ; } } config_core :: ReplaceOpt :: Override => { if other . vendor . is_some () { self . vendor = other . vendor ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . vendor . is_some () { if self . vendor . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "vendor" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . vendor = other . vendor ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . full_bootstrap . is_none () { self . full_bootstrap = other . full_bootstrap ; } } config_core :: ReplaceOpt :: Override => { if other . full_bootstrap . is_some () { self . full_bootstrap = other . full_bootstrap ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . full_bootstrap . is_some () { if self . full_bootstrap . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "full-bootstrap" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . full_bootstrap = other . full_bootstrap ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . bootstrap_cache_path . is_none () { self . bootstrap_cache_path = other . bootstrap_cache_path ; } } config_core :: ReplaceOpt :: Override => { if other . bootstrap_cache_path . is_some () { self . bootstrap_cache_path = other . bootstrap_cache_path ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . bootstrap_cache_path . is_some () { if self . bootstrap_cache_path . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "bootstrap-cache-path" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . bootstrap_cache_path = other . bootstrap_cache_path ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . extended . is_none () { self . extended = other . extended ; } } config_core :: ReplaceOpt :: Override => { if other . extended . is_some () { self . extended = other . extended ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . extended . is_some () { if self . extended . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "extended" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . extended = other . extended ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . tools . is_none () { self . tools = other . tools ; } } config_core :: ReplaceOpt :: Override => { if other . tools . is_some () { self . tools = other . tools ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . tools . is_some () { if self . tools . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "tools") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . tools = other . tools ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . verbose . is_none () { self . verbose = other . verbose ; } } config_core :: ReplaceOpt :: Override => { if other . verbose . is_some () { self . verbose = other . verbose ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . verbose . is_some () { if self . verbose . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "verbose" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . verbose = other . verbose ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . sanitizers . is_none () { self . sanitizers = other . sanitizers ; } } config_core :: ReplaceOpt :: Override => { if other . sanitizers . is_some () { self . sanitizers = other . sanitizers ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . sanitizers . is_some () { if self . sanitizers . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "sanitizers" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . sanitizers = other . sanitizers ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . profiler . is_none () { self . profiler = other . profiler ; } } config_core :: ReplaceOpt :: Override => { if other . profiler . is_some () { self . profiler = other . profiler ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . profiler . is_some () { if self . profiler . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "profiler" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . profiler = other . profiler ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . cargo_native_static . is_none () { self . cargo_native_static = other . cargo_native_static ; } } config_core :: ReplaceOpt :: Override => { if other . cargo_native_static . is_some () { self . cargo_native_static = other . cargo_native_static ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . cargo_native_static . is_some () { if self . cargo_native_static . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "cargo-native-static" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . cargo_native_static = other . cargo_native_static ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . low_priority . is_none () { self . low_priority = other . low_priority ; } } config_core :: ReplaceOpt :: Override => { if other . low_priority . is_some () { self . low_priority = other . low_priority ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . low_priority . is_some () { if self . low_priority . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "low-priority" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . low_priority = other . low_priority ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . configure_args . is_none () { self . configure_args = other . configure_args ; } } config_core :: ReplaceOpt :: Override => { if other . configure_args . is_some () { self . configure_args = other . configure_args ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . configure_args . is_some () { if self . configure_args . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "configure-args" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . configure_args = other . configure_args ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . local_rebuild . is_none () { self . local_rebuild = other . local_rebuild ; } } config_core :: ReplaceOpt :: Override => { if other . local_rebuild . is_some () { self . local_rebuild = other . local_rebuild ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . local_rebuild . is_some () { if self . local_rebuild . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "local-rebuild" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . local_rebuild = other . local_rebuild ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . print_step_timings . is_none () { self . print_step_timings = other . print_step_timings ; } } config_core :: ReplaceOpt :: Override => { if other . print_step_timings . is_some () { self . print_step_timings = other . print_step_timings ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . print_step_timings . is_some () { if self . print_step_timings . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "print-step-timings" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . print_step_timings = other . print_step_timings ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . print_step_rusage . is_none () { self . print_step_rusage = other . print_step_rusage ; } } config_core :: ReplaceOpt :: Override => { if other . print_step_rusage . is_some () { self . print_step_rusage = other . print_step_rusage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . print_step_rusage . is_some () { if self . print_step_rusage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "print-step-rusage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . print_step_rusage = other . print_step_rusage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . check_stage . is_none () { self . check_stage = other . check_stage ; } } config_core :: ReplaceOpt :: Override => { if other . check_stage . is_some () { self . check_stage = other . check_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . check_stage . is_some () { if self . check_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "check-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . check_stage = other . check_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . doc_stage . is_none () { self . doc_stage = other . doc_stage ; } } config_core :: ReplaceOpt :: Override => { if other . doc_stage . is_some () { self . doc_stage = other . doc_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . doc_stage . is_some () { if self . doc_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "doc-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . doc_stage = other . doc_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . build_stage . is_none () { self . build_stage = other . build_stage ; } } config_core :: ReplaceOpt :: Override => { if other . build_stage . is_some () { self . build_stage = other . build_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . build_stage . is_some () { if self . build_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "build-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . build_stage = other . build_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . test_stage . is_none () { self . test_stage = other . test_stage ; } } config_core :: ReplaceOpt :: Override => { if other . test_stage . is_some () { self . test_stage = other . test_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . test_stage . is_some () { if self . test_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "test-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . test_stage = other . test_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . install_stage . is_none () { self . install_stage = other . install_stage ; } } config_core :: ReplaceOpt :: Override => { if other . install_stage . is_some () { self . install_stage = other . install_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . install_stage . is_some () { if self . install_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "install-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . install_stage = other . install_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . dist_stage . is_none () { self . dist_stage = other . dist_stage ; } } config_core :: ReplaceOpt :: Override => { if other . dist_stage . is_some () { self . dist_stage = other . dist_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . dist_stage . is_some () { if self . dist_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "dist-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . dist_stage = other . dist_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . bench_stage . is_none () { self . bench_stage = other . bench_stage ; } } config_core :: ReplaceOpt :: Override => { if other . bench_stage . is_some () { self . bench_stage = other . bench_stage ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . bench_stage . is_some () { if self . bench_stage . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "bench-stage" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . bench_stage = other . bench_stage ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . patch_binaries_for_nix . is_none () { self . patch_binaries_for_nix = other . patch_binaries_for_nix ; } } config_core :: ReplaceOpt :: Override => { if other . patch_binaries_for_nix . is_some () { self . patch_binaries_for_nix = other . patch_binaries_for_nix ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . patch_binaries_for_nix . is_some () { if self . patch_binaries_for_nix . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "patch-binaries-for-nix" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . patch_binaries_for_nix = other . patch_binaries_for_nix ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . metrics . is_none () { self . metrics = other . metrics ; } } config_core :: ReplaceOpt :: Override => { if other . metrics . is_some () { self . metrics = other . metrics ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . metrics . is_some () { if self . metrics . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "metrics" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . metrics = other . metrics ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . android_ndk . is_none () { self . android_ndk = other . android_ndk ; } } config_core :: ReplaceOpt :: Override => { if other . android_ndk . is_some () { self . android_ndk = other . android_ndk ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . android_ndk . is_some () { if self . android_ndk . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "android-ndk" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . android_ndk = other . android_ndk ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . optimized_compiler_builtins . is_none () { self . optimized_compiler_builtins = other . optimized_compiler_builtins ; } } config_core :: ReplaceOpt :: Override => { if other . optimized_compiler_builtins . is_some () { self . optimized_compiler_builtins = other . optimized_compiler_builtins ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . optimized_compiler_builtins . is_some () { if self . optimized_compiler_builtins . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "optimized-compiler-builtins" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . optimized_compiler_builtins = other . optimized_compiler_builtins ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . jobs . is_none () { self . jobs = other . jobs ; } } config_core :: ReplaceOpt :: Override => { if other . jobs . is_some () { self . jobs = other . jobs ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . jobs . is_some () { if self . jobs . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "jobs") ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . jobs = other . jobs ; } } } match replace { config_core :: ReplaceOpt :: IgnoreDuplicate => { if self . compiletest_diff_tool . is_none () { self . compiletest_diff_tool = other . compiletest_diff_tool ; } } config_core :: ReplaceOpt :: Override => { if other . compiletest_diff_tool . is_some () { self . compiletest_diff_tool = other . compiletest_diff_tool ; } } config_core :: ReplaceOpt :: ErrorOnDuplicate => { if other . compiletest_diff_tool . is_some () { if self . compiletest_diff_tool . is_some () { if false { { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } } else { { :: std :: io :: _eprint (format_args ! ("overriding existing option: `{0}`\n" , "compiletest-diff-tool" ,) ,) ; } ; { :: core :: panicking :: panic_fmt (format_args ! ("overriding existing option") ,) ; } ; } } } else { self . compiletest_diff_tool = other . compiletest_diff_tool ; } } } } } }