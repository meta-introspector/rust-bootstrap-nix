use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod rustclto { # [doc = " LTO mode used for compiling rustc itself."] pub enum RustcLto { Off , # [default] ThinLocal , Thin , Fat , } # [automatically_derived] impl :: core :: default :: Default for RustcLto { # [inline] fn default () -> RustcLto { Self :: ThinLocal } } # [automatically_derived] impl :: core :: clone :: Clone for RustcLto { # [inline] fn clone (& self) -> RustcLto { match self { RustcLto :: Off => RustcLto :: Off , RustcLto :: ThinLocal => RustcLto :: ThinLocal , RustcLto :: Thin => RustcLto :: Thin , RustcLto :: Fat => RustcLto :: Fat , } } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for RustcLto { } # [automatically_derived] impl :: core :: cmp :: PartialEq for RustcLto { # [inline] fn eq (& self , other : & RustcLto) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } # [automatically_derived] impl :: core :: fmt :: Debug for RustcLto { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { RustcLto :: Off => "Off" , RustcLto :: ThinLocal => "ThinLocal" , RustcLto :: Thin => "Thin" , RustcLto :: Fat => "Fat" , } ,) } } impl std :: str :: FromStr for RustcLto { type Err = String ; fn from_str (s : & str) -> Result < Self , Self :: Err > { match s { "thin-local" => Ok (RustcLto :: ThinLocal) , "thin" => Ok (RustcLto :: Thin) , "fat" => Ok (RustcLto :: Fat) , "off" => Ok (RustcLto :: Off) , _ => { Err (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Invalid value for rustc LTO: {0}" , s) ,) }) ,) } } } } }