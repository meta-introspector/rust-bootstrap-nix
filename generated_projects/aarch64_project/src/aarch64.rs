use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod aarch64 { use core :: arch :: aarch64 :: uint8x16_t ; use alloc :: sync :: Arc ; use crate :: packed :: { pattern :: Patterns , teddy :: generic :: { self , Match } } ; use super :: { Searcher , SearcherT } ; pub (super) struct SlimNeon < const BYTES : usize > { slim128 : generic :: Slim < uint8x16_t , BYTES > , } # [automatically_derived] impl < const BYTES : usize > :: core :: clone :: Clone for SlimNeon < BYTES > { # [inline] fn clone (& self) -> SlimNeon < BYTES > { SlimNeon { slim128 : :: core :: clone :: Clone :: clone (& self . slim128) , } } } # [automatically_derived] impl < const BYTES : usize > :: core :: fmt :: Debug for SlimNeon < BYTES > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter ,) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "SlimNeon" , "slim128" , & & self . slim128 ,) } } impl SlimNeon < 1 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 1 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 1 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 1 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 2 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 2 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 2 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 2 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 3 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 3 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 3 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 3 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } impl SlimNeon < 4 > { # [doc = " Creates a new searcher using \"slim\" Teddy with 128-bit"] # [doc = " vectors. If SSSE3 is not available in the current"] # [doc = " environment, then this returns `None`."] pub (super) fn new (patterns : & Arc < Patterns >) -> Option < Searcher > { Some (unsafe { SlimNeon :: < 4 > :: new_unchecked (patterns) }) } # [doc = " Creates a new searcher using \"slim\" Teddy with 256-bit"] # [doc = " vectors without checking whether SSSE3 is available or not."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that SSSE3 is available in the current"] # [doc = " environment."] # [target_feature (enable = "neon")] unsafe fn new_unchecked (patterns : & Arc < Patterns >) -> Searcher { let slim128 = generic :: Slim :: < uint8x16_t , 4 , > :: new (Arc :: clone (patterns)) ; let memory_usage = slim128 . memory_usage () ; let minimum_len = slim128 . minimum_len () ; let imp = Arc :: new (SlimNeon { slim128 }) ; Searcher { imp , memory_usage , minimum_len , } } } impl SearcherT for SlimNeon < 4 > { # [target_feature (enable = "neon")] # [inline] unsafe fn find (& self , start : * const u8 , end : * const u8 ,) -> Option < Match > { self . slim128 . find (start , end) } } }