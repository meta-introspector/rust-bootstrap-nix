use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod rust_optimize { use serde :: { Deserialize , Deserializer } ; use crate :: config_part6 :: OptimizeVisitor ; pub enum RustOptimize { String (String) , Int (u8) , Bool (bool) , } # [automatically_derived] impl :: core :: clone :: Clone for RustOptimize { # [inline] fn clone (& self) -> RustOptimize { match self { RustOptimize :: String (__self_0) => { RustOptimize :: String (:: core :: clone :: Clone :: clone (__self_0)) } RustOptimize :: Int (__self_0) => { RustOptimize :: Int (:: core :: clone :: Clone :: clone (__self_0)) } RustOptimize :: Bool (__self_0) => { RustOptimize :: Bool (:: core :: clone :: Clone :: clone (__self_0)) } } } } # [automatically_derived] impl :: core :: fmt :: Debug for RustOptimize { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { match self { RustOptimize :: String (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "String" , & __self_0 ,) } RustOptimize :: Int (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Int" , & __self_0 ,) } RustOptimize :: Bool (__self_0) => { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "Bool" , & __self_0 ,) } } } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for RustOptimize { } # [automatically_derived] impl :: core :: cmp :: PartialEq for RustOptimize { # [inline] fn eq (& self , other : & RustOptimize) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr && match (self , other) { (RustOptimize :: String (__self_0) , RustOptimize :: String (__arg1_0)) => { __self_0 == __arg1_0 } (RustOptimize :: Int (__self_0) , RustOptimize :: Int (__arg1_0)) => { __self_0 == __arg1_0 } (RustOptimize :: Bool (__self_0) , RustOptimize :: Bool (__arg1_0)) => { __self_0 == __arg1_0 } _ => unsafe { :: core :: intrinsics :: unreachable () } } } } # [automatically_derived] impl :: core :: cmp :: Eq for RustOptimize { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < String > ; let _ : :: core :: cmp :: AssertParamIsEq < u8 > ; let _ : :: core :: cmp :: AssertParamIsEq < bool > ; } } impl Default for RustOptimize { fn default () -> RustOptimize { RustOptimize :: Bool (false) } } impl < 'de > Deserialize < 'de > for RustOptimize { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : Deserializer < 'de > , { deserializer . deserialize_any (OptimizeVisitor) } } }