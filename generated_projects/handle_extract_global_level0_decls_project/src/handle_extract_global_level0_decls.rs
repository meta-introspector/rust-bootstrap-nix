use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub async fn handle_extract_global_level0_decls (project_root : & PathBuf , args : & crate :: Args , all_numerical_constants : & mut Vec < syn :: ItemConst > , all_string_constants : & mut Vec < syn :: ItemConst > , rustc_info : & crate :: use_extractor :: rustc_info :: RustcInfo , cache_dir : & std :: path :: Path ,) -> anyhow :: Result < () > { { :: std :: io :: _print (format_args ! ("Extracting global Level 0 declarations...\n") ,) ; } ; { :: std :: io :: _print (format_args ! ("Project root: {0}\n" , project_root . display ()) ,) ; } ; let generated_decls_output_dir = args . generated_decls_output_dir . clone () . unwrap_or_else (| | { project_root . join ("generated/level0_decls") }) ; { :: std :: io :: _print (format_args ! ("Generated decls output dir: {0}\n" , generated_decls_output_dir . display () ,) ,) ; } ; let gem_config_path = project_root . join ("gems.toml") ; let gem_config = GemConfig :: load_from_file (& gem_config_path) . context (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to load gem config from {0}" , gem_config_path . display () ,) ,) }) ,) ? ; let type_map = type_extractor :: extract_bag_of_types (project_root , & args . filter_names ,) . await ? ; let metadata = MetadataCommand :: new () . manifest_path (project_root . join ("Cargo.toml")) . exec () . context ("Failed to execute cargo metadata") ? ; let mut all_declarations : Vec < crate :: declaration :: Declaration > = Vec :: new () ; let mut total_files_processed = 0 ; let mut collected_errors = Vec :: new () ; let mut total_fns = 0 ; let mut total_structs = 0 ; let mut total_enums = 0 ; let mut total_statics = 0 ; let mut total_other_items = 0 ; let total_structs_per_layer : HashMap < usize , usize > = HashMap :: new () ; let mut packages_to_process : Vec < & Package > = Vec :: new () ; for member_id in & metadata . workspace_members { if let Some (pkg) = metadata . packages . iter () . find (| p | & p . id == member_id) { packages_to_process . push (pkg) ; } } for pkg in & metadata . packages { if pkg . manifest_path . starts_with (project_root) && ! metadata . workspace_members . contains (& pkg . id) { packages_to_process . push (pkg) ; } } for pkg in packages_to_process { let manifest_path = pkg . manifest_path . to_path_buf () ; { :: std :: io :: _print (format_args ! ("Processing crate: {0} at {1}\n" , pkg . name , manifest_path ,) ,) ; } ; let (decls , files_processed , fns , structs , enums , statics , other_items , _structs_per_layer , errors ,) = declaration_processing :: extract_all_declarations_from_crate (manifest_path . as_ref () , & args , & type_map , & args . filter_names , rustc_info , cache_dir , & gem_config ,) . await ? ; all_declarations . extend (decls) ; collected_errors . extend (errors) ; total_files_processed += files_processed ; total_fns += fns ; total_structs += structs ; total_enums += enums ; total_statics += statics ; total_other_items += other_items ; } let mut error_collection = ErrorCollection :: default () ; for err_sample in collected_errors { error_collection . add_error (err_sample) ; } let layered_declarations = declaration_processing :: layer_declarations (all_declarations ,) ; { :: std :: io :: _print (format_args ! ("\n--- Layered Declaration Analysis ---\n")) ; } ; for layer_num in 0 ..= 8 { if let Some (decls_in_layer) = layered_declarations . get (& layer_num) { { :: std :: io :: _print (format_args ! ("Layer {0}: {1} declarations\n" , layer_num , decls_in_layer . len () ,) ,) ; } ; } else if layer_num == 0 && layered_declarations . get (& 0) . is_none () { { :: std :: io :: _print (format_args ! ("Layer 0: No declarations found.\n")) ; } ; } else if layered_declarations . get (& layer_num) . is_none () && layer_num > 0 { { :: std :: io :: _print (format_args ! ("Layer {0}: No declarations found.\n" , layer_num) ,) ; } ; if layered_declarations . keys () . all (| & k | k < layer_num) { break ; } } } { :: std :: io :: _print (format_args ! ("-------------------------------------\n")) ; } ; let mut constants : Vec < syn :: ItemConst > = Vec :: new () ; let mut structs : HashMap < usize , Vec < syn :: ItemStruct > > = HashMap :: new () ; for (_layer_num , decls_in_layer) in layered_declarations . iter () { for decl in decls_in_layer { match & decl . item { crate :: declaration :: DeclarationItem :: Const (c) => { constants . push (c . clone ()) } crate :: declaration :: DeclarationItem :: Struct (s) => { let struct_name = s . ident . to_string () ; let layer = type_map . get (& struct_name) . and_then (| info | info . layer) . unwrap_or (0) ; structs . entry (layer) . or_insert_with (Vec :: new) . push (s . clone ()) ; } _ => { } } } } if let Err (e) = declaration_processing :: process_constants (constants . clone () , & args , & project_root , all_numerical_constants , all_string_constants , & type_map ,) . await { { :: std :: io :: _eprint (format_args ! ("Error processing constants: {0:?}\n" , e) ,) ; } ; } { :: std :: io :: _print (format_args ! ("Total files processed: {0}\n" , total_files_processed) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total constants extracted: {0}\n" , constants . len ()) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total functions found: {0}\n" , total_fns)) ; } ; { :: std :: io :: _print (format_args ! ("Total structs found: {0}\n" , total_structs)) ; } ; { :: std :: io :: _print (format_args ! ("Total structs extracted per layer: {0:?}\n" , total_structs_per_layer ,) ,) ; } ; { :: std :: io :: _print (format_args ! ("Total enums found: {0}\n" , total_enums)) ; } ; { :: std :: io :: _print (format_args ! ("Total statics found: {0}\n" , total_statics)) ; } ; { :: std :: io :: _print (format_args ! ("Total other items found: {0}\n" , total_other_items) ,) ; } ; { :: std :: io :: _print (format_args ! ("---------------------------------------------\n") ,) ; } ; if ! error_collection . errors . is_empty () { { :: std :: io :: _eprint (format_args ! ("\\n--- Summary of Errors Encountered During Macro Expansion/Parsing ---\n" ,) ,) ; } ; for error in & error_collection . errors { { :: std :: io :: _eprint (format_args ! ("File: {0}, Type: {1}, Message: {2}\n" , error . file_path . display () , error . error_type , error . error_message ,) ,) ; } ; } { :: std :: io :: _eprint (format_args ! ("---------------------------------------------------------------------\n" ,) ,) ; } ; let error_output_path = project_root . join ("collected_errors.json") ; error_collection . write_to_file (& error_output_path) . await ? ; { :: std :: io :: _eprint (format_args ! ("Collected errors written to: {0}\n" , error_output_path . display () ,) ,) ; } ; } Ok (()) }