use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod debug_info_level { use std :: fmt ; use serde :: { Deserialize , Deserializer , de :: Error } ; use crate :: StringOrInt ; use std :: fmt :: Display ; pub enum DebuginfoLevel { # [default] None , LineDirectivesOnly , LineTablesOnly , Limited , Full , } # [automatically_derived] impl :: core :: marker :: Copy for DebuginfoLevel { } # [automatically_derived] impl :: core :: clone :: Clone for DebuginfoLevel { # [inline] fn clone (& self) -> DebuginfoLevel { * self } } # [automatically_derived] impl :: core :: default :: Default for DebuginfoLevel { # [inline] fn default () -> DebuginfoLevel { Self :: None } } # [automatically_derived] impl :: core :: fmt :: Debug for DebuginfoLevel { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { DebuginfoLevel :: None => "None" , DebuginfoLevel :: LineDirectivesOnly => "LineDirectivesOnly" , DebuginfoLevel :: LineTablesOnly => "LineTablesOnly" , DebuginfoLevel :: Limited => "Limited" , DebuginfoLevel :: Full => "Full" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for DebuginfoLevel { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for DebuginfoLevel { } # [automatically_derived] impl :: core :: cmp :: PartialEq for DebuginfoLevel { # [inline] fn eq (& self , other : & DebuginfoLevel) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } impl < 'de > Deserialize < 'de > for DebuginfoLevel { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : Deserializer < 'de > , { Ok (match Deserialize :: deserialize (deserializer) ? { StringOrInt :: String (s) if s == "none" => DebuginfoLevel :: None , StringOrInt :: Int (0) => DebuginfoLevel :: None , StringOrInt :: String (s) if s == "line-directives-only" => { DebuginfoLevel :: LineDirectivesOnly } StringOrInt :: String (s) if s == "line-tables-only" => { DebuginfoLevel :: LineTablesOnly } StringOrInt :: String (s) if s == "limited" => DebuginfoLevel :: Limited , StringOrInt :: Int (1) => DebuginfoLevel :: Limited , StringOrInt :: String (s) if s == "full" => DebuginfoLevel :: Full , StringOrInt :: Int (2) => DebuginfoLevel :: Full , StringOrInt :: Int (n) => { let other = serde :: de :: Unexpected :: Signed (n) ; return Err (D :: Error :: invalid_value (other , & "expected 0, 1, or 2") ,) ; } StringOrInt :: String (s) => { let other = serde :: de :: Unexpected :: Str (& s) ; return Err (D :: Error :: invalid_value (other , & "expected none, line-tables-only, limited, or full" ,) ,) ; } } ,) } } # [doc = " Suitable for passing to `-C debuginfo`"] impl Display for DebuginfoLevel { fn fmt (& self , f : & mut fmt :: Formatter < '_ >) -> fmt :: Result { use DebuginfoLevel :: * ; f . write_str (match self { None => "0" , LineDirectivesOnly => "line-directives-only" , LineTablesOnly => "line-tables-only" , Limited => "1" , Full => "2" , } ,) } } }