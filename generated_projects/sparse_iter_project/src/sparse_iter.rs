use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " Iterate over all possible equivalence class transitions in this state."] # [doc = " The closure is called for all transitions with a distinct equivalence"] # [doc = " class, even those not explicitly represented in this sparse state. For"] # [doc = " any implicitly defined transitions, the given closure is called with"] # [doc = " the fail state ID."] # [doc = ""] # [doc = " The closure is guaranteed to be called precisely"] # [doc = " `byte_classes.alphabet_len()` times, once for every possible class in"] # [doc = " ascending order."] fn sparse_iter < F : FnMut (u8 , u8 , StateID) > (nnfa : & noncontiguous :: NFA , oldsid : StateID , classes : & ByteClasses , mut f : F ,) { let mut prev_class = None ; let mut byte = 0usize ; for t in nnfa . iter_trans (oldsid) { while byte < usize :: from (t . byte ()) { let rep = byte . as_u8 () ; let class = classes . get (rep) ; byte += 1 ; if prev_class != Some (class) { f (rep , class , noncontiguous :: NFA :: FAIL) ; prev_class = Some (class) ; } } let rep = t . byte () ; let class = classes . get (rep) ; byte += 1 ; if prev_class != Some (class) { f (rep , class , t . next ()) ; prev_class = Some (class) ; } } for b in byte ..= 255 { let rep = b . as_u8 () ; let class = classes . get (rep) ; if prev_class != Some (class) { f (rep , class , noncontiguous :: NFA :: FAIL) ; prev_class = Some (class) ; } } }