use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " A trait for describing vector operations used by vectorized searchers."] # [doc = ""] # [doc = " The trait is highly constrained to low level vector operations needed for"] # [doc = " the specific algorithms used in this crate. In general, it was invented"] # [doc = " mostly to be generic over x86's __m128i and __m256i types. At time of"] # [doc = " writing, it also supports wasm and aarch64 128-bit vector types as well."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " All methods are not safe since they are intended to be implemented using"] # [doc = " vendor intrinsics, which are also not safe. Callers must ensure that"] # [doc = " the appropriate target features are enabled in the calling function,"] # [doc = " and that the current CPU supports them. All implementations should"] # [doc = " avoid marking the routines with `#[target_feature]` and instead mark"] # [doc = " them as `#[inline(always)]` to ensure they get appropriately inlined."] # [doc = " (`inline(always)` cannot be used with target_feature.)"] pub (crate) trait Vector : Copy + Debug + Send + Sync + UnwindSafe + RefUnwindSafe { # [doc = " The number of bits in the vector."] const BITS : usize ; # [doc = " The number of bytes in the vector. That is, this is the size of the"] # [doc = " vector in memory."] const BYTES : usize ; # [doc = " Create a vector with 8-bit lanes with the given byte repeated into each"] # [doc = " lane."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn splat (byte : u8) -> Self ; # [doc = " Read a vector-size number of bytes from the given pointer. The pointer"] # [doc = " does not need to be aligned."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [doc = ""] # [doc = " Callers must guarantee that at least `BYTES` bytes are readable from"] # [doc = " `data`."] unsafe fn load_unaligned (data : * const u8) -> Self ; # [doc = " Returns true if and only if this vector has zero in all of its lanes."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn is_zero (self) -> bool ; # [doc = " Do an 8-bit pairwise equality check. If lane `i` is equal in this"] # [doc = " vector and the one given, then lane `i` in the resulting vector is set"] # [doc = " to `0xFF`. Otherwise, it is set to `0x00`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn cmpeq (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'and' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn and (self , vector2 : Self) -> Self ; # [doc = " Perform a bitwise 'or' of this vector and the one given and return"] # [doc = " the result."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] # [allow (dead_code)] unsafe fn or (self , vector2 : Self) -> Self ; # [doc = " Shift each 8-bit lane in this vector to the right by the number of"] # [doc = " bits indictated by the `BITS` type parameter."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_8bit_lane_right < const BITS : i32 > (self) -> Self ; # [doc = " Shift this vector to the left by one byte and shift the most"] # [doc = " significant byte of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 1` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 1`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_one_byte (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by two bytes and shift the two most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 2` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last two bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 2`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_two_bytes (self , vector2 : Self) -> Self ; # [doc = " Shift this vector to the left by three bytes and shift the three most"] # [doc = " significant bytes of `vector2` into the least significant position of"] # [doc = " this vector."] # [doc = ""] # [doc = " Stated differently, this behaves as if `self` and `vector2` were"] # [doc = " concatenated into a `2 * Self::BITS` temporary buffer and then shifted"] # [doc = " right by `Self::BYTES - 3` bytes."] # [doc = ""] # [doc = " With respect to the Teddy algorithm, `vector2` is usually a previous"] # [doc = " `Self::BYTES` chunk from the haystack and `self` is the chunk"] # [doc = " immediately following it. This permits combining the last three bytes"] # [doc = " from the previous chunk (`vector2`) with the first `Self::BYTES - 3`"] # [doc = " bytes from the current chunk. This permits aligning the result of"] # [doc = " various shuffles so that they can be and-ed together and a possible"] # [doc = " candidate discovered."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shift_in_three_bytes (self , vector2 : Self) -> Self ; # [doc = " Shuffles the bytes in this vector according to the indices in each of"] # [doc = " the corresponding lanes in `indices`."] # [doc = ""] # [doc = " If `i` is the index of corresponding lanes, `A` is this vector, `B` is"] # [doc = " indices and `C` is the resulting vector, then `C = A[B[i]]`."] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn shuffle_bytes (self , indices : Self) -> Self ; # [doc = " Call the provided function for each 64-bit lane in this vector. The"] # [doc = " given function is provided the lane index and lane value as a `u64`."] # [doc = ""] # [doc = " If `f` returns `Some`, then iteration over the lanes is stopped and the"] # [doc = " value is returned. Otherwise, this returns `None`."] # [doc = ""] # [doc = " # Notes"] # [doc = ""] # [doc = " Conceptually it would be nice if we could have a"] # [doc = " `unpack64(self) -> [u64; BITS / 64]` method, but defining that is"] # [doc = " tricky given Rust's [current support for const generics][support]."] # [doc = " And even if we could, it would be tricky to write generic code over"] # [doc = " it. (Not impossible. We could introduce another layer that requires"] # [doc = " `AsRef<[u64]>` or something.)"] # [doc = ""] # [doc = " [support]: https://github.com/rust-lang/rust/issues/60551"] # [doc = ""] # [doc = " # Safety"] # [doc = ""] # [doc = " Callers must ensure that this is okay to call in the current target for"] # [doc = " the current CPU."] unsafe fn for_each_64bit_lane < T > (self , f : impl FnMut (usize , u64) -> Option < T > ,) -> Option < T > ; }