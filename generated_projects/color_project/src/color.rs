use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod color { use clap :: * ; pub enum Color { Always , Never , # [default] Auto , } # [automatically_derived] impl :: core :: marker :: Copy for Color { } # [automatically_derived] impl :: core :: clone :: Clone for Color { # [inline] fn clone (& self) -> Color { * self } } # [automatically_derived] impl :: core :: default :: Default for Color { # [inline] fn default () -> Color { Self :: Auto } } # [automatically_derived] impl :: core :: fmt :: Debug for Color { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { Color :: Always => "Always" , Color :: Never => "Never" , Color :: Auto => "Auto" , } ,) } } # [allow (dead_code , unreachable_code , unused_variables , unused_braces , unused_qualifications ,)] # [allow (clippy :: style , clippy :: complexity , clippy :: pedantic , clippy :: restriction , clippy :: perf , clippy :: deprecated , clippy :: nursery , clippy :: cargo , clippy :: suspicious_else_formatting , clippy :: almost_swapped , clippy :: redundant_locals ,)] # [automatically_derived] impl clap :: ValueEnum for Color { fn value_variants < 'a > () -> & 'a [Self] { & [Self :: Always , Self :: Never , Self :: Auto] } fn to_possible_value < 'a > (& self ,) -> :: std :: option :: Option < clap :: builder :: PossibleValue > { match self { Self :: Always => Some ({ clap :: builder :: PossibleValue :: new ("always") }) , Self :: Never => Some ({ clap :: builder :: PossibleValue :: new ("never") }) , Self :: Auto => Some ({ clap :: builder :: PossibleValue :: new ("auto") }) , _ => None , } } } }