use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub (crate) mod int { # ! [doc = "\nThis module provides several integer oriented traits for converting between\nboth fixed size integers and integers whose size varies based on the target\n(like `usize`).\n\nThe main design principle for this module is to centralize all uses of `as`.\nThe thinking here is that `as` makes it very easy to perform accidental lossy\nconversions, and if we centralize all its uses here under more descriptive\nhigher level operations, its use and correctness becomes easier to audit.\n\nThis was copied mostly wholesale from `regex-automata`.\n\nNOTE: for simplicity, we don't take target pointer width into account here for\n`usize` conversions. Since we currently only panic in debug mode, skipping the\ncheck when it can be proven it isn't needed at compile time doesn't really\nmatter. Now, if we wind up wanting to do as many checks as possible in release\nmode, then we would want to skip those when we know the conversions are always\nnon-lossy.\n"] # ! [allow (dead_code)] pub (crate) trait U8 { fn as_usize (self) -> usize ; } impl U8 for u8 { fn as_usize (self) -> usize { usize :: from (self) } } pub (crate) trait U16 { fn as_usize (self) -> usize ; fn low_u8 (self) -> u8 ; fn high_u8 (self) -> u8 ; } impl U16 for u16 { fn as_usize (self) -> usize { usize :: from (self) } fn low_u8 (self) -> u8 { self as u8 } fn high_u8 (self) -> u8 { (self >> 8) as u8 } } pub (crate) trait U32 { fn as_usize (self) -> usize ; fn low_u8 (self) -> u8 ; fn low_u16 (self) -> u16 ; fn high_u16 (self) -> u16 ; } impl U32 for u32 { # [inline] fn as_usize (self) -> usize { { usize :: try_from (self) . expect ("u32 overflowed usize") } } fn low_u8 (self) -> u8 { self as u8 } fn low_u16 (self) -> u16 { self as u16 } fn high_u16 (self) -> u16 { (self >> 16) as u16 } } pub (crate) trait U64 { fn as_usize (self) -> usize ; fn low_u8 (self) -> u8 ; fn low_u16 (self) -> u16 ; fn low_u32 (self) -> u32 ; fn high_u32 (self) -> u32 ; } impl U64 for u64 { fn as_usize (self) -> usize { { usize :: try_from (self) . expect ("u64 overflowed usize") } } fn low_u8 (self) -> u8 { self as u8 } fn low_u16 (self) -> u16 { self as u16 } fn low_u32 (self) -> u32 { self as u32 } fn high_u32 (self) -> u32 { (self >> 32) as u32 } } pub (crate) trait I8 { fn as_usize (self) -> usize ; fn to_bits (self) -> u8 ; fn from_bits (n : u8) -> i8 ; } impl I8 for i8 { fn as_usize (self) -> usize { { usize :: try_from (self) . expect ("i8 overflowed usize") } } fn to_bits (self) -> u8 { self as u8 } fn from_bits (n : u8) -> i8 { n as i8 } } pub (crate) trait I32 { fn as_usize (self) -> usize ; fn to_bits (self) -> u32 ; fn from_bits (n : u32) -> i32 ; } impl I32 for i32 { fn as_usize (self) -> usize { { usize :: try_from (self) . expect ("i32 overflowed usize") } } fn to_bits (self) -> u32 { self as u32 } fn from_bits (n : u32) -> i32 { n as i32 } } pub (crate) trait I64 { fn as_usize (self) -> usize ; fn to_bits (self) -> u64 ; fn from_bits (n : u64) -> i64 ; } impl I64 for i64 { fn as_usize (self) -> usize { { usize :: try_from (self) . expect ("i64 overflowed usize") } } fn to_bits (self) -> u64 { self as u64 } fn from_bits (n : u64) -> i64 { n as i64 } } pub (crate) trait Usize { fn as_u8 (self) -> u8 ; fn as_u16 (self) -> u16 ; fn as_u32 (self) -> u32 ; fn as_u64 (self) -> u64 ; } impl Usize for usize { fn as_u8 (self) -> u8 { { u8 :: try_from (self) . expect ("usize overflowed u8") } } fn as_u16 (self) -> u16 { { u16 :: try_from (self) . expect ("usize overflowed u16") } } fn as_u32 (self) -> u32 { { u32 :: try_from (self) . expect ("usize overflowed u32") } } fn as_u64 (self) -> u64 { { u64 :: try_from (self) . expect ("usize overflowed u64") } } } pub (crate) trait Pointer { fn as_usize (self) -> usize ; } impl < T > Pointer for * const T { fn as_usize (self) -> usize { self as usize } } }