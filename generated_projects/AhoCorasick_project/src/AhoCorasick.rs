use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " An automaton for searching multiple strings in linear time."] # [doc = ""] # [doc = " The `AhoCorasick` type supports a few basic ways of constructing an"] # [doc = " automaton, with the default being [`AhoCorasick::new`]. However, there"] # [doc = " are a fair number of configurable options that can be set by using"] # [doc = " [`AhoCorasickBuilder`] instead. Such options include, but are not limited"] # [doc = " to, how matches are determined, simple case insensitivity, whether to use a"] # [doc = " DFA or not and various knobs for controlling the space-vs-time trade offs"] # [doc = " taken when building the automaton."] # [doc = ""] # [doc = " # Resource usage"] # [doc = ""] # [doc = " Aho-Corasick automatons are always constructed in `O(p)` time, where"] # [doc = " `p` is the combined length of all patterns being searched. With that"] # [doc = " said, building an automaton can be fairly costly because of high constant"] # [doc = " factors, particularly when enabling the [DFA](AhoCorasickKind::DFA) option"] # [doc = " with [`AhoCorasickBuilder::kind`]. For this reason, it's generally a good"] # [doc = " idea to build an automaton once and reuse it as much as possible."] # [doc = ""] # [doc = " Aho-Corasick automatons can also use a fair bit of memory. To get"] # [doc = " a concrete idea of how much memory is being used, try using the"] # [doc = " [`AhoCorasick::memory_usage`] method."] # [doc = ""] # [doc = " To give a quick idea of the differences between Aho-Corasick"] # [doc = " implementations and their resource usage, here's a sample of construction"] # [doc = " times and heap memory used after building an automaton from 100,000"] # [doc = " randomly selected titles from Wikipedia:"] # [doc = ""] # [doc = " * 99MB for a [`noncontiguous::NFA`] in 240ms."] # [doc = " * 21MB for a [`contiguous::NFA`] in 275ms."] # [doc = " * 1.6GB for a [`dfa::DFA`] in 1.88s."] # [doc = ""] # [doc = " (Note that the memory usage above reflects the size of each automaton and"] # [doc = " not peak memory usage. For example, building a contiguous NFA requires"] # [doc = " first building a noncontiguous NFA. Once the contiguous NFA is built, the"] # [doc = " noncontiguous NFA is freed.)"] # [doc = ""] # [doc = " This experiment very strongly argues that a contiguous NFA is often the"] # [doc = " best balance in terms of resource usage. It takes a little longer to build,"] # [doc = " but its memory usage is quite small. Its search speed (not listed) is"] # [doc = " also often faster than a noncontiguous NFA, but a little slower than a"] # [doc = " DFA. Indeed, when no specific [`AhoCorasickKind`] is used (which is the"] # [doc = " default), a contiguous NFA is used in most cases."] # [doc = ""] # [doc = " The only \"catch\" to using a contiguous NFA is that, because of its variety"] # [doc = " of compression tricks, it may not be able to support automatons as large as"] # [doc = " what the noncontiguous NFA supports. In which case, building a contiguous"] # [doc = " NFA will fail and (by default) `AhoCorasick` will automatically fall"] # [doc = " back to a noncontiguous NFA. (This typically only happens when building"] # [doc = " automatons from millions of patterns.) Otherwise, the small additional time"] # [doc = " for building a contiguous NFA is almost certainly worth it."] # [doc = ""] # [doc = " # Cloning"] # [doc = ""] # [doc = " The `AhoCorasick` type uses thread safe reference counting internally. It"] # [doc = " is guaranteed that it is cheap to clone."] # [doc = ""] # [doc = " # Search configuration"] # [doc = ""] # [doc = " Most of the search routines accept anything that can be cheaply converted"] # [doc = " to an [`Input`]. This includes `&[u8]`, `&str` and `Input` itself."] # [doc = ""] # [doc = " # Construction failure"] # [doc = ""] # [doc = " It is generally possible for building an Aho-Corasick automaton to fail."] # [doc = " Construction can fail in generally one way: when the inputs provided are"] # [doc = " too big. Whether that's a pattern that is too long, too many patterns"] # [doc = " or some combination of both. A first approximation for the scale at which"] # [doc = " construction can fail is somewhere around \"millions of patterns.\""] # [doc = ""] # [doc = " For that reason, if you're building an Aho-Corasick automaton from"] # [doc = " untrusted input (or input that doesn't have any reasonable bounds on its"] # [doc = " size), then it is strongly recommended to handle the possibility of an"] # [doc = " error."] # [doc = ""] # [doc = " If you're constructing an Aho-Corasick automaton from static or trusted"] # [doc = " data, then it is likely acceptable to panic (by calling `unwrap()` or"] # [doc = " `expect()`) if construction fails."] # [doc = ""] # [doc = " # Fallibility"] # [doc = ""] # [doc = " The `AhoCorasick` type provides a number of methods for searching, as one"] # [doc = " might expect. Depending on how the Aho-Corasick automaton was built and"] # [doc = " depending on the search configuration, it is possible for a search to"] # [doc = " return an error. Since an error is _never_ dependent on the actual contents"] # [doc = " of the haystack, this type provides both infallible and fallible methods"] # [doc = " for searching. The infallible methods panic if an error occurs, and can be"] # [doc = " used for convenience and when you know the search will never return an"] # [doc = " error."] # [doc = ""] # [doc = " For example, the [`AhoCorasick::find_iter`] method is the infallible"] # [doc = " version of the [`AhoCorasick::try_find_iter`] method."] # [doc = ""] # [doc = " Examples of errors that can occur:"] # [doc = ""] # [doc = " * Running a search that requires [`MatchKind::Standard`] semantics (such"] # [doc = " as a stream or overlapping search) with an automaton that was built with"] # [doc = " [`MatchKind::LeftmostFirst`] or [`MatchKind::LeftmostLongest`] semantics."] # [doc = " * Running an anchored search with an automaton that only supports"] # [doc = " unanchored searches. (By default, `AhoCorasick` only supports unanchored"] # [doc = " searches. But this can be toggled with [`AhoCorasickBuilder::start_kind`].)"] # [doc = " * Running an unanchored search with an automaton that only supports"] # [doc = " anchored searches."] # [doc = ""] # [doc = " The common thread between the different types of errors is that they are"] # [doc = " all rooted in the automaton construction and search configurations. If"] # [doc = " those configurations are a static property of your program, then it is"] # [doc = " reasonable to call infallible routines since you know an error will never"] # [doc = " occur. And if one _does_ occur, then it's a bug in your program."] # [doc = ""] # [doc = " To re-iterate, if the patterns, build or search configuration come from"] # [doc = " user or untrusted data, then you should handle errors at build or search"] # [doc = " time. If only the haystack comes from user or untrusted data, then there"] # [doc = " should be no need to handle errors anywhere and it is generally encouraged"] # [doc = " to `unwrap()` (or `expect()`) both build and search time calls."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " This example shows how to search for occurrences of multiple patterns"] # [doc = " simultaneously in a case insensitive fashion. Each match includes the"] # [doc = " pattern that matched along with the byte offsets of the match."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"apple\", \"maple\", \"snapple\"];"] # [doc = " let haystack = \"Nobody likes maple in their apple flavored Snapple.\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut matches = vec![];"] # [doc = " for mat in ac.find_iter(haystack) {"] # [doc = "     matches.push((mat.pattern(), mat.start(), mat.end()));"] # [doc = " }"] # [doc = " assert_eq!(matches, vec!["] # [doc = "     (PatternID::must(1), 13, 18),"] # [doc = "     (PatternID::must(0), 28, 33),"] # [doc = "     (PatternID::must(2), 43, 50),"] # [doc = " ]);"] # [doc = " ```"] # [doc = ""] # [doc = " This example shows how to replace matches with some other string:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let patterns = &[\"fox\", \"brown\", \"quick\"];"] # [doc = " let haystack = \"The quick brown fox.\";"] # [doc = " let replace_with = &[\"sloth\", \"grey\", \"slow\"];"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let result = ac.replace_all(haystack, replace_with);"] # [doc = " assert_eq!(result, \"The slow grey sloth.\");"] # [doc = " ```"] pub struct AhoCorasick { # [doc = " The underlying Aho-Corasick automaton. It's one of"] # [doc = " nfa::noncontiguous::NFA, nfa::contiguous::NFA or dfa::DFA."] aut : Arc < dyn AcAutomaton > , # [doc = " The specific Aho-Corasick kind chosen. This makes it possible to"] # [doc = " inspect any `AhoCorasick` and know what kind of search strategy it"] # [doc = " uses."] kind : AhoCorasickKind , # [doc = " The start kind of this automaton as configured by the caller."] # [doc = ""] # [doc = " We don't really *need* to put this here, since the underlying automaton"] # [doc = " will correctly return errors if the caller requests an unsupported"] # [doc = " search type. But we do keep this here for API behavior consistency."] # [doc = " Namely, the NFAs in this crate support both unanchored and anchored"] # [doc = " searches unconditionally. There's no way to disable one or the other."] # [doc = " They always both work. But the DFA in this crate specifically only"] # [doc = " supports both unanchored and anchored searches if it's configured to"] # [doc = " do so. Why? Because for the DFA, supporting both essentially requires"] # [doc = " two copies of the transition table: one generated by following failure"] # [doc = " transitions from the original NFA and one generated by not following"] # [doc = " those failure transitions."] # [doc = ""] # [doc = " So why record the start kind here? Well, consider what happens"] # [doc = " when no specific 'AhoCorasickKind' is selected by the caller and"] # [doc = " 'StartKind::Unanchored' is used (both are the default). It *might*"] # [doc = " result in using a DFA or it might pick an NFA. If it picks an NFA, the"] # [doc = " caller would then be able to run anchored searches, even though the"] # [doc = " caller only asked for support for unanchored searches. Maybe that's"] # [doc = " fine, but what if the DFA was chosen instead? Oops, the caller would"] # [doc = " get an error."] # [doc = ""] # [doc = " Basically, it seems bad to return an error or not based on some"] # [doc = " internal implementation choice. So we smooth things out and ensure"] # [doc = " anchored searches *always* report an error when only unanchored support"] # [doc = " was asked for (and vice versa), even if the underlying automaton"] # [doc = " supports it."] start_kind : StartKind , }