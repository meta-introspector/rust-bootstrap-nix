use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " A simple type for mapping between state indices and state IDs."] # [doc = ""] # [doc = " The reason why this exists is because state IDs are \"premultiplied\" in a"] # [doc = " DFA. That is, in order to get to the transitions for a particular state,"] # [doc = " one need only use the state ID as-is, instead of having to multiply it by"] # [doc = " transition table's stride."] # [doc = ""] # [doc = " The downside of this is that it's inconvenient to map between state IDs"] # [doc = " using a dense map, e.g., Vec<StateID>. That's because state IDs look like"] # [doc = " `0`, `stride`, `2*stride`, `3*stride`, etc., instead of `0`, `1`, `2`, `3`,"] # [doc = " etc."] # [doc = ""] # [doc = " Since our state IDs are premultiplied, we can convert back-and-forth"] # [doc = " between IDs and indices by simply unmultiplying the IDs and multiplying the"] # [doc = " indices."] # [doc = ""] # [doc = " Note that for a sparse NFA, state IDs and indices are equivalent. In this"] # [doc = " case, we set the stride of the index mapped to be `0`, which acts as an"] # [doc = " identity."] struct IndexMapper { # [doc = " The power of 2 corresponding to the stride of the corresponding"] # [doc = " transition table. 'id >> stride2' de-multiplies an ID while 'index <<"] # [doc = " stride2' pre-multiplies an index to an ID."] stride2 : usize , }