use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

mod ahocorasick { use core :: { fmt :: Debug , panic :: { RefUnwindSafe , UnwindSafe } } ; use alloc :: { string :: String , sync :: Arc , vec :: Vec } ; use crate :: { automaton :: { self , Automaton , OverlappingState } , dfa , nfa :: { contiguous , noncontiguous } , util :: { error :: { BuildError , MatchError } , prefilter :: Prefilter , primitives :: { PatternID , StateID } , search :: { Anchored , Input , Match , MatchKind , StartKind } , } , } ; # [doc = " An automaton for searching multiple strings in linear time."] # [doc = ""] # [doc = " The `AhoCorasick` type supports a few basic ways of constructing an"] # [doc = " automaton, with the default being [`AhoCorasick::new`]. However, there"] # [doc = " are a fair number of configurable options that can be set by using"] # [doc = " [`AhoCorasickBuilder`] instead. Such options include, but are not limited"] # [doc = " to, how matches are determined, simple case insensitivity, whether to use a"] # [doc = " DFA or not and various knobs for controlling the space-vs-time trade offs"] # [doc = " taken when building the automaton."] # [doc = ""] # [doc = " # Resource usage"] # [doc = ""] # [doc = " Aho-Corasick automatons are always constructed in `O(p)` time, where"] # [doc = " `p` is the combined length of all patterns being searched. With that"] # [doc = " said, building an automaton can be fairly costly because of high constant"] # [doc = " factors, particularly when enabling the [DFA](AhoCorasickKind::DFA) option"] # [doc = " with [`AhoCorasickBuilder::kind`]. For this reason, it's generally a good"] # [doc = " idea to build an automaton once and reuse it as much as possible."] # [doc = ""] # [doc = " Aho-Corasick automatons can also use a fair bit of memory. To get"] # [doc = " a concrete idea of how much memory is being used, try using the"] # [doc = " [`AhoCorasick::memory_usage`] method."] # [doc = ""] # [doc = " To give a quick idea of the differences between Aho-Corasick"] # [doc = " implementations and their resource usage, here's a sample of construction"] # [doc = " times and heap memory used after building an automaton from 100,000"] # [doc = " randomly selected titles from Wikipedia:"] # [doc = ""] # [doc = " * 99MB for a [`noncontiguous::NFA`] in 240ms."] # [doc = " * 21MB for a [`contiguous::NFA`] in 275ms."] # [doc = " * 1.6GB for a [`dfa::DFA`] in 1.88s."] # [doc = ""] # [doc = " (Note that the memory usage above reflects the size of each automaton and"] # [doc = " not peak memory usage. For example, building a contiguous NFA requires"] # [doc = " first building a noncontiguous NFA. Once the contiguous NFA is built, the"] # [doc = " noncontiguous NFA is freed.)"] # [doc = ""] # [doc = " This experiment very strongly argues that a contiguous NFA is often the"] # [doc = " best balance in terms of resource usage. It takes a little longer to build,"] # [doc = " but its memory usage is quite small. Its search speed (not listed) is"] # [doc = " also often faster than a noncontiguous NFA, but a little slower than a"] # [doc = " DFA. Indeed, when no specific [`AhoCorasickKind`] is used (which is the"] # [doc = " default), a contiguous NFA is used in most cases."] # [doc = ""] # [doc = " The only \"catch\" to using a contiguous NFA is that, because of its variety"] # [doc = " of compression tricks, it may not be able to support automatons as large as"] # [doc = " what the noncontiguous NFA supports. In which case, building a contiguous"] # [doc = " NFA will fail and (by default) `AhoCorasick` will automatically fall"] # [doc = " back to a noncontiguous NFA. (This typically only happens when building"] # [doc = " automatons from millions of patterns.) Otherwise, the small additional time"] # [doc = " for building a contiguous NFA is almost certainly worth it."] # [doc = ""] # [doc = " # Cloning"] # [doc = ""] # [doc = " The `AhoCorasick` type uses thread safe reference counting internally. It"] # [doc = " is guaranteed that it is cheap to clone."] # [doc = ""] # [doc = " # Search configuration"] # [doc = ""] # [doc = " Most of the search routines accept anything that can be cheaply converted"] # [doc = " to an [`Input`]. This includes `&[u8]`, `&str` and `Input` itself."] # [doc = ""] # [doc = " # Construction failure"] # [doc = ""] # [doc = " It is generally possible for building an Aho-Corasick automaton to fail."] # [doc = " Construction can fail in generally one way: when the inputs provided are"] # [doc = " too big. Whether that's a pattern that is too long, too many patterns"] # [doc = " or some combination of both. A first approximation for the scale at which"] # [doc = " construction can fail is somewhere around \"millions of patterns.\""] # [doc = ""] # [doc = " For that reason, if you're building an Aho-Corasick automaton from"] # [doc = " untrusted input (or input that doesn't have any reasonable bounds on its"] # [doc = " size), then it is strongly recommended to handle the possibility of an"] # [doc = " error."] # [doc = ""] # [doc = " If you're constructing an Aho-Corasick automaton from static or trusted"] # [doc = " data, then it is likely acceptable to panic (by calling `unwrap()` or"] # [doc = " `expect()`) if construction fails."] # [doc = ""] # [doc = " # Fallibility"] # [doc = ""] # [doc = " The `AhoCorasick` type provides a number of methods for searching, as one"] # [doc = " might expect. Depending on how the Aho-Corasick automaton was built and"] # [doc = " depending on the search configuration, it is possible for a search to"] # [doc = " return an error. Since an error is _never_ dependent on the actual contents"] # [doc = " of the haystack, this type provides both infallible and fallible methods"] # [doc = " for searching. The infallible methods panic if an error occurs, and can be"] # [doc = " used for convenience and when you know the search will never return an"] # [doc = " error."] # [doc = ""] # [doc = " For example, the [`AhoCorasick::find_iter`] method is the infallible"] # [doc = " version of the [`AhoCorasick::try_find_iter`] method."] # [doc = ""] # [doc = " Examples of errors that can occur:"] # [doc = ""] # [doc = " * Running a search that requires [`MatchKind::Standard`] semantics (such"] # [doc = " as a stream or overlapping search) with an automaton that was built with"] # [doc = " [`MatchKind::LeftmostFirst`] or [`MatchKind::LeftmostLongest`] semantics."] # [doc = " * Running an anchored search with an automaton that only supports"] # [doc = " unanchored searches. (By default, `AhoCorasick` only supports unanchored"] # [doc = " searches. But this can be toggled with [`AhoCorasickBuilder::start_kind`].)"] # [doc = " * Running an unanchored search with an automaton that only supports"] # [doc = " anchored searches."] # [doc = ""] # [doc = " The common thread between the different types of errors is that they are"] # [doc = " all rooted in the automaton construction and search configurations. If"] # [doc = " those configurations are a static property of your program, then it is"] # [doc = " reasonable to call infallible routines since you know an error will never"] # [doc = " occur. And if one _does_ occur, then it's a bug in your program."] # [doc = ""] # [doc = " To re-iterate, if the patterns, build or search configuration come from"] # [doc = " user or untrusted data, then you should handle errors at build or search"] # [doc = " time. If only the haystack comes from user or untrusted data, then there"] # [doc = " should be no need to handle errors anywhere and it is generally encouraged"] # [doc = " to `unwrap()` (or `expect()`) both build and search time calls."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " This example shows how to search for occurrences of multiple patterns"] # [doc = " simultaneously in a case insensitive fashion. Each match includes the"] # [doc = " pattern that matched along with the byte offsets of the match."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"apple\", \"maple\", \"snapple\"];"] # [doc = " let haystack = \"Nobody likes maple in their apple flavored Snapple.\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut matches = vec![];"] # [doc = " for mat in ac.find_iter(haystack) {"] # [doc = "     matches.push((mat.pattern(), mat.start(), mat.end()));"] # [doc = " }"] # [doc = " assert_eq!(matches, vec!["] # [doc = "     (PatternID::must(1), 13, 18),"] # [doc = "     (PatternID::must(0), 28, 33),"] # [doc = "     (PatternID::must(2), 43, 50),"] # [doc = " ]);"] # [doc = " ```"] # [doc = ""] # [doc = " This example shows how to replace matches with some other string:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let patterns = &[\"fox\", \"brown\", \"quick\"];"] # [doc = " let haystack = \"The quick brown fox.\";"] # [doc = " let replace_with = &[\"sloth\", \"grey\", \"slow\"];"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let result = ac.replace_all(haystack, replace_with);"] # [doc = " assert_eq!(result, \"The slow grey sloth.\");"] # [doc = " ```"] pub struct AhoCorasick { # [doc = " The underlying Aho-Corasick automaton. It's one of"] # [doc = " nfa::noncontiguous::NFA, nfa::contiguous::NFA or dfa::DFA."] aut : Arc < dyn AcAutomaton > , # [doc = " The specific Aho-Corasick kind chosen. This makes it possible to"] # [doc = " inspect any `AhoCorasick` and know what kind of search strategy it"] # [doc = " uses."] kind : AhoCorasickKind , # [doc = " The start kind of this automaton as configured by the caller."] # [doc = ""] # [doc = " We don't really *need* to put this here, since the underlying automaton"] # [doc = " will correctly return errors if the caller requests an unsupported"] # [doc = " search type. But we do keep this here for API behavior consistency."] # [doc = " Namely, the NFAs in this crate support both unanchored and anchored"] # [doc = " searches unconditionally. There's no way to disable one or the other."] # [doc = " They always both work. But the DFA in this crate specifically only"] # [doc = " supports both unanchored and anchored searches if it's configured to"] # [doc = " do so. Why? Because for the DFA, supporting both essentially requires"] # [doc = " two copies of the transition table: one generated by following failure"] # [doc = " transitions from the original NFA and one generated by not following"] # [doc = " those failure transitions."] # [doc = ""] # [doc = " So why record the start kind here? Well, consider what happens"] # [doc = " when no specific 'AhoCorasickKind' is selected by the caller and"] # [doc = " 'StartKind::Unanchored' is used (both are the default). It *might*"] # [doc = " result in using a DFA or it might pick an NFA. If it picks an NFA, the"] # [doc = " caller would then be able to run anchored searches, even though the"] # [doc = " caller only asked for support for unanchored searches. Maybe that's"] # [doc = " fine, but what if the DFA was chosen instead? Oops, the caller would"] # [doc = " get an error."] # [doc = ""] # [doc = " Basically, it seems bad to return an error or not based on some"] # [doc = " internal implementation choice. So we smooth things out and ensure"] # [doc = " anchored searches *always* report an error when only unanchored support"] # [doc = " was asked for (and vice versa), even if the underlying automaton"] # [doc = " supports it."] start_kind : StartKind , } # [automatically_derived] impl :: core :: clone :: Clone for AhoCorasick { # [inline] fn clone (& self) -> AhoCorasick { AhoCorasick { aut : :: core :: clone :: Clone :: clone (& self . aut) , kind : :: core :: clone :: Clone :: clone (& self . kind) , start_kind : :: core :: clone :: Clone :: clone (& self . start_kind) , } } } # [doc = " Convenience constructors for an Aho-Corasick searcher. To configure the"] # [doc = " searcher, use an [`AhoCorasickBuilder`] instead."] impl AhoCorasick { # [doc = " Create a new Aho-Corasick automaton using the default configuration."] # [doc = ""] # [doc = " The default configuration optimizes for less space usage, but at the"] # [doc = " expense of longer search times. To change the configuration, use"] # [doc = " [`AhoCorasickBuilder`]."] # [doc = ""] # [doc = " This uses the default [`MatchKind::Standard`] match semantics, which"] # [doc = " reports a match as soon as it is found. This corresponds to the"] # [doc = " standard match semantics supported by textbook descriptions of the"] # [doc = " Aho-Corasick algorithm."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"baz\"]).unwrap();"] # [doc = " assert_eq!("] # [doc = "     Some(PatternID::must(1)),"] # [doc = "     ac.find(\"xxx bar xxx\").map(|m| m.pattern()),"] # [doc = " );"] # [doc = " ```"] pub fn new < I , P > (patterns : I) -> Result < AhoCorasick , BuildError > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { AhoCorasickBuilder :: new () . build (patterns) } # [doc = " A convenience method for returning a new Aho-Corasick builder."] # [doc = ""] # [doc = " This usually permits one to just import the `AhoCorasick` type."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Match, MatchKind};"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(&[\"samwise\", \"sam\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(Some(Match::must(0, 0..7)), ac.find(\"samwise\"));"] # [doc = " ```"] pub fn builder () -> AhoCorasickBuilder { AhoCorasickBuilder :: new () } } # [doc = " Infallible search routines. These APIs panic when the underlying search"] # [doc = " would otherwise fail. Infallible routines are useful because the errors are"] # [doc = " a result of both search-time configuration and what configuration is used"] # [doc = " to build the Aho-Corasick searcher. Both of these things are not usually"] # [doc = " the result of user input, and thus, an error is typically indicative of a"] # [doc = " programmer error. In cases where callers want errors instead of panics, use"] # [doc = " the corresponding `try` method in the section below."] impl AhoCorasick { # [doc = " Returns true if and only if this automaton matches the haystack at any"] # [doc = " position."] # [doc = ""] # [doc = " `input` may be any type that is cheaply convertible to an `Input`. This"] # [doc = " includes, but is not limited to, `&str` and `&[u8]`."] # [doc = ""] # [doc = " Aside from convenience, when `AhoCorasick` was built with"] # [doc = " leftmost-first or leftmost-longest semantics, this might result in a"] # [doc = " search that visits less of the haystack than [`AhoCorasick::find`]"] # [doc = " would otherwise. (For standard semantics, matches are always"] # [doc = " immediately returned once they are seen, so there is no way for this to"] # [doc = " do less work in that case.)"] # [doc = ""] # [doc = " Note that there is no corresponding fallible routine for this method."] # [doc = " If you need a fallible version of this, then [`AhoCorasick::try_find`]"] # [doc = " can be used with [`Input::earliest`] enabled."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&["] # [doc = "     \"foo\", \"bar\", \"quux\", \"baz\","] # [doc = " ]).unwrap();"] # [doc = " assert!(ac.is_match(\"xxx bar xxx\"));"] # [doc = " assert!(!ac.is_match(\"xxx qux xxx\"));"] # [doc = " ```"] pub fn is_match < 'h , I : Into < Input < 'h > > > (& self , input : I) -> bool { self . aut . try_find (& input . into () . earliest (true)) . expect ("AhoCorasick::try_find is not expected to fail") . is_some () } # [doc = " Returns the location of the first match according to the match"] # [doc = " semantics that this automaton was constructed with."] # [doc = ""] # [doc = " `input` may be any type that is cheaply convertible to an `Input`. This"] # [doc = " includes, but is not limited to, `&str` and `&[u8]`."] # [doc = ""] # [doc = " This is the infallible version of [`AhoCorasick::try_find`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_find`] would return an error."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage, with standard semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::Standard) // default, not necessary"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " assert_eq!(\"b\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] # [doc = ""] # [doc = " Now with leftmost-first semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " assert_eq!(\"abc\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] # [doc = ""] # [doc = " And finally, leftmost-longest semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: configuring a search"] # [doc = ""] # [doc = " Because this method accepts anything that can be turned into an"] # [doc = " [`Input`], it's possible to provide an `Input` directly in order to"] # [doc = " configure the search. In this example, we show how to use the"] # [doc = " `earliest` option to force the search to return as soon as it knows"] # [doc = " a match has occurred."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Input, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(Input::new(haystack).earliest(true))"] # [doc = "     .expect(\"should have a match\");"] # [doc = " // The correct leftmost-longest match here is 'abcd', but since we"] # [doc = " // told the search to quit as soon as it knows a match has occurred,"] # [doc = " // we get a different match back."] # [doc = " assert_eq!(\"b\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] pub fn find < 'h , I : Into < Input < 'h > > > (& self , input : I) -> Option < Match > { self . try_find (input) . expect ("AhoCorasick::try_find is not expected to fail") } # [doc = " Returns the location of the first overlapping match in the given"] # [doc = " input with respect to the current state of the underlying searcher."] # [doc = ""] # [doc = " `input` may be any type that is cheaply convertible to an `Input`. This"] # [doc = " includes, but is not limited to, `&str` and `&[u8]`."] # [doc = ""] # [doc = " Overlapping searches do not report matches in their return value."] # [doc = " Instead, matches can be accessed via [`OverlappingState::get_match`]"] # [doc = " after a search call."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_find_overlapping`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_find_overlapping`] would"] # [doc = " return an error. For example, when the Aho-Corasick searcher"] # [doc = " doesn't support overlapping searches. (Only searchers built with"] # [doc = " [`MatchKind::Standard`] semantics support overlapping searches.)"] # [doc = ""] # [doc = " # Example"] # [doc = ""] # [doc = " This shows how we can repeatedly call an overlapping search without"] # [doc = " ever needing to explicitly re-slice the haystack. Overlapping search"] # [doc = " works this way because searches depend on state saved during the"] # [doc = " previous search."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut state = OverlappingState::start();"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(2, 0..3)), state.get_match());"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(0, 0..6)), state.get_match());"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(2, 11..14)), state.get_match());"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(2, 22..25)), state.get_match());"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(0, 22..28)), state.get_match());"] # [doc = ""] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(Some(Match::must(1, 22..31)), state.get_match());"] # [doc = ""] # [doc = " // No more match matches to be found."] # [doc = " ac.find_overlapping(haystack, &mut state);"] # [doc = " assert_eq!(None, state.get_match());"] # [doc = " ```"] pub fn find_overlapping < 'h , I : Into < Input < 'h > > > (& self , input : I , state : & mut OverlappingState ,) { self . try_find_overlapping (input , state) . expect ("AhoCorasick::try_find_overlapping is not expected to fail") } # [doc = " Returns an iterator of non-overlapping matches, using the match"] # [doc = " semantics that this automaton was constructed with."] # [doc = ""] # [doc = " `input` may be any type that is cheaply convertible to an `Input`. This"] # [doc = " includes, but is not limited to, `&str` and `&[u8]`."] # [doc = ""] # [doc = " This is the infallible version of [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_find_iter`] would return an error."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage, with standard semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::Standard) // default, not necessary"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .find_iter(haystack)"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = " ], matches);"] # [doc = " ```"] # [doc = ""] # [doc = " Now with leftmost-first semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .find_iter(haystack)"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = " ], matches);"] # [doc = " ```"] # [doc = ""] # [doc = " And finally, leftmost-longest semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .find_iter(haystack)"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(1),"] # [doc = " ], matches);"] # [doc = " ```"] pub fn find_iter < 'a , 'h , I : Into < Input < 'h > > > (& 'a self , input : I ,) -> FindIter < 'a , 'h > { self . try_find_iter (input) . expect ("AhoCorasick::try_find_iter is not expected to fail") } # [doc = " Returns an iterator of overlapping matches. Stated differently, this"] # [doc = " returns an iterator of all possible matches at every position."] # [doc = ""] # [doc = " `input` may be any type that is cheaply convertible to an `Input`. This"] # [doc = " includes, but is not limited to, `&str` and `&[u8]`."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_find_overlapping_iter`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `AhoCorasick::try_find_overlapping_iter` would return"] # [doc = " an error. For example, when the Aho-Corasick searcher is built with"] # [doc = " either leftmost-first or leftmost-longest match semantics. Stated"] # [doc = " differently, overlapping searches require one to build the searcher"] # [doc = " with [`MatchKind::Standard`] (it is the default)."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .find_overlapping_iter(haystack)"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(1),"] # [doc = " ], matches);"] # [doc = " ```"] pub fn find_overlapping_iter < 'a , 'h , I : Into < Input < 'h > > > (& 'a self , input : I ,) -> FindOverlappingIter < 'a , 'h > { self . try_find_overlapping_iter (input) . expect ("AhoCorasick::try_find_overlapping_iter is not expected to fail") } # [doc = " Replace all matches with a corresponding value in the `replace_with`"] # [doc = " slice given. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " Replacements are determined by the index of the matching pattern."] # [doc = " For example, if the pattern with index `2` is found, then it is"] # [doc = " replaced by `replace_with[2]`."] # [doc = ""] # [doc = " This is the infallible version of [`AhoCorasick::try_replace_all`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_replace_all`] would return an"] # [doc = " error."] # [doc = ""] # [doc = " This also panics when `replace_with.len()` does not equal"] # [doc = " [`AhoCorasick::patterns_len`]."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let result = ac.replace_all(haystack, &[\"x\", \"y\", \"z\"]);"] # [doc = " assert_eq!(\"x the z to the xage\", result);"] # [doc = " ```"] pub fn replace_all < B > (& self , haystack : & str , replace_with : & [B]) -> String where B : AsRef < str > , { self . try_replace_all (haystack , replace_with) . expect ("AhoCorasick::try_replace_all is not expected to fail") } # [doc = " Replace all matches using raw bytes with a corresponding value in the"] # [doc = " `replace_with` slice given. Matches correspond to the same matches as"] # [doc = " reported by [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " Replacements are determined by the index of the matching pattern."] # [doc = " For example, if the pattern with index `2` is found, then it is"] # [doc = " replaced by `replace_with[2]`."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_replace_all_bytes`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_replace_all_bytes`] would return an"] # [doc = " error."] # [doc = ""] # [doc = " This also panics when `replace_with.len()` does not equal"] # [doc = " [`AhoCorasick::patterns_len`]."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = b\"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let result = ac.replace_all_bytes(haystack, &[\"x\", \"y\", \"z\"]);"] # [doc = " assert_eq!(b\"x the z to the xage\".to_vec(), result);"] # [doc = " ```"] pub fn replace_all_bytes < B > (& self , haystack : & [u8] , replace_with : & [B] ,) -> Vec < u8 > where B : AsRef < [u8] > , { self . try_replace_all_bytes (haystack , replace_with) . expect ("AhoCorasick::try_replace_all_bytes should not fail") } # [doc = " Replace all matches using a closure called on each match."] # [doc = " Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " The closure accepts three parameters: the match found, the text of"] # [doc = " the match and a string buffer with which to write the replaced text"] # [doc = " (if any). If the closure returns `true`, then it continues to the next"] # [doc = " match. If the closure returns `false`, then searching is stopped."] # [doc = ""] # [doc = " Note that any matches with boundaries that don't fall on a valid UTF-8"] # [doc = " boundary are silently skipped."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_replace_all_with`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_replace_all_with`] would return an"] # [doc = " error."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut result = String::new();"] # [doc = " ac.replace_all_with(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.push_str(&mat.pattern().as_usize().to_string());"] # [doc = "     true"] # [doc = " });"] # [doc = " assert_eq!(\"0 the 2 to the 0age\", result);"] # [doc = " ```"] # [doc = ""] # [doc = " Stopping the replacement by returning `false` (continued from the"] # [doc = " example above):"] # [doc = ""] # [doc = " ```"] # [doc = " # use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = " # let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " # let haystack = \"append the app to the appendage\";"] # [doc = " # let ac = AhoCorasick::builder()"] # [doc = " #    .match_kind(MatchKind::LeftmostFirst)"] # [doc = " #    .build(patterns)"] # [doc = " #    .unwrap();"] # [doc = " let mut result = String::new();"] # [doc = " ac.replace_all_with(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.push_str(&mat.pattern().as_usize().to_string());"] # [doc = "     mat.pattern() != PatternID::must(2)"] # [doc = " });"] # [doc = " assert_eq!(\"0 the 2 to the appendage\", result);"] # [doc = " ```"] pub fn replace_all_with < F > (& self , haystack : & str , dst : & mut String , replace_with : F ,) where F : FnMut (& Match , & str , & mut String) -> bool , { self . try_replace_all_with (haystack , dst , replace_with) . expect ("AhoCorasick::try_replace_all_with should not fail") } # [doc = " Replace all matches using raw bytes with a closure called on each"] # [doc = " match. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " The closure accepts three parameters: the match found, the text of"] # [doc = " the match and a byte buffer with which to write the replaced text"] # [doc = " (if any). If the closure returns `true`, then it continues to the next"] # [doc = " match. If the closure returns `false`, then searching is stopped."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_replace_all_with_bytes`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_replace_all_with_bytes`] would"] # [doc = " return an error."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = b\"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.replace_all_with_bytes(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.extend(mat.pattern().as_usize().to_string().bytes());"] # [doc = "     true"] # [doc = " });"] # [doc = " assert_eq!(b\"0 the 2 to the 0age\".to_vec(), result);"] # [doc = " ```"] # [doc = ""] # [doc = " Stopping the replacement by returning `false` (continued from the"] # [doc = " example above):"] # [doc = ""] # [doc = " ```"] # [doc = " # use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = " # let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " # let haystack = b\"append the app to the appendage\";"] # [doc = " # let ac = AhoCorasick::builder()"] # [doc = " #    .match_kind(MatchKind::LeftmostFirst)"] # [doc = " #    .build(patterns)"] # [doc = " #    .unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.replace_all_with_bytes(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.extend(mat.pattern().as_usize().to_string().bytes());"] # [doc = "     mat.pattern() != PatternID::must(2)"] # [doc = " });"] # [doc = " assert_eq!(b\"0 the 2 to the appendage\".to_vec(), result);"] # [doc = " ```"] pub fn replace_all_with_bytes < F > (& self , haystack : & [u8] , dst : & mut Vec < u8 > , replace_with : F ,) where F : FnMut (& Match , & [u8] , & mut Vec < u8 >) -> bool , { self . try_replace_all_with_bytes (haystack , dst , replace_with) . expect ("AhoCorasick::try_replace_all_with_bytes should not fail") } # [doc = " Returns an iterator of non-overlapping matches in the given"] # [doc = " stream. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " The matches yielded by this iterator use absolute position offsets in"] # [doc = " the stream given, where the first byte has index `0`. Matches are"] # [doc = " yieled until the stream is exhausted."] # [doc = ""] # [doc = " Each item yielded by the iterator is an `Result<Match,"] # [doc = " std::io::Error>`, where an error is yielded if there was a problem"] # [doc = " reading from the reader given."] # [doc = ""] # [doc = " When searching a stream, an internal buffer is used. Therefore, callers"] # [doc = " should avoiding providing a buffered reader, if possible."] # [doc = ""] # [doc = " This is the infallible version of"] # [doc = " [`AhoCorasick::try_stream_find_iter`]. Note that both methods return"] # [doc = " iterators that produce `Result` values. The difference is that this"] # [doc = " routine panics if _construction_ of the iterator failed. The `Result`"] # [doc = " values yield by the iterator come from whether the given reader returns"] # [doc = " an error or not during the search."] # [doc = ""] # [doc = " # Memory usage"] # [doc = ""] # [doc = " In general, searching streams will use a constant amount of memory for"] # [doc = " its internal buffer. The one requirement is that the internal buffer"] # [doc = " must be at least the size of the longest possible match. In most use"] # [doc = " cases, the default buffer size will be much larger than any individual"] # [doc = " match."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when [`AhoCorasick::try_stream_find_iter`] would return"] # [doc = " an error. For example, when the Aho-Corasick searcher doesn't support"] # [doc = " stream searches. (Only searchers built with [`MatchKind::Standard`]"] # [doc = " semantics support stream searches.)"] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut matches = vec![];"] # [doc = " for result in ac.stream_find_iter(haystack.as_bytes()) {"] # [doc = "     let mat = result?;"] # [doc = "     matches.push(mat.pattern());"] # [doc = " }"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = " ], matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn stream_find_iter < 'a , R : std :: io :: Read > (& 'a self , rdr : R ,) -> StreamFindIter < 'a , R > { self . try_stream_find_iter (rdr) . expect ("AhoCorasick::try_stream_find_iter should not fail") } } # [doc = " Fallible search routines. These APIs return an error in cases where the"] # [doc = " infallible routines would panic."] impl AhoCorasick { # [doc = " Returns the location of the first match according to the match"] # [doc = " semantics that this automaton was constructed with, and according"] # [doc = " to the given `Input` configuration."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::find`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the given `Input` configuration."] # [doc = ""] # [doc = " For example, if the Aho-Corasick searcher only supports anchored"] # [doc = " searches or only supports unanchored searches, then providing an"] # [doc = " `Input` that requests an anchored (or unanchored) search when it isn't"] # [doc = " supported would result in an error."] # [doc = ""] # [doc = " # Example: leftmost-first searching"] # [doc = ""] # [doc = " Basic usage with leftmost-first semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind, Input};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"foo abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.try_find(haystack)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"abc\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: anchored leftmost-first searching"] # [doc = ""] # [doc = " This shows how to anchor the search, so that even if the haystack"] # [doc = " contains a match somewhere, a match won't be reported unless one can"] # [doc = " be found that starts at the beginning of the search:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Anchored, Input, MatchKind, StartKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"foo abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).anchored(Anchored::Yes);"] # [doc = " assert_eq!(None, ac.try_find(input)?);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " If the beginning of the search is changed to where a match begins, then"] # [doc = " it will be found:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Anchored, Input, MatchKind, StartKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"foo abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).range(4..).anchored(Anchored::Yes);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"abc\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: earliest leftmost-first searching"] # [doc = ""] # [doc = " This shows how to run an \"earliest\" search even when the Aho-Corasick"] # [doc = " searcher was compiled with leftmost-first match semantics. In this"] # [doc = " case, the search is stopped as soon as it is known that a match has"] # [doc = " occurred, even if it doesn't correspond to the leftmost-first match."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Input, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"foo abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).earliest(true);"] # [doc = " let mat = ac.try_find(input)?.expect(\"should have a match\");"] # [doc = " assert_eq!(\"b\", &haystack[mat.span()]);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_find < 'h , I : Into < Input < 'h > > > (& self , input : I ,) -> Result < Option < Match > , MatchError > { let input = input . into () ; enforce_anchored_consistency (self . start_kind , input . get_anchored ()) ? ; self . aut . try_find (& input) } # [doc = " Returns the location of the first overlapping match in the given"] # [doc = " input with respect to the current state of the underlying searcher."] # [doc = ""] # [doc = " Overlapping searches do not report matches in their return value."] # [doc = " Instead, matches can be accessed via [`OverlappingState::get_match`]"] # [doc = " after a search call."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::find_overlapping`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the given `Input` configuration or if overlapping search is not"] # [doc = " supported."] # [doc = ""] # [doc = " One example is that only Aho-Corasicker searchers built with"] # [doc = " [`MatchKind::Standard`] semantics support overlapping searches. Using"] # [doc = " any other match semantics will result in this returning an error."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " This shows how we can repeatedly call an overlapping search without"] # [doc = " ever needing to explicitly re-slice the haystack. Overlapping search"] # [doc = " works this way because searches depend on state saved during the"] # [doc = " previous search."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut state = OverlappingState::start();"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(2, 0..3)), state.get_match());"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(0, 0..6)), state.get_match());"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(2, 11..14)), state.get_match());"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(2, 22..25)), state.get_match());"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(0, 22..28)), state.get_match());"] # [doc = ""] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(Some(Match::must(1, 22..31)), state.get_match());"] # [doc = ""] # [doc = " // No more match matches to be found."] # [doc = " ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = " assert_eq!(None, state.get_match());"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: implementing your own overlapping iteration"] # [doc = ""] # [doc = " The previous example can be easily adapted to implement your own"] # [doc = " iteration by repeatedly calling `try_find_overlapping` until either"] # [doc = " an error occurs or no more matches are reported."] # [doc = ""] # [doc = " This is effectively equivalent to the iterator returned by"] # [doc = " [`AhoCorasick::try_find_overlapping_iter`], with the only difference"] # [doc = " being that the iterator checks for errors before construction and"] # [doc = " absolves the caller of needing to check for errors on every search"] # [doc = " call. (Indeed, if the first `try_find_overlapping` call succeeds and"] # [doc = " the same `Input` is given to subsequent calls, then all subsequent"] # [doc = " calls are guaranteed to succeed.)"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Input, Match,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut state = OverlappingState::start();"] # [doc = " let mut matches = vec![];"] # [doc = ""] # [doc = " loop {"] # [doc = "     ac.try_find_overlapping(haystack, &mut state)?;"] # [doc = "     let mat = match state.get_match() {"] # [doc = "         None => break,"] # [doc = "         Some(mat) => mat,"] # [doc = "     };"] # [doc = "     matches.push(mat);"] # [doc = " }"] # [doc = " let expected = vec!["] # [doc = "     Match::must(2, 0..3),"] # [doc = "     Match::must(0, 0..6),"] # [doc = "     Match::must(2, 11..14),"] # [doc = "     Match::must(2, 22..25),"] # [doc = "     Match::must(0, 22..28),"] # [doc = "     Match::must(1, 22..31),"] # [doc = " ];"] # [doc = " assert_eq!(expected, matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: anchored iteration"] # [doc = ""] # [doc = " The previous example can also be adapted to implement"] # [doc = " iteration over all anchored matches. In particular,"] # [doc = " [`AhoCorasick::try_find_overlapping_iter`] does not support this"] # [doc = " because it isn't totally clear what the match semantics ought to be."] # [doc = ""] # [doc = " In this example, we will find all overlapping matches that start at"] # [doc = " the beginning of our search."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     automaton::OverlappingState,"] # [doc = "     AhoCorasick, Anchored, Input, Match, StartKind,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).anchored(Anchored::Yes);"] # [doc = " let mut state = OverlappingState::start();"] # [doc = " let mut matches = vec![];"] # [doc = ""] # [doc = " loop {"] # [doc = "     ac.try_find_overlapping(input.clone(), &mut state)?;"] # [doc = "     let mat = match state.get_match() {"] # [doc = "         None => break,"] # [doc = "         Some(mat) => mat,"] # [doc = "     };"] # [doc = "     matches.push(mat);"] # [doc = " }"] # [doc = " let expected = vec!["] # [doc = "     Match::must(2, 0..3),"] # [doc = "     Match::must(0, 0..6),"] # [doc = " ];"] # [doc = " assert_eq!(expected, matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_find_overlapping < 'h , I : Into < Input < 'h > > > (& self , input : I , state : & mut OverlappingState ,) -> Result < () , MatchError > { let input = input . into () ; enforce_anchored_consistency (self . start_kind , input . get_anchored ()) ? ; self . aut . try_find_overlapping (& input , state) } # [doc = " Returns an iterator of non-overlapping matches, using the match"] # [doc = " semantics that this automaton was constructed with."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::find_iter`]."] # [doc = ""] # [doc = " Note that the error returned by this method occurs during construction"] # [doc = " of the iterator. The iterator itself yields `Match` values. That is,"] # [doc = " once the iterator is constructed, the iteration itself will never"] # [doc = " report an error."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the given `Input` configuration."] # [doc = ""] # [doc = " For example, if the Aho-Corasick searcher only supports anchored"] # [doc = " searches or only supports unanchored searches, then providing an"] # [doc = " `Input` that requests an anchored (or unanchored) search when it isn't"] # [doc = " supported would result in an error."] # [doc = ""] # [doc = " # Example: leftmost-first searching"] # [doc = ""] # [doc = " Basic usage with leftmost-first semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Input, MatchKind, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .try_find_iter(Input::new(haystack))?"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = " ], matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: anchored leftmost-first searching"] # [doc = ""] # [doc = " This shows how to anchor the search, such that all matches must begin"] # [doc = " at the starting location of the search. For an iterator, an anchored"] # [doc = " search implies that all matches are adjacent."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     AhoCorasick, Anchored, Input, MatchKind, PatternID, StartKind,"] # [doc = " };"] # [doc = ""] # [doc = " let patterns = &[\"foo\", \"bar\", \"quux\"];"] # [doc = " let haystack = \"fooquuxbar foo\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .try_find_iter(Input::new(haystack).anchored(Anchored::Yes))?"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(1),"] # [doc = "     // The final 'foo' is not found because it is not adjacent to the"] # [doc = "     // 'bar' match. It needs to be adjacent because our search is"] # [doc = "     // anchored."] # [doc = " ], matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_find_iter < 'a , 'h , I : Into < Input < 'h > > > (& 'a self , input : I ,) -> Result < FindIter < 'a , 'h > , MatchError > { let input = input . into () ; enforce_anchored_consistency (self . start_kind , input . get_anchored ()) ? ; Ok (FindIter (self . aut . try_find_iter (input) ?)) } # [doc = " Returns an iterator of overlapping matches."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::find_overlapping_iter`]."] # [doc = ""] # [doc = " Note that the error returned by this method occurs during construction"] # [doc = " of the iterator. The iterator itself yields `Match` values. That is,"] # [doc = " once the iterator is constructed, the iteration itself will never"] # [doc = " report an error."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the given `Input` configuration or does not support overlapping"] # [doc = " searches."] # [doc = ""] # [doc = " One example is that only Aho-Corasicker searchers built with"] # [doc = " [`MatchKind::Standard`] semantics support overlapping searches. Using"] # [doc = " any other match semantics will result in this returning an error."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Input, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let matches: Vec<PatternID> = ac"] # [doc = "     .try_find_overlapping_iter(Input::new(haystack))?"] # [doc = "     .map(|mat| mat.pattern())"] # [doc = "     .collect();"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(0),"] # [doc = "     PatternID::must(1),"] # [doc = " ], matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: anchored overlapping search returns an error"] # [doc = ""] # [doc = " It isn't clear what the match semantics for anchored overlapping"] # [doc = " iterators *ought* to be, so currently an error is returned. Callers"] # [doc = " may use [`AhoCorasick::try_find_overlapping`] to implement their own"] # [doc = " semantics if desired."] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, Anchored, Input, StartKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"appendappendage app\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let input = Input::new(haystack).anchored(Anchored::Yes);"] # [doc = " assert!(ac.try_find_overlapping_iter(input).is_err());"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_find_overlapping_iter < 'a , 'h , I : Into < Input < 'h > > > (& 'a self , input : I ,) -> Result < FindOverlappingIter < 'a , 'h > , MatchError > { let input = input . into () ; enforce_anchored_consistency (self . start_kind , input . get_anchored ()) ? ; Ok (FindOverlappingIter (self . aut . try_find_overlapping_iter (input) ?)) } # [doc = " Replace all matches with a corresponding value in the `replace_with`"] # [doc = " slice given. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " Replacements are determined by the index of the matching pattern."] # [doc = " For example, if the pattern with index `2` is found, then it is"] # [doc = " replaced by `replace_with[2]`."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `replace_with.len()` does not equal"] # [doc = " [`AhoCorasick::patterns_len`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this replacement routine always does an unanchored search."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let result = ac.try_replace_all(haystack, &[\"x\", \"y\", \"z\"])?;"] # [doc = " assert_eq!(\"x the z to the xage\", result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_replace_all < B > (& self , haystack : & str , replace_with : & [B] ,) -> Result < String , MatchError > where B : AsRef < str > , { enforce_anchored_consistency (self . start_kind , Anchored :: No) ? ; self . aut . try_replace_all (haystack , replace_with) } # [doc = " Replace all matches using raw bytes with a corresponding value in the"] # [doc = " `replace_with` slice given. Matches correspond to the same matches as"] # [doc = " reported by [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " Replacements are determined by the index of the matching pattern."] # [doc = " For example, if the pattern with index `2` is found, then it is"] # [doc = " replaced by `replace_with[2]`."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::replace_all_bytes`]."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `replace_with.len()` does not equal"] # [doc = " [`AhoCorasick::patterns_len`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this replacement routine always does an unanchored search."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = b\"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let result = ac.try_replace_all_bytes(haystack, &[\"x\", \"y\", \"z\"])?;"] # [doc = " assert_eq!(b\"x the z to the xage\".to_vec(), result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_replace_all_bytes < B > (& self , haystack : & [u8] , replace_with : & [B] ,) -> Result < Vec < u8 > , MatchError > where B : AsRef < [u8] > , { enforce_anchored_consistency (self . start_kind , Anchored :: No) ? ; self . aut . try_replace_all_bytes (haystack , replace_with) } # [doc = " Replace all matches using a closure called on each match."] # [doc = " Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " The closure accepts three parameters: the match found, the text of"] # [doc = " the match and a string buffer with which to write the replaced text"] # [doc = " (if any). If the closure returns `true`, then it continues to the next"] # [doc = " match. If the closure returns `false`, then searching is stopped."] # [doc = ""] # [doc = " Note that any matches with boundaries that don't fall on a valid UTF-8"] # [doc = " boundary are silently skipped."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::replace_all_with`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this replacement routine always does an unanchored search."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut result = String::new();"] # [doc = " ac.try_replace_all_with(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.push_str(&mat.pattern().as_usize().to_string());"] # [doc = "     true"] # [doc = " })?;"] # [doc = " assert_eq!(\"0 the 2 to the 0age\", result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " Stopping the replacement by returning `false` (continued from the"] # [doc = " example above):"] # [doc = ""] # [doc = " ```"] # [doc = " # use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = " # let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " # let haystack = \"append the app to the appendage\";"] # [doc = " # let ac = AhoCorasick::builder()"] # [doc = " #    .match_kind(MatchKind::LeftmostFirst)"] # [doc = " #    .build(patterns)"] # [doc = " #    .unwrap();"] # [doc = " let mut result = String::new();"] # [doc = " ac.try_replace_all_with(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.push_str(&mat.pattern().as_usize().to_string());"] # [doc = "     mat.pattern() != PatternID::must(2)"] # [doc = " })?;"] # [doc = " assert_eq!(\"0 the 2 to the appendage\", result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_replace_all_with < F > (& self , haystack : & str , dst : & mut String , replace_with : F ,) -> Result < () , MatchError > where F : FnMut (& Match , & str , & mut String) -> bool , { enforce_anchored_consistency (self . start_kind , Anchored :: No) ? ; self . aut . try_replace_all_with (haystack , dst , replace_with) } # [doc = " Replace all matches using raw bytes with a closure called on each"] # [doc = " match. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " The closure accepts three parameters: the match found, the text of"] # [doc = " the match and a byte buffer with which to write the replaced text"] # [doc = " (if any). If the closure returns `true`, then it continues to the next"] # [doc = " match. If the closure returns `false`, then searching is stopped."] # [doc = ""] # [doc = " This is the fallible version of"] # [doc = " [`AhoCorasick::replace_all_with_bytes`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this replacement routine always does an unanchored search."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = b\"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.try_replace_all_with_bytes(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.extend(mat.pattern().as_usize().to_string().bytes());"] # [doc = "     true"] # [doc = " })?;"] # [doc = " assert_eq!(b\"0 the 2 to the 0age\".to_vec(), result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " Stopping the replacement by returning `false` (continued from the"] # [doc = " example above):"] # [doc = ""] # [doc = " ```"] # [doc = " # use aho_corasick::{AhoCorasick, MatchKind, PatternID};"] # [doc = " # let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " # let haystack = b\"append the app to the appendage\";"] # [doc = " # let ac = AhoCorasick::builder()"] # [doc = " #    .match_kind(MatchKind::LeftmostFirst)"] # [doc = " #    .build(patterns)"] # [doc = " #    .unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.try_replace_all_with_bytes(haystack, &mut result, |mat, _, dst| {"] # [doc = "     dst.extend(mat.pattern().as_usize().to_string().bytes());"] # [doc = "     mat.pattern() != PatternID::must(2)"] # [doc = " })?;"] # [doc = " assert_eq!(b\"0 the 2 to the appendage\".to_vec(), result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_replace_all_with_bytes < F > (& self , haystack : & [u8] , dst : & mut Vec < u8 > , replace_with : F ,) -> Result < () , MatchError > where F : FnMut (& Match , & [u8] , & mut Vec < u8 >) -> bool , { enforce_anchored_consistency (self . start_kind , Anchored :: No) ? ; self . aut . try_replace_all_with_bytes (haystack , dst , replace_with) } # [doc = " Returns an iterator of non-overlapping matches in the given"] # [doc = " stream. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " The matches yielded by this iterator use absolute position offsets in"] # [doc = " the stream given, where the first byte has index `0`. Matches are"] # [doc = " yieled until the stream is exhausted."] # [doc = ""] # [doc = " Each item yielded by the iterator is an `Result<Match,"] # [doc = " std::io::Error>`, where an error is yielded if there was a problem"] # [doc = " reading from the reader given."] # [doc = ""] # [doc = " When searching a stream, an internal buffer is used. Therefore, callers"] # [doc = " should avoiding providing a buffered reader, if possible."] # [doc = ""] # [doc = " This is the fallible version of [`AhoCorasick::stream_find_iter`]."] # [doc = " Note that both methods return iterators that produce `Result` values."] # [doc = " The difference is that this routine returns an error if _construction_"] # [doc = " of the iterator failed. The `Result` values yield by the iterator"] # [doc = " come from whether the given reader returns an error or not during the"] # [doc = " search."] # [doc = ""] # [doc = " # Memory usage"] # [doc = ""] # [doc = " In general, searching streams will use a constant amount of memory for"] # [doc = " its internal buffer. The one requirement is that the internal buffer"] # [doc = " must be at least the size of the longest possible match. In most use"] # [doc = " cases, the default buffer size will be much larger than any individual"] # [doc = " match."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this stream searching routine always does an unanchored search."] # [doc = ""] # [doc = " This also returns an error if the searcher does not support stream"] # [doc = " searches. Only searchers built with [`MatchKind::Standard`] semantics"] # [doc = " support stream searches."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"append\", \"appendage\", \"app\"];"] # [doc = " let haystack = \"append the app to the appendage\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut matches = vec![];"] # [doc = " for result in ac.try_stream_find_iter(haystack.as_bytes())? {"] # [doc = "     let mat = result?;"] # [doc = "     matches.push(mat.pattern());"] # [doc = " }"] # [doc = " assert_eq!(vec!["] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = "     PatternID::must(2),"] # [doc = " ], matches);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_stream_find_iter < 'a , R : std :: io :: Read > (& 'a self , rdr : R ,) -> Result < StreamFindIter < 'a , R > , MatchError > { enforce_anchored_consistency (self . start_kind , Anchored :: No) ? ; self . aut . try_stream_find_iter (rdr) . map (StreamFindIter) } # [doc = " Search for and replace all matches of this automaton in"] # [doc = " the given reader, and write the replacements to the given"] # [doc = " writer. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " Replacements are determined by the index of the matching pattern. For"] # [doc = " example, if the pattern with index `2` is found, then it is replaced by"] # [doc = " `replace_with[2]`."] # [doc = ""] # [doc = " After all matches are replaced, the writer is _not_ flushed."] # [doc = ""] # [doc = " If there was a problem reading from the given reader or writing to the"] # [doc = " given writer, then the corresponding `io::Error` is returned and all"] # [doc = " replacement is stopped."] # [doc = ""] # [doc = " When searching a stream, an internal buffer is used. Therefore, callers"] # [doc = " should avoiding providing a buffered reader, if possible. However,"] # [doc = " callers may want to provide a buffered writer."] # [doc = ""] # [doc = " Note that there is currently no infallible version of this routine."] # [doc = ""] # [doc = " # Memory usage"] # [doc = ""] # [doc = " In general, searching streams will use a constant amount of memory for"] # [doc = " its internal buffer. The one requirement is that the internal buffer"] # [doc = " must be at least the size of the longest possible match. In most use"] # [doc = " cases, the default buffer size will be much larger than any individual"] # [doc = " match."] # [doc = ""] # [doc = " # Panics"] # [doc = ""] # [doc = " This panics when `replace_with.len()` does not equal"] # [doc = " [`AhoCorasick::patterns_len`]."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this stream searching routine always does an unanchored search."] # [doc = ""] # [doc = " This also returns an error if the searcher does not support stream"] # [doc = " searches. Only searchers built with [`MatchKind::Standard`] semantics"] # [doc = " support stream searches."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let patterns = &[\"fox\", \"brown\", \"quick\"];"] # [doc = " let haystack = \"The quick brown fox.\";"] # [doc = " let replace_with = &[\"sloth\", \"grey\", \"slow\"];"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.try_stream_replace_all("] # [doc = "     haystack.as_bytes(),"] # [doc = "     &mut result,"] # [doc = "     replace_with,"] # [doc = " )?;"] # [doc = " assert_eq!(b\"The slow grey sloth.\".to_vec(), result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_stream_replace_all < R , W , B > (& self , rdr : R , wtr : W , replace_with : & [B] ,) -> Result < () , std :: io :: Error > where R : std :: io :: Read , W : std :: io :: Write , B : AsRef < [u8] > , { enforce_anchored_consistency (self . start_kind , Anchored :: No) . map_err (| e | std :: io :: Error :: new (std :: io :: ErrorKind :: Other , e)) ? ; self . aut . try_stream_replace_all (rdr , wtr , replace_with) } # [doc = " Search the given reader and replace all matches of this automaton"] # [doc = " using the given closure. The result is written to the given"] # [doc = " writer. Matches correspond to the same matches as reported by"] # [doc = " [`AhoCorasick::try_find_iter`]."] # [doc = ""] # [doc = " The closure accepts three parameters: the match found, the text of"] # [doc = " the match and the writer with which to write the replaced text (if any)."] # [doc = ""] # [doc = " After all matches are replaced, the writer is _not_ flushed."] # [doc = ""] # [doc = " If there was a problem reading from the given reader or writing to the"] # [doc = " given writer, then the corresponding `io::Error` is returned and all"] # [doc = " replacement is stopped."] # [doc = ""] # [doc = " When searching a stream, an internal buffer is used. Therefore, callers"] # [doc = " should avoiding providing a buffered reader, if possible. However,"] # [doc = " callers may want to provide a buffered writer."] # [doc = ""] # [doc = " Note that there is currently no infallible version of this routine."] # [doc = ""] # [doc = " # Memory usage"] # [doc = ""] # [doc = " In general, searching streams will use a constant amount of memory for"] # [doc = " its internal buffer. The one requirement is that the internal buffer"] # [doc = " must be at least the size of the longest possible match. In most use"] # [doc = " cases, the default buffer size will be much larger than any individual"] # [doc = " match."] # [doc = ""] # [doc = " # Errors"] # [doc = ""] # [doc = " This returns an error when this Aho-Corasick searcher does not support"] # [doc = " the default `Input` configuration. More specifically, this occurs only"] # [doc = " when the Aho-Corasick searcher does not support unanchored searches"] # [doc = " since this stream searching routine always does an unanchored search."] # [doc = ""] # [doc = " This also returns an error if the searcher does not support stream"] # [doc = " searches. Only searchers built with [`MatchKind::Standard`] semantics"] # [doc = " support stream searches."] # [doc = ""] # [doc = " # Example: basic usage"] # [doc = ""] # [doc = " ```"] # [doc = " use std::io::Write;"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let patterns = &[\"fox\", \"brown\", \"quick\"];"] # [doc = " let haystack = \"The quick brown fox.\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(patterns).unwrap();"] # [doc = " let mut result = vec![];"] # [doc = " ac.try_stream_replace_all_with("] # [doc = "     haystack.as_bytes(),"] # [doc = "     &mut result,"] # [doc = "     |mat, _, wtr| {"] # [doc = "         wtr.write_all(mat.pattern().as_usize().to_string().as_bytes())"] # [doc = "     },"] # [doc = " )?;"] # [doc = " assert_eq!(b\"The 2 1 0.\".to_vec(), result);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn try_stream_replace_all_with < R , W , F > (& self , rdr : R , wtr : W , replace_with : F ,) -> Result < () , std :: io :: Error > where R : std :: io :: Read , W : std :: io :: Write , F : FnMut (& Match , & [u8] , & mut W) -> Result < () , std :: io :: Error > , { enforce_anchored_consistency (self . start_kind , Anchored :: No) . map_err (| e | std :: io :: Error :: new (std :: io :: ErrorKind :: Other , e)) ? ; self . aut . try_stream_replace_all_with (rdr , wtr , replace_with) } } # [doc = " Routines for querying information about the Aho-Corasick automaton."] impl AhoCorasick { # [doc = " Returns the kind of the Aho-Corasick automaton used by this searcher."] # [doc = ""] # [doc = " Knowing the Aho-Corasick kind is principally useful for diagnostic"] # [doc = " purposes. In particular, if no specific kind was given to"] # [doc = " [`AhoCorasickBuilder::kind`], then one is automatically chosen and"] # [doc = " this routine will report which one."] # [doc = ""] # [doc = " Note that the heuristics used for choosing which `AhoCorasickKind`"] # [doc = " may be changed in a semver compatible release."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, AhoCorasickKind};"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"quux\", \"baz\"]).unwrap();"] # [doc = " // The specific Aho-Corasick kind chosen is not guaranteed!"] # [doc = " assert_eq!(AhoCorasickKind::DFA, ac.kind());"] # [doc = " ```"] pub fn kind (& self) -> AhoCorasickKind { self . kind } # [doc = " Returns the type of starting search configuration supported by this"] # [doc = " Aho-Corasick automaton."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, StartKind};"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"quux\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(StartKind::Unanchored, ac.start_kind());"] # [doc = " ```"] pub fn start_kind (& self) -> StartKind { self . start_kind } # [doc = " Returns the match kind used by this automaton."] # [doc = ""] # [doc = " The match kind is important because it determines what kinds of"] # [doc = " matches are returned. Also, some operations (such as overlapping"] # [doc = " search and stream searching) are only supported when using the"] # [doc = " [`MatchKind::Standard`] match kind."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"quux\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(MatchKind::Standard, ac.match_kind());"] # [doc = " ```"] pub fn match_kind (& self) -> MatchKind { self . aut . match_kind () } # [doc = " Returns the length of the shortest pattern matched by this automaton."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"quux\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(3, ac.min_pattern_len());"] # [doc = " ```"] # [doc = ""] # [doc = " Note that an `AhoCorasick` automaton has a minimum length of `0` if"] # [doc = " and only if it can match the empty string:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"\", \"quux\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(0, ac.min_pattern_len());"] # [doc = " ```"] pub fn min_pattern_len (& self) -> usize { self . aut . min_pattern_len () } # [doc = " Returns the length of the longest pattern matched by this automaton."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"quux\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(4, ac.max_pattern_len());"] # [doc = " ```"] pub fn max_pattern_len (& self) -> usize { self . aut . max_pattern_len () } # [doc = " Return the total number of patterns matched by this automaton."] # [doc = ""] # [doc = " This includes patterns that may never participate in a match. For"] # [doc = " example, if [`MatchKind::LeftmostFirst`] match semantics are used, and"] # [doc = " the patterns `Sam` and `Samwise` were used to build the automaton (in"] # [doc = " that order), then `Samwise` can never participate in a match because"] # [doc = " `Sam` will always take priority."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let ac = AhoCorasick::new(&[\"foo\", \"bar\", \"baz\"]).unwrap();"] # [doc = " assert_eq!(3, ac.patterns_len());"] # [doc = " ```"] pub fn patterns_len (& self) -> usize { self . aut . patterns_len () } # [doc = " Returns the approximate total amount of heap used by this automaton, in"] # [doc = " units of bytes."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " This example shows the difference in heap usage between a few"] # [doc = " configurations:"] # [doc = ""] # [doc = " ```"] # [doc = " # if !cfg!(target_pointer_width = \"64\") { return; }"] # [doc = " use aho_corasick::{AhoCorasick, AhoCorasickKind, MatchKind};"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .kind(None) // default"] # [doc = "     .build(&[\"foobar\", \"bruce\", \"triskaidekaphobia\", \"springsteen\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(5_632, ac.memory_usage());"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .kind(None) // default"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(&[\"foobar\", \"bruce\", \"triskaidekaphobia\", \"springsteen\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(11_136, ac.memory_usage());"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .kind(Some(AhoCorasickKind::NoncontiguousNFA))"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(&[\"foobar\", \"bruce\", \"triskaidekaphobia\", \"springsteen\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(10_879, ac.memory_usage());"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .kind(Some(AhoCorasickKind::ContiguousNFA))"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(&[\"foobar\", \"bruce\", \"triskaidekaphobia\", \"springsteen\"])"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(2_584, ac.memory_usage());"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .kind(Some(AhoCorasickKind::DFA))"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(&[\"foobar\", \"bruce\", \"triskaidekaphobia\", \"springsteen\"])"] # [doc = "     .unwrap();"] # [doc = " // While this shows the DFA being the biggest here by a small margin,"] # [doc = " // don't let the difference fool you. With such a small number of"] # [doc = " // patterns, the difference is small, but a bigger number of patterns"] # [doc = " // will reveal that the rate of growth of the DFA is far bigger than"] # [doc = " // the NFAs above. For a large number of patterns, it is easy for the"] # [doc = " // DFA to take an order of magnitude more heap space (or more!)."] # [doc = " assert_eq!(11_136, ac.memory_usage());"] # [doc = " ```"] pub fn memory_usage (& self) -> usize { self . aut . memory_usage () } } impl core :: fmt :: Debug for AhoCorasick { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_tuple ("AhoCorasick") . field (& self . aut) . finish () } } # [doc = " An iterator of non-overlapping matches in a particular haystack."] # [doc = ""] # [doc = " This iterator yields matches according to the [`MatchKind`] used by this"] # [doc = " automaton."] # [doc = ""] # [doc = " This iterator is constructed via the [`AhoCorasick::find_iter`] and"] # [doc = " [`AhoCorasick::try_find_iter`] methods."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the `AhoCorasick` automaton."] # [doc = ""] # [doc = " The lifetime `'h` refers to the lifetime of the haystack being searched."] pub struct FindIter < 'a , 'h > (automaton :: FindIter < 'a , 'h , Arc < dyn AcAutomaton > >) ; # [automatically_derived] impl < 'a , 'h > :: core :: fmt :: Debug for FindIter < 'a , 'h > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "FindIter" , & & self . 0) } } impl < 'a , 'h > Iterator for FindIter < 'a , 'h > { type Item = Match ; # [inline] fn next (& mut self) -> Option < Match > { self . 0 . next () } } # [doc = " An iterator of overlapping matches in a particular haystack."] # [doc = ""] # [doc = " This iterator will report all possible matches in a particular haystack,"] # [doc = " even when the matches overlap."] # [doc = ""] # [doc = " This iterator is constructed via the [`AhoCorasick::find_overlapping_iter`]"] # [doc = " and [`AhoCorasick::try_find_overlapping_iter`] methods."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the `AhoCorasick` automaton."] # [doc = ""] # [doc = " The lifetime `'h` refers to the lifetime of the haystack being searched."] pub struct FindOverlappingIter < 'a , 'h > (automaton :: FindOverlappingIter < 'a , 'h , Arc < dyn AcAutomaton > > ,) ; # [automatically_derived] impl < 'a , 'h > :: core :: fmt :: Debug for FindOverlappingIter < 'a , 'h > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "FindOverlappingIter" , & & self . 0 ,) } } impl < 'a , 'h > Iterator for FindOverlappingIter < 'a , 'h > { type Item = Match ; # [inline] fn next (& mut self) -> Option < Match > { self . 0 . next () } } # [doc = " An iterator that reports Aho-Corasick matches in a stream."] # [doc = ""] # [doc = " This iterator yields elements of type `Result<Match, std::io::Error>`,"] # [doc = " where an error is reported if there was a problem reading from the"] # [doc = " underlying stream. The iterator terminates only when the underlying stream"] # [doc = " reaches `EOF`."] # [doc = ""] # [doc = " This iterator is constructed via the [`AhoCorasick::stream_find_iter`] and"] # [doc = " [`AhoCorasick::try_stream_find_iter`] methods."] # [doc = ""] # [doc = " The type variable `R` refers to the `io::Read` stream that is being read"] # [doc = " from."] # [doc = ""] # [doc = " The lifetime `'a` refers to the lifetime of the corresponding"] # [doc = " [`AhoCorasick`] searcher."] pub struct StreamFindIter < 'a , R > (automaton :: StreamFindIter < 'a , Arc < dyn AcAutomaton > , R > ,) ; # [automatically_derived] impl < 'a , R : :: core :: fmt :: Debug > :: core :: fmt :: Debug for StreamFindIter < 'a , R > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "StreamFindIter" , & & self . 0 ,) } } impl < 'a , R : std :: io :: Read > Iterator for StreamFindIter < 'a , R > { type Item = Result < Match , std :: io :: Error > ; fn next (& mut self) -> Option < Result < Match , std :: io :: Error > > { self . 0 . next () } } # [doc = " A builder for configuring an Aho-Corasick automaton."] # [doc = ""] # [doc = " # Quick advice"] # [doc = ""] # [doc = " * Use [`AhoCorasickBuilder::match_kind`] to configure your searcher"] # [doc = " with [`MatchKind::LeftmostFirst`] if you want to match how backtracking"] # [doc = " regex engines execute searches for `pat1|pat2|..|patN`. Use"] # [doc = " [`MatchKind::LeftmostLongest`] if you want to match how POSIX regex engines"] # [doc = " do it."] # [doc = " * If you need an anchored search, use [`AhoCorasickBuilder::start_kind`] to"] # [doc = " set the [`StartKind::Anchored`] mode since [`StartKind::Unanchored`] is the"] # [doc = " default. Or just use [`StartKind::Both`] to support both types of searches."] # [doc = " * You might want to use [`AhoCorasickBuilder::kind`] to set your searcher"] # [doc = " to always use a [`AhoCorasickKind::DFA`] if search speed is critical and"] # [doc = " memory usage isn't a concern. Otherwise, not setting a kind will probably"] # [doc = " make the right choice for you. Beware that if you use [`StartKind::Both`]"] # [doc = " to build a searcher that supports both unanchored and anchored searches"] # [doc = " _and_ you set [`AhoCorasickKind::DFA`], then the DFA will essentially be"] # [doc = " duplicated to support both simultaneously. This results in very high memory"] # [doc = " usage."] # [doc = " * For all other options, their defaults are almost certainly what you want."] pub struct AhoCorasickBuilder { nfa_noncontiguous : noncontiguous :: Builder , nfa_contiguous : contiguous :: Builder , dfa : dfa :: Builder , kind : Option < AhoCorasickKind > , start_kind : StartKind , } # [automatically_derived] impl :: core :: clone :: Clone for AhoCorasickBuilder { # [inline] fn clone (& self) -> AhoCorasickBuilder { AhoCorasickBuilder { nfa_noncontiguous : :: core :: clone :: Clone :: clone (& self . nfa_noncontiguous) , nfa_contiguous : :: core :: clone :: Clone :: clone (& self . nfa_contiguous) , dfa : :: core :: clone :: Clone :: clone (& self . dfa) , kind : :: core :: clone :: Clone :: clone (& self . kind) , start_kind : :: core :: clone :: Clone :: clone (& self . start_kind) , } } } # [automatically_derived] impl :: core :: fmt :: Debug for AhoCorasickBuilder { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field5_finish (f , "AhoCorasickBuilder" , "nfa_noncontiguous" , & self . nfa_noncontiguous , "nfa_contiguous" , & self . nfa_contiguous , "dfa" , & self . dfa , "kind" , & self . kind , "start_kind" , & & self . start_kind ,) } } # [automatically_derived] impl :: core :: default :: Default for AhoCorasickBuilder { # [inline] fn default () -> AhoCorasickBuilder { AhoCorasickBuilder { nfa_noncontiguous : :: core :: default :: Default :: default () , nfa_contiguous : :: core :: default :: Default :: default () , dfa : :: core :: default :: Default :: default () , kind : :: core :: default :: Default :: default () , start_kind : :: core :: default :: Default :: default () , } } } impl AhoCorasickBuilder { # [doc = " Create a new builder for configuring an Aho-Corasick automaton."] # [doc = ""] # [doc = " The builder provides a way to configure a number of things, including"] # [doc = " ASCII case insensitivity and what kind of match semantics are used."] pub fn new () -> AhoCorasickBuilder { AhoCorasickBuilder :: default () } # [doc = " Build an Aho-Corasick automaton using the configuration set on this"] # [doc = " builder."] # [doc = ""] # [doc = " A builder may be reused to create more automatons."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasickBuilder, PatternID};"] # [doc = ""] # [doc = " let patterns = &[\"foo\", \"bar\", \"baz\"];"] # [doc = " let ac = AhoCorasickBuilder::new().build(patterns).unwrap();"] # [doc = " assert_eq!("] # [doc = "     Some(PatternID::must(1)),"] # [doc = "     ac.find(\"xxx bar xxx\").map(|m| m.pattern()),"] # [doc = " );"] # [doc = " ```"] pub fn build < I , P > (& self , patterns : I) -> Result < AhoCorasick , BuildError > where I : IntoIterator < Item = P > , P : AsRef < [u8] > , { let nfa = self . nfa_noncontiguous . build (patterns) ? ; let (aut , kind) : (Arc < dyn AcAutomaton > , AhoCorasickKind) = match self . kind { None => { self . build_auto (nfa) } Some (AhoCorasickKind :: NoncontiguousNFA) => { (Arc :: new (nfa) , AhoCorasickKind :: NoncontiguousNFA) } Some (AhoCorasickKind :: ContiguousNFA) => { let cnfa = self . nfa_contiguous . build_from_noncontiguous (& nfa) ? ; (Arc :: new (cnfa) , AhoCorasickKind :: ContiguousNFA) } Some (AhoCorasickKind :: DFA) => { let dfa = self . dfa . build_from_noncontiguous (& nfa) ? ; (Arc :: new (dfa) , AhoCorasickKind :: DFA) } } ; Ok (AhoCorasick { aut , kind , start_kind : self . start_kind , }) } # [doc = " Implements the automatic selection logic for the Aho-Corasick"] # [doc = " implementation to use. Since all Aho-Corasick automatons are built"] # [doc = " from a non-contiguous NFA, the caller is responsible for building"] # [doc = " that first."] fn build_auto (& self , nfa : noncontiguous :: NFA ,) -> (Arc < dyn AcAutomaton > , AhoCorasickKind) { let try_dfa = ! # [allow (non_exhaustive_omitted_patterns)] match self . start_kind { StartKind :: Both => true , _ => false , } && nfa . patterns_len () <= 100 ; if try_dfa { match self . dfa . build_from_noncontiguous (& nfa) { Ok (dfa) => { return (Arc :: new (dfa) , AhoCorasickKind :: DFA) ; } Err (_err) => { } } } match self . nfa_contiguous . build_from_noncontiguous (& nfa) { Ok (nfa) => { return (Arc :: new (nfa) , AhoCorasickKind :: ContiguousNFA) ; } # [allow (unused_variables)] Err (_err) => { } } ; (Arc :: new (nfa) , AhoCorasickKind :: NoncontiguousNFA) } # [doc = " Set the desired match semantics."] # [doc = ""] # [doc = " The default is [`MatchKind::Standard`], which corresponds to the match"] # [doc = " semantics supported by the standard textbook description of the"] # [doc = " Aho-Corasick algorithm. Namely, matches are reported as soon as they"] # [doc = " are found. Moreover, this is the only way to get overlapping matches"] # [doc = " or do stream searching."] # [doc = ""] # [doc = " The other kinds of match semantics that are supported are"] # [doc = " [`MatchKind::LeftmostFirst`] and [`MatchKind::LeftmostLongest`]. The"] # [doc = " former corresponds to the match you would get if you were to try to"] # [doc = " match each pattern at each position in the haystack in the same order"] # [doc = " that you give to the automaton. That is, it returns the leftmost match"] # [doc = " corresponding to the earliest pattern given to the automaton. The"] # [doc = " latter corresponds to finding the longest possible match among all"] # [doc = " leftmost matches."] # [doc = ""] # [doc = " For more details on match semantics, see the [documentation for"] # [doc = " `MatchKind`](MatchKind)."] # [doc = ""] # [doc = " Note that setting this to [`MatchKind::LeftmostFirst`] or"] # [doc = " [`MatchKind::LeftmostLongest`] will cause some search routines on"] # [doc = " [`AhoCorasick`] to return an error (or panic if you're using the"] # [doc = " infallible API). Notably, this includes stream and overlapping"] # [doc = " searches."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " In these examples, we demonstrate the differences between match"] # [doc = " semantics for a particular set of patterns in a specific order:"] # [doc = " `b`, `abc`, `abcd`."] # [doc = ""] # [doc = " Standard semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::Standard) // default, not necessary"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " assert_eq!(\"b\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] # [doc = ""] # [doc = " Leftmost-first semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " assert_eq!(\"abc\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] # [doc = ""] # [doc = " Leftmost-longest semantics:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{AhoCorasick, MatchKind};"] # [doc = ""] # [doc = " let patterns = &[\"b\", \"abc\", \"abcd\"];"] # [doc = " let haystack = \"abcd\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostLongest)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " let mat = ac.find(haystack).expect(\"should have a match\");"] # [doc = " assert_eq!(\"abcd\", &haystack[mat.start()..mat.end()]);"] # [doc = " ```"] pub fn match_kind (& mut self , kind : MatchKind) -> & mut AhoCorasickBuilder { self . nfa_noncontiguous . match_kind (kind) ; self . nfa_contiguous . match_kind (kind) ; self . dfa . match_kind (kind) ; self } # [doc = " Sets the starting state configuration for the automaton."] # [doc = ""] # [doc = " Every Aho-Corasick automaton is capable of having two start states: one"] # [doc = " that is used for unanchored searches and one that is used for anchored"] # [doc = " searches. Some automatons, like the NFAs, support this with almost zero"] # [doc = " additional cost. Other automatons, like the DFA, require two copies of"] # [doc = " the underlying transition table to support both simultaneously."] # [doc = ""] # [doc = " Because there may be an added non-trivial cost to supporting both, it"] # [doc = " is possible to configure which starting state configuration is needed."] # [doc = ""] # [doc = " Indeed, since anchored searches tend to be somewhat more rare,"] # [doc = " _only_ unanchored searches are supported by default. Thus,"] # [doc = " [`StartKind::Unanchored`] is the default."] # [doc = ""] # [doc = " Note that when this is set to [`StartKind::Unanchored`], then"] # [doc = " running an anchored search will result in an error (or a panic"] # [doc = " if using the infallible APIs). Similarly, when this is set to"] # [doc = " [`StartKind::Anchored`], then running an unanchored search will"] # [doc = " result in an error (or a panic if using the infallible APIs). When"] # [doc = " [`StartKind::Both`] is used, then both unanchored and anchored searches"] # [doc = " are always supported."] # [doc = ""] # [doc = " Also note that even if an `AhoCorasick` searcher is using an NFA"] # [doc = " internally (which always supports both unanchored and anchored"] # [doc = " searches), an error will still be reported for a search that isn't"] # [doc = " supported by the configuration set via this method. This means,"] # [doc = " for example, that an error is never dependent on which internal"] # [doc = " implementation of Aho-Corasick is used."] # [doc = ""] # [doc = " # Example: anchored search"] # [doc = ""] # [doc = " This shows how to build a searcher that only supports anchored"] # [doc = " searches:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     AhoCorasick, Anchored, Input, Match, MatchKind, StartKind,"] # [doc = " };"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .start_kind(StartKind::Anchored)"] # [doc = "     .build(&[\"b\", \"abc\", \"abcd\"])"] # [doc = "     .unwrap();"] # [doc = ""] # [doc = " // An unanchored search is not supported! An error here is guaranteed"] # [doc = " // given the configuration above regardless of which kind of"] # [doc = " // Aho-Corasick implementation ends up being used internally."] # [doc = " let input = Input::new(\"foo abcd\").anchored(Anchored::No);"] # [doc = " assert!(ac.try_find(input).is_err());"] # [doc = ""] # [doc = " let input = Input::new(\"foo abcd\").anchored(Anchored::Yes);"] # [doc = " assert_eq!(None, ac.try_find(input)?);"] # [doc = ""] # [doc = " let input = Input::new(\"abcd\").anchored(Anchored::Yes);"] # [doc = " assert_eq!(Some(Match::must(1, 0..3)), ac.try_find(input)?);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] # [doc = ""] # [doc = " # Example: unanchored and anchored searches"] # [doc = ""] # [doc = " This shows how to build a searcher that supports both unanchored and"] # [doc = " anchored searches:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::{"] # [doc = "     AhoCorasick, Anchored, Input, Match, MatchKind, StartKind,"] # [doc = " };"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .match_kind(MatchKind::LeftmostFirst)"] # [doc = "     .start_kind(StartKind::Both)"] # [doc = "     .build(&[\"b\", \"abc\", \"abcd\"])"] # [doc = "     .unwrap();"] # [doc = ""] # [doc = " let input = Input::new(\"foo abcd\").anchored(Anchored::No);"] # [doc = " assert_eq!(Some(Match::must(1, 4..7)), ac.try_find(input)?);"] # [doc = ""] # [doc = " let input = Input::new(\"foo abcd\").anchored(Anchored::Yes);"] # [doc = " assert_eq!(None, ac.try_find(input)?);"] # [doc = ""] # [doc = " let input = Input::new(\"abcd\").anchored(Anchored::Yes);"] # [doc = " assert_eq!(Some(Match::must(1, 0..3)), ac.try_find(input)?);"] # [doc = ""] # [doc = " # Ok::<(), Box<dyn std::error::Error>>(())"] # [doc = " ```"] pub fn start_kind (& mut self , kind : StartKind) -> & mut AhoCorasickBuilder { self . dfa . start_kind (kind) ; self . start_kind = kind ; self } # [doc = " Enable ASCII-aware case insensitive matching."] # [doc = ""] # [doc = " When this option is enabled, searching will be performed without"] # [doc = " respect to case for ASCII letters (`a-z` and `A-Z`) only."] # [doc = ""] # [doc = " Enabling this option does not change the search algorithm, but it may"] # [doc = " increase the size of the automaton."] # [doc = ""] # [doc = " **NOTE:** It is unlikely that support for Unicode case folding will"] # [doc = " be added in the future. The ASCII case works via a simple hack to the"] # [doc = " underlying automaton, but full Unicode handling requires a fair bit of"] # [doc = " sophistication. If you do need Unicode handling, you might consider"] # [doc = " using the [`regex` crate](https://docs.rs/regex) or the lower level"] # [doc = " [`regex-automata` crate](https://docs.rs/regex-automata)."] # [doc = ""] # [doc = " # Examples"] # [doc = ""] # [doc = " Basic usage:"] # [doc = ""] # [doc = " ```"] # [doc = " use aho_corasick::AhoCorasick;"] # [doc = ""] # [doc = " let patterns = &[\"FOO\", \"bAr\", \"BaZ\"];"] # [doc = " let haystack = \"foo bar baz\";"] # [doc = ""] # [doc = " let ac = AhoCorasick::builder()"] # [doc = "     .ascii_case_insensitive(true)"] # [doc = "     .build(patterns)"] # [doc = "     .unwrap();"] # [doc = " assert_eq!(3, ac.find_iter(haystack).count());"] # [doc = " ```"] pub fn ascii_case_insensitive (& mut self , yes : bool) -> & mut AhoCorasickBuilder { self . nfa_noncontiguous . ascii_case_insensitive (yes) ; self . nfa_contiguous . ascii_case_insensitive (yes) ; self . dfa . ascii_case_insensitive (yes) ; self } # [doc = " Choose the type of underlying automaton to use."] # [doc = ""] # [doc = " Currently, there are four choices:"] # [doc = ""] # [doc = " * [`AhoCorasickKind::NoncontiguousNFA`] instructs the searcher to"] # [doc = " use a [`noncontiguous::NFA`]. A noncontiguous NFA is the fastest to"] # [doc = " be built, has moderate memory usage and is typically the slowest to"] # [doc = " execute a search."] # [doc = " * [`AhoCorasickKind::ContiguousNFA`] instructs the searcher to use a"] # [doc = " [`contiguous::NFA`]. A contiguous NFA is a little slower to build than"] # [doc = " a noncontiguous NFA, has excellent memory usage and is typically a"] # [doc = " little slower than a DFA for a search."] # [doc = " * [`AhoCorasickKind::DFA`] instructs the searcher to use a"] # [doc = " [`dfa::DFA`]. A DFA is very slow to build, uses exorbitant amounts of"] # [doc = " memory, but will typically execute searches the fastest."] # [doc = " * `None` (the default) instructs the searcher to choose the \"best\""] # [doc = " Aho-Corasick implementation. This choice is typically based primarily"] # [doc = " on the number of patterns."] # [doc = ""] # [doc = " Setting this configuration does not change the time complexity for"] # [doc = " constructing the Aho-Corasick automaton (which is `O(p)` where `p`"] # [doc = " is the total number of patterns being compiled). Setting this to"] # [doc = " [`AhoCorasickKind::DFA`] does however reduce the time complexity of"] # [doc = " non-overlapping searches from `O(n + p)` to `O(n)`, where `n` is the"] # [doc = " length of the haystack."] # [doc = ""] # [doc = " In general, you should probably stick to the default unless you have"] # [doc = " some kind of reason to use a specific Aho-Corasick implementation. For"] # [doc = " example, you might choose `AhoCorasickKind::DFA` if you don't care"] # [doc = " about memory usage and want the fastest possible search times."] # [doc = ""] # [doc = " Setting this guarantees that the searcher returned uses the chosen"] # [doc = " implementation. If that implementation could not be constructed, then"] # [doc = " an error will be returned. In contrast, when `None` is used, it is"] # [doc = " possible for it to attempt to construct, for example, a contiguous"] # [doc = " NFA and have it fail. In which case, it will fall back to using a"] # [doc = " noncontiguous NFA."] # [doc = ""] # [doc = " If `None` is given, then one may use [`AhoCorasick::kind`] to determine"] # [doc = " which Aho-Corasick implementation was chosen."] # [doc = ""] # [doc = " Note that the heuristics used for choosing which `AhoCorasickKind`"] # [doc = " may be changed in a semver compatible release."] pub fn kind (& mut self , kind : Option < AhoCorasickKind > ,) -> & mut AhoCorasickBuilder { self . kind = kind ; self } # [doc = " Enable heuristic prefilter optimizations."] # [doc = ""] # [doc = " When enabled, searching will attempt to quickly skip to match"] # [doc = " candidates using specialized literal search routines. A prefilter"] # [doc = " cannot always be used, and is generally treated as a heuristic. It"] # [doc = " can be useful to disable this if the prefilter is observed to be"] # [doc = " sub-optimal for a particular workload."] # [doc = ""] # [doc = " Currently, prefilters are typically only active when building searchers"] # [doc = " with a small (less than 100) number of patterns."] # [doc = ""] # [doc = " This is enabled by default."] pub fn prefilter (& mut self , yes : bool) -> & mut AhoCorasickBuilder { self . nfa_noncontiguous . prefilter (yes) ; self . nfa_contiguous . prefilter (yes) ; self . dfa . prefilter (yes) ; self } # [doc = " Set the limit on how many states use a dense representation for their"] # [doc = " transitions. Other states will generally use a sparse representation."] # [doc = ""] # [doc = " A dense representation uses more memory but is generally faster, since"] # [doc = " the next transition in a dense representation can be computed in a"] # [doc = " constant number of instructions. A sparse representation uses less"] # [doc = " memory but is generally slower, since the next transition in a sparse"] # [doc = " representation requires executing a variable number of instructions."] # [doc = ""] # [doc = " This setting is only used when an Aho-Corasick implementation is used"] # [doc = " that supports the dense versus sparse representation trade off. Not all"] # [doc = " do."] # [doc = ""] # [doc = " This limit is expressed in terms of the depth of a state, i.e., the"] # [doc = " number of transitions from the starting state of the automaton. The"] # [doc = " idea is that most of the time searching will be spent near the starting"] # [doc = " state of the automaton, so states near the start state should use a"] # [doc = " dense representation. States further away from the start state would"] # [doc = " then use a sparse representation."] # [doc = ""] # [doc = " By default, this is set to a low but non-zero number. Setting this to"] # [doc = " `0` is almost never what you want, since it is likely to make searches"] # [doc = " very slow due to the start state itself being forced to use a sparse"] # [doc = " representation. However, it is unlikely that increasing this number"] # [doc = " will help things much, since the most active states have a small depth."] # [doc = " More to the point, the memory usage increases superlinearly as this"] # [doc = " number increases."] pub fn dense_depth (& mut self , depth : usize) -> & mut AhoCorasickBuilder { self . nfa_noncontiguous . dense_depth (depth) ; self . nfa_contiguous . dense_depth (depth) ; self } # [doc = " A debug settting for whether to attempt to shrink the size of the"] # [doc = " automaton's alphabet or not."] # [doc = ""] # [doc = " This option is enabled by default and should never be disabled unless"] # [doc = " one is debugging the underlying automaton."] # [doc = ""] # [doc = " When enabled, some (but not all) Aho-Corasick automatons will use a map"] # [doc = " from all possible bytes to their corresponding equivalence class. Each"] # [doc = " equivalence class represents a set of bytes that does not discriminate"] # [doc = " between a match and a non-match in the automaton."] # [doc = ""] # [doc = " The advantage of this map is that the size of the transition table can"] # [doc = " be reduced drastically from `#states * 256 * sizeof(u32)` to"] # [doc = " `#states * k * sizeof(u32)` where `k` is the number of equivalence"] # [doc = " classes (rounded up to the nearest power of 2). As a result, total"] # [doc = " space usage can decrease substantially. Moreover, since a smaller"] # [doc = " alphabet is used, automaton compilation becomes faster as well."] # [doc = ""] # [doc = " **WARNING:** This is only useful for debugging automatons. Disabling"] # [doc = " this does not yield any speed advantages. Namely, even when this is"] # [doc = " disabled, a byte class map is still used while searching. The only"] # [doc = " difference is that every byte will be forced into its own distinct"] # [doc = " equivalence class. This is useful for debugging the actual generated"] # [doc = " transitions because it lets one see the transitions defined on actual"] # [doc = " bytes instead of the equivalence classes."] pub fn byte_classes (& mut self , yes : bool) -> & mut AhoCorasickBuilder { self . nfa_contiguous . byte_classes (yes) ; self . dfa . byte_classes (yes) ; self } } # [doc = " The type of Aho-Corasick implementation to use in an [`AhoCorasick`]"] # [doc = " searcher."] # [doc = ""] # [doc = " This is principally used as an input to the"] # [doc = " [`AhoCorasickBuilder::start_kind`] method. Its documentation goes into more"] # [doc = " detail about each choice."] # [non_exhaustive] pub enum AhoCorasickKind { # [doc = " Use a noncontiguous NFA."] NoncontiguousNFA , # [doc = " Use a contiguous NFA."] ContiguousNFA , # [doc = " Use a DFA. Warning: DFAs typically use a large amount of memory."] DFA , } # [automatically_derived] impl :: core :: clone :: Clone for AhoCorasickKind { # [inline] fn clone (& self) -> AhoCorasickKind { * self } } # [automatically_derived] impl :: core :: marker :: Copy for AhoCorasickKind { } # [automatically_derived] impl :: core :: fmt :: Debug for AhoCorasickKind { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: write_str (f , match self { AhoCorasickKind :: NoncontiguousNFA => "NoncontiguousNFA" , AhoCorasickKind :: ContiguousNFA => "ContiguousNFA" , AhoCorasickKind :: DFA => "DFA" , } ,) } } # [automatically_derived] impl :: core :: cmp :: Eq for AhoCorasickKind { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for AhoCorasickKind { } # [automatically_derived] impl :: core :: cmp :: PartialEq for AhoCorasickKind { # [inline] fn eq (& self , other : & AhoCorasickKind) -> bool { let __self_discr = :: core :: intrinsics :: discriminant_value (self) ; let __arg1_discr = :: core :: intrinsics :: discriminant_value (other) ; __self_discr == __arg1_discr } } # [doc = " A trait that effectively gives us practical dynamic dispatch over anything"] # [doc = " that impls `Automaton`, but without needing to add a bunch of bounds to"] # [doc = " the core `Automaton` trait. Basically, we provide all of the marker traits"] # [doc = " that our automatons have, in addition to `Debug` impls and requiring that"] # [doc = " there is no borrowed data. Without these, the main `AhoCorasick` type would"] # [doc = " not be able to meaningfully impl `Debug` or the marker traits without also"] # [doc = " requiring that all impls of `Automaton` do so, which would be not great."] trait AcAutomaton : Automaton + Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static { } impl < A > AcAutomaton for A where A : Automaton + Debug + Send + Sync + UnwindSafe + RefUnwindSafe + 'static , { } impl crate :: automaton :: private :: Sealed for Arc < dyn AcAutomaton > { } # [doc (hidden)] unsafe impl Automaton for Arc < dyn AcAutomaton > { # [inline (always)] fn start_state (& self , anchored : Anchored) -> Result < StateID , MatchError > { (* * self) . start_state (anchored) } # [inline (always)] fn next_state (& self , anchored : Anchored , sid : StateID , byte : u8) -> StateID { (* * self) . next_state (anchored , sid , byte) } # [inline (always)] fn is_special (& self , sid : StateID) -> bool { (* * self) . is_special (sid) } # [inline (always)] fn is_dead (& self , sid : StateID) -> bool { (* * self) . is_dead (sid) } # [inline (always)] fn is_match (& self , sid : StateID) -> bool { (* * self) . is_match (sid) } # [inline (always)] fn is_start (& self , sid : StateID) -> bool { (* * self) . is_start (sid) } # [inline (always)] fn match_kind (& self) -> MatchKind { (* * self) . match_kind () } # [inline (always)] fn match_len (& self , sid : StateID) -> usize { (* * self) . match_len (sid) } # [inline (always)] fn match_pattern (& self , sid : StateID , index : usize) -> PatternID { (* * self) . match_pattern (sid , index) } # [inline (always)] fn patterns_len (& self) -> usize { (* * self) . patterns_len () } # [inline (always)] fn pattern_len (& self , pid : PatternID) -> usize { (* * self) . pattern_len (pid) } # [inline (always)] fn min_pattern_len (& self) -> usize { (* * self) . min_pattern_len () } # [inline (always)] fn max_pattern_len (& self) -> usize { (* * self) . max_pattern_len () } # [inline (always)] fn memory_usage (& self) -> usize { (* * self) . memory_usage () } # [inline (always)] fn prefilter (& self) -> Option < & Prefilter > { (* * self) . prefilter () } # [inline (always)] fn try_find (& self , input : & Input < '_ >) -> Result < Option < Match > , MatchError > { (* * self) . try_find (input) } # [inline (always)] fn try_find_overlapping (& self , input : & Input < '_ > , state : & mut OverlappingState ,) -> Result < () , MatchError > { (* * self) . try_find_overlapping (input , state) } } # [doc = " Returns an error if the start state configuration does not support the"] # [doc = " desired search configuration. See the internal 'AhoCorasick::start_kind'"] # [doc = " field docs for more details."] fn enforce_anchored_consistency (have : StartKind , want : Anchored ,) -> Result < () , MatchError > { match have { StartKind :: Both => Ok (()) , StartKind :: Unanchored if ! want . is_anchored () => Ok (()) , StartKind :: Unanchored => Err (MatchError :: invalid_input_anchored ()) , StartKind :: Anchored if want . is_anchored () => Ok (()) , StartKind :: Anchored => Err (MatchError :: invalid_input_unanchored ()) , } } }