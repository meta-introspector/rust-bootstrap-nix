use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub mod modify_file { use anyhow :: Result ; use std :: fs ; use std :: path :: Path ; use syn :: Item ; use prettyplease ; # [doc = " Modifies a source file to remove its `use` statements and add `use crate::prelude::*;`."] pub fn modify_file (path : & Path , dry_run : bool , force : bool) -> Result < () > { { :: std :: io :: _print (format_args ! ("  -> Entering modify_file for path: {0}\n" , path . display ()) ,) ; } ; let content = fs :: read_to_string (path) ? ; let ast = syn :: parse_file (& content) ? ; let mut new_items = Vec :: new () ; let mut has_use_statements = false ; for item in & ast . items { if let Item :: Use (_) = item { has_use_statements = true ; } else { new_items . push (item . clone ()) ; } } if has_use_statements { let prelude_use : Item = :: syn :: __private :: parse_quote ({ let mut _s = :: quote :: __private :: TokenStream :: new () ; :: quote :: __private :: push_ident (& mut _s , "use") ; :: quote :: __private :: push_ident (& mut _s , "crate") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_ident (& mut _s , "prelude") ; :: quote :: __private :: push_colon2 (& mut _s) ; :: quote :: __private :: push_star (& mut _s) ; :: quote :: __private :: push_semi (& mut _s) ; _s }) ; new_items . insert (0 , prelude_use) ; let mut new_ast = ast . clone () ; new_ast . items = new_items ; let new_content = prettyplease :: unparse (& new_ast) ; if dry_run { { :: std :: io :: _print (format_args ! ("[DRY RUN] Would modify file: {0}\n---\n{1}---\n" , path . display () , new_content ,) ,) ; } ; } else { if path . exists () && ! force { { :: std :: io :: _print (format_args ! ("  -> Skipping file modification for {0} (file exists, use --force to overwrite).\n" , path . display () ,) ,) ; } ; } else { { :: std :: io :: _print (format_args ! ("  -> Modifying file: {0}\n" , path . display ()) ,) ; } ; { :: std :: io :: _print (format_args ! ("    -> Writing modified content to: {0}\n" , path . display () ,) ,) ; } ; fs :: write (path , new_content) ? ; } } } Ok (()) } }