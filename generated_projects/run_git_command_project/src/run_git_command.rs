use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

# [doc = " Runs a git command and returns the output, handling errors."] pub fn run_git_command (current_dir : & Path , args : & [& str] , error_message : & str , dry_run : bool ,) -> Result < () > { { :: std :: io :: _print (format_args ! ("Running git command in CWD: {0:?}\n" , current_dir) ,) ; } ; let command_str = :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("git {0}" , args . join (" "))) }) ; if dry_run { { :: std :: io :: _print (format_args ! ("Dry run: Would execute: {0}\n" , command_str) ,) ; } ; return Ok (()) ; } { :: std :: io :: _print (format_args ! ("Executing: {0}\n" , command_str)) ; } ; let output = Command :: new ("git") . current_dir (current_dir) . args (args) . output () . with_context (| | :: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Failed to execute git command: {0}" , command_str) ,) })) ? ; if ! output . status . success () { return :: anyhow :: __private :: Err (:: anyhow :: Error :: msg (:: alloc :: __export :: must_use ({ :: alloc :: fmt :: format (format_args ! ("Git command failed: {0}\nStdout: {1}\nStderr: {2}" , error_message , String :: from_utf8_lossy (& output . stdout) , String :: from_utf8_lossy (& output . stderr) ,) ,) }) ,) ,) ; } Ok (()) }