use std::collections::HashSet;
use split_expanded_lib::{DeclarationItem};

pub (crate) mod alphabet { use crate :: util :: int :: Usize ; # [doc = " A representation of byte oriented equivalence classes."] # [doc = ""] # [doc = " This is used in finite state machines to reduce the size of the transition"] # [doc = " table. This can have a particularly large impact not only on the total size"] # [doc = " of an FSM, but also on FSM build times because it reduces the number of"] # [doc = " transitions that need to be visited/set."] pub (crate) struct ByteClasses ([u8 ; 256]) ; # [automatically_derived] impl :: core :: clone :: Clone for ByteClasses { # [inline] fn clone (& self) -> ByteClasses { let _ : :: core :: clone :: AssertParamIsClone < [u8 ; 256] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for ByteClasses { } impl ByteClasses { # [doc = " Creates a new set of equivalence classes where all bytes are mapped to"] # [doc = " the same class."] pub (crate) fn empty () -> ByteClasses { ByteClasses ([0 ; 256]) } # [doc = " Creates a new set of equivalence classes where each byte belongs to"] # [doc = " its own equivalence class."] pub (crate) fn singletons () -> ByteClasses { let mut classes = ByteClasses :: empty () ; for b in 0 ..= 255 { classes . set (b , b) ; } classes } # [doc = " Set the equivalence class for the given byte."] # [inline] pub (crate) fn set (& mut self , byte : u8 , class : u8) { self . 0 [usize :: from (byte)] = class ; } # [doc = " Get the equivalence class for the given byte."] # [inline] pub (crate) fn get (& self , byte : u8) -> u8 { self . 0 [usize :: from (byte)] } # [doc = " Return the total number of elements in the alphabet represented by"] # [doc = " these equivalence classes. Equivalently, this returns the total number"] # [doc = " of equivalence classes."] # [inline] pub (crate) fn alphabet_len (& self) -> usize { usize :: from (self . 0 [255]) + 1 } # [doc = " Returns the stride, as a base-2 exponent, required for these"] # [doc = " equivalence classes."] # [doc = ""] # [doc = " The stride is always the smallest power of 2 that is greater than or"] # [doc = " equal to the alphabet length. This is done so that converting between"] # [doc = " state IDs and indices can be done with shifts alone, which is much"] # [doc = " faster than integer division. The \"stride2\" is the exponent. i.e.,"] # [doc = " `2^stride2 = stride`."] pub (crate) fn stride2 (& self) -> usize { let zeros = self . alphabet_len () . next_power_of_two () . trailing_zeros () ; usize :: try_from (zeros) . unwrap () } # [doc = " Returns the stride for these equivalence classes, which corresponds"] # [doc = " to the smallest power of 2 greater than or equal to the number of"] # [doc = " equivalence classes."] pub (crate) fn stride (& self) -> usize { 1 << self . stride2 () } # [doc = " Returns true if and only if every byte in this class maps to its own"] # [doc = " equivalence class. Equivalently, there are 257 equivalence classes"] # [doc = " and each class contains exactly one byte (plus the special EOI class)."] # [inline] pub (crate) fn is_singleton (& self) -> bool { self . alphabet_len () == 256 } # [doc = " Returns an iterator over all equivalence classes in this set."] pub (crate) fn iter (& self) -> ByteClassIter { ByteClassIter { it : 0 .. self . alphabet_len () , } } # [doc = " Returns an iterator of the bytes in the given equivalence class."] pub (crate) fn elements (& self , class : u8) -> ByteClassElements { ByteClassElements { classes : self , class , bytes : 0 ..= 255 , } } # [doc = " Returns an iterator of byte ranges in the given equivalence class."] # [doc = ""] # [doc = " That is, a sequence of contiguous ranges are returned. Typically, every"] # [doc = " class maps to a single contiguous range."] fn element_ranges (& self , class : u8) -> ByteClassElementRanges { ByteClassElementRanges { elements : self . elements (class) , range : None , } } } impl core :: fmt :: Debug for ByteClasses { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { if self . is_singleton () { f . write_fmt (format_args ! ("ByteClasses(<one-class-per-byte>)")) } else { f . write_fmt (format_args ! ("ByteClasses(")) ? ; for (i , class) in self . iter () . enumerate () { if i > 0 { f . write_fmt (format_args ! (", ")) ? ; } f . write_fmt (format_args ! ("{0:?} => [" , class)) ? ; for (start , end) in self . element_ranges (class) { if start == end { f . write_fmt (format_args ! ("{0:?}" , start)) ? ; } else { f . write_fmt (format_args ! ("{0:?}-{1:?}" , start , end)) ? ; } } f . write_fmt (format_args ! ("]")) ? ; } f . write_fmt (format_args ! (")")) } } } # [doc = " An iterator over each equivalence class."] pub (crate) struct ByteClassIter { it : core :: ops :: Range < usize > , } # [automatically_derived] impl :: core :: fmt :: Debug for ByteClassIter { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "ByteClassIter" , "it" , & & self . it ,) } } impl Iterator for ByteClassIter { type Item = u8 ; fn next (& mut self) -> Option < u8 > { self . it . next () . map (| class | class . as_u8 ()) } } # [doc = " An iterator over all elements in a specific equivalence class."] pub (crate) struct ByteClassElements < 'a > { classes : & 'a ByteClasses , class : u8 , bytes : core :: ops :: RangeInclusive < u8 > , } # [automatically_derived] impl < 'a > :: core :: fmt :: Debug for ByteClassElements < 'a > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field3_finish (f , "ByteClassElements" , "classes" , & self . classes , "class" , & self . class , "bytes" , & & self . bytes ,) } } impl < 'a > Iterator for ByteClassElements < 'a > { type Item = u8 ; fn next (& mut self) -> Option < u8 > { while let Some (byte) = self . bytes . next () { if self . class == self . classes . get (byte) { return Some (byte) ; } } None } } # [doc = " An iterator over all elements in an equivalence class expressed as a"] # [doc = " sequence of contiguous ranges."] pub (crate) struct ByteClassElementRanges < 'a > { elements : ByteClassElements < 'a > , range : Option < (u8 , u8) > , } # [automatically_derived] impl < 'a > :: core :: fmt :: Debug for ByteClassElementRanges < 'a > { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field2_finish (f , "ByteClassElementRanges" , "elements" , & self . elements , "range" , & & self . range ,) } } impl < 'a > Iterator for ByteClassElementRanges < 'a > { type Item = (u8 , u8) ; fn next (& mut self) -> Option < (u8 , u8) > { loop { let element = match self . elements . next () { None => return self . range . take () , Some (element) => element , } ; match self . range . take () { None => { self . range = Some ((element , element)) ; } Some ((start , end)) => { if usize :: from (end) + 1 != usize :: from (element) { self . range = Some ((element , element)) ; return Some ((start , end)) ; } self . range = Some ((start , element)) ; } } } } } # [doc = " A partitioning of bytes into equivalence classes."] # [doc = ""] # [doc = " A byte class set keeps track of an *approximation* of equivalence classes"] # [doc = " of bytes during NFA construction. That is, every byte in an equivalence"] # [doc = " class cannot discriminate between a match and a non-match."] # [doc = ""] # [doc = " Note that this may not compute the minimal set of equivalence classes."] # [doc = " Basically, any byte in a pattern given to the noncontiguous NFA builder"] # [doc = " will automatically be treated as its own equivalence class. All other"] # [doc = " bytes---any byte not in any pattern---will be treated as their own"] # [doc = " equivalence classes. In theory, all bytes not in any pattern should"] # [doc = " be part of a single equivalence class, but in practice, we only treat"] # [doc = " contiguous ranges of bytes as an equivalence class. So the number of"] # [doc = " classes computed may be bigger than necessary. This usually doesn't make"] # [doc = " much of a difference, and keeps the implementation simple."] pub (crate) struct ByteClassSet (ByteSet) ; # [automatically_derived] impl :: core :: clone :: Clone for ByteClassSet { # [inline] fn clone (& self) -> ByteClassSet { ByteClassSet (:: core :: clone :: Clone :: clone (& self . 0)) } } # [automatically_derived] impl :: core :: fmt :: Debug for ByteClassSet { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_tuple_field1_finish (f , "ByteClassSet" , & & self . 0 ,) } } impl Default for ByteClassSet { fn default () -> ByteClassSet { ByteClassSet :: empty () } } impl ByteClassSet { # [doc = " Create a new set of byte classes where all bytes are part of the same"] # [doc = " equivalence class."] pub (crate) fn empty () -> Self { ByteClassSet (ByteSet :: empty ()) } # [doc = " Indicate the the range of byte given (inclusive) can discriminate a"] # [doc = " match between it and all other bytes outside of the range."] pub (crate) fn set_range (& mut self , start : u8 , end : u8) { if true { if ! (start <= end) { :: core :: panicking :: panic ("assertion failed: start <= end") } } if start > 0 { self . 0 . add (start - 1) ; } self . 0 . add (end) ; } # [doc = " Convert this boolean set to a map that maps all byte values to their"] # [doc = " corresponding equivalence class. The last mapping indicates the largest"] # [doc = " equivalence class identifier (which is never bigger than 255)."] pub (crate) fn byte_classes (& self) -> ByteClasses { let mut classes = ByteClasses :: empty () ; let mut class = 0u8 ; let mut b = 0u8 ; loop { classes . set (b , class) ; if b == 255 { break ; } if self . 0 . contains (b) { class = class . checked_add (1) . unwrap () ; } b = b . checked_add (1) . unwrap () ; } classes } } # [doc = " A simple set of bytes that is reasonably cheap to copy and allocation free."] pub (crate) struct ByteSet { bits : BitSet , } # [automatically_derived] impl :: core :: clone :: Clone for ByteSet { # [inline] fn clone (& self) -> ByteSet { let _ : :: core :: clone :: AssertParamIsClone < BitSet > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for ByteSet { } # [automatically_derived] impl :: core :: fmt :: Debug for ByteSet { # [inline] fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { :: core :: fmt :: Formatter :: debug_struct_field1_finish (f , "ByteSet" , "bits" , & & self . bits ,) } } # [automatically_derived] impl :: core :: default :: Default for ByteSet { # [inline] fn default () -> ByteSet { ByteSet { bits : :: core :: default :: Default :: default () , } } } # [automatically_derived] impl :: core :: cmp :: Eq for ByteSet { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < BitSet > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for ByteSet { } # [automatically_derived] impl :: core :: cmp :: PartialEq for ByteSet { # [inline] fn eq (& self , other : & ByteSet) -> bool { self . bits == other . bits } } # [doc = " The representation of a byte set. Split out so that we can define a"] # [doc = " convenient Debug impl for it while keeping \"ByteSet\" in the output."] struct BitSet ([u128 ; 2]) ; # [automatically_derived] impl :: core :: clone :: Clone for BitSet { # [inline] fn clone (& self) -> BitSet { let _ : :: core :: clone :: AssertParamIsClone < [u128 ; 2] > ; * self } } # [automatically_derived] impl :: core :: marker :: Copy for BitSet { } # [automatically_derived] impl :: core :: default :: Default for BitSet { # [inline] fn default () -> BitSet { BitSet (:: core :: default :: Default :: default ()) } } # [automatically_derived] impl :: core :: cmp :: Eq for BitSet { # [inline] # [doc (hidden)] # [coverage (off)] fn assert_receiver_is_total_eq (& self) -> () { let _ : :: core :: cmp :: AssertParamIsEq < [u128 ; 2] > ; } } # [automatically_derived] impl :: core :: marker :: StructuralPartialEq for BitSet { } # [automatically_derived] impl :: core :: cmp :: PartialEq for BitSet { # [inline] fn eq (& self , other : & BitSet) -> bool { self . 0 == other . 0 } } impl ByteSet { # [doc = " Create an empty set of bytes."] pub (crate) fn empty () -> ByteSet { ByteSet { bits : BitSet ([0 ; 2]) } } # [doc = " Add a byte to this set."] # [doc = ""] # [doc = " If the given byte already belongs to this set, then this is a no-op."] pub (crate) fn add (& mut self , byte : u8) { let bucket = byte / 128 ; let bit = byte % 128 ; self . bits . 0 [usize :: from (bucket)] |= 1 << bit ; } # [doc = " Return true if and only if the given byte is in this set."] pub (crate) fn contains (& self , byte : u8) -> bool { let bucket = byte / 128 ; let bit = byte % 128 ; self . bits . 0 [usize :: from (bucket)] & (1 << bit) > 0 } } impl core :: fmt :: Debug for BitSet { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { let mut fmtd = f . debug_set () ; for b in 0u8 ..= 255 { if (ByteSet { bits : * self }) . contains (b) { fmtd . entry (& b) ; } } fmtd . finish () } } }